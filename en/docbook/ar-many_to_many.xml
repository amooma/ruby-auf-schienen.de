<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="ar-many_to_many"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="ar-many_to_many.title">Many-to-Many â€“ n:n Association</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>relations</secondary>

    <tertiary>has_many()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>relations</secondary>

    <tertiary>belongs_to()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>associations</secondary>

    <see>ActiveRecord, relations</see>
  </indexterm>

  <para>Up to now, we have always associated a database table directly with
  another table. For many-to-many, we will associate two tables via a third
  table. As example for this kind of relation, we use an order in a very basic
  online shop. In this type of shop system, a <classname>Product</classname>
  can appear in several orders (<classname>Order</classname>) and at the same
  time an order can contain several products. This is referred to as
  many-to-many. Let's recreate this scenario with code.</para>

  <section xml:id="many_to_many_vorbereitung">
    <title>Preparation</title>

    <para>Create the shop application:<screen>$ <command>rails new shop</command>
  [...]
$ <command>cd shop</command></screen></para>

    <para>A model for products:<screen>$ <command>rails generate model product name 'price:decimal{7,2}'</command>
  [...]
$</screen></para>

    <para>A model for an order:<screen>$ <command>rails generate model order delivery_address</command>
  [...]
$</screen></para>

    <para>And a model for individual items of an order:<screen>$ <command>rails generate model line_item order_id:integer product_id:integer quantity:integer</command>
  [...]
$ </screen></para>

    <para>Then, create the database:<screen>$ <command>rake db:migrate</command>
  [...]
$</screen></para>
  </section>

  <section xml:id="many_to_many_die_verknuepfung">
    <title>The Association</title>

    <para>An order (<classname>Order</classname>) consists of one or several
    items (<classname>LineItem</classname>). This
    <classname>LineItem</classname> consists of the
    <varname>order_id</varname>, a <varname>product_id</varname> and the
    number of items ordered (<varname>quantity</varname>). The individual
    product is defined in the product database
    (<classname>Product</classname>).</para>

    <para>Associating the models happens as always in the directory
    <filename>app/models</filename>. First, in the file
    <filename>app/models/order.rb:</filename><programlisting>class Order &lt; ActiveRecord::Base
  has_many :line_items
  has_many :products, :through =&gt; :line_items
end</programlisting></para>

    <para>Then in the counterpart in the file
    <filename>app/models/product.rb:</filename><programlisting>class Product &lt; ActiveRecord::Base
  has_many :line_items
  has_many :orders, :through =&gt; :line_items
end</programlisting></para>

    <para>Finally, the file
    <filename>app/models/line_item.rb:</filename><programlisting>class LineItem &lt; ActiveRecord::Base
  belongs_to :order
  belongs_to :product
end</programlisting></para>
  </section>

  <section xml:id="many_to_many_funktioniert_wie_has_many">
    <title>The Association Works Transparent</title>

    <para>As we implement the associations via
    <methodname>has_many</methodname>, most things will already be familiar to
    you from <xref linkend="activerecord_has_many"/>. I am going to discuss a
    few examples. For more details, see <xref
    linkend="activerecord_has_many"/>.</para>

    <para>First we populate our product database with the following
    values:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>milk = Product.create(name: 'Milk (1 liter)', price: 0.45)</command>
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:30:29 UTC +00:00], ["name", "Milk (1 liter)"], ["price", #&lt;BigDecimal:7fb985120d18,'0.45E0',9(45)&gt;], ["updated_at", Tue, 16 Jul 2013 12:30:29 UTC +00:00]]
   (2.5ms)  commit transaction
=&gt; #&lt;Product id: 1, name: "Milk (1 liter)", price: #&lt;BigDecimal:7fb985120d18,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29"&gt;
&gt;&gt; <command>butter = Product.create(name: 'Butter (250 gr)', price: 0.75)</command>
   (0.1ms)  begin transaction
  SQL (0.9ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:30:36 UTC +00:00], ["name", "Butter (250 gr)"], ["price", #&lt;BigDecimal:7fb98281fe28,'0.75E0',9(45)&gt;], ["updated_at", Tue, 16 Jul 2013 12:30:36 UTC +00:00]]
   (2.3ms)  commit transaction
=&gt; #&lt;Product id: 2, name: "Butter (250 gr)", price: #&lt;BigDecimal:7fb98281fe28,'0.75E0',9(45)&gt;, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36"&gt;
&gt;&gt; <command>flour = Product.create(name: 'Flour (1 kg)', price: 0.45)</command>
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:30:43 UTC +00:00], ["name", "Flour (1 kg)"], ["price", #&lt;BigDecimal:7fb98520b9f8,'0.45E0',9(45)&gt;], ["updated_at", Tue, 16 Jul 2013 12:30:43 UTC +00:00]]
   (2.0ms)  commit transaction
=&gt; #&lt;Product id: 3, name: "Flour (1 kg)", price: #&lt;BigDecimal:7fb98520b9f8,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:43", updated_at: "2013-07-16 12:30:43"&gt;
&gt;&gt;  </screen></para>

    <para>Now we create a new <classname>Order</classname> object with the
    name <varname>order</varname>:<screen>&gt;&gt; <command>order = Order.new(delivery_address: '123 Acme Street, ACME STATE 12345')</command>
=&gt; #&lt;Order id: nil, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: nil, updated_at: nil&gt;
&gt;&gt; </screen></para>

    <para>Logically, this new order does not yet contain any products:<screen>&gt;&gt; <command>order.products.count</command>
=&gt; 0
&gt;&gt;</screen></para>

    <para>As often, there are several ways of adding products to the order.
    The simplest way: as the products are integrated as array, you can simply
    insert them as elements of an array:<screen>&gt;&gt; <command>order.products &lt;&lt; milk</command>
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Product id: 1, name: "Milk (1 liter)", price: #&lt;BigDecimal:7fb985120d18,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29"&gt;]&gt;
&gt;&gt;</screen></para>

    <para>But if the customer wants to buy three liters of milk instead of one
    liter, we need to enter it in the <classname>LineItem</classname> (in the
    linking element) table. ActiveRecord already build an object for
    us:<screen>&gt;&gt; <command>order.line_items</command>
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;LineItem id: nil, order_id: nil, product_id: 1, quantity: nil, created_at: nil, updated_at: nil&gt;]&gt;
&gt;&gt;</screen></para>

    <para>But the object is not yet saved in the database. After we do this
    via <methodname>save</methodname>, we can change the quantity in the
    <classname>LineItem</classname> object:<screen>&gt;&gt; <command>order.save</command>
   (0.1ms)  begin transaction
  SQL (0.9ms)  INSERT INTO "orders" ("created_at", "delivery_address", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00], ["delivery_address", "123 Acme Street, ACME STATE 12345"], ["updated_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00]]
  SQL (0.3ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00], ["order_id", 1], ["product_id", 1], ["updated_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00]]
   (2.6ms)  commit transaction
=&gt; true
&gt;&gt; <command>order.line_items.first.update_attributes(quantity: 3)</command>
   (0.2ms)  begin transaction
  SQL (1.0ms)  UPDATE "line_items" SET "quantity" = ?, "updated_at" = ? WHERE "line_items"."id" = 1  [["quantity", 3], ["updated_at", Tue, 16 Jul 2013 12:34:49 UTC +00:00]]
   (3.0ms)  commit transaction
=&gt; true
&gt;&gt;</screen></para>

    <para>Alternatively, we can also buy butter twice directly by adding a
    <classname>LineItem</classname>:<screen>&gt;&gt; <command>order.line_items.create(product_id: butter.id, quantity: 2)</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "quantity", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:35:38 UTC +00:00], ["order_id", 1], ["product_id", 2], ["quantity", 2], ["updated_at", Tue, 16 Jul 2013 12:35:38 UTC +00:00]]
   (2.3ms)  commit transaction
=&gt; #&lt;LineItem id: 2, order_id: 1, product_id: 2, quantity: 2, created_at: "2013-07-16 12:35:38", updated_at: "2013-07-16 12:35:38"&gt;
&gt;&gt; </screen></para>

    <warning>
      <para>When creating a line_item we bypass the has_many: ... :through ..
      logic. The database table contains all the correct information but order
      hasn't been updated: <screen>&gt;&gt; <command>order.products</command>
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Product id: 1, name: "Milk (1 liter)", price: #&lt;BigDecimal:7fb985120d18,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29"&gt;]&gt;
&gt;&gt;</screen></para>

      <para>But in the database table, it is of course correct:<screen>&gt;&gt; <command>Order.first.products</command>
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" ORDER BY "orders"."id" ASC LIMIT 1
  Product Load (0.2ms)  SELECT "products".* FROM "products" INNER JOIN "line_items" ON "products"."id" = "line_items"."product_id" WHERE "line_items"."order_id" = ?  [["order_id", 1]]
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Product id: 1, name: "Milk (1 liter)", price: #&lt;BigDecimal:7fb985148ac0,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29"&gt;, #&lt;Product id: 2, name: "Butter (250 gr)", price: #&lt;BigDecimal:7fb985153c90,'0.75E0',9(45)&gt;, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36"&gt;]&gt;
&gt;&gt; </screen></para>

      <para>In this specific case, you would need to reload the object from
      the database via the method <methodname>reload</methodname>:<screen>&gt;&gt; <command>order.reload</command>
  Order Load (0.4ms)  SELECT "orders".* FROM "orders" WHERE "orders"."id" = ? LIMIT 1  [["id", 1]]
=&gt; #&lt;Order id: 1, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: "2013-07-16 12:34:08", updated_at: "2013-07-16 12:34:08"&gt;
&gt;&gt; <command>order.products</command>
  Product Load (0.3ms)  SELECT "products".* FROM "products" INNER JOIN "line_items" ON "products"."id" = "line_items"."product_id" WHERE "line_items"."order_id" = ?  [["order_id", 1]]
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Product id: 1, name: "Milk (1 liter)", price: #&lt;BigDecimal:7fb98516a2d8,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29"&gt;, #&lt;Product id: 2, name: "Butter (250 gr)", price: #&lt;BigDecimal:7fb985169540,'0.75E0',9(45)&gt;, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36"&gt;]&gt;
&gt;&gt; </screen></para>
    </warning>

    <para>Let's enter a second order with all available products into the
    system:<screen>&gt;&gt; <command>order2 = Order.create(delivery_address: '2, Test Road')</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "orders" ("created_at", "delivery_address", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:27 UTC +00:00], ["delivery_address", "2, Test Road"], ["updated_at", Tue, 16 Jul 2013 12:39:27 UTC +00:00]]
   (2.7ms)  commit transaction
=&gt; #&lt;Order id: 2, delivery_address: "2, Test Road", created_at: "2013-07-16 12:39:27", updated_at: "2013-07-16 12:39:27"&gt;
&gt;&gt; <command>order2.products &lt;&lt; Product.all</command>
  Product Load (0.3ms)  SELECT "products".* FROM "products"
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00], ["order_id", 2], ["product_id", 1], ["updated_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00]]
  SQL (0.1ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00], ["order_id", 2], ["product_id", 2], ["updated_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00]]
  SQL (0.1ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00], ["order_id", 2], ["product_id", 3], ["updated_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00]]
   (2.6ms)  commit transaction
  Product Load (0.1ms)  SELECT "products".* FROM "products" INNER JOIN "line_items" ON "products"."id" = "line_items"."product_id" WHERE "line_items"."order_id" = ?  [["order_id", 2]]
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Product id: 1, name: "Milk (1 liter)", price: #&lt;BigDecimal:7fb9851c32c0,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29"&gt;, #&lt;Product id: 2, name: "Butter (250 gr)", price: #&lt;BigDecimal:7fb9851c1538,'0.75E0',9(45)&gt;, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36"&gt;, #&lt;Product id: 3, name: "Flour (1 kg)", price: #&lt;BigDecimal:7fb9851cafe8,'0.45E0',9(45)&gt;, created_at: "2013-07-16 12:30:43", updated_at: "2013-07-16 12:30:43"&gt;]&gt;
&gt;&gt; <command>order2.save</command>
   (0.1ms)  begin transaction
   (0.1ms)  commit transaction
=&gt; true
&gt;&gt;</screen></para>

    <para>Now we can try out the oposite direction of this many-to-many
    association. Let's search for all orders that contain the first
    product:<screen>&gt;&gt; <command>Product.first.orders</command>
  Product Load (0.3ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
  Order Load (0.2ms)  SELECT "orders".* FROM "orders" INNER JOIN "line_items" ON "orders"."id" = "line_items"."order_id" WHERE "line_items"."product_id" = ?  [["product_id", 1]]
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Order id: 1, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: "2013-07-16 12:34:08", updated_at: "2013-07-16 12:34:08"&gt;, #&lt;Order id: 2, delivery_address: "2, Test Road", created_at: "2013-07-16 12:39:27", updated_at: "2013-07-16 12:39:27"&gt;]&gt;
&gt;&gt; </screen></para>

    <para>Of course, we can also work with a <methodname>joins</methodname>
    (see <xref linkend="activerecord_1n_joins"/>) and search for all orders
    that contain the product "Milk (1 liter)":<screen>&gt;&gt; <command>Order.joins(:products).where(:products =&gt; {name: 'Milk (1 liter)'})</command>
  Order Load (0.2ms)  SELECT "orders".* FROM "orders" INNER JOIN "line_items" ON "line_items"."order_id" = "orders"."id" INNER JOIN "products" ON "products"."id" = "line_items"."product_id" WHERE "products"."name" = 'Milk (1 liter)'
=&gt; #&lt;ActiveRecord::Relation [#&lt;Order id: 1, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: "2013-07-16 12:34:08", updated_at: "2013-07-16 12:34:08"&gt;, #&lt;Order id: 2, delivery_address: "2, Test Road", created_at: "2013-07-16 12:39:27", updated_at: "2013-07-16 12:39:27"&gt;]&gt;
&gt;&gt; <command>exit</command>
$</screen></para>
  </section>
</section>
