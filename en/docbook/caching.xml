<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="caching" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="caching.title">Caching</title>

  <indexterm>
    <primary>caching</primary>
  </indexterm>

  <section xml:id="caching_einleitung">
    <title xml:id="caching_einleitung.title">Introduction</title>

    <para>Where caching of web applications is concerned, most people tend to
    wait until they encounter performance problems. Then the admin first looks
    at the database and adds an index here and there. If that does not help,
    he has a look at the views and adds fragment caching. But this is not the
    best approach for working with caches. The aim of this chapter is to help
    you understand how key based cache expiration works. You can then use this
    approach to plan new applications already on the database structure level
    in such a way that you can cache optimally during development.</para>

    <para>There are two main arguments for using caching:<itemizedlist>
        <listitem>
          <para>The application becomes faster for the user. A faster web page
          results in happier users.</para>
        </listitem>

        <listitem>
          <para>You need less hardware for the web server, because you require
          less resources for processing the queries. On average, a well cached
          system only needs a fifth of the processing power of a non-cached
          system. Quite often, it is even less.</para>
        </listitem>
      </itemizedlist></para>

    <para>If these two arguments are irrelevant for you, then you do not need
    to read this chapter.</para>

    <para>We are going to look at three different caching
    methods:<itemizedlist>
        <listitem>
          <para>HTTP caching</para>

          <para>This is the sledge hammer among the caching methods and the
          ultimate performance weapon. In particular, web pages that are
          intended for mobile devices (for example iPhone) should try to make
          the most of HTTP caching. If you use a combination of key based
          cache expiration and HTTP caching, you save a huge amount of
          processing time on the server and also bandwidth.</para>
        </listitem>

        <listitem>
          <para>Page caching</para>

          <para>This is the screwdriver among the caching methods. You can get
          a lot of performance out of the system, but it is not as good as
          HTTP caching.</para>
        </listitem>

        <listitem>
          <para>Fragment caching</para>

          <para>The tweezers among the caching methods, so to speak. But don't
          underestimate it. Every little helps.</para>
        </listitem>
      </itemizedlist></para>

    <tip>
      <para>The aim is to optimally combine all three methods.</para>
    </tip>

    <section xml:id="caching_beispielapplikation">
      <title xml:id="caching_beispielapplikation.title">A Simple Example
      Application</title>

      <para>To try out the caching methods, we need an example application. We
      are going to use a simple phone book with a model for the company and a
      model for the employees of the company.</para>

      <important>
        <para>Please consider: if the processing power you save (shown later)
        is already so significant in such a simple application, it will be
        even more significant in a more complex application with more complex
        views.</para>
      </important>

      <para>We create the new Rails app:<screen>MacBook:~ xyz$ <command>rails new phone_book</command>
[...]
MacBook:~ xyz$ <command>cd phone_book</command> 
MacBook:phone_book xyz$ <command>rails generate scaffold company name</command>
[...]
MacBook:phone_book xyz$ <command>rails generate scaffold employee company_id:integer last_name first_name phone_number</command>
[...]
MacBook:phone_book xyz$ <command>rake db:migrate</command>
[...]
MacBook:phone_book xyz$</screen></para>

      <section>
        <title>Models</title>

        <para>We insert a few rudimentary rules in the two models.</para>

        <para><filename>app/models/company.rb</filename><programlisting>class Company &lt; ActiveRecord::Base
  attr_accessible :name

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true

  has_many :employees, :dependent =&gt; :destroy

  def to_s
    name
  end
end
</programlisting></para>

        <para><filename>app/models/employee.rb</filename><programlisting>class Employee &lt; ActiveRecord::Base
  attr_accessible :company_id, :first_name, :last_name, :phone_number

  belongs_to :company, :touch =&gt; true

  validates :first_name,
            :presence =&gt; true

  validates :last_name,
            :presence =&gt; true

  validates :company,
            :presence =&gt; true

  def to_s
    "#{first_name} #{last_name}"
  end
end</programlisting></para>
      </section>

      <section>
        <title>Views</title>

        <para>We change the following two company views to list the number of
        employees in the Index view and all the employees in the Show
        view.</para>

        <para><filename>app/views/companies/index.html.erb</filename><programlisting>&lt;h1&gt;Listing companies&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Number of employees&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @companies.each do |company| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= company.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= company.employees.count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', company %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_company_path(company) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', company, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Company', new_company_path %&gt;
</programlisting></para>

        <para><filename>app/views/companies/show.html.erb</filename><programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Name:&lt;/b&gt;
  &lt;%= @company.name %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_company_path(@company) %&gt; |
&lt;%= link_to 'Back', companies_path %&gt;

&lt;h2&gt;Listing employees&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Last name&lt;/th&gt;
    &lt;th&gt;First name&lt;/th&gt;
    &lt;th&gt;Phone number&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @company.employees.each do |employee| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= employee.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= employee.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= employee.phone_number %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</programlisting></para>
      </section>

      <section>
        <title>Example Data</title>

        <para>To easily populate the database, we use the Faker gem (see <uri
        xlink:href="http://faker.rubyforge.org/">http://faker.rubyforge.org/</uri>).
        With Faker, you can generate random names and phone numbers. Please
        add the following line in the
        <filename>Gemfile</filename>:<programlisting>gem 'faker'</programlisting></para>

        <para>Then start a <command>bundle install</command>:<screen>MacBook:phone_book xyz$ <command>bundle install</command>
[...]
MacBook:phone_book xyz$</screen></para>

        <para>In the <filename>db/seeds.rb</filename> we create 30 companies
        with a random number of employees in each case:<programlisting>30.times do
  company = Company.new(:name =&gt; Faker::Company.name)
  if company.save
    SecureRandom.random_number(100).times do
      company.employees.create(
                               :first_name =&gt; Faker::Name.first_name, 
                               :last_name =&gt; Faker::Name.last_name, 
                               :phone_number =&gt; Faker::PhoneNumber.phone_number
                              )
    end
  end
end</programlisting></para>

        <para>We populate it via <command>rake db:seed</command><screen>MacBook:phone_book xyz$ <command>rake db:seed</command>
MacBook:phone_book xyz$</screen></para>

        <para>You can start the application with <command>rails
        server</command> and retrieve the example data with a web browser by
        going to the URLs <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
        and <uri
        xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/1</uri>.</para>
      </section>
    </section>

    <section xml:id="caching_einleitung_normale_geschwindigkeit">
      <title xml:id="caching_einleitung_normale_geschwindigkeit.title">Normal
      Speed of the Pages to Optimize</title>

      <para>In this chapter, we optimize the following web pages. Start the
      Rails application in development mode with <command>rails
      server</command>. The relevant numbers of course depend on the hardware
      you are using.<screen>MacBook:phone_book xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.6 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-07-13 14:31:45] INFO  WEBrick 1.3.1
[2012-07-13 14:31:45] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-07-13 14:31:45] INFO  WEBrick::HTTPServer#start: pid=14357 port=3000</screen></para>

      <para>To access the web pages, we use the command line tool curl (<uri
      xlink:href="http://curl.haxx.se/">http://curl.haxx.se/</uri>). Of course
      you can also access the web pages with other web browsers. We look at
      the time shown in the Rails log for creating the page. In reality, you
      need to add the time it takes for the page to be delivered to the web
      browser.</para>

      <section xml:id="caching_einleitung_normale_geschwindigkeit_index_view">
        <title
        xml:id="caching_einleitung_normale_geschwindigkeit_index_view.title">List
        of All Companies (Index View)</title>

        <para>At the URL <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
        the user can see a list of all saved companies with the relevant
        number of employees.</para>

        <para>Generating the page takes 85ms.<screen>Completed 200 OK in 85ms (Views: 71.9ms | ActiveRecord: 12.5ms)</screen></para>
      </section>

      <section xml:id="caching_einleitung_normale_geschwindigkeit_show_view">
        <title
        xml:id="caching_einleitung_normale_geschwindigkeit_show_view.title">Detailled
        View of a Single Company (Show View)</title>

        <para>At the URL <uri
        xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/1</uri>
        the user can see the details of the first company with all
        employees.</para>

        <para>Generating the page takes 21ms.<screen>Completed 200 OK in 21ms (Views: 19.1ms | ActiveRecord: 1.1ms)</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="http_caching">
    <title xml:id="http_caching.title">HTTP Caching</title>

    <indexterm>
      <primary>caching</primary>

      <secondary>HTTP caching</secondary>
    </indexterm>

    <para>HTTP caching attempts to reuse already loaded web pages or files.
    For example, if you visit a web page such as <uri
    xlink:href="http://www.heise.de">http://www.heise.de</uri> or <uri
    xlink:href="http://www.spiegel.de">http://www.spiegel.de</uri> several
    times a day to read the latest news, then certain elements of that page
    (for example, the logo image at the top of the page) will not be loaded
    again on your second visit. Your browser already has these files in the
    cache, which saves loading time and bandwidth.</para>

    <para>Within the Rails framework, our aim is answering the question "Has a
    page changed?" already in the controller. Because normally, most of the
    time is spent on rendering the page in a view. You can see this really
    well in <xref
    linkend="caching_einleitung_normale_geschwindigkeit_index_view"/>: of the
    total 85ms, a massive 71.9ms and therefore 80% of the overall time are
    spent on rendering the view.</para>

    <section xml:id="http_caching_last_modified">
      <title xml:id="http_caching_last_modified.title">Last-Modified</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>HTTP caching</secondary>

        <tertiary>last-modified</tertiary>
      </indexterm>

      <important>
        <para>Please modify the times used in the examples in accordance with
        your own local circumstances.</para>
      </important>

      <para>The web browser knows when it has downloaded a web page and then
      placed it into the cache. It can pass this information to the web server
      in an <code>If-Modified-Since:</code> header. The web server can then
      compare this information to the corresponding file and either deliver a
      newer version or return an HTTP 304 Not Modified code as response. In
      case of a 304, the web server delivers the cached version. Now you are
      going to say, "That's all very well for images, but it won't help me at
      all for dynamically generated web pages such as the Index view of the
      companies." Ah, but you are underestimating what Rails can do.
      ;-)</para>

      <para>Please edit the <methodname>index</methodname> and
      <methodname>show</methodname> methods in the controller file
      <filename>app/controllers/companies_controller.rb</filename> as follows
      :<programlisting>  def index
    @companies = Company.order(:id)

    fresh_when last_modified: @companies.maximum(:updated_at)
  end

  def show
    @company = Company.find(params[:id])

    fresh_when last_modified: @company.updated_at
  end</programlisting></para>

      <note>
        <para>We use <code>@companies = Company.order(:id)</code> instead of
        <code>@companies = Company.all</code> in order to be able to use
        ActiveRecord's lazy loading (see <xref
        linkend="lazy_loading"/>).</para>
      </note>

      <para>After restarting the Rails application, we have a look at the HTTP
      header of <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies</command>
HTTP/1.1 200 OK 
<emphasis>Last-Modified: Fri, 13 Jul 2012 12:14:50 GMT</emphasis>
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
X-Ua-Compatible: IE=Edge
X-Request-Id: a2b4f9bc64f53637691a4665563568f6
X-Runtime: 0.066358
Content-Length: 0
Server: WEBrick/1.3.1 (Ruby/1.9.3/2012-04-20)
Date: Fri, 13 Jul 2012 14:22:24 GMT
Connection: Keep-Alive
Set-Cookie: _phone_book_session=BAh7B0kiD3Nlc3Npb25faWQGOgZFRkkiJTliNWQxOTQ4ZDNmNTI2M2Q0ZjZiZTI5ZjdjYzIyY2EwBjsAVEkiEF9jc3JmX3Rva2VuBjsARkkiMVg1ZjNBNFBWcWxZSWJQRzM3aVczS2hiTzBtckx4SzFjeWQwOEZGWHVwNkU9BjsARg%3D%3D--08bd7983f93a82133df64e0c742953808c2e6d1f; path=/; HttpOnly

MacBook:~ xyz$</screen></para>

      <para>The <code>Last-Modified</code> entry in the HTTP header was
      generated by <methodname>fresh_when</methodname> in the controller. If
      we later go to the same web page and specify this time as well, then we
      do not get the web page back, but a <code>304 Not Modified</code>
      message:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies --header 'If-Modified-Since: Fri, 13 Jul 2012 12:14:50 GMT'</command>
HTTP/1.1 304 Not Modified 
Last-Modified: Fri, 13 Jul 2012 12:14:50 GMT
Cache-Control: max-age=0, private, must-revalidate
X-Ua-Compatible: IE=Edge
X-Request-Id: 7802f078add46dc372adaec92f343fe2
X-Runtime: 0.008647
Server: WEBrick/1.3.1 (Ruby/1.9.3/2012-04-20)
Date: Fri, 13 Jul 2012 14:27:15 GMT
Connection: close

MacBook:~ xyz$</screen></para>

      <para>In the Rails log, we find this:<screen>Started HEAD "/companies" for 127.0.0.1 at 2012-07-13 16:29:53 +0200
Processing by CompaniesController#index as */*
   (0.2ms)  SELECT MAX("companies"."updated_at") AS max_id FROM "companies" 
<emphasis>Completed 304 Not Modified in 2ms (ActiveRecord: 0.2ms)</emphasis></screen></para>

      <para>Rails took 2ms to answer this request, compared to the 67ms of the
      standard variation. This is more than 40 times faster! So you have used
      around 40 times less resources on the server. And saved a massive amount
      of bandwidth. The user will be able to see the page much more
      quickly.</para>

      <para>This result was achieved through
      <code>@companies.maximum(:updated_at)</code> in the controller. We only
      had to check when the last update was done in the database. As soon as a
      single company record changes, the value is set to the then current time
      and the whole web page is delivered once more. With this method, you can
      also deliver generically generated web pages via
      <code>Last-Modified</code> headers.</para>
    </section>

    <section xml:id="http_caching_etag">
      <title xml:id="http_caching_etag.title">Etag</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>HTTP caching</secondary>

        <tertiary>etag</tertiary>
      </indexterm>

      <para>Sometimes the <varname>update_at</varname> field of a particular
      object is not meaningful on its own. For example, if you have a web page
      where users can log in and this page then generates web page contents
      based on a role model, it can happen that user A as admin is able to see
      an Edit link that is not displayed to user B as normal user. In such a
      scenario, the Last-Modified header explained in <xref
      linkend="http_caching_last_modified"/> does not help.</para>

      <para>In these cases, we can use the etag header. The etag is generated
      by the web server and delivered when the web page is first visited. If
      the user visits the same URL again, the browser can then check if the
      corresponding web page has changed by sending a
      <code>If-None-Match:</code> query to the web server.</para>

      <para>Please edit the <methodname>index</methodname> and
      <methodname>show</methodname> methods in the controller file
      <filename>app/controllers/companies_controller.rb</filename> as
      follows:<programlisting>  def index
    @companies = Company.all

    fresh_when etag: @companies
  end

  def show
    @company = Company.find(params[:id])

    fresh_when etag: @company
  end</programlisting></para>

      <para>A special Rails feature comes into play for the etag: Rails
      automatically sets a new CSRF token for each new visitor of the website.
      This prevents cross-site request forgery attacks (see <uri
      xlink:href="http://de.wikipedia.org/wiki/Cross-Site_Request_Forgery">http://en.wikipedia.org/wiki/Cross_site_request_forgery</uri>).
      But it also means that each new user of a web page gets a new etag for
      the same page. To ensure that the same users also get identical CSRF
      tokens, these are stored in a cookie by the web browser and consequently
      sent back to the web server every time the web page is visited. The curl
      we used for developing does not do this by default. But we can tell curl
      that we want to save all cookies in a file and transmit these cookies
      later if a request is received.</para>

      <para>For saving, we use the <code>-c cookies.txt</code>
      parameter.<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -c cookies.txt</command>
HTTP/1.1 200 OK 
Etag: "b5f711016cb2e5fce352230e607ceffe"
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$</screen></para>

      <para>With the parameter <code>-b cookies.txt</code>, curl sends these
      cookies to the web server when a request arrives. Now we get the same
      etag for two subsequent requests:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -b cookies.txt</command>
HTTP/1.1 200 OK 
<emphasis>Etag: "132c1be24595b9b5f7b2c08b300592b1"</emphasis>
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -b cookies.txt</command>
HTTP/1.1 200 OK 
<emphasis>Etag: "132c1be24595b9b5f7b2c08b300592b1"</emphasis>
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$</screen></para>

      <para>We now use this etag to find out in the request with If-None-Match
      if the version we have cached is still up to date:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -b cookies.txt --header 'If-None-Match: "132c1be24595b9b5f7b2c08b300592b1"'</command>
<emphasis>HTTP/1.1 304 Not Modified</emphasis> 
Etag: "132c1be24595b9b5f7b2c08b300592b1"
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$</screen></para>

      <para>We get a <code>304 Not Modified</code> in response. Let's look at
      the Rails log:<screen>Started HEAD "/companies" for 127.0.0.1 at 2012-07-13 18:45:38 +0200
Processing by CompaniesController#index as */*
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" 
<emphasis>Completed 304 Not Modified in 3ms (ActiveRecord: 0.3ms)</emphasis></screen></para>

      <para>Rails only took 3ms to process the request. Almost 30 times as
      fast as the variation without cache! Plus we have saved bandwidth again.
      The user will be happy with the speedy web application.</para>

      <section xml:id="http_caching_etag_current_user">
        <title xml:id="http_caching_etag_current_user.title">current_user and
        Other Potential Parameters</title>

        <para>As basis for generating an etag, we can not just pass an object,
        but also an array of objects. This way, we can solve the problem with
        the logged-in user. Let's assume that a logged-in user is output with
        the method <methodname>current_user</methodname>. The methods
        <methodname>index</methodname> and <methodname>show</methodname> would
        then look like this in the
        <filename>app/controllers/companies_controller.rb</filename>
        controller:<programlisting>  def index
    @companies = Company.all

    <emphasis>fresh_when etag: [@companies, current_user]</emphasis>
  end

  def show
    @company = Company.find(params[:id])

    <emphasis>fresh_when etag: [@company, current_user]</emphasis>
  end</programlisting></para>

        <para>You can accommodate any number of objects in this array and use
        this approach to define when a page has not changed.</para>
      </section>
    </section>

    <section xml:id="http_caching_etag_and_last_modified">
      <title xml:id="http_caching_etag_and_last_modified.title">Combining Etag
      and Last-Modified</title>

      <para>You can also use <code>Etag</code> and <code>Last-Modified</code>
      together. Here is what it looks like:<programlisting>  def index
    @companies = Company.order(:id)

    fresh_when :etag =&gt; @companies.all, 
               :last_modified =&gt; @companies.maximum(:updated_at)
  end

  def show
    @company = Company.find(params[:id])

    fresh_when @company
  end</programlisting></para>

      <para>As you can see, there is an abbreviated form for the show view.
      That is because <varname>@company</varname> has a method
      <methodname>updated_at</methodname>. This is then used automatically by
      <methodname>fresh_when</methodname>.</para>
    </section>

    <section xml:id="http_caching_touch">
      <title xml:id="http_caching_touch.title">The Magic of touch</title>

      <para>What happens if an <classname>Employee</classname> is edited or
      deleted? Then the show view and potentially also the index view would
      have to change as well. That is the reason for the line <programlisting>belongs_to :company, :touch =&gt; true</programlisting>
      in the employee model. Every time an object of the class
      <classname>Employee</classname> is saved in edited form, and if
      <code>:touch =&gt; true</code> is used, ActiveRecord updates the
      superordinate <classname>Company</classname> element in the database.
      The <varname>updated_at</varname> field is set to the current time. It
      is "touched".</para>

      <para>This approach ensures that a correct web page is once more
      delivered.</para>
    </section>

    <section xml:id="http_caching_stale">
      <title xml:id="http_caching_stale.title">stale?</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>HTTP caching</secondary>

        <tertiary>stale?</tertiary>
      </indexterm>

      <para>Up to now, we have always assumed that only HTML pages are
      deliverd. So we were able to use <methodname>fresh_when</methodname> and
      then do without the <code>respond_to do |format|</code> block. But HTTP
      caching is not limited to HTML pages. Yet if we render JSON (for
      example) as well and want to deliver it via HTTP caching, we need to use
      the method <methodname>stale?</methodname>. Using
      <methodname>stale?</methodname> resembles using the method
      <methodname>fresh_when</methodname>. The example of <xref
      linkend="http_caching_etag_and_last_modified"/> would then look like
      this if we use <methodname>stale?</methodname> and additionally render
      JSON:<programlisting>  def index
    @companies = Company.order(:id)

    if stale? :etag =&gt; @companies.all, 
              :last_modified =&gt; @companies.maximum(:updated_at)
      respond_to do |format|
        format.html
        format.json { render json: @companies }
      end
    end
  end

  def show
    @company = Company.find(params[:id])

    if stale? @company
      respond_to do |format|
        format.html
        format.json { render json: @company }
      end
    end
  end</programlisting></para>
    </section>

    <section xml:id="http_caching_public">
      <title xml:id="http_caching_public.title">Using Proxies (public)</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>HTTP caching</secondary>

        <tertiary>public</tertiary>
      </indexterm>

      <para>Up to now, we always assumed that we are using a cache on the web
      browser. But on the Internet, there are many proxies that are often
      closer to the user and can therefore useful for caching in case of
      non-personalized pages. If our example was a publicly accessible phone
      book, then we could activate the free services of the proxies with the
      parameter <code>public: true</code> in
      <methodname>fresh_when</methodname> or <methodname>stale?</methodname>.
      The example of <xref linkend="http_caching_etag_and_last_modified"/>
      would then look like this if using <code>public:
      true</code>:<programlisting>  def index
    @companies = Company.order(:id)

    fresh_when :etag =&gt; @companies.all, 
               :last_modified =&gt; @companies.maximum(:updated_at),
               :public =&gt; true
  end

  def show
    @company = Company.find(params[:id])

    fresh_when @company, public: true
  end</programlisting></para>

      <para>We go to the web page and get the output:<screen>MacBook:rails-buch stefan$ <command>curl -I http://0.0.0.0:3000/companies</command>
HTTP/1.1 200 OK 
Etag: "d45a37972109e8ccea1160d81a6ff79d"
Last-Modified: Sat, 14 Jul 2012 12:40:25 GMT
Content-Type: text/html; charset=utf-8
<emphasis>Cache-Control: public</emphasis>
[...]</screen></para>

      <para>The header <code>Cache-Control: public</code> tells all proxies
      that they can also cache this web page.</para>

      <warning>
        <para>Using proxies always has to be done with great caution. On the
        one hand, they are brilliantly suited for delivering your own web page
        quickly to more users, but on the other, you have to be absolutely
        sure that no personalized pages are cached on public proxies. For
        example, CSRF tags and Flash messages should never end up in a public
        proxy. To be sure with the CSRF tags, it is a good idea to make the
        output of <methodname>csrf_meta_tag</methodname> in the default
        <filename>app/views/layouts/application.html.erb</filename> layout
        dependent on the question whether the page may be cached publicly or
        not:<programlisting>&lt;%= csrf_meta_tag unless response.cache_control[:public] %&gt;</programlisting></para>
      </warning>
    </section>

    <section>
      <title>Cache-Control With Time Limit</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>HTTP caching</secondary>

        <tertiary>time limit</tertiary>
      </indexterm>

      <indexterm>
        <primary>caching</primary>

        <secondary>HTTP caching</secondary>

        <tertiary>Cache-Control</tertiary>
      </indexterm>

      <para>When using <code>Etag</code> and <code>Last-Modified</code> we
      assume in <xref linkend="http_caching_etag"/> and <xref
      linkend="http_caching_last_modified"/> that the web browser definitely
      checks once more with the web server if the cached version of a web page
      is still current. This is a very safe approach.</para>

      <para>But you can take the optimization one step further by predicting
      the future: if I am already sure when delivering the web page that this
      web page is not going to change in the next two minutes, hours or days,
      then I can tell the web browser this directly. It then does not need to
      check back again within this specified period of time. This overhead
      saving has advantages, especially with mobile web browsers with
      relatively high latency. Plus you also save server load on the web
      server.</para>

      <para>In the output of the HTTP header, you may already have noticed the
      corresponding line in the <code>Etag</code> and
      <code>Last-Modified</code> examples: <screen>Cache-Control: max-age=0, private, must-revalidate</screen>The
      item <code>must-revalidate</code> tells the web browser that it should
      definitely check back with the web server to see if a web page has
      changed in the meantime. The second parameter <code>private</code> means
      that only the web browser is allowed to cache this page. Any proxies on
      the way are not permitted to cache this page.</para>

      <para>If we decide for our phone book that the web page is going to stay
      unchanged for at least 2 minutes, then we can expand the example <xref
      linkend="http_caching_etag_and_last_modified"/> by adding the method
      <methodname>expires_in</methodname>. The controller
      <filename>app/controllers/companies.rb</filename> would then contain the
      following code for the method <methodname>index</methodname> and
      <methodname>show</methodname>:<programlisting>  def index
    @companies = Company.order(:id)

    expires_in 2.minutes
    fresh_when :etag =&gt; @companies.all, :last_modified =&gt; @companies.maximum(:updated_at)
  end

  def show
    @company = Company.find(params[:id])

    expires_in 2.minutes
    fresh_when @company
  end
</programlisting></para>

      <para>Now we get a different cache control information in response to a
      request:<screen>MacBook:rails-buch stefan$ <command>curl -I http://0.0.0.0:3000/companies</command>
HTTP/1.1 200 OK 
Etag: "d45a37972109e8ccea1160d81a6ff79d"
Last-Modified: Sat, 14 Jul 2012 12:40:25 GMT
Content-Type: text/html; charset=utf-8
<emphasis>Cache-Control: max-age=120, private</emphasis>
[...]</screen></para>

      <para>The two minutes are specified in seconds
      (<code>max-age=120</code>) and we no longer need
      <code>must-revalidate</code>. So in the next 120 seconds, the web
      browser does not need to check back with the web server to see if the
      content of this page has changed.</para>

      <note>
        <para>This mechanism is also used by the asset pipeline. Assets
        created there in the production environment can be identified clearly
        by the checksum in the file name and can be cached for a very long
        time both in the web browser and in public proxies. That's why we have
        the following section in the nginx configuration file in <xref
        linkend="production_webserver_capistrano_nginx_konfiguration"/>:<programlisting>location ^~ /assets/ {
  gzip_static on;
  expires max;
  add_header Cache-Control public;
}</programlisting></para>
      </note>
    </section>
  </section>

  <section xml:id="page_caching">
    <title xml:id="page_caching.title">Page Caching</title>

    <indexterm>
      <primary>caching</primary>

      <secondary>page caching</secondary>
    </indexterm>

    <para>With page caching, it's all about placing a complete HTML page (in
    other words, the render result of a view) into a subdirectory of the
    <filename>public</filename> directory and to have it delivered directly
    from there by the web server (for example Nginx) whenever the web page is
    visited next. Additionally, you can also save a compressed gz version of
    the HTML page there. A production web server will automatically deliver
    files below <filename>public</filename> itself and can also be configured
    so that any gz files present are delivered directly.</para>

    <para>In complex views that may take 500ms or even more for rendering, the
    amount of time you save is of course considerable. As web page operator,
    you once more save valuable server resources and can service more visitors
    with the same hardware. The web page user profits from a faster delivery
    of the web page.</para>

    <warning>
      <para>When programming your Rails application, please ensure that you
      also update this page itself, or delete it! You will find a description
      in <xref linkend="page_caches_automatisch_loeschen"/>. Otherwise, you
      end up with an outdated cache later.</para>

      <para>Please also ensure that page caching rejects all URL parameters by
      default. For example, if you try to go to <uri
      xlink:href="http://0.0.0.0:3000/companies?search=abc">http://0.0.0.0:3000/companies?search=abc</uri>
      this automatically becomes <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>.
      But that can easily be fixed with a better route logic.</para>
    </warning>

    <para>Please install a fresh example application (see <xref
    linkend="caching_beispielapplikation"/>).</para>

    <section xml:id="page_caching_im_devel_modus_aktivieren">
      <title xml:id="page_caching_im_devel_modus_aktivieren.title">Activating
      Page Caching in Development Mode</title>

      <para>First we need to go to the file
      <filename>config/environments/development.rb</filename> and set the item
      <code>config.action_controller.perform_caching</code> to
      <code>true</code>:<programlisting>config.action_controller.perform_caching = true</programlisting></para>

      <para>Otherwise, we cannot try the page caching in development mode. In
      production mode, page caching is enabled by default.</para>
    </section>

    <section xml:id="page_caching_fuer_index_und_show">
      <title>Caching Company Index and Show View</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>page caching</secondary>

        <tertiary>caches_page</tertiary>
      </indexterm>

      <para>Enabling page caching happens in the controller. If we want to
      cache the index and show views for Company, we need to go to the
      controller <filename>app/controllers/companies_controller.rb</filename>
      and enter the command <code>caches_page :index, :show</code> at the
      top:<programlisting>class CompaniesController &lt; ApplicationController
  <emphasis>caches_page :index, :show</emphasis>

  # GET /companies
  # GET /companies.json
  def index
    @companies = Company.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @companies }
    end
  end

[...]</programlisting></para>

      <para>Before starting the application, the <filename>public</filename>
      directory looks like this:<screen>public/
|-- 404.html
|-- 422.html
|-- 500.html
|-- favicon.ico
|-- index.html
`-- robots.txt</screen></para>

      <para>After starting the appliation with <command>rails server</command>
      and going to the URLs <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      and <uri
      xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/1</uri>
      via a web browser, it looks like this:<screen>public/
|-- 404.html
|-- 422.html
|-- 500.html
|-- companies
|   `-- 1.html
|-- companies.html
|-- favicon.ico
|-- index.html
`-- robots.txt</screen></para>

      <para>The files <filename>public/companies.html</filename> and
      <filename>public/companies/1.html</filename> have been created by page
      caching. From now on, the web server will only deliver the cached
      versions when these pages are accessed.</para>

      <section xml:id="page_caching_gz_compression">
        <title>gz Versions</title>

        <indexterm>
          <primary>caching</primary>

          <secondary>page caching</secondary>

          <tertiary>:gzip =&gt; :best_compression</tertiary>
        </indexterm>

        <para>If you use page cache, you should also cache directly zipped gz
        files. You can do this via the option <code>:gzip =&gt; true</code> or
        use a specific compression parameter as symbol instead of
        <code>true</code> (for example <code>:best_compression</code>).</para>

        <para>The controller
        <filename>app/controllers/companies_controller.rb</filename> would
        then look like this at the beginning:<programlisting>class CompaniesController &lt; ApplicationController
  <emphasis>caches_page :index, :show, :gzip =&gt; :best_compression</emphasis>

  # GET /companies
  # GET /companies.json
  def index
    @companies = Company.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @companies }
    end
  end

[...]</programlisting></para>

        <para>This automatically saves a compressed and an uncompressed
        version of each page cache:<screen>public/
|-- 404.html
|-- 422.html
|-- 500.html
|-- companies
|   |-- 1.html
|   `-- 1.html.gz
|-- companies.html
|-- companies.html.gz
|-- favicon.ico
|-- index.html
`-- robots.txt</screen></para>
      </section>

      <section xml:id="page_caching_html_ending_nginx_rewrite">
        <title>The File Extension .html</title>

        <para>Rails saves the page accessed at <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
        under the file name <filename>companies.html</filename>. So the
        upstream web server will find and deliver this file if you go to <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies.html</uri>,
        but not if you try to go to <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>,
        because the extension <filename>.html</filename> at the end of the URI
        is missing.</para>

        <para>If you are using the Nginx server as described in <xref
        linkend="rails_production_webserver"/>, the easiest way is adapting
        the <code>try_files</code> instruction in the Nginx configuration file
        as follows:<programlisting>try_files $uri/index.html $uri $uri.html @unicorn;
</programlisting></para>

        <para>Nginx then checks if a file with the extension
        <filename>.html</filename> of the currently accessed URI
        exists.</para>
      </section>
    </section>

    <section xml:id="page_caches_automatisch_loeschen">
      <title xml:id="page_caches_automatisch_loeschen.title">Deleting Page
      Caches Automatically</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>page caching</secondary>

        <tertiary>delete</tertiary>
      </indexterm>

      <indexterm>
        <primary>caching</primary>

        <secondary>page caching</secondary>

        <tertiary>Sweeper</tertiary>
      </indexterm>

      <para>As soon as the data used in the view changes, the saved cache
      files have to be deleted. Otherwise, the cache would no longer be up to
      date.</para>

      <para>According to the official Rails documentation, the solution for
      this problem is the class
      <classname>ActionController::Caching::Sweeper</classname>. But this
      approach, described at <uri
      xlink:href="http://guides.rubyonrails.org/caching_with_rails.html#sweepers">http://guides.rubyonrails.org/caching_with_rails.html#sweepers</uri>,
      has a big disadvantage: it is limited to actions that happen within the
      controller. So if an action is triggered via URL by the web browser, the
      corresponding cache is also changed or deleted. But if an object is
      deleted in the console, for example, the sweeper would not realize this.
      For that reason, I am going to show you an approach that does not use a
      sweeper, but works directly in the model with ActiveRecord
      callbacks.</para>

      <para>In our phone book application, we always need to delete the cache
      for <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      and <uri
      xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/company_id</uri>
      when editing a company. When editing an employee, we also have to delete
      the corresponding cache for the relevant employee.</para>

      <important>
        <para>We need to ensure that we do not cache pages with a flash
        message. Nor does it make sense to integrate a CSRF metatag in these
        cached pages. In the following code, we take care of both these
        issues.</para>
      </important>

      <section>
        <title>Controllers</title>

        <para>Let's start with the controllers. Please edit the beginning of
        <filename>app/controllers/companies_controller.rb</filename> as
        follows:<programlisting>class CompaniesController &lt; ApplicationController
<emphasis>  caches_page :index, :show, :gzip =&gt; :best_compression, 
                             :if =&gt; Proc.new { flash.count == 0 }
  before_filter(only: [:index, :show]) { @page_caching_is_active = true if flash.count == 0 }</emphasis>

  # GET /companies
  # GET /companies.json
  def index
    @companies = Company.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @companies }
    end
  end

[...]</programlisting></para>

        <para>Please also insert the <methodname>cache_page</methodname>
        instruction into the controller
        <filename>app/controllers/employees_controller.rb</filename>:<programlisting>class EmployeesController &lt; ApplicationController
<emphasis>  caches_page :index, :show, :gzip =&gt; :best_compression, 
                             :if =&gt; Proc.new { flash.count == 0 }
  before_filter(only: [:index, :show]) { @page_caching_is_active = true if flash.count == 0 }</emphasis>

  # GET /employees
  # GET /employees.json
  def index
    @employees = Employee.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @employees }
    end
  end

[...]</programlisting></para>
      </section>

      <section>
        <title>Models</title>

        <para>Now we still need to fix the models so that the corresponding
        caches are deleted automatically as soon as an object is created,
        edited or deleted.</para>

        <para><filename>app/models/company.rb</filename><programlisting>class Company &lt; ActiveRecord::Base
  attr_accessible :name

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true

  has_many :employees, :dependent =&gt; :destroy

<emphasis>  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache
</emphasis>
  def to_s
    name
  end

<emphasis>  def expire_cache
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.company_path(self))
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.companies_path)
  end
</emphasis>
end</programlisting></para>

        <para><filename>app/models/employee.rb</filename><programlisting>class Employee &lt; ActiveRecord::Base
  attr_accessible :company_id, :first_name, :last_name, :phone_number

  belongs_to :company, :touch =&gt; true

  validates :first_name,
            :presence =&gt; true

  validates :last_name,
            :presence =&gt; true

  validates :company,
            :presence =&gt; true

<emphasis>  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache</emphasis>

  def to_s
    "#{first_name} #{last_name}"
  end

<emphasis>  def expire_cache
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.employee_path(self))
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.employees_path)
    self.company.expire_cache
  end</emphasis>

end</programlisting></para>
      </section>

      <section>
        <title>application.html.erb</title>

        <para>In the
        <filename>app/views/layouts/application.html.erb</filename> we still
        need to check if a CSRF metatag is present. This is not the case with
        cached pages.<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;PhoneBook&lt;/title&gt;
  &lt;%= stylesheet_link_tag    "application", :media =&gt; "all" %&gt;
  &lt;%= javascript_include_tag "application" %&gt;
  <emphasis>&lt;%= csrf_meta_tag unless @page_caching_is_active %&gt;</emphasis>
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="fragment_caching">
    <title xml:id="fragment_caching.title">Fragment Caching</title>

    <indexterm>
      <primary>caching</primary>

      <secondary>fragment caching</secondary>
    </indexterm>

    <para>With fragment caching you can cache individual parts of a view. You
    can safely use it in combination with <xref linkend="http_caching"/> and
    <xref linkend="page_caching"/>. The advantages once again are a reduction
    of server load and faster web page generation, which means increased
    usability.</para>

    <para>Please install a new example application (see <xref
    linkend="caching_beispielapplikation"/>).</para>

    <section xml:id="fragment_caching_im_devel_modus_aktivieren">
      <title
      xml:id="fragment_caching_im_devel_modus_aktivieren.title">Enabling
      Fragment Caching in Development Mode</title>

      <para>First, we need to go to the file
      <filename>config/environments/development.rb</filename> and set the item
      <code>config.action_controller.perform_caching</code> to
      <code>true</code>:<programlisting>config.action_controller.perform_caching = true</programlisting></para>

      <para>Otherwise, we cannot try out the fragment caching in development
      mode. In production mode, fragment caching is enabled by default.</para>
    </section>

    <section xml:id="fragment_caching_tabelle_cachen">
      <title xml:id="fragment_caching_tabelle_cachen.title">Caching Table of
      Index View</title>

      <para>On the page <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>,
      a very computationally intensive table with all companies is rendered.
      We can cache this table as a whole. To do so, we need to enclose the
      table in a <code>&lt;% cache('name_of_cache') do %&gt; ... &lt;% end
      %&gt;</code> block:<programlisting>&lt;% cache('name_of_cache') do %&gt;

[...]

&lt;% end %&gt;</programlisting></para>

      <para>Please edit the file
      <filename>app/views/companies/index.html.erb</filename> as
      follows:<programlisting>&lt;h1&gt;Listing companies&lt;/h1&gt;

<emphasis>&lt;% cache('table_of_all_companies') do %&gt;</emphasis>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Number of employees&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @companies.each do |company| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= company.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= company.employees.count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', company %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_company_path(company) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', company, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;
<emphasis>&lt;% end %&gt;</emphasis>

&lt;br /&gt;

&lt;%= link_to 'New Company', new_company_path %&gt;</programlisting></para>

      <para>Then you can start the Rails server with <command>rails
      server</command> and go to the URL <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>.
      In the development log, you will now see the following entry:<screen><emphasis>Write fragment views/table_of_all_companies (2.9ms)</emphasis>
  Rendered companies/index.html.erb within layouts/application (119.8ms)
Completed 200 OK in <emphasis>209ms</emphasis> (Views: 143.1ms | ActiveRecord: 15.0ms)</screen></para>

      <para>Writing the cache took 2.9 ms. In total, rendering the page took
      209 ms.</para>

      <para>If you repeatedly go to the same page, you will get a different
      result in the log:<screen><emphasis>Read fragment views/table_of_all_companies (0.2ms)</emphasis>
  Rendered companies/index.html.erb within layouts/application (0.8ms)
Completed 200 OK in <emphasis>37ms</emphasis> (Views: 34.6ms | ActiveRecord: 0.3ms)</screen></para>

      <para>Reading the cache took 0.2 ms and rendering the page in total
      37ms. Only a fifth of the processing time!</para>
    </section>

    <section xml:id="fragment_cache_loeschen">
      <title xml:id="fragment_cache_loeschen.title">Deleting Fragment
      Cache</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>fragment caching</secondary>

        <tertiary>deleting cache</tertiary>
      </indexterm>

      <indexterm>
        <primary>caching</primary>

        <secondary>fragment caching</secondary>

        <tertiary>expire_fragment</tertiary>
      </indexterm>

      <para>With the method <methodname>expire_fragment</methodname> you can
      clear specific fragment caches. Basically, we can build this idea into
      the model in the same way as shown in <xref
      linkend="page_caches_automatisch_loeschen"/>.</para>

      <para>The model file <filename>app/models/company.rb</filename> would
      then look like this:<programlisting>class Company &lt; ActiveRecord::Base
  attr_accessible :name

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true

  has_many :employees, :dependent =&gt; :destroy

  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache

  def to_s
    name
  end

  def expire_cache
    <emphasis>ActionController::Base.new.expire_fragment('table_of_all_companies')</emphasis>
  end
end</programlisting></para>

      <para>As the number of employees also has an effect on this table, we
      would also have to expand the file
      <filename>app/models/employees.rb</filename>
      accordingly:<programlisting>class Employee &lt; ActiveRecord::Base
  attr_accessible :company_id, :first_name, :last_name, :phone_number

  belongs_to :company, :touch =&gt; true

  validates :first_name,
            :presence =&gt; true

  validates :last_name,
            :presence =&gt; true

  validates :company,
            :presence =&gt; true

  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache

  def to_s
    "#{first_name} #{last_name}"
  end

  def expire_cache
    <emphasis>ActionController::Base.new.expire_fragment('table_of_all_companies')</emphasis>
  end  
end</programlisting></para>

      <para>Deleting specific fragment caches often involves a lot of effort
      in terms of programming. One, you often miss things and two, in big
      projects it's not easy to keep track of all the different cache names.
      Often it is easier to automatically create names via the method
      <methodname>cache_key</methodname>. These then expire automatically in
      the cache (see <xref linkend="fragment_auto_expiring"/>).</para>
    </section>

    <section xml:id="fragment_auto_expiring">
      <title xml:id="fragment_auto_expiring.title">Auto-Expiring
      Caches</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>fragment caching</secondary>

        <tertiary>cache_key</tertiary>
      </indexterm>

      <indexterm>
        <primary>caching</primary>

        <secondary>fragment caching</secondary>

        <tertiary>auto-expiring</tertiary>
      </indexterm>

      <indexterm>
        <primary>cache_key</primary>
      </indexterm>

      <para>Managing fragment caching is rather complex with the naming
      convention used in <xref linkend="fragment_caching_tabelle_cachen"/>. On
      the one hand, you can be sure that the cache does not have any
      superfluous ballast if you have programmed neatly, but on the other, it
      does not really matter. A cache is structured in such a way that it
      deletes old and no longer required elements on its own. If we use a
      mechanism that gives a fragment cache a unique name, as in the asset
      pipeline (see <xref linkend="asset_pipeline"/>), then we would not need
      to go to all the trouble of deleting fragment caches.</para>

      <para>That is precisely what the method
      <methodname>cache_key</methodname> is for.
      <methodname>cache_key</methodname> gives you a unique name for an
      element. Let's try it in the console. First, we get the always identical
      <methodname>cache_key</methodname> of the first company item three times
      in a row ("companies/2-20120716190032"), then we touch the item (a
      <methodname>touch</methodname> sets the attribute
      <varname>updated_at</varname> to the current time) and finally we output
      the new <methodname>cache_key</methodname> again three times in a row
      ("companies/2-20120716192035"):<screen>MacBook:phone_book xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.6)
1.9.3p194 :001 &gt; <command>Company.first.cache_key</command>
  Company Load (0.1ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716190032" 
1.9.3p194 :002 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716190032" 
1.9.3p194 :003 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716190032" 
1.9.3p194 :004 &gt; <command>Company.first.touch</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
  SQL (2.0ms)  UPDATE "companies" SET "updated_at" = '2012-07-16 19:20:35.223146' WHERE "companies"."id" = 2
 =&gt; true 
1.9.3p194 :005 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716192035" 
1.9.3p194 :006 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716192035" 
1.9.3p194 :007 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716192035" 
1.9.3p194 :008 &gt; <command>exit</command>
MacBook:phone_book xyz$</screen></para>

      <para>Let's use this knowledge to edit the index view in the file
      <filename>app/views/companies/index.html.erb</filename>:<programlisting>&lt;h1&gt;Listing companies&lt;/h1&gt;

<emphasis>&lt;% cache(@companies) do %&gt;</emphasis>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Number of employees&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @companies.each do |company| %&gt;
  <emphasis>&lt;% cache(company) do %&gt;</emphasis>
  &lt;tr&gt;
    &lt;td&gt;&lt;%= company.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= company.employees.count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', company %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_company_path(company) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', company, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
  <emphasis>&lt;% end %&gt;</emphasis>
&lt;% end %&gt;
&lt;/table&gt;<emphasis>
&lt;% end %&gt;</emphasis>

&lt;br /&gt;

&lt;%= link_to 'New Company', new_company_path %&gt;</programlisting></para>

      <para>Here, we not only use a fragment cache for the whole table, but
      also one for each line. So the initial call will take longer than
      before. But if any individual companies change, only one line has to be
      re-rendered in each case.</para>

      <note>
        <para>There is no general answer to the question in how much detail
        you should use fragment caching. Just go ahead and experiment with it,
        then look in the log to see how long things take.</para>
      </note>
    </section>

    <section xml:id="fragment_cache_software_version">
      <title xml:id="fragment_cache_software_version.title">Software
      Versioning and current_user</title>

      <para>As developer, you should always include the version in the code
      when using fragment caches. Then you don't risk serving out an old cache
      with old content for a new software version. You can specify the name of
      a fragment cache as array instead of as string. Example:<programlisting>&lt;% cache(['V3.23', @companies]) do %&gt;

[...]

&lt;% end %&gt;</programlisting></para>

      <para>Via this mechanism, you can also implement caches for individual
      users. If you have a user object with the name
      <code>current_user</code>, you can use the following code for fragment
      caching:<programlisting>&lt;% cache(['V3.23', current_user, @companies]) do %&gt;

[...]

&lt;% end %&gt;</programlisting></para>

      <para>If no user is logged in, then <code>current_user</code> is nil and
      works for all not logged in users.</para>

      <tip>
        <para>It would take us beyond the scope of this book, but when using a
        file version management system (such as git) it can be useful to
        integrate a constant instead of the 'V3.23' and to set it in an
        initializer with the current commit SHA from the used
        repository.</para>
      </tip>
    </section>

    <section xml:id="fragment_cache_cache_store">
      <title xml:id="fragment_cache_cache_store.title">Cache Store</title>

      <indexterm>
        <primary>caching</primary>

        <secondary>fragment caching</secondary>

        <tertiary>cache store</tertiary>
      </indexterm>

      <indexterm>
        <primary>cache store</primary>
      </indexterm>

      <para>The cache store manages the stored fragment caches. If not
      configured otherwise, this is the Rails MemoryStore. This cache store is
      good for developing, but less suitable for a production system because
      it acts independently for each Ruby on Rails process. So if you have
      several Ruby on Rails processes running in parallel in the production
      system, each process holds its own MemoryStore.</para>

      <section xml:id="fragment_cache_memcachestore">
        <title
        xml:id="fragment_cache_memcachestore.title">MemCacheStore</title>

        <indexterm>
          <primary>cache store</primary>

          <secondary>MemCacheStore</secondary>
        </indexterm>

        <indexterm>
          <primary>memcached</primary>
        </indexterm>

        <para>Most production systems use memcached (<uri
        xlink:href="http://memcached.org/">http://memcached.org/</uri>) as
        cache store. To enable memcached as cache store in the production
        system, you need to add the following line in the file
        <filename>config/environments/production.rb</filename>:<programlisting>config.cache_store = :mem_cache_store</programlisting></para>

        <para>Additionally, you need to go to the file Gemfile and add an
        entry for loading the memcache-client gem:<programlisting>group :production do
  gem 'memcache-client'
end</programlisting></para>

        <para>Then you need to do a <command>bundle install</command>:<screen>Stefan-Wintermeyers-MacBook-Air:phone_book xyz$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phone_book xyz$</screen></para>

        <para>The combination of appropriately used auto-expiring caches and
        memcached is an excellent recipe for a successful web page.</para>

        <para>For a description of how to install a Rails production system
        with memcached, please read <xref
        linkend="rails_production_webserver"/>.</para>
      </section>

      <section>
        <title>Other Cache Stores</title>

        <para>In the official Rails documentation you will find a list of
        other cache stores at <uri
        xlink:href="http://guides.rubyonrails.org/caching_with_rails.html#cache-stores">http://guides.rubyonrails.org/caching_with_rails.html#cache-stores</uri>.</para>
      </section>
    </section>
  </section>

  <section xml:id="cache_vorheizen">
    <title xml:id="cache_vorheizen.title">Preheating</title>

    <indexterm>
      <primary>caching</primary>

      <secondary>preheat</secondary>
    </indexterm>

    <para>Now that you have read your way through the caching chapter, here is
    a final tip: preheat your cache!</para>

    <para>For example, if you have a web application in a company and you know
    that at 9 o'clock in the morning, all employees are going to log in and
    then access this web application, then it's a good idea to let your web
    server go through all those views a few hours in advance with cron-job. At
    night, your server is probably bored anyway.</para>

    <para>Check out the behavior patterns of your users. With public web
    pages, this can be done for example via Google Analytics (<uri
    xlink:href="http://www.google.com/intl/de/analytics/">http://www.google.com/analytics/</uri>).
    You will find that at certain times of the day, there is a lot more
    traffic going in. If you have a quiet phase prior to this, you can use it
    to warm up your cache.</para>

    <para>The purpose of preheating is once more saving server ressources and
    achieving better quality for the user, as the web page is displayed more
    quickly.</para>
  </section>
</chapter>
