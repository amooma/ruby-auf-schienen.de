<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_datensatz_veraendern"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_datensatz_veraendern.title">Editing a
  Record</title>

  <para>Adding data is quite nice, but often you want to edit a record. To
  show how that's done I use the album database from <xref
  linkend="queries"/>.</para>

  <section xml:id="activerecord_einfaches_editieren">
    <title xml:id="activerecord_einfaches_editieren.title">Simple
    Editing</title>

    <para>Simple editing of a record takes place in the following
    steps:<orderedlist>
        <listitem>
          <para>Finding the record and creating a corresponding
          instance</para>
        </listitem>

        <listitem>
          <para>Changing the attribute</para>
        </listitem>

        <listitem>
          <para>Saving the record via the method <indexterm>
              <primary>ActiveRecord</primary>

              <secondary>methods</secondary>

              <tertiary>save()</tertiary>
            </indexterm><methodname>save</methodname></para>
        </listitem>
      </orderedlist></para>

    <para>We are now searching for the album <quote>The Beatles</quote> and
    changing its name to <quote>A Test</quote>:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>beatles_album = Album.where(name: 'The Beatles').first</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'The Beatles' ORDER BY "albums"."id" ASC LIMIT 1
=&gt; #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;
&gt;&gt; <command>beatles_album.name</command>
=&gt; "The Beatles"
&gt;&gt; <command>beatles_album.name = 'A Test'</command>
=&gt; "A Test"
&gt;&gt; <command>beatles_album.save</command>
   (0.2ms)  begin transaction
  SQL (2.1ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 10  [["name", "A Test"], ["updated_at", Tue, 16 Jul 2013 08:08:00 UTC +00:00]]
   (2.6ms)  commit transaction
=&gt; <command>true</command>
&gt;&gt; <command>exit</command>
$</screen></para>
  </section>

  <section xml:id="activerecord_changed">
    <title xml:id="activerecord_changed.title">changed?</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>changed?()</tertiary>
    </indexterm>

    <para>If you are not sure if a record has been changed and not yet saved,
    you can check via the method <methodname>changed?</methodname>:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>beatles_album = Album.where(id: 10).first</command>
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = 10 ORDER BY "albums"."id" ASC LIMIT 1
=&gt; #&lt;Album id: 10, name: "A Test", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-16 08:08:00"&gt;
&gt;&gt; <command>beatles_album.changed?</command>
=&gt; false
&gt;&gt; <command>beatles_album.name = 'The Beatles'</command>
=&gt; "The Beatles"
&gt;&gt; <command>beatles_album.changed?</command>
=&gt; true
&gt;&gt; <command>beatles_album.save</command>
   (0.2ms)  begin transaction
  SQL (2.3ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 10  [["name", "The Beatles"], ["updated_at", Tue, 16 Jul 2013 08:23:52 UTC +00:00]]
   (2.9ms)  commit transaction
=&gt; true
&gt;&gt; <command>beatles_album.changed?</command>
=&gt; false
&gt;&gt; <command>exit</command>
$</screen></para>
  </section>

  <section xml:id="activerecord_update_attributes">
    <title
    xml:id="activerecord_update_attributes.title">update_attributes</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>update_attributes()</tertiary>
    </indexterm>

    <para>With the method <methodname>update_attributes</methodname> you can
    change several attributes of an object in one go and then immediately save
    them automatically.</para>

    <para>Let's use this method within the example used in <xref
    linkend="activerecord_einfaches_editieren"/>:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>first_album = Album.first</command>
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" ASC LIMIT 1
=&gt; #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;
&gt;&gt; <command>first_album.changed?</command>
=&gt; false
&gt;&gt; <command>first_album.update_attributes(name: 'Another Test')</command>
   (0.2ms)  begin transaction
  SQL (2.2ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 1  [["name", "Another Test"], ["updated_at", Tue, 16 Jul 2013 08:25:24 UTC +00:00]]
   (3.0ms)  commit transaction
=&gt; true
&gt;&gt; <command>first_album.changed?</command>
=&gt; false
&gt;&gt; <command>Album.first</command>
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" ASC LIMIT 1
=&gt; #&lt;Album id: 1, name: "Another Test", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-16 08:25:24"&gt;
&gt;&gt; </screen></para>

    <para>This kind of update can also be chained with a
    <methodname>where</methodname> method:<screen>&gt;&gt; <command>Album.where(name: 'Another Test').first.update_attributes(name: "Sgt. Pepper's Lonely Hearts Club Band")</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'Another Test' ORDER BY "albums"."id" ASC LIMIT 1
   (0.1ms)  begin transaction
  SQL (0.9ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 1  [["name", "Sgt. Pepper's Lonely Hearts Club Band"], ["updated_at", Tue, 16 Jul 2013 08:27:25 UTC +00:00]]
   (3.0ms)  commit transaction
=&gt; <command>true</command>
&gt;&gt; <command>exit</command>
$</screen></para>
  </section>

  <section xml:id="activerecord_locking">
    <title xml:id="activerecord_locking.title">Locking</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>locking</secondary>
    </indexterm>

    <para>There are many ways of locking a database. By default, Rails uses
    <quote>optimistic locking</quote> of records. To activate locking you need
    to have an attribute with the name <varname>lock_version</varname> which
    has to be an integer. To show how it works I'll create a new Rails project
    with a <classname>Product</classname> model. Than I'll try to change the
    price of the first <classname>Product</classname> on two different
    instances. The second change will raise an
    <errorname>ActiveRecord::StaleObjectError</errorname>.</para>

    <para>Example setup:<screen>$ <command>rails new shop</command>
  [...]
$ <command>cd shop</command>
$ <command>rails generate model Product name 'price:decimal{8,2}' lock_version:integer</command> 
  [...]
$ <command>rake db:migrate</command>
  [...]
$</screen></para>

    <para>Raising an
    <errorname>ActiveRecord::StaleObjectError</errorname>:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>Product.create(name: 'Orange', price: 0.5)</command>
   (0.1ms)  begin transaction
  SQL (4.7ms)  INSERT INTO "products" ("created_at", "lock_version", "name", "price", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 11:24:56 UTC +00:00], ["lock_version", 0], ["name", "Orange"], ["price", #&lt;BigDecimal:7f958e0f5de0,'0.5E0',9(45)&gt;], ["updated_at", Tue, 16 Jul 2013 11:24:56 UTC +00:00]]
   (3.2ms)  commit transaction
=&gt; #&lt;Product id: 1, name: "Orange", price: #&lt;BigDecimal:7f958e0f5de0,'0.5E0',9(45)&gt;, lock_version: 0, created_at: "2013-07-16 11:24:56", updated_at: "2013-07-16 11:24:56"&gt;
&gt;&gt; <command>a = Product.first</command>
  Product Load (0.3ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
=&gt; #&lt;Product id: 1, name: "Orange", price: #&lt;BigDecimal:7f958d098768,'0.5E0',9(45)&gt;, lock_version: 0, created_at: "2013-07-16 11:24:56", updated_at: "2013-07-16 11:24:56"&gt;
&gt;&gt; <command>b = Product.first</command>
  Product Load (0.4ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
=&gt; #&lt;Product id: 1, name: "Orange", price: #&lt;BigDecimal:7f958e1268a0,'0.5E0',9(45)&gt;, lock_version: 0, created_at: "2013-07-16 11:24:56", updated_at: "2013-07-16 11:24:56"&gt;
&gt;&gt; <command>a.price = 0.6</command>
=&gt; 0.6
&gt;&gt; <command>a.save</command>
   (0.2ms)  begin transaction
   (0.5ms)  UPDATE "products" SET "price" = 0.6, "updated_at" = '2013-07-16 11:25:41.931401', "lock_version" = 1 WHERE ("products"."id" = 1 AND "products"."lock_version" = 0)
   (2.0ms)  commit transaction
=&gt; true
&gt;&gt; <command>b.price = 0.7</command>
=&gt; 0.7
&gt;&gt; <command>b.save</command>
   (0.1ms)  begin transaction
   (0.2ms)  UPDATE "products" SET "price" = 0.7, "updated_at" = '2013-07-16 11:25:49.170722', "lock_version" = 1 WHERE ("products"."id" = 1 AND "products"."lock_version" = 0)
   (0.1ms)  rollback transaction
ActiveRecord::StaleObjectError: Attempted to update a stale object: Product
[...]
&gt;&gt; <command>exit</command>
$</screen></para>

    <para>You have to deal with the conflict by rescuing the exception and fix
    the conflict depending on your business logic. Please make sure to add a
    <varname>lock_version</varname> hidden field in your forms while using
    this mechanism with a WebGUI.</para>
  </section>
</section>
