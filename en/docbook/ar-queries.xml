<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="queries" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="queries.title">Searching and Finding with Queries</title>

  <para>The methods <methodname>first</methodname> and
  <methodname>all</methodname> are already quite nice, but usually you want to
  search for something specific with a query.</para>

  <para>For describing queries, we create a new Rails project:<screen>$ rails new jukebox
  [...]
$ cd jukebox 
$ rails generate model Album name release_year:integer
  [...]
$ rake db:migrate
  [...]
$</screen></para>

  <para>For the examples uses here, use a <filename>db/seeds.rb</filename>
  with the following content:<programlisting>Album.create(name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967)
Album.create(name: "Pet Sounds", release_year: 1966)
Album.create(name: "Revolver", release_year: 1966)
Album.create(name: "Highway 61 Revisited", release_year: 1965)
Album.create(name: "Rubber Soul", release_year: 1965)
Album.create(name: "What's Going On", release_year: 1971)
Album.create(name: "Exile on Main St.", release_year: 1972)
Album.create(name: "London Calling", release_year: 1979)
Album.create(name: "Blonde on Blonde", release_year: 1966)
Album.create(name: "The Beatles", release_year: 1968)</programlisting></para>

  <para>Then, set up the new database with <command>rake
  db:setup</command>:<screen>$ rake db:setup
db/development.sqlite3 already exists
-- create_table("albums", {:force=&gt;true})
   -&gt; 0.0085s
-- initialize_schema_migrations_table()
   -&gt; 0.0010s
$ </screen></para>

  <section>
    <title>Opinionated </title>

    <para>Over the last couple of years there have been many changes in the
    way queries can be placed in ActiveRecord. Many of those became deprecated
    or will become deprecated in Rails 5.0. In this chapter I'll show you the
    way to search for results which will not get you into trouble when you
    want to upgrade later.</para>
  </section>

  <section xml:id="activerecord_find">
    <title xml:id="activerecord_find.title">find</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>find()</tertiary>
    </indexterm>

    <para>The simplest case is searching for a record via a primary key (by
    default, the <varname>id</varname> field in the database table). If I know
    the ID of an object (here: a record line), then I can search for the
    individual object or several objects at once via the ID:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.find(2)
  Album Load (1.7ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 2]]
=&gt; #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;
&gt;&gt; Album.find([1,3,7])
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" IN (1, 3, 7)
=&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]
&gt;&gt;  </screen></para>

    <para>If you always want to have an array as result, you also always have
    to pass an array as parameter:<screen>&gt;&gt; Album.find(5).class
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 5]]
=&gt; Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime)
&gt;&gt; Album.find([5]).class
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 5]]
=&gt; Array
&gt;&gt; exit
$ </screen></para>

    <warning>
      <para>The method<methodname> find</methodname> generates an exception if
      the ID you are searching for does not have a record in the database. If
      in doubt, you should use <methodname>where</methodname> (see <xref
      linkend="activerecord_where"/>).</para>
    </warning>
  </section>

  <section xml:id="activerecord_where">
    <title xml:id="activerecord_where.title">where</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>where()</tertiary>
    </indexterm>

    <para>With the method <methodname>where</methodname>, you can search for
    specific values in the database. Let's search for all albums from the year
    1966:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where(release_year: 1966)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; Album.where(release_year: 1966).count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE "albums"."release_year" = 1966
=&gt; 3
&gt;&gt; </screen></para>

    <para>You can also use <methodname>where</methodname> to search for
    <foreignphrase xml:lang="en">ranges</foreignphrase> (see <xref
    linkend="range_class"/>):<screen>&gt;&gt; Album.where(release_year: 1960..1966)
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; Album.where(release_year: 1960..1966).count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
=&gt; 5
&gt;&gt;</screen></para>

    <para>And you can also specify several search factors simultaneously,
    separated by commas:<screen>&gt;&gt; Album.where(release_year: 1960..1966, id: 1..5)
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966) AND ("albums"."id" BETWEEN 1 AND 5)
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt;</screen></para>

    <para>Or an array of parameters:<screen>&gt;&gt; Album.where(release_year: [1966, 1968])
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968)
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt;</screen></para>

    <para>The result of <methodname>where</methodname> is always an array.
    Even if it only contains one hit or if no hits are returned. If you are
    looking for the first hit, you need to combine the method
    <methodname>where</methodname> with the method
    <methodname>first</methodname>:<screen>&gt;&gt; Album.where(release_year: [1966, 1968]).first
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968) ORDER BY "albums"."id" ASC LIMIT 1
=&gt; #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;
&gt;&gt; Album.where(release_year: [1966, 1968]).first.class
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968) ORDER BY "albums"."id" ASC LIMIT 1
=&gt; Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime)
&gt;&gt; exit
$ </screen></para>

    <section xml:id="activerecord_sql">
      <title xml:id="activerecord_sql.title">SQL Queries with where</title>

      <para>Sometimes there is no other way and you just have to define and
      execute your own SQL query. In ActiveRecord, there are two different
      ways of doing this. One <foreignphrase
      xml:lang="en">sanitizes</foreignphrase> each query before executing it
      and the other passes the query on to the SQL database 1 to 1 as it is.
      Normally, you should always use the sanitized version because otherwise
      you can easily fall victim to an <foreignphrase xml:lang="en">SQL
      injection</foreignphrase> attack (see <uri
      xlink:href="http://de.wikipedia.org/wiki/SQL-Injection">http://en.wikipedia.org/wiki/Sql_injection</uri>).</para>

      <para>If you do not know much about SQL, you can safely skip this
      section. The SQL commands used here are not explained further.</para>

      <section>
        <title>Sanitized Queries</title>

        <para>In this variant, all dynamic search parts are replaced by a
        question mark as placeholder and only listed as parameters after the
        SQL string.</para>

        <para>In this example, we are searching for all albums whose name
        contains the string <quote>on</quote>:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where( 'name like ?', '%on%' )
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE (name like '%on%')
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 8, name: "London Calling", release_year: 1979, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt;</screen></para>

        <para>Now the number of albums that were published from 1965
        onwards:<screen>&gt;&gt; Album.where( 'release_year &gt; ?', 1964 ).count
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE (release_year &gt; 1964)
=&gt; 10
&gt;&gt; </screen></para>

        <para>The number of albums that are more recent than 1970 and whose
        name contains the string <quote>on</quote>:<screen>&gt;&gt; Album.where( 'name like ? AND release_year &gt; ?', '%on%', 1970 ).count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%' AND release_year &gt; 1970)
=&gt; 3
&gt;&gt;</screen></para>

        <para>If the variable <varname>search_string</varname> contains the
        desired string, you can search for it as follows:<screen>&gt;&gt; search_string = 'ing'
=&gt; "ing"
&gt;&gt; Album.where( 'name like ?', "%#{search_string}%").count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%ing%')
=&gt; 2
&gt;&gt; exit
$</screen></para>
      </section>

      <section>
        <title><quote>Dangerous</quote> SQL Queries</title>

        <para>If you really know what you are doing, you can of course also
        define the SQL query completely and forego the <foreignphrase
        xml:lang="en">sanitizing</foreignphrase> of the query.</para>

        <para>Let's count all albums whose name contain the string
        <quote>on</quote>:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where( "name like '%on%'" ).count
   (0.1ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%')
=&gt; 5
&gt;&gt; exit
$ </screen></para>

        <para>Please only use this variation if you know exactly what you are
        doing and once you have familiarized yourself with the topic SQL
        injections (see <uri
        xlink:href="http://de.wikipedia.org/wiki/SQL-Injection">http://en.wikipedia.org/wiki/Sql_injection</uri>).</para>
      </section>
    </section>

    <section xml:id="lazy_loading">
      <title xml:id="lazy_loading.title">Lazy Loading</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>lazy loading</secondary>
      </indexterm>

      <indexterm>
        <primary>lazy loading</primary>

        <see>ActiveRecord, lazy loading</see>
      </indexterm>

      <para>Lazy Loading is a mechanism that only carries out a database query
      if the program flow cannot be realised without the result of this query.
      Until then, the query is saved as
      <classname>ActiveRecord::Relation</classname>. (Incidentally, the
      opposite of <foreignphrase xml:lang="en">lazy loading</foreignphrase> is
      referred to as <foreignphrase xml:lang="en">eager
      loading</foreignphrase>.)</para>

      <para>Does it make sense in principle, but you are not sure what the
      point of it all is? Then let's cobble together a query where we nest
      several methods. In the following example, <varname>a</varname> is
      defined more and more closely and only at the end (when calling the
      method <methodname>all</methodname>) the database query would really be
      executed in a production system. With the method <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>methods</secondary>

          <tertiary>to_sql()</tertiary>
        </indexterm><methodname>to_sql</methodname> you can display the
      current SQL query.<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; a = Album.where(release_year: 1965..1968)
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968)
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; a.class
=&gt; ActiveRecord::Relation::ActiveRecord_Relation_Album
&gt;&gt; a = a.order(:release_year)
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968) ORDER BY "albums".release_year ASC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; a = a.limit(3)
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968) ORDER BY "albums".release_year ASC LIMIT 3
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; exit
$ </screen></para>

      <para>The console can be a bit tricky about this. It tries to help the
      developer by actually showing the result but in a non-console
      environment this would would only happen at the very last time.</para>

      <section xml:id="activerecord_lazyloading_automatische_optimierung">
        <title
        xml:id="activerecord_lazyloading_automatische_optimierung.title">Automatic
        Optimization</title>

        <para>One of the great advantages of <foreignphrase xml:lang="en">lazy
        loading</foreignphrase> is the automatic optimization of the SQL query
        through ActiveRecord.</para>

        <para>Let's take the sum of all release years of the albums that came
        out in the 70s. Then we sort the albums alphabetically and then
        calculate the sum.<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where(release_year: 1970..1979).sum(:release_year)
   (2.7ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
=&gt; 5922
&gt;&gt; Album.where(release_year: 1970..1979).order(:name).sum(:release_year)
   (0.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
=&gt; 5922
&gt;&gt; exit
$</screen></para>

        <para>Logically, the result is the same for both queries. But the
        interesting thing is that ActiveRecord uses the same SQL code for both
        queries. It has detected that <methodname>order</methodname> is
        completely irrelevant for <methodname>sum</methodname> and therefore
        taken it out altogether.</para>

        <note>
          <para>In case you are asking yourself why the first query took 2.7ms
          and the second 0.2ms: ActiveRecord cached the results of the first
          SQL request.</para>
        </note>
      </section>
    </section>
  </section>

  <section xml:id="activerecord_order">
    <title xml:id="activerecord_order.title">order and reverse_order</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>order()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>reverse_order</tertiary>
    </indexterm>

    <para>To sort a database query, you can use the method
    <methodname>order</methodname>. Example: all albums from the 60s, sorted
    by name:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where(release_year: 1960..1969).order(:name)
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY "albums".name ASC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; </screen></para>

    <para>With the method reverse_order you can reverse an order previously
    defined via <methodname>order</methodname>:<screen>&gt;&gt; Album.where(release_year: 1960..1969).order(:name).reverse_order
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY "albums".name DESC
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; exit
$ </screen></para>
  </section>

  <section xml:id="activerecord_limit">
    <title xml:id="activerecord_limit.title">limit</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>limit()</tertiary>
    </indexterm>

    <para>The result of any search can be limited to a certain range via the
    method <methodname>limit</methodname>.</para>

    <para>The first 5 albums from the 60s:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where(release_year: 1960..1969).limit(5)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) LIMIT 5
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt;</screen></para>

    <para>All albums sorted by name, then the first 5 of those:<screen>&gt;&gt; Album.order(:name).limit(5)
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" ORDER BY "albums".name ASC LIMIT 5
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 8, name: "London Calling", release_year: 1979, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; exit
$ </screen></para>

    <section xml:id="activerecord_offset">
      <title xml:id="activerecord_offset.title">offset</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>methods</secondary>

        <tertiary>offset()</tertiary>
      </indexterm>

      <para>With the method <methodname>offset</methodname>, you can define
      the starting position of the method
      <methodname>limit</methodname>.</para>

      <para>First, we return the first two records and then the first two
      records with an offset of 5:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.limit(2)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 2
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; Album.limit(2).offset(5)
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" LIMIT 2 OFFSET 5
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; exit
$</screen></para>
    </section>
  </section>

  <section xml:id="activerecord_group">
    <title xml:id="activerecord_group.title">group</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>group()</tertiary>
    </indexterm>

    <para>With the method <methodname>group</methodname>, you can return the
    result of a query in grouped form.</para>

    <para>Let's return all albums, grouped by their release year:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.group(:release_year)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" GROUP BY release_year
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 8, name: "London Calling", release_year: 1979, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; exit
$</screen></para>
  </section>

  <section xml:id="activerecord_pluck">
    <title xml:id="activerecord_pluck.title">pluck</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>pluck()</tertiary>
    </indexterm>

    <para>Normally, ActiveRecord pulls all table columns from the database and
    leaves it up to the programmer to later pick out the components he is
    interested in. But in case of large amounts of data, it can be useful and
    above all much quicker to define a specific database field directly for
    the query. You can do this via the method <methodname>pluck</methodname>.
    <screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where(release_year: 1960..1969).pluck(:name)
   (0.1ms)  SELECT "albums"."name" FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; ["Sgt. Pepper's Lonely Hearts Club Band", "Pet Sounds", "Revolver", "Highway 61 Revisited", "Rubber Soul", "Blonde on Blonde", "The Beatles"]
&gt;&gt; Album.where(release_year: 1960..1969).pluck(:name, :release_year)
   (0.1ms)  SELECT "albums"."name", "albums"."release_year" FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; [["Sgt. Pepper's Lonely Hearts Club Band", 1967], ["Pet Sounds", 1966], ["Revolver", 1966], ["Highway 61 Revisited", 1965], ["Rubber Soul", 1965], ["Blonde on Blonde", 1966], ["The Beatles", 1968]]
&gt;&gt; exit
$</screen></para>

    <para>As a result, <methodname>pluck</methodname> returns an array.</para>
  </section>

  <section xml:id="activerecord_berechnungen">
    <title xml:id="activerecord_berechnungen.title">Calculations</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>calculations</secondary>
    </indexterm>

    <section xml:id="activerecord_average">
      <title xml:id="activerecord_average.title">average</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>methods</secondary>

        <tertiary>average()</tertiary>
      </indexterm>

      <para>With the method <methodname>average</methodname>, you can
      calculate the average of the values in a particular column of the table.
      Our data material is of course not really suited to this. But as an
      example, let's calculate the average release year of all albums and then
      the same for albums from the 60s:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.average(:release_year)
   (0.1ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums"
=&gt; #&lt;BigDecimal:7fbf9bbe1fb0,'0.19685E4',18(45)&gt;
&gt;&gt; Album.average(:release_year).to_s
   (0.4ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums"
=&gt; "1968.5"
&gt;&gt; Album.where( :release_year =&gt; 1960..1969 ).average(:release_year)
   (0.2ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; #&lt;BigDecimal:7fbf9f002510,'0.1966142857 142857E4',27(45)&gt;
&gt;&gt; Album.where( :release_year =&gt; 1960..1969 ).average(:release_year).to_s
   (0.3ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; "1966.142857142857"
&gt;&gt; exit
$</screen></para>
    </section>

    <section xml:id="activerecord_count">
      <title xml:id="activerecord_count.title">count</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>methods</secondary>

        <tertiary>count()</tertiary>
      </indexterm>

      <para>The name says it all: the method <methodname>count</methodname>
      counts the number of records.</para>

      <para>First, we return the number of all albums in the database and then
      the number of albums from the 60s:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.count
   (0.1ms)  SELECT COUNT(*) FROM "albums"
=&gt; 10
&gt;&gt; Album.where(release_year: 1960..1969).count
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; 7
&gt;&gt; exit
$</screen></para>
    </section>

    <section xml:id="activerecord_maximum">
      <title xml:id="activerecord_maximum.title">maximum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>methods</secondary>

        <tertiary>maximum()</tertiary>
      </indexterm>

      <para>With the method <methodname>maximum</methodname>, you can output
      the item with the highest value within a query.</para>

      <para>Let's look for the highest release year:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.maximum(:release_year)
   (0.1ms)  SELECT MAX("albums"."release_year") AS max_id FROM "albums"
=&gt; 1979
&gt;&gt; exit
$</screen></para>
    </section>

    <section xml:id="activerecord_minimum">
      <title xml:id="activerecord_minimum.title">minimum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>methods</secondary>

        <tertiary>minimum()</tertiary>
      </indexterm>

      <para>With the method <methodname>minimum</methodname>, you can output
      the item with the lowest value within a query.</para>

      <para>Let's find the lowest release year:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.minimum(:release_year)
   (0.1ms)  SELECT MIN("albums"."release_year") AS min_id FROM "albums"
=&gt; 1965
&gt;&gt; exit
$</screen></para>
    </section>

    <section xml:id="activerecord_sum">
      <title xml:id="activerecord_sum.title">sum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>methods</secondary>

        <tertiary>sum()</tertiary>
      </indexterm>

      <para>With the method sum, you can calculate the sum of all items in a
      specific column of the database query.</para>

      <para>Let's find the sum of all release years:<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.sum(:release_year)
   (0.1ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums"
=&gt; 19685
&gt;&gt; exit
$ </screen></para>
    </section>
  </section>

  <section xml:id="activerecord_explain">
    <title xml:id="activerecord_explain.title">SQL EXPLAIN</title>

    <para>Most SQL databases can provide detailled information on a SQL query
    with the command EXPLAIN. This does not make much sense for our mini
    application, but if you are working with a large database one day, then
    EXPLAIN is a good debugging method, for example to find out where to place
    an index. SQL EXPLAIN can be called with the method
    <methodname>explain</methodname> (it will be displayed in prettier form if
    you add a <code>puts</code>):<screen>$ rails console
Loading development environment (Rails 4.0.0)
&gt;&gt; Album.where(release_year: 1960..1969)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; #&lt;ActiveRecord::Relation [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50"&gt;]&gt;
&gt;&gt; Album.where(release_year: 1960..1969).explain
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=&gt; EXPLAIN for: SELECT "albums".* FROM "albums"  WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
0|0|0|SCAN TABLE albums (~500000 rows)

&gt;&gt; exit
$ </screen></para>
  </section>
</section>
