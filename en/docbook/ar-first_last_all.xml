<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="ar-first_last_all"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="ar-first_last_all.title">first, last and all</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>methods</secondary>

    <tertiary>first()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>methods</secondary>

    <tertiary>last()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>methods</secondary>

    <tertiary>all()</tertiary>
  </indexterm>

  <para>In certain cases, you may need the first record, or the last one, or
  perhaps even all records. Conveniently, there is a ready-made method for
  each case. Let's start with the easiest ones: <methodname>first</methodname>
  and <methodname>last</methodname>.<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>Country.first</command>
  Country Load (0.1ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=&gt; #&lt;Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20"&gt;
&gt;&gt; <command>Country.last</command>
  Country Load (0.3ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" DESC LIMIT 1
=&gt; #&lt;Country id: 4, name: "Netherlands", population: nil, created_at: "2013-07-15 18:08:52", updated_at: "2013-07-15 18:08:52"&gt;
&gt;&gt;</screen></para>

  <para>And now all at once with <methodname>all</methodname>:<screen>&gt;&gt; <command>Country.all</command>
  Country Load (0.2ms)  SELECT "countries".* FROM "countries"
=&gt; #&lt;ActiveRecord::Relation [#&lt;Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20"&gt;, #&lt;Country id: 2, name: "France", population: 65447374, created_at: "2013-07-15 18:07:03", updated_at: "2013-07-15 18:07:03"&gt;, #&lt;Country id: 3, name: "Belgium", population: 10839905, created_at: "2013-07-15 18:08:07", updated_at: "2013-07-15 18:08:07"&gt;, #&lt;Country id: 4, name: "Netherlands", population: nil, created_at: "2013-07-15 18:08:52", updated_at: "2013-07-15 18:08:52"&gt;]&gt;
&gt;&gt;</screen></para>

  <para>But the objects created by <methodname>first</methodname>,
  <methodname>last</methodname> and <methodname>all</methodname> are
  different. <methodname>first</methodname> and <methodname>last</methodname>
  return an object of the class <classname>Country</classname> and
  <methodname>all</methodname> of course returns an array of such
  objects:<screen>&gt;&gt; <command>Country.first.class</command>
  Country Load (0.3ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=&gt; Country(id: integer, name: string, population: integer, created_at: datetime, updated_at: datetime)
&gt;&gt; <command>Country.all.class</command>
=&gt; ActiveRecord::Relation::ActiveRecord_Relation_Country
&gt;&gt;</screen></para>

  <para>So <code>Country.first</code> is a <classname>Country</classname>
  which makes sense. But <code>Country.all</code> is something we haven't had
  yet. Let's use the console to get a better idea of it:<screen>&gt;&gt; <command>puts Country.all.to_yaml</command>
  Country Load (0.4ms)  SELECT "countries".* FROM "countries"
---
- !ruby/object:Country
  attributes:
    id: 1
    name: Germany
    population: 81831000
    created_at: 2013-07-15 18:03:20.814776000 Z
    updated_at: 2013-07-15 18:03:20.814776000 Z
- !ruby/object:Country
  attributes:
    id: 2
    name: France
    population: 65447374
    created_at: 2013-07-15 18:07:03.227571000 Z
    updated_at: 2013-07-15 18:07:03.227571000 Z
- !ruby/object:Country
  attributes:
    id: 3
    name: Belgium
    population: 10839905
    created_at: 2013-07-15 18:08:07.125974000 Z
    updated_at: 2013-07-15 18:08:07.125974000 Z
- !ruby/object:Country
  attributes:
    id: 4
    name: Netherlands
    population: 
    created_at: 2013-07-15 18:08:52.736007000 Z
    updated_at: 2013-07-15 18:08:52.736007000 Z
=&gt; nil
&gt;&gt;</screen></para>

  <para>hmmm... by using the <methodname>to_yaml</methodname> method suddenly
  the database has work to do. The reason for this behavior is optimization.
  Let's assume that you want to chain a couple of methods. Than it might be
  better for ActiveRecord to wait till the very last second which it does. It
  only requests the data from the SQL database when it has to do it. Until
  than it stores the request in a
  <classname>ActiveRecord::Relation</classname>.</para>

  <para>The result of <code>Country.all</code> is actually an
  <classname>Array</classname> of <classname>Country</classname>.</para>

  <para>If <methodname>Country.all</methodname> returns an array, then we
  should also be able to use iterators (see <xref linkend="iterator"/> and
  <xref linkend="array_iterator"/>), right? Yes, of course! That is the beauty
  of it. Here is a little experiment with
  <methodname>each</methodname>:<screen>&gt;&gt; <command>Country.all.each do |country|</command>
?&gt; <command>puts country.name</command>
&gt;&gt; <command>end</command>
  Country Load (0.3ms)  SELECT "countries".* FROM "countries"
Germany
France
Belgium
Netherlands
=&gt; [#&lt;Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20"&gt;, #&lt;Country id: 2, name: "France", population: 65447374, created_at: "2013-07-15 18:07:03", updated_at: "2013-07-15 18:07:03"&gt;, #&lt;Country id: 3, name: "Belgium", population: 10839905, created_at: "2013-07-15 18:08:07", updated_at: "2013-07-15 18:08:07"&gt;, #&lt;Country id: 4, name: "Netherlands", population: nil, created_at: "2013-07-15 18:08:52", updated_at: "2013-07-15 18:08:52"&gt;]
&gt;&gt; </screen></para>

  <para>So can we also use <code>.all.first</code> as an alternative for
  <code>.first</code>? Yes, but it does not make much sense. Have a look for
  yourself:<screen>&gt;&gt; <command>Country.first</command>
  Country Load (0.3ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=&gt; #&lt;Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20"&gt;
&gt;&gt; <command>Country.all.first</command>
  Country Load (0.4ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=&gt; #&lt;Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20"&gt;
&gt;&gt; </screen></para>

  <para><code>Country.first</code> and <code>Country.all.first</code> result
  in exact the same SQL query.</para>
</section>
