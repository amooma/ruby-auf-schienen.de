<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="erste_schritte_mit_rails" xml:lang="en"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="erste_schritte_mit_rails.title">First Steps with
  Rails</title>

  <indexterm>
    <primary>Rails</primary>

    <secondary>introduction</secondary>
  </indexterm>

  <indexterm>
    <primary>Ruby on Rails</primary>

    <see>Rails</see>
  </indexterm>

  <section xml:id="erste-schritte-mit-rails-einleitung">
    <title>Introduction</title>

    <para>Now that you have painstakingly read your way through <xref
    linkend="ruby-grundlagen"/> we can move on to a more exciting bit. In this
    chapter, we will start our first Ruby on Rails project and find our way
    into the topic step by step.</para>

    <para>We will use Ruby on Rails version 4.0. Please update to this version
    in case have installed an older one.</para>

    <note>
      <para>In this chapter, we will also move on the double in some cases.
      Once more, there will be some typical chicken and egg problems.</para>
    </note>

    <section xml:id="arbeits-umgebung-development">
      <title>Environment (Development)</title>

      <para>By default a Rails project offers three different
      environments<indexterm>
          <primary>environments</primary>
        </indexterm><indexterm>
          <primary>Rails</primary>

          <secondary>environments</secondary>

          <see>environments</see>
        </indexterm><foreignphrase xml:lang="en"/>:<itemizedlist>
          <listitem>
            <para><foreignphrase
            xml:lang="en">Development</foreignphrase><indexterm>
                <primary>Development</primary>

                <secondary>environment</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><foreignphrase xml:lang="en">Test</foreignphrase><indexterm>
                <primary>Test</primary>

                <secondary>environment</secondary>
              </indexterm></para>
          </listitem>

          <listitem>
            <para><foreignphrase
            xml:lang="en">Production</foreignphrase><indexterm>
                <primary>Production</primary>

                <secondary>environment</secondary>
              </indexterm></para>
          </listitem>
        </itemizedlist></para>

      <para>In this chapter, we are only working with the Development
      environment. Once you have gained a better feeling for Rails, we will
      start using tests and then we will need the corresponding environment
      (where, for example, the Test database is populated when you start a
      test and then cleared). Later, I will exlain the various scenarios to
      show how you can roll out your Rails application from the Development
      environment to the Production environment.</para>

      <para>The Development environment has everything you need for
      developing, apart from an editor and a web browser. So you do not need
      to install a special web server, but can use the integrated Rails web
      server. It does not exactly have extremely high performance, but you do
      not need that for developing. Later, you can switch to big web servers
      like <application>Apache</application> or
      <application>Nginx</application>. The same applies to the
      database.</para>

      <para>In order to work in the Development environment, you do not need
      to make any changes to start with - all commands work by default.</para>

      <section xml:id="sqlite3_datenbank_default">
        <title>SQLite-3 Database</title>

        <indexterm>
          <primary>SQLite</primary>
        </indexterm>

        <para>In terms of the database, the main focus in this chapter is once
        more not on optimum performance, but on showing you a simple way of
        getting started. That's why we are using the SQLite-3 database. You
        already have everything you need fully installed and you don't need to
        worry about anything. Later I will explain how you can use other
        databases (for example MySQL).</para>
      </section>
    </section>

    <section xml:id="warum_english">
      <title xml:id="warum_english.title">Why Is It All in English?</title>

      <para>If you are a native English speaker, you may not find it
      surprising that Rails apparently loves the English language. Even if you
      are not a native English speaker, you should try to accept and even
      adopt Rails' love for the English language. Much of it will then be much
      easier and more logical. Most of the code then reads just like a normal
      English sentence. <indexterm>
          <primary>inflections</primary>
        </indexterm><indexterm>
          <primary>inflector</primary>

          <see>inflections</see>
        </indexterm><indexterm>
          <primary>inflexion</primary>

          <see>inflections</see>
        </indexterm><indexterm>
          <primary>pluralization</primary>

          <see>inflections</see>
        </indexterm><indexterm>
          <primary>singularization</primary>

          <see>inflections</see>
        </indexterm>For example, many mechanisms automagically use plural or
      singular forms of normal English words. If you get used to naming
      database fields and tables with English terms (even if you are
      programming in a different language), then you can make use of the whole
      power of this magic. This mechanism is referred to as
      <code>Inflector</code> <footnote>
          <para>see <uri
          xlink:href="http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html">http://api.rubyonrails.org/classes/ActiveSupport/Inflector.html</uri></para>
        </footnote> or <foreignphrase
      xml:lang="en">Inflections</foreignphrase> (inflexions <footnote>
          <para>see <uri
          xlink:href="http://de.wikipedia.org/wiki/Flexion">http://en.wikipedia.org/wiki/Inflection</uri></para>
        </footnote>).</para>

      <para>If you are programming in a language other than English, it still
      makes sense to use English names for variables, classes and methods. You
      can write the comments in your own language, but if you take part in
      international projects, you should obviously write the comments in
      English as well. Yeah, sure … well written code does not need any
      comments. ;-)</para>
    </section>
  </section>

  <section xml:id="statische_webseiten">
    <title xml:id="statische_webseiten.title">Static Content (HTML and
    Graphics Files)</title>

    <para>If you are reading this text, you will already know that you can use
    Rails to somehow output web pages. The question is just how it's done.
    Let's first create a new Rails project.</para>

    <section xml:id="rails-projekt-anlegen">
      <title>Create Rails Project</title>

      <indexterm>
        <primary>Rails</primary>

        <secondary>create project</secondary>
      </indexterm>

      <para>Before we even get going, please check that you are using Ruby
      version 2.0:<screen>$ <command>ruby -v</command>
ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin12.4.0]
$</screen></para>

      <para>Next, check if Rails 4.0 is also installed:<screen>$ <command>rails -v</command>
Rails 4.0.0
$</screen></para>

      <para>That's looking good. If you have an older version of Ruby or Rails
      installed, please install the 4.0 version before you read any
      further.</para>

      <para>Now we start by creating a new Rails project with the name
      <literal>testproject</literal>. Ruby on Rails is a framework, so we
      first need to set up the corresponding directory structure and basic
      configuration, including several scripts. Easy as pie, just use the
      command <command>rails new testproject</command>:<screen>$ <command>rails new testproject</command>
      create  
      create  README.rdoc
      create  Rakefile
      create  config.ru
      [...]
$ </screen></para>

      <note>
        <para><indexterm>
            <primary>bundle</primary>
          </indexterm><indexterm>
            <primary>bundler</primary>
          </indexterm><indexterm>
            <primary>gems</primary>
          </indexterm>In previous versions of Rails, you had to do a
        <command>bundle install</command> first. With Rails 3.2 onwards, this
        is done automatically when you create a new Rails project. The Rails
        project then has all required <foreignphrase
        xml:lang="en">gems</foreignphrase> available. A <foreignphrase
        xml:lang="en">gem</foreignphrase> is a kind of software library. You
        can integrate certain ready-made functionalities with it, without
        having to reinvent the wheel.</para>
      </note>

      <para><indexterm>
          <primary>Webrick</primary>
        </indexterm><indexterm>
          <primary>web server</primary>

          <secondary>integrated</secondary>
        </indexterm>Next, we check if the new Rails application is working by
      launching the integrated web server.<tip>
          <para>Depending on the operating system (for example, Mac OS X) and
          on your firewall settings, you may see a popup window when first
          starting a Rails application, asking you if the firewall should
          permit the corresponding connection. As we are only working locally,
          you can safely confirm.</para>
        </tip><screen>$ <command>cd testproject</command> 
$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Run `rails server -h` for more startup options
=&gt; Ctrl-C to shutdown server
[2013-07-15 13:58:48] INFO  WEBrick 1.3.1
[2013-07-15 13:58:48] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-15 13:58:48] INFO  WEBrick::HTTPServer#start: pid=98552 port=3000</screen></para>

      <para>The start of the Rails application is looking good. It tells
      us:<screen>Rails 4.0.0 application starting in development on http://0.0.0.0:3000</screen></para>

      <para>So let's go to the URL <uri
      xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri> or <uri
      xlink:href="http://localhost:3000">http://localhost:3000</uri> in the
      web browser.<screenshot>
          <info>
            <title>Default index page in a new Rails project.</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/virgin_rails_app.jpg"/>
            </imageobject>

            <textobject>
              <simpara>Welcome aboard</simpara>

              <simpara>You're riding Ruby on Rails!</simpara>

              <para>…</para>
            </textobject>
          </mediaobject>
        </screenshot></para>

      <para>Looks good. Rails seems to be working fine. The log of it tells
      what just happend:<screen>Started GET "/" for 127.0.0.1 at 2013-07-15 13:59:35 +0200
Processing by Rails::WelcomeController#index as HTML
  Rendered /Users/xyz/.rvm/gems/ruby-2.0.0-p247/gems/railties-4.0.0/lib/rails/templates/rails/welcome/index.html.erb (1.1ms)
Completed 200 OK in 21ms (Views: 5.3ms | ActiveRecord: 0.0ms)</screen></para>

      <para>If we now click the link <quote><foreignphrase xml:lang="en">About
      your application's environment</foreignphrase></quote>, we can more
      information on the current environment.</para>

      <important>
        <para>With <keycombo>
            <keycap function="control">Ctrl</keycap>

            <keycap>C</keycap>
          </keycombo> you can stop the web server.</para>
      </important>
    </section>

    <section xml:id="rails-statische-inhalte">
      <title>Static Pages</title>

      <indexterm>
        <primary>static pages/contents</primary>

        <secondary>in a Rails application</secondary>
      </indexterm>

      <indexterm>
        <primary>public</primary>

        <secondary>directory</secondary>
      </indexterm>

      <para>There are certain static pages, images and JavaScript files that
      are automatically output by Rails. Remember part of the output of the
      command <command>rails new testproject</command>: <screen>$ <command>rails new testproject</command>
      [...]
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/robots.txt
      [...]
</screen></para>

      <para>The directory name <filename>public</filename> and the files it
      contains already look very much like static pages. <indexterm>
          <primary>Hello World</primary>

          <secondary>in Rails</secondary>
        </indexterm> Let's have a go and create the file
      <filename>public/hello-world.html</filename> with the following
      content:<programlisting>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Hello World!&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;p&gt;An example page.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

      <para>Now start the Rails web server with <command>rails
      server</command><screen>$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Run `rails server -h` for more startup options
=&gt; Ctrl-C to shutdown server
[2013-07-15 14:05:57] INFO  WEBrick 1.3.1
[2013-07-15 14:05:57] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-15 14:05:57] INFO  WEBrick::HTTPServer#start: pid=98564 port=3000</screen></para>

      <para>We can have a look at this web page at the URL <uri
      xlink:href="http://0.0.0.0:3000/hello-world">http://0.0.0.0:3000/hello-world</uri>:<screenshot>
          <info>
            <title>Hello World HTML page</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/hello-world-html.jpg"/>
            </imageobject>

            <textobject>
              <para>Hello World!</para>
            </textobject>
          </mediaobject>
        </screenshot></para>

      <para>No output in the log means: This page was not handled by the Rails
      framework. It was delivered directly from the webserver.</para>

      <note>
        <para>We can of course also use the URL <uri
        xlink:href="http://0.0.0.0:3000/hello-world.html">http://0.0.0.0:3000/hello-world.html</uri>.
        But Rails regards HTML and therefore the file ending
        <literal>.html</literal> as standard output format, so you can omit
        the <quote><literal>.html</literal></quote> here.</para>
      </note>

      <para>Now you know how you can integrate fully static pages in Rails.
      This is useful for pages that never change and that you want to work
      even if Rails is not currently working, for example because of an
      update. In a production environment, you would usually put a classic web
      server such as <application>Apache</application> or
      <application>Nginx</application> infront of the Rails server. Which is
      capable of autonomously delivering static files from the
      <filename>public</filename> directory. You'll learn how to set up a
      production webserver in <xref
      linkend="rails_production_webserver"/>.</para>

      <para>With <keycombo>
          <keycap function="control">Ctrl</keycap>

          <keycap>C</keycap>
        </keycombo> you can stop the Rails server.</para>
    </section>
  </section>

  <section xml:id="dynamische_webseiten">
    <title xml:id="dynamische_webseiten.title">Creating HTML Dynamically with
    erb</title>

    <indexterm>
      <primary>erb</primary>
    </indexterm>

    <indexterm>
      <primary>rhtml</primary>

      <see>erb</see>
    </indexterm>

    <indexterm>
      <primary>templates</primary>

      <seealso>erb</seealso>

      <seealso>views</seealso>

      <seealso>layouts</seealso>
    </indexterm>

    <para>The the content of an <literal>erb</literal> file will propably seem
    familiar to you. It is a mixture of HTML and Ruby code
    (<literal>erb</literal> stands for <foreignphrase xml:lang="en"><emphasis
    role="bold">e</emphasis>mbedded <emphasis
    role="bold">R</emphasis>u<emphasis
    role="bold">b</emphasis>y</foreignphrase>). erb pages are rendered as
    Views. This is the first time for us to get in touch with the <indexterm>
        <primary>Model-View-Controller</primary>

        <see>MVC</see>
      </indexterm><indexterm>
        <primary>MVC</primary>
      </indexterm>MVC model.<footnote>
        <para><uri
        xlink:href="http://de.wikipedia.org/wiki/Model_View_Controller">http://en.wikipedia.org/wiki/Model-view-controller</uri></para>
      </footnote> We need a <indexterm>
        <primary>controller</primary>
      </indexterm>controller to use a view. That can be created it via the
    generator <command>rails generate controller</command>. Let's have a look
    at the onboard help of this generator:<screen>$ <command>rails generate controller</command>
Usage:
  rails generate controller NAME [action action] [options]

Options:
      [--skip-namespace]        # Skip namespace (affects only isolated applications)
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
  -t, [--test-framework=NAME]   # Test framework to be invoked
                                # Default: test_unit
      [--helper]                # Indicates when to generate helper
                                # Default: true
      [--assets]                # Indicates when to generate assets
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Suppress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Stubs out a new controller and its views. Pass the controller name, either
    CamelCased or under_scored, and a list of views as arguments.

    To create a controller within a module, specify the controller name as a
    path like 'parent_module/controller_name'.

    This generates a controller class in app/controllers and invokes helper,
    template engine, assets, and test framework generators.

Example:
    `rails generate controller CreditCards open debit credit close`

    CreditCards controller with URLs like /credit_cards/debit.
        Controller: app/controllers/credit_cards_controller.rb
        Test:       test/controllers/credit_cards_controller_test.rb
        Views:      app/views/credit_cards/debit.html.erb [...]
        Helper:     app/helpers/credit_cards_helper.rb
$</screen></para>

    <para>Nice! We are kindly provided with an example further
    down:<programlisting>rails generate controller CreditCard open debit credit close</programlisting>Doesn't
    really fit the bill for our case but I am feeling brave and suggest that
    we simply try <command>rails generate controller Example
    test</command><screen>$ <command>rails generate controller Example test</command>
      create  app/controllers/example_controller.rb
       route  get "example/test"
      invoke  erb
      create    app/views/example
      create    app/views/example/test.html.erb
      invoke  test_unit
      create    test/controllers/example_controller_test.rb
      invoke  helper
      create    app/helpers/example_helper.rb
      invoke    test_unit
      create      test/helpers/example_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/example.js.coffee
      invoke    scss
      create      app/assets/stylesheets/example.css.scss
$</screen></para>

    <para>Phew... that's a lot of stuff being created. Amongst others, the
    file <filename>app/views/example/test.html.erb</filename>. Let's have a
    closer look at it:<screen>$ <command>cat app/views/example/test.html.erb</command> 
&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;
$</screen></para>

    <para>It's HTML, but for it to be a valid HTML page, something is
    <quote>missing</quote> at the top and bottom (the missing HTML "rest" will
    be explained in <xref linkend="erb_layouts"/>). We launch the web server
    to test it<screen>$ <command>rails server</command></screen></para>

    <para>and have a look at the web page in the browser at the URL <uri
    xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>:<screenshot>
        <info>
          <title>test.html.erb web page</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/example-test-erb.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>In the <indexterm>
        <primary>Log</primary>
      </indexterm>log <filename>log/development.log</filename> we find the
    following lines:<programlisting>Started GET "/example/test" for 127.0.0.1 at 2013-07-15 14:32:07 +0200
Processing by ExampleController#test as HTML
  Rendered example/test.html.erb within layouts/application (0.8ms)
Completed 200 OK in 768ms (Views: 751.0ms | ActiveRecord: 0.0ms)

Started GET "/assets/example.css?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/example.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/application.css?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/jquery_ujs.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/jquery.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/application.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/turbolinks.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200</programlisting></para>

    <para>That almost reads like normal English. Let us analyse the first
    part:<programlisting>Started GET "/example/test" for 127.0.0.1 at 2013-07-15 14:32:07 +0200
Processing by ExampleController#test as HTML
  Rendered example/test.html.erb within layouts/application (0.8ms)</programlisting></para>

    <para><literal>localhost</literal> (127.0.0.1) sent in an HTTP GET request
    for the URI <quote><literal>/example/test</literal></quote>. That was then
    apparently rendered as HTML by the controller
    <code>ExampleController</code> using the method
    <methodname>test</methodname>.</para>

    <note>
      <para>The other lines tell us that a bunch of CSS and JavaScript files
      are compiled and than delivered. In production mode these would be
      precompiled and delivered as one CSS and one J</para>
    </note>

    <para>Now we just need to find the controller. Good thing you bough this
    book. ;-) All controllers are in the directory
    <filename>app/controllers</filename>, and there you go, we indeed find the
    corresponding file
    <filename>app/controllers/example_controller.rb.</filename><screen>$ <command>ls -l app/controllers/</command>
total 16
-rw-r--r--  1 xyz  staff  204 15 Jul 13:56 application_controller.rb
drwxr-xr-x  3 xyz  staff  102 15 Jul 13:56 concerns
-rw-r--r--  1 xyz  staff   69 15 Jul 14:31 example_controller.rb
$</screen></para>

    <para>Please open the file
    <filename>app/controllers/example_controller.rb</filename> with your
    favorite editor:<programlisting>class ExampleController &lt; ApplicationController
  def test
  end
end</programlisting></para>

    <para>That is very clear. The controller <code>ExampleController</code> is
    a descendant of the <code>ApplicationController</code> and contains
    currently just one method with the name <methodname>test</methodname>.
    This method contains currently no program logic.</para>

    <para><indexterm>
        <primary>routing</primary>
      </indexterm><indexterm>
        <primary>routes.rb</primary>
      </indexterm><indexterm>
        <primary>inflections</primary>
      </indexterm>You will probably ask yourself how Rails knows that for the
    URL path <uri>/example/test</uri> it should process the controller
    <code>ExampleController</code> and the method <code>test</code>. This is
    not determined by some magical logic, but by a <foreignphrase
    xml:lang="en">routing</foreignphrase> configuration. The current routings
    can be listed with the command <command>rake routes</command><screen>$ <command>rake routes</command>
      Prefix Verb URI Pattern             Controller#Action
example_test GET /example/test(.:format) example#test
$ </screen></para>

    <para>These routes are configured in the file
    <filename>config/routes.rb</filename> which has been auto-filled by the
    controller generator with a route to <code>example/test</code>. The one
    line which is important for us right now is the second one:<screen>$ <command>head -n 2 config/routes.rb</command> 
Testproject::Application.routes.draw do
  get "example/test"
$ </screen></para>

    <para>The <filename>config/routes.rb</filename> file includes a lot of
    examples. Give it a read when you have time. We'll dive into that later
    (<xref linkend="routes"/>).</para>

    <important>
      <para>A static file in the directory <filename>public</filename> always
      has higher priority than a route in the
      <filename>config/routes.rb</filename>! So if we were to save a static
      file <filename>public/example/test</filename> that file will be
      delivered.</para>
    </important>

    <section xml:id="erb-programmieren">
      <title>Programming in an erb File</title>

      <indexterm>
        <primary>erb</primary>
      </indexterm>

      <para><literal>Erb</literal> pages can contain Ruby code. You can use it
      to program and give these page dynamic content.</para>

      <para>Let's start with something very simple: adding 1 and 1. First we
      try out the code in <literal>irb</literal>:<screen>$ <command>irb --simple-prompt</command>
&gt;&gt; <command>1 + 1</command>
=&gt; 2
&gt;&gt; <command>exit</command>
$</screen></para>

      <para>That was easy. We fill the <literal>erb</literal> file
      <filename>app/views/example/test.html.erb</filename> as
      follows:<programlisting>&lt;h1&gt;First experiment with erb&lt;/h1&gt;
&lt;p&gt;Addition:
&lt;%= 1 + 1 %&gt;
&lt;/p&gt;</programlisting></para>

      <para>Then use <command>rails server</command> to launch the web
      server.<screen>$ <command>rails server</command></screen></para>

      <para>Visit that page with the URL <uri
      xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri><screenshot>
          <info>
            <title>Simple addition</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/erb_einfache_addition.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <important>
        <para>If you want to output the result of Ruby code, enclose the code
        within a <code>&lt;%=</code> ... <code>%&gt;</code>.</para>
      </important>

      <para>You may ask yourself: how can the result of adding two
      <classname>Fixnums</classname> be displayed as a String? Let's first
      look up in <literal>irb</literal> if it really is a
      <classname>Fixnum</classname>:<screen>$ <command>irb --simple-prompt</command>
&gt;&gt; <command>1.class</command>
=&gt; Fixnum
&gt;&gt; <command>(1 + 1).class</command>
=&gt; Fixnum </screen></para>

      <para>Yes, both the number 1 and the result of 1 + 1 is a
      <classname>Fixnum</classname>. What happened? Rails is so intelligent
      that it automatically calls all objects in a <indexterm>
          <primary>view</primary>
        </indexterm>view (that is the file <filename>test.html.erb</filename>)
      that are not already a string via the method <indexterm>
          <primary>to_s()</primary>
        </indexterm><methodname>.to_s</methodname>, which always converts the
      content of the object to a string (<xref linkend="ruby-to_s"/>). Once
      more, a brief trip to <literal>irb</literal>:<screen>&gt;&gt; <command>(1 + 1).to_s</command>
=&gt; "2"
&gt;&gt; <command>(1 + 1).to_s.class</command>
=&gt; String
&gt;&gt; <command>exit</command>
$</screen></para>

      <para>You are now going to learn the finer points of
      <literal>erb</literal> step by step. Don't worry, it's neither magic nor
      rocket science.</para>

      <section>
        <title>&lt;% ... %&gt; vs. &lt;%= ... %&gt;</title>

        <para>In a <filename>.html.erb </filename>file, there are two kinds of
        Ruby code instructions in addition to the HTML elements:<itemizedlist>
            <listitem>
              <para>&lt;% … %&gt;</para>

              <para>Executes the Ruby code it contains, but does not output
              anything (unless you explicitly use something like
              <code>print</code> or <code>puts</code>).</para>
            </listitem>

            <listitem>
              <para>&lt;%= … %&gt;</para>

              <para>Executes the Ruby code it contains and outputs the result
              as a String. If is is not a String the methode
              <methodname>to_s</methodname> will be called.</para>
            </listitem>
          </itemizedlist></para>

        <important>
          <para>The output of &lt;%= ... %&gt; is automatically escaped. So
          you don't need to worry about "dangerous" HTML.</para>
        </important>

        <para>Let's use an example, to make sure it all makes sense. We use
        <methodname>each</methodname> to iterate through the
        <classname>Range</classname> <code>(0..5)</code>. Edit the
        <filename>app/views/example/test.html.erb</filename> as
        follows:<programlisting>&lt;p&gt;Loop from 0 to 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;
</programlisting></para>

        <para>Open this view In the browser:<screenshot>
            <info>
              <title>Simple addition</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/erb_einfache_schleife.jpg"/>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Let's now have a look at the HTML source code in the
        browser:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Testproject&lt;/title&gt;
  &lt;link data-turbolinks-track="true" href="/assets/application.css?body=1" media="all" rel="stylesheet" /&gt;
&lt;link data-turbolinks-track="true" href="/assets/example.css?body=1" media="all" rel="stylesheet" /&gt;
  &lt;script data-turbolinks-track="true" src="/assets/jquery.js?body=1"&gt;&lt;/script&gt;
&lt;script data-turbolinks-track="true" src="/assets/jquery_ujs.js?body=1"&gt;&lt;/script&gt;
&lt;script data-turbolinks-track="true" src="/assets/turbolinks.js?body=1"&gt;&lt;/script&gt;
&lt;script data-turbolinks-track="true" src="/assets/example.js?body=1"&gt;&lt;/script&gt;
&lt;script data-turbolinks-track="true" src="/assets/application.js?body=1"&gt;&lt;/script&gt;
  &lt;meta content="authenticity_token" name="csrf-param" /&gt;
&lt;meta content="FjIAd8nQGbKSAdbXdY47d3dhW1ZNLhe4eWJYYOgVdes=" name="csrf-token" /&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p&gt;Loop from 0 to 5:
  0, 
  1, 
  2, 
  3, 
  4, 
  5, 
&lt;/p&gt;


&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

        <para>Now you have the important tools to use Ruby code in a
        view.</para>
      </section>

      <section>
        <title>Q &amp; A</title>

        <para>Potentially, there are two open questions:<qandaset>
            <qandadiv>
              <qandaentry>
                <question>
                  <para>I don't understand anything. I can't cope with the
                  Ruby code. Could you please explain that again?</para>
                </question>

                <answer>
                  <para>Is it possible that you have not completely worked
                  your way through <xref linkend="ruby-grundlagen"/>? Please
                  do take your time with it and have another thorough look.
                  Otherwise, the rest won't make any sense here.</para>
                </answer>
              </qandaentry>

              <qandaentry>
                <question>
                  <para>I can understand the Ruby code and the HTML output.
                  But I don't get why some HTML code was rendered around it if
                  I didn't even write that HTML code. Where does it come from,
                  and can I influence it?</para>
                </question>

                <answer>
                  <para>Excellent question! We will get to that next (see
                  <xref linkend="erb_layouts"/>).</para>
                </answer>
              </qandaentry>
            </qandadiv>
          </qandaset></para>
      </section>
    </section>

    <section xml:id="erb_layouts">
      <title xml:id="erb_layouts.title">Layouts</title>

      <indexterm>
        <primary>layouts</primary>
      </indexterm>

      <indexterm>
        <primary>views</primary>
      </indexterm>

      <indexterm>
        <primary>application.html.erb</primary>
      </indexterm>

      <indexterm>
        <primary>templates</primary>
      </indexterm>

      <para>The <literal>erb</literal> file in the directory
      <filename>app/views/example/</filename> only forms the core of the later
      HTML page. By default, an automatically generated
      <filename>app/views/layouts/application.html.erb</filename> is always
      rendered around it. Let's have a closer look at it:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Testproject&lt;/title&gt;
  &lt;%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" =&gt; true %&gt;
  &lt;%= javascript_include_tag "application", "data-turbolinks-track" =&gt; true %&gt;
  &lt;%= csrf_meta_tags %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

      <para>The interesting bit is the line<programlisting>&lt;%= yield %&gt;</programlisting></para>

      <para>With <code>&lt;%= yield %&gt;</code> the View file is included
      here<indexterm>
          <primary>yield()</primary>
        </indexterm>. The lines with the stylesheets, the JavaScript and the
      csrf_meta_tags can stay as they are for now. They integrate default CSS
      and JavaScript files. We'll have a look into that in <xref
      linkend="asset_pipeline"/>. No need to bother with that right
      now.</para>

      <para>The file
      <filename>app/views/layouts/application.html.erb</filename> enables you
      to determine the basic layout for the entire Rails application. If you
      want to enter a <code>&lt;hr&gt;</code> for each page and above it a
      text, then you can do this between the <code>&lt;%= yield %&gt;</code>
      and the <code>&lt;body&gt;</code> tag:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Testproject&lt;/title&gt;
  &lt;%= stylesheet_link_tag    "application", :media =&gt; "all" %&gt;
  &lt;%= javascript_include_tag "application" %&gt;
  &lt;%= csrf_meta_tags %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;h1&gt;My Header&lt;/h1&gt;
&lt;hr&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

      <para>You can also create other layouts in the directory
      <filename>app/views/layouts/</filename> and apply these layouts
      depending on the relevant situation. But let's leave it for now. The
      important thing is that you understand the basic concept.</para>
    </section>

    <section xml:id="erb_mit_programmierlogik">
      <title>Passing Instance Variables from a Controller to a View</title>

      <indexterm>
        <primary>MVC</primary>
      </indexterm>

      <indexterm>
        <primary>Model-View-Controller</primary>

        <see>MVC</see>
      </indexterm>

      <indexterm>
        <primary>controller</primary>
      </indexterm>

      <indexterm>
        <primary>view</primary>
      </indexterm>

      <indexterm>
        <primary>instance variables</primary>
      </indexterm>

      <para>One of the cardinal sins in the MVC model<footnote>
          <para><uri
          xlink:href="http://de.wikipedia.org/wiki/Model_View_Controller">http://en.wikipedia.org/wiki/Model–view–controller</uri></para>
        </footnote>is to put too much program logic into the view. That's more
      or less what used to be done frequently in PHP programming in the past.
      I'm guilty of having done it myself. But one of the aims of MVC is that
      any HTML designer can create a view without having to worry about the
      programming. Yeah, yeah, … if only it was always that easy. But let's
      just play it through in our minds: if I have a value in the controller
      that I want to display in the view, then I need a mechanism for this.
      This is referred to as <foreignphrase xml:lang="en">instance
      variable</foreignphrase> and always starts with a <code>@</code>. If you
      are not 100 % sure any more which variable has which <indexterm>
          <primary>Scope</primary>
        </indexterm><foreignphrase xml:lang="en">scope</foreignphrase>, then
      please have another quick look at <xref
      linkend="scope_von_variablen"/>.</para>

      <para>In the following example, we insert an instance variable for the
      current time in the controller and then insert it in the view. So we are
      taking programming intelligence from the view to the controller.</para>

      <para>The controller file
      <filename>app/controllers/example_controller.rb</filename> looks like
      this:<programlisting>class ExampleController &lt; ApplicationController
  def test
    @current_time = Time.now
  end
end</programlisting></para>

      <para>In the view file
      <filename>app/views/example/test.html.erb</filename> we can then access
      this instance variable:<programlisting>&lt;p&gt;
The current time is 
&lt;%= @current_time %&gt;
&lt;/p&gt;</programlisting></para>

      <para>With the controller and the view, we now have a clear separation
      of programming logic and presentation logic. So now we can automatically
      adjust the time in the controller in accordance with the user's time
      zone, without the designer of the page having to worry about it. As
      always, the method <methodname>to_s</methodname> is automatically
      applied in the view.</para>

      <para>I am well aware that no-one will now jump up from their chair and
      shout: <quote>Thank you for enlightening me! From now on, I will only
      program neatly in accordance with MVC.</quote> The above example is just
      the first small step in the right direction and shows how we can easily
      get values from the controller to the view with instance
      variables.</para>
    </section>

    <section xml:id="partials">
      <title xml:id="partials.title">Partials</title>

      <indexterm>
        <primary>partials</primary>
      </indexterm>

      <indexterm>
        <primary>erb</primary>
      </indexterm>

      <para>Even with small web projects, there are often elements that appear
      repeatedly, for example a <indexterm>
          <primary>footer</primary>
        </indexterm><foreignphrase xml:lang="en">footer</foreignphrase> on the
      page with contact info or a menu. Rails gives us the option of
      encapsulate this HTML code in form of
      <foreignphrase>partials</foreignphrase> and then integrating it within a
      <indexterm>
          <primary>view</primary>
        </indexterm>view. A partial is also stored in the directory
      <filename>app/views/example/</filename>. But the file name must start
      with an underscore (<literal>_</literal>).</para>

      <para>As an example, we now add a mini footer to our page in a separate
      partial. Copy the following content into the new file
      <filename>app/views/example/_footer.html.erb</filename>:<programlisting>&lt;hr&gt;
&lt;p&gt;
Copyright 2009 - &lt;%= Date.today.year %&gt; the Easter Bunny.
&lt;/p&gt;</programlisting></para>

      <note>
        <para>Yes, this is not the MVC way of doing it. Date.today.year should
        be defined in the Controller. I'm glad that you caught this mistake. I
        made it to show the use of a partial.</para>
      </note>

      <para>We edit the file
      <filename>app/views/example/test.html.erb</filename> as follows and
      insert the partial via the command<indexterm>
          <primary>render()</primary>
        </indexterm><methodname>render</methodname>:<programlisting>&lt;p&gt;Loop from 0 to 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;

&lt;%= render "footer" %&gt;</programlisting></para>

      <para>So now we have the following files in the directory
      <filename>app/views/example</filename>:<screen>$ <command>ls app/views/example</command>
_footer.html.erb
test.html.erb
$ </screen></para>

      <para>The new web page now looks like this:<screenshot>
          <info>
            <title>Page with footer as partial</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/partials_footer.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para><important>
          <para>The name of a partial in the code is always specified
          <emphasis>without</emphasis> the preceding underscore
          (<literal>_</literal>) and <emphasis>without</emphasis> the file
          extension <literal>.erb</literal> and <literal>.html</literal>. But
          the actual file must have the underscore at the beginning of the
          file name and end with the file extension <literal>.erb</literal>
          and <literal>.html</literal>.</para>
        </important></para>

      <para>Partials can also be integrated from other areas of the
      subdirectory <filename>app/views</filename>. For example, you can create
      a directory <filename>app/views/shared</filename> for recurring and
      shared content and create a file <filename>_footer.html.erb</filename>
      in this directory. You would then integrate this file into the
      <literal>erb</literal> code via the line:<indexterm>
          <primary>render()</primary>
        </indexterm><programlisting>&lt;%= render "shared/footer" %&gt;</programlisting></para>

      <section xml:id="partials_locale_variables">
        <title xml:id="partials_locale_variables.title">Passing Variables to a
        Partial</title>

        <indexterm>
          <primary>Partial</primary>
        </indexterm>

        <para>Partials are great in the sense of the <indexterm>
            <primary>DRY</primary>
          </indexterm><indexterm>
            <primary>Don't Repeat Yourself</primary>

            <see>DRY</see>
          </indexterm>DRY (<foreignphrase xml:lang="en"><emphasis
        role="bold">D</emphasis>on't <emphasis role="bold">R</emphasis>epeat
        <emphasis role="bold">Y</emphasis>ourself</foreignphrase>) concept.
        But what makes them really useful is the option of passing variables.
        Let's stick with the copyright example. If we want to pass the start
        year as value, we can integrate this by adding the following in the
        file
        <filename>app/views/example/_footer.html.erb</filename>:<programlisting>&lt;hr&gt;
&lt;p&gt;
Copyright &lt;%= start_year %&gt; - &lt;%= Date.today.year %&gt; the Easter Bunny.
&lt;/p&gt;</programlisting></para>

        <para>So let's change the file
        <filename>app/views/example/test.html.erb</filename> as
        follows:<indexterm>
            <primary>render()</primary>
          </indexterm><programlisting>&lt;p&gt;Loop from 0 to 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;

&lt;%= render "footer", :start_year =&gt; '2000' %&gt;</programlisting></para>

        <para>If we now go to the URL <uri
        xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>,
        we see the 2000:<screenshot>
            <info>
              <title>Partial with local start_year</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/partial_start_year_2000.jpg"/>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Sometimes you need a partial that partially uses a local
        variable and somewhere else you may need the same partial, but without
        the local variable. We can take care of this in the partial itself
        with an if statement:</para>

        <para><programlisting>&lt;hr&gt;
&lt;p&gt;
Copyright 
&lt;%= "#{start_year} - " if defined? start_year %&gt;
&lt;%= Date.today.year %&gt; 
the Easter Bunny.
&lt;/p&gt;</programlisting></para>

        <note>
          <para><indexterm>
              <primary>defined?</primary>

              <secondary>methods</secondary>
            </indexterm><methodname>defined?</methodname> can be used to check
          if an expression has been defined.</para>
        </note>

        <para>You can call this partial with <code>&lt;%= render 'footer',
        :start_year =&gt; '2000' %&gt;</code> and with <code>&lt;%= render
        'footer' %&gt;</code>.</para>
      </section>

      <section xml:id="partials_lange_schreibweise">
        <title>Alternative Notation</title>

        <para>In <xref linkend="partials_locale_variables"/> we only use the
        short form for rendering partials. Often, you will also see this long
        version:<programlisting>&lt;%= render :partial =&gt; "footer", :locals =&gt; { :start_year =&gt; '2000' } %&gt;</programlisting></para>
      </section>

      <section xml:id="weitere_doku_zu_partials">
        <title xml:id="weitere_doku_zu_partials.title">Further Documentation
        on Partials</title>

        <para>We have really only barely scratched the surface here. Partials
        are very powerful tools. You can find the official Ruby on Rails
        documentation on partials at <uri
        xlink:href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials</uri>.</para>
      </section>
    </section>
  </section>

  <section xml:id="redirects">
    <title xml:id="redirects.title">Redirects</title>

    <indexterm>
      <primary>redirects</primary>
    </indexterm>

    <indexterm>
      <primary>routing</primary>
    </indexterm>

    <para>The name says it all, really: <foreignphrase
    xml:lang="en">redirects</foreignphrase> are commands that you can use
    within the controller to <quote>skip</quote>, i.e. redirect, to other to
    other web pages.<note>
        <para>A redirect returns to the browser the response "302 Moved" with
        the new target. So each redirect does a roundtrip to the browser and
        back.</para>
      </note>Let's create a new Rails project for a suitable example:<screen>$ <command>rails new redirect_example</command>
[...]
$ <command>cd redirect_example</command> 
$ </screen></para>

    <para>Before we can redirect, we need a controller with at least two
    different methods. Off we go then:<screen>$ <command>rails generate controller Game ping pong</command>
      create  app/controllers/game_controller.rb
       route  get "game/pong"
       route  get "game/ping"
      invoke  erb
      create    app/views/game
      create    app/views/game/ping.html.erb
      create    app/views/game/pong.html.erb
      invoke  test_unit
      create    test/controllers/game_controller_test.rb
      invoke  helper
      create    app/helpers/game_helper.rb
      invoke    test_unit
      create      test/helpers/game_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/game.js.coffee
      invoke    scss
      create      app/assets/stylesheets/game.css.scss
$</screen></para>

    <para>The controller
    <filename>app/controllers/game_controller.rb</filename> has the following
    content:<programlisting>class GameController &lt; ApplicationController
  def ping
  end

  def pong
  end
end</programlisting></para>

    <para>Now for the redirect: how can we achieve that we get immediately
    redirected to the method <methodname>pong</methodname> when we go to <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>?
    Easy, you will say, we just change the route in <indexterm>
        <primary>routes.rb</primary>
      </indexterm><filename>config/routes.rb</filename>. And you are right. So
    we don't necessarily need a redirect. But if we want to process something
    else in the method <methodname>ping</methodname> before redirecting, then
    this is only possible by using a <methodname>redirect_to</methodname> in
    the controller
    <filename>app/controllers/game_controller.rb</filename>:<programlisting>class GameController &lt; ApplicationController
  def ping
   logger.info '+++  Example  +++'
   redirect_to game_pong_path
  end

  def pong
  end
end</programlisting></para>

    <para>But what is <code>game_pong_path</code>? Let's have a look a the
    routes generated for this Rails application:<screen>$ <command>rake routes</command>
   Prefix Verb URI Pattern          Controller#Action
game_ping GET /game/ping(.:format) game#ping
game_pong GET /game/pong(.:format) game#pong
$</screen></para>

    <note>
      <para>As you can see, the route to the <foreignphrase
      xml:lang="en">action </foreignphrase><literal>ping</literal> of the
      controller <literal>GameController</literal> now gets the name
      <literal>game_ping</literal> (see beginning of the line). We could also
      write the redirect like this:<programlisting>redirect_to :action =&gt; 'pong'</programlisting></para>
    </note>

    <para>I will explain the details and the individual options of the
    redirect later in the context of each specific case. For now, you just
    need to know that you can redirect not just to another method, but also to
    another controller or an entirely different web page.</para>

    <para>When we try to go to <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    we are automatically redirected to <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    and in the log output we see this:<screen>Started GET "/game/ping" for 127.0.0.1 at 2013-07-15 18:49:01 +0200
Processing by GameController#ping as HTML
+++  Example  +++
Redirected to http://0.0.0.0:3000/game/pong
Completed 302 Found in 19ms (ActiveRecord: 0.0ms)


Started GET "/game/pong" for 127.0.0.1 at 2013-07-15 18:49:01 +0200
Processing by GameController#pong as HTML
  Rendered game/pong.html.erb within layouts/application (1.3ms)
Completed 200 OK in 743ms (Views: 741.9ms | ActiveRecord: 0.0ms)</screen></para>

    <section>
      <title>redirect_to :back</title>

      <para>If you want to redirect the user of your webapplication to the
      page he has just been you can use <code>redirect_to :back</code>. This
      is very useful in a scenario where your user first has to login to get
      access to a specific page.</para>
    </section>
  </section>

  <section xml:id="flash">
    <title xml:id="flash.title">Flash Messages</title>

    <indexterm>
      <primary>flash messages</primary>
    </indexterm>

    <indexterm>
      <primary>redirects</primary>
    </indexterm>

    <para>In my eyes, the term <quote><foreignphrase xml:lang="en">flash
    messages</foreignphrase></quote> is somewhat misleading. Almost anyone
    would associate the term <quote><foreignphrase
    xml:lang="en">Flash</foreignphrase></quote> with more or less colorful web
    pages that were implemented with the Adobe Shockwave Flash Plug-in. But in
    Ruby on Rails, flash messages are something completely different. They are
    messages that are displayed, for example on the new page after a redirect
    (see <xref linkend="redirects"/>).</para>

    <para>Flash messages are good friends with redirects. The two often work
    together in a team to give the user feedback on an action he just carried
    out. A typical example of a flash message is the system feedback when a
    user has logged in. Often the user is redirected back to the original page
    and gets the message <quote>You are now logged in.</quote></para>

    <para>As an example, we are once more constructing the ping pong scenario
    from <xref linkend="redirects"/>:<screen>$ <command>rails new pingpong</command>
      [...]
$ <command>cd pingpong</command> 
$ <command>rails generate controller Game ping pong</command>
      [...]
$</screen></para>

    <para>We fill the <filename>app/controllers/game_controller.rb</filename>
    with the following content:<programlisting>class GameController &lt; ApplicationController
  def ping
   redirect_to game_pong_path, notice: 'Ping-Pong!'
  end

  def pong
  end
end</programlisting></para>

    <para>Now we start the Rails web server with <command>rails
    server</command> and use the browser to go to <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>.
    We are redirected from <methodname>ping</methodname> to
    <methodname>pong</methodname>. But the flash message "Ping-Pong!" is
    nowhere to be seen. We first need to expand
    <filename>app/views/layouts/application.html.erb</filename>:<programlisting>&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Pingpong&lt;/title&gt;
  &lt;%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" =&gt; true %&gt;
  &lt;%= javascript_include_tag "application", "data-turbolinks-track" =&gt; true %&gt;
  &lt;%= csrf_meta_tags %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%- flash.each do |name, message| %&gt;
&lt;p&gt;&lt;i&gt;&lt;%= "#{name}: #{message}" %&gt;&lt;/i&gt;&lt;/p&gt;
&lt;% end %&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

    <para>Now we see the flash message at the top of the page when we go to
    <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    in the browser:<screenshot>
        <info>
          <title>Pong page with flash message</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/flash_pong_notice.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>If we go to <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    we still see the normal Pong page. But if we go to <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/ping</uri>
    we are redirected to the Pong page and then the flash message is displayed
    at the top.</para>

    <tip>
      <para>If you do not see a flash message that you were expecting, first
      check in the view to see if the flash message is output there.</para>
    </tip>

    <section xml:id="verschiedene_arten_von_flash_nachrichten">
      <title xml:id="verschiedene_arten_von_flash_nachrichten.title">Different
      Types of Flash Message</title>

      <indexterm>
        <primary>flash messages</primary>
      </indexterm>

      <para>Flash messages are automagically passed to the view in a hash. By
      default, there are three different types: <literal>error</literal>,
      <literal>warning</literal> and <literal>notice</literal>. You can also
      invent your own category and then get it in the view later.</para>
    </section>

    <section xml:id="neue_flash_redirect_schreibweise">
      <title xml:id="neue_flash_redirect_schreibweise.title">Different
      Syntaxes</title>

      <indexterm>
        <primary>flash messages</primary>
      </indexterm>

      <para>Depending on the programmer's preferences, you will find different
      syntaxes of flash messages in practice. I am not going to take part in
      the discussion about which is the best syntax, but just show you briefly
      the two most common variations:<itemizedlist>
          <listitem>
            <para><programlisting>redirect_to game_pong_path, notice: 'Ping-Pong!'</programlisting></para>
          </listitem>

          <listitem>
            <para><programlisting>flash[:notice] = 'Ping-Pong!'
redirect_to action: pong</programlisting></para>
          </listitem>
        </itemizedlist></para>

      <para>Please have a look at the official documentation at <uri
      xlink:href="http://guides.rubyonrails.org/action_controller_overview.html#the-flash">http://guides.rubyonrails.org/action_controller_overview.html#the-flash</uri>
      for more information.</para>
    </section>

    <section>
      <title>Why Are There Flash Messages At All?</title>

      <indexterm>
        <primary>flash messages</primary>
      </indexterm>

      <para>You may wonder why there are flash messages in the first place.
      Couldn't you just build them yourself if you need them? Yes, indeed. But
      flash messages have the advantage that they offer a defined approach
      that is the same for any programmer. So you don't need to start from
      scratch every single time you need one.</para>
    </section>
  </section>

  <section xml:id="die_console" xml:lang="">
    <title xml:base="" xml:id="die_console.title">The Rails Console</title>

    <indexterm>
      <primary>Rails</primary>

      <secondary>console</secondary>
    </indexterm>

    <indexterm>
      <primary>console</primary>
    </indexterm>

    <para>The <foreignphrase xml:lang="en">console</foreignphrase> in Rails is
    nothing more than an <literal>irb</literal> (see <xref linkend="irb"/>)
    built around the Rails environment. The console is very useful both for
    developing and for administration purposes, because the whole Rails
    environment is represented and available.</para>

    <para>For our working environment, we again use a variation of the ping
    pong scenario from <xref linkend="redirects"/>:<screen>$ <command>rails new pingpong</command>
      [...]
$ <command>cd pingpong</command> 
$ <command>rails generate controller Game ping pong</command>
      [...]
$</screen></para>

    <para>Start the Rails console with the command <command>rails
    console</command>:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
2.0.0-p247 :001 &gt; </screen></para>

    <para>And you can use <command>exit</command> to get back out:<screen>2.0.0-p247 :001 &gt; <command>exit</command>
$ </screen></para>

    <para>Many readers use this document on mobile devises. For them I try to
    keep any code or terminal output width to a minimum. To save the real
    estate which is by default occupied by <code>2.0.0-p247 :001 &gt;</code>
    we can start <command>rails console</command> with the parameter
    <parameter>-- --simple-prompt</parameter>.<screen>$ <command>rails console -- --simple-prompt</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>exit</command>
$</screen></para>

    <para>Alternativly you can change the IRB configuration in the file
    <filename>.irbrc</filename> which is located in your home directory. If
    you want to have the simple prompt you have to add the following line in
    that file.<programlisting>IRB.conf[:PROMPT_MODE] = :SIMPLE</programlisting></para>

    <para>In the console, you have access to all variables that are also
    available later in the proper application:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>Rails.env</command>
=&gt; "development"
&gt;&gt; <command>Rails.root</command>
=&gt; #&lt;Pathname:/Users/xyz/pingpong&gt;
&gt;&gt; <command>exit</command>
$</screen></para>

    <para>Already in <xref linkend="activerecord_chapter"/> we are going to be
    working lots with the console and will soon begin to appreciate the
    possibilities it offers.</para>

    <tip>
      <para>One of my best buddies when developing Rails applications is the
      Tab key. Whenever you are looking for a method for a particular problem,
      recreate it in the Rails console and then press the Tab key twice to
      list all available methods. The names of the methods are usually
      self-exlanatory.</para>
    </tip>

    <section>
      <title>app</title>

      <para><indexterm>
          <primary>app</primary>
        </indexterm><indexterm>
          <primary>routing</primary>
        </indexterm><command>app</command> is useful if you want to analyze
      things to do with routing:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>app.url_for(:controller =&gt; 'game', :action =&gt; 'ping')</command>
=&gt; "http://www.example.com/game/ping"
&gt;&gt; <command>app.get 'game/ping'</command>


Started GET "/game/ping" for 127.0.0.1 at 2013-07-15 19:19:36 +0200
Processing by GameController#ping as HTML
Redirected to http://www.example.com/game/pong
Completed 302 Found in 16ms (ActiveRecord: 0.0ms)
=&gt; 302
&gt;&gt; <command>app.get 'game/pong'</command>


Started GET "/game/pong" for 127.0.0.1 at 2013-07-15 19:19:39 +0200
Processing by GameController#pong as HTML
  Rendered game/pong.html.erb within layouts/application (0.9ms)
Completed 200 OK in 50ms (Views: 49.2ms | ActiveRecord: 0.0ms)
=&gt; 200
&gt;&gt; <command>exit</command>
$</screen></para>
    </section>
  </section>

  <section xml:id="einstieg_misc">
    <title xml:id="einstieg_misc.title">Misc</title>

    <para>You have now already created a simple Rails application and in the
    next chapter you will dive deeply into the topic ActiveRecord. So now is a
    good time to very briefly introduce a few terms that often surface in the
    world of Rails.</para>

    <section xml:id="mvc">
      <title xml:id="mvc.title">"Model View Controller" Architecture
      (MVC)</title>

      <para>According to Wikipedia (<uri
      xlink:href="http://de.wikipedia.org/wiki/Model_View_Controller">http://en.wikipedia.org/wiki/Model–view–controller</uri>),
      MVC is a design pattern that separates the representation of information
      from the user's interaction with it.</para>

      <para>MVC is a structure for software development. It was agreed that it
      makes sense to have one part of the software in one place and another
      part of the software in another place. Nothing more, nothing less. This
      agreement has the enormous advantage that once you are used to this
      concept, you know exactly where you can find or need to integrate a
      certain functionaity in a Rails project.</para>

      <section xml:id="mvc_model">
        <title xml:id="mvc_model.title">Model</title>

        <indexterm>
          <primary>Rails</primary>

          <secondary>MVC</secondary>

          <tertiary>model</tertiary>
        </indexterm>

        <para>"Model" in this case means data model. By default, Rails
        applications are an ActiveRecord data model (see <xref
        linkend="activerecord_chapter"/>).</para>

        <para>All models can be found in the directory
        <filename>app/models/.</filename></para>
      </section>

      <section xml:id="mvc_view">
        <title xml:id="mvc_view.title">View</title>

        <indexterm>
          <primary>Rails</primary>

          <secondary>MVC</secondary>

          <tertiary>view</tertiary>
        </indexterm>

        <para>The "view" is responsible for the presentation of the
        application. It takes care of rendering the web page, an XML or JSON
        file. A view could also render a PDF or an ASCII text. It depends
        entirely on your application.</para>

        <para>You will find all the views in the directory
        <filename>app/views/.</filename></para>
      </section>

      <section xml:id="mvc_controller">
        <title xml:id="mvc_controller.title">Controller</title>

        <indexterm>
          <primary>Rails</primary>

          <secondary>MVC</secondary>

          <tertiary>controller</tertiary>
        </indexterm>

        <para>Once a web page call has ended up in a route (see <xref
        linkend="routes"/>), it goes from there to the controller. The route
        specifies a certain method (action) as target. This method can then
        fulfil the desired tasks (such as finding a specific set of data and
        saving it in an instance variable) and then renders the desired
        view.</para>

        <para>All controllers can be found in the directory
        <filename>app/controllers/.</filename></para>
      </section>
    </section>

    <section xml:id="was_ist_ein_generator">
      <title xml:id="was_ist_ein_generator.title">What is a Generator?</title>

      <indexterm>
        <primary>Rails</primary>

        <secondary>generator</secondary>
      </indexterm>

      <para>We have already used the command <command>rails generate
      controller</command>. It starts the generator with the name
      <code>controller</code>. There are other generators as well. You can use
      the command <command>rails generate</command> to display a list of
      available generators:<screen>$ <command>rails generate</command>
Usage: rails generate GENERATOR [args] [options]

General options:
  -h, [--help]     # Print generator's options and usage
  -p, [--pretend]  # Run but do not make any changes
  -f, [--force]    # Overwrite files that already exist
  -s, [--skip]     # Skip files that already exist
  -q, [--quiet]    # Suppress status output

Please choose a generator below.

Rails:
  assets
  controller
  generator
  helper
  integration_test
  jbuilder
  mailer
  migration
  model
  resource
  scaffold
  scaffold_controller
  task

Coffee:
  coffee:assets

Jquery:
  jquery:install

Js:
  js:assets

TestUnit:
  test_unit:plugin

$</screen></para>

      <para>What does a generator do? A generator makes a programmer's job
      easier by doing some of the mindless tasks for you. It creates files and
      fills them with content, depending on the parameters passed. You could
      do the same manually, without the generator. So you do not have to use a
      generator. It is primarily intended to save you work and avoid potential
      errors that can easily arise from mindless repetitive tasks.</para>

      <tip>
        <para>Someday you might want to create your own generator. Have a look
        at <uri
        xlink:href="http://guides.rubyonrails.org/generators.html">http://guides.rubyonrails.org/generators.html</uri>
        to find a description of how to do that.</para>
      </tip>
    </section>

    <section xml:id="helper">
      <title xml:id="helper.title">Helper</title>

      <indexterm>
        <primary>Rails</primary>

        <secondary>helper</secondary>
      </indexterm>

      <para>A helper method takes care of recurring tasks in a view. For
      example, if you want to display stars (*) for rating a restaurant and
      not a number from 1 to 5, you can define the following helper in the
      file <filename>app/helpers/application_helper.rb</filename>
      :<programlisting>module ApplicationHelper

  def render_stars(value)
    output = ''
    if (1..5).include?(value)
      value.times { output += '*'}
    end
    output
  end

end
</programlisting></para>

      <para>With this helper, we can then apply the following code in a
      view:<programlisting>&lt;p&gt;
&lt;b&gt;Rating:&lt;/b&gt; &lt;%= render_stars(5) %&gt;
&lt;/p&gt;</programlisting></para>

      <para>You can also try out the helper in the console:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>helper.render_stars(5)</command>
=&gt; "*****"
&gt;&gt; <command>helper.render_stars(3)</command>
=&gt; "***"
&gt;&gt; <command>exit</command>
$ </screen></para>

      <para>There are lots of predefined helpers in Rails and we will use some
      of them in the next chapters. But you can also define your own custom
      helpers. Any of the helpers from the file
      <filename>app/helpers/application_helper.rb</filename> can be used in
      any view. Helpers that you want to be only available in certain views
      must be defined for each controller. When creating a controller, a file
      for helpers of that controller is automatically created in
      <filename>app/helpers</filename>. This gives you the option of defining
      helpers only for this controller or for the views of this
      controller.</para>

      <para>All helpers are in the directory
      <filename>app/helpers/.</filename></para>
    </section>

    <section>
      <title>Rails Lingo</title>

      <para>Here you find a couple of words which you'll often find in the
      Ruby on Rails universe.</para>

      <section xml:id="dry">
        <title xml:id="dry.title">DRY - Don't repeat yourself</title>

        <indexterm>
          <primary>DRY</primary>
        </indexterm>

        <para>Many Rails programmers are big fans of DRY. DRY means purely and
        simply that you should try to place repeated programming logic into
        separate methods.</para>
      </section>

      <section xml:id="refactoring">
        <title xml:id="refactoring.title">Refactoring</title>

        <indexterm>
          <primary>refactoring</primary>
        </indexterm>

        <para>You often hear the word refactoring in the context of DRY. This
        involves functioning applications that are further improved. The
        application in itself remains unchanged in its interface. But its core
        is optimized, amongst others through DRY.</para>
      </section>

      <section xml:id="convention_over_configuration">
        <title xml:id="convention_over_configuration.title">Convention Over
        Configuration</title>

        <indexterm>
          <primary>convention over configuration</primary>
        </indexterm>

        <para>Convention over configuration (also known as coding by
        convention, see <uri
        xlink:href="http://de.wikipedia.org/wiki/Konvention_vor_Konfiguration">http://en.wikipedia.org/wiki/Convention_over_configuration</uri>)
        is an important pillar of a Rails application. It states that the
        programmer does not need to decide in favour of certain features when
        starting a project and set these via configuration parameters. It
        specifies an underlying basic consensus and this is set by default.
        But if you want to work outside of this conventional basic consensus,
        then you will need to change the corresponding parameters.</para>
      </section>
    </section>
  </section>
</chapter>
