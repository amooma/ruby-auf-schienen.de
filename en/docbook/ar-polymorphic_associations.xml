<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_polymorphic"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_polymorphic.title">Polymorphic
  Associations</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>polymorphic associations</secondary>
  </indexterm>

  <para>Already the word "polymorphic" will probably make you tense up. What
  can it mean? Here is what the website <uri
  xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
  tells us: <quote>Polymorphic associations on models are not restricted on
  what types of models they can be associated with.</quote> Well, there you go
  - as clear as mud! ;-)</para>

  <para>I am showing you an example in which we create a model for cars
  (<classname>Car</classname>) and a model for bicycles
  (<classname>Bike</classname>). To describe a car or bike, we use a model to
  tag it (<classname>Tag</classname>). A car and a bike can have any number of
  <methodname>tags</methodname>. The application:<screen>$ <command>rails new example</command>
  [...]
$ <command>cd example</command> 
$</screen></para>

  <para>Now the three required models:<screen>$ <command>rails generate model Car name</command>
  [...]
$ <command>rails generate model Bike name</command>
  [...]
$ <command>rails generate model Tag name taggable:references{polymorphic}</command>
  [...]
$ <command>rake db:migrate</command>
  [...]
$</screen></para>

  <para><classname>Car</classname> and <classname>Bike</classname> are clear.
  For <classname>Tag</classname> we use the migration shortcut
  <code>taggable:references{polymorphic}</code> to generate the fields
  <methodname>taggable_type</methodname> and
  <methodname>taggable_id</methodname>, to give ActiveRecord an opportunity to
  save the assignment for the polymorphic association. We have to enter it
  accordingly in the model.</para>

  <para>The model generator already filed the
  <filename>app/models/tag.rb</filename> file with the configuration for the
  polymorphic association:</para>

  <para><filename>app/models/tag.rb</filename><programlisting>class Tag &lt; ActiveRecord::Base
  belongs_to :taggable, polymorphic: true
end</programlisting></para>

  <para>For the other models we have to add the polymorphic association
  manually:</para>

  <para><filename>app/models/car.rb</filename><programlisting>class Car &lt; ActiveRecord::Base
  has_many :tags, as: :taggable
end</programlisting></para>

  <para><filename>app/models/bike.rb</filename><programlisting>class Bike &lt; ActiveRecord::Base
  has_many :tags, as: :taggable
end
</programlisting></para>

  <para>For Car and Bike we use an additional <code>:as: :taggable</code> when
  defining has_many. For <classname>Tag</classname> we use <code>belongs_to
  :taggable, polymorphic: true</code> to indicate the polymorphic association
  to ActiveRecord.</para>

  <tip>
    <para>The suffix <quote><foreignphrase
    xml:lang="en">able</foreignphrase></quote> in the name
    <quote><foreignphrase xml:lang="en">taggable</foreignphrase></quote> is
    commonly used in Rails, but not obligatory. For creating the association
    we now not only need the ID of the entry, but also need to know which
    <foreignphrase xml:lang="en">model</foreignphrase> it actually is. So the
    term <quote><foreignphrase
    xml:lang="en">taggable_type</foreignphrase></quote> makes sense.</para>
  </tip>

  <para>Let's go into the <foreignphrase xml:lang="en">console</foreignphrase>
  and create a car and a bike:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>beetle = Car.create(name: 'Beetle')</command>
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "cars" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:04:50 UTC +00:00], ["name", "Beetle"], ["updated_at", Tue, 16 Jul 2013 13:04:50 UTC +00:00]]
   (0.9ms)  commit transaction
=&gt; #&lt;Car id: 1, name: "Beetle", created_at: "2013-07-16 13:04:50", updated_at: "2013-07-16 13:04:50"&gt;
&gt;&gt; <command>mountainbike = Bike.create(name: 'Mountainbike')</command>
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "bikes" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:04:57 UTC +00:00], ["name", "Mountainbike"], ["updated_at", Tue, 16 Jul 2013 13:04:57 UTC +00:00]]
   (2.5ms)  commit transaction
=&gt; #&lt;Bike id: 1, name: "Mountainbike", created_at: "2013-07-16 13:04:57", updated_at: "2013-07-16 13:04:57"&gt;
&gt;&gt;</screen></para>

  <para>Now we define for each a tag with the color of the corresponding
  object:<screen>&gt;&gt; <command>beetle.tags.create(name: 'blue')</command>
   (0.0ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "tags" ("created_at", "name", "taggable_id", "taggable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:05:19 UTC +00:00], ["name", "blue"], ["taggable_id", 1], ["taggable_type", "Car"], ["updated_at", Tue, 16 Jul 2013 13:05:19 UTC +00:00]]
   (3.0ms)  commit transaction
=&gt; #&lt;Tag id: 1, name: "blue", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:19", updated_at: "2013-07-16 13:05:19"&gt;
&gt;&gt; <command>mountainbike.tags.create(name: 'black')</command>
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "tags" ("created_at", "name", "taggable_id", "taggable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:05:27 UTC +00:00], ["name", "black"], ["taggable_id", 1], ["taggable_type", "Bike"], ["updated_at", Tue, 16 Jul 2013 13:05:27 UTC +00:00]]
   (2.3ms)  commit transaction
=&gt; #&lt;Tag id: 2, name: "black", taggable_id: 1, taggable_type: "Bike", created_at: "2013-07-16 13:05:27", updated_at: "2013-07-16 13:05:27"&gt;
&gt;&gt; </screen></para>

  <para>For the <varname>beetle</varname>, we add another
  <classname>Tag</classname>:<screen>&gt;&gt; <command>beetle.tags.create(name: 'Automatic')</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "tags" ("created_at", "name", "taggable_id", "taggable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:05:56 UTC +00:00], ["name", "Automatic"], ["taggable_id", 1], ["taggable_type", "Car"], ["updated_at", Tue, 16 Jul 2013 13:05:56 UTC +00:00]]
   (2.1ms)  commit transaction
=&gt; #&lt;Tag id: 3, name: "Automatic", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:56", updated_at: "2013-07-16 13:05:56"&gt;
&gt;&gt;</screen></para>

  <para>Let's have a look at all <classname>Tag</classname> items:<screen>&gt;&gt; <command>Tag.all</command>
  Tag Load (0.3ms)  SELECT "tags".* FROM "tags"
=&gt; #&lt;ActiveRecord::Relation [#&lt;Tag id: 1, name: "blue", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:19", updated_at: "2013-07-16 13:05:19"&gt;, #&lt;Tag id: 2, name: "black", taggable_id: 1, taggable_type: "Bike", created_at: "2013-07-16 13:05:27", updated_at: "2013-07-16 13:05:27"&gt;, #&lt;Tag id: 3, name: "Automatic", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:56", updated_at: "2013-07-16 13:05:56"&gt;]&gt;
&gt;&gt;</screen></para>

  <para>And now all tags of the beetle:<screen>&gt;&gt; <command>beetle.tags</command>
  Tag Load (0.4ms)  SELECT "tags".* FROM "tags" WHERE "tags"."taggable_id" = ? AND "tags"."taggable_type" = ?  [["taggable_id", 1], ["taggable_type", "Car"]]
=&gt; #&lt;ActiveRecord::Associations::CollectionProxy [#&lt;Tag id: 1, name: "blue", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:19", updated_at: "2013-07-16 13:05:19"&gt;, #&lt;Tag id: 3, name: "Automatic", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:56", updated_at: "2013-07-16 13:05:56"&gt;]&gt;
&gt;&gt;</screen></para>

  <para>Of course you can also check which object the last
  <classname>Tag</classname> belongs to:<screen>&gt;&gt; <command>Tag.last.taggable</command>
  Tag Load (0.3ms)  SELECT "tags".* FROM "tags" ORDER BY "tags"."id" DESC LIMIT 1
  Car Load (0.2ms)  SELECT "cars".* FROM "cars" WHERE "cars"."id" = ? ORDER BY "cars"."id" ASC LIMIT 1  [["id", 1]]
=&gt; #&lt;Car id: 1, name: "Beetle", created_at: "2013-07-16 13:04:50", updated_at: "2013-07-16 13:04:50"&gt;
&gt;&gt; <command>exit</command>
$</screen></para>

  <para>Polymorphic associations are always useful if you want to normalize
  the database structure. In this example, we could also have defined a model
  <classname>CarTag</classname> and <classname>BikeTag</classname>, but as
  <classname>Tag</classname> is the same for both, a polymorphic association
  makes more sense in this case.</para>

  <section>
    <title>Options</title>

    <para>Polymorphic associations can be configured with the same options as
    a normal <xref linkend="activerecord_has_many"/> model.</para>
  </section>
</section>
