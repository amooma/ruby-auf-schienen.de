<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="datensatz-loeschen"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Delete/Destroy a Record</title>

  <para>To remove a database record, you can use the methods
  <methodname>destroy</methodname> and <methodname>delete</methodname>. It's
  quite easy to confuse these two terms, but they are different and after a
  while you get used to it.</para>

  <para>As an example, we use the following Rails application:<screen>$ <command>rails new bookshelf</command>
  [...]
$ <command>cd bookshelf</command>
$ <command>rails generate model book title</command>
  [...]
$ <command>rails generate model author book_id:integer first_name last_name</command>
  [...]
$ <command>rake db:migrate</command>
  [...]
$</screen></para>

  <para><filename>app/models/book.rb</filename><programlisting>class Book &lt; ActiveRecord::Base
  has_many :authors, dependent: :destroy
end</programlisting></para>

  <para><filename>app/models/author.rb</filename><programlisting>class Author &lt; ActiveRecord::Base
  belongs_to :book
end</programlisting></para>

  <section xml:id="activerecord_destroy">
    <title xml:id="activerecord_destroy.title">destroy</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>destroy()</tertiary>
    </indexterm>

    <para>With <methodname>destroy</methodname> you can remove a record and
    any existing dependencies are also taken into account (see for example
    <code>:dependent =&gt; :destroy</code> in <xref
    linkend="activerecord_1n_optionen"/>). Simply put: to be on the safe side,
    it's better to use <methodname>destroy</methodname> because then the Rails
    system does more for you.</para>

    <para>Let's create a record and then destroy it again:<screen>$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>book = Book.create(title: 'Homo faber')</command>
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:30:24 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:30:24 UTC +00:00]]
   (2.2ms)  commit transaction
=&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2013-07-16 13:30:24", updated_at: "2013-07-16 13:30:24"&gt;
&gt;&gt; <command>Book.count</command>
   (0.3ms)  SELECT COUNT(*) FROM "books"
=&gt; 1
&gt;&gt; <command>book.destroy</command>
   (0.2ms)  begin transaction
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 1]]
  SQL (0.3ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 1]]
   (0.6ms)  commit transaction
=&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2013-07-16 13:30:24", updated_at: "2013-07-16 13:30:24"&gt;
&gt;&gt; <command>Book.count</command>
   (0.4ms)  SELECT COUNT(*) FROM "books"
=&gt; 0
&gt;&gt;</screen></para>

    <para>As we are using the option <code>dependent: :destroy</code> in the
    Book model, we can also automatically remove all authors:<screen>&gt;&gt; <command>Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00]]
   (1.9ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 2], ["created_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00]]
   (1.0ms)  commit transaction
=&gt; #&lt;Author id: 1, book_id: 2, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 13:31:11", updated_at: "2013-07-16 13:31:11"&gt;
&gt;&gt; <command>Author.count</command>
   (0.4ms)  SELECT COUNT(*) FROM "authors"
=&gt; 1
&gt;&gt; <command>Book.first.destroy</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT 1
   (0.1ms)  begin transaction
  Author Load (0.1ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 2]]
  SQL (0.3ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 1]]
  SQL (0.1ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 2]]
   (2.1ms)  commit transaction
=&gt; #&lt;Book id: 2, title: "Homo faber", created_at: "2013-07-16 13:31:11", updated_at: "2013-07-16 13:31:11"&gt;
&gt;&gt; <command>Author.count</command>
   (0.4ms)  SELECT COUNT(*) FROM "authors"
=&gt; 0
&gt;&gt;</screen></para>

    <para>When removing records, please always consider the difference between
    the content of the database table and the value of the currently removed
    object. The instance is <foreignphrase
    xml:lang="en">frozen</foreignphrase> after removing the database field. So
    it is no longer in the database, but still present in the program, yet it
    can no longer be modified there. It is read-only. To check, you can use
    the method <indexterm>
        <primary>frozen?()</primary>
      </indexterm><methodname>frozen?</methodname>:<screen>&gt;&gt; <command>book = Book.create(title: 'Homo faber')</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:32:30 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:32:30 UTC +00:00]]
   (2.0ms)  commit transaction
=&gt; #&lt;Book id: 3, title: "Homo faber", created_at: "2013-07-16 13:32:30", updated_at: "2013-07-16 13:32:30"&gt;
&gt;&gt; <command>book.destroy</command>
   (0.1ms)  begin transaction
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 3]]
  SQL (0.4ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 3]]
   (1.9ms)  commit transaction
=&gt; #&lt;Book id: 3, title: "Homo faber", created_at: "2013-07-16 13:32:30", updated_at: "2013-07-16 13:32:30"&gt;
&gt;&gt; <command>Book.count</command>
   (0.2ms)  SELECT COUNT(*) FROM "books"
=&gt; 0
&gt;&gt; <command>book</command>
=&gt; #&lt;Book id: 3, title: "Homo faber", created_at: "2013-07-16 13:32:30", updated_at: "2013-07-16 13:32:30"&gt;
&gt;&gt; <command>book.frozen?</command>
=&gt; true
&gt;&gt; </screen></para>

    <para>The record has been removed from the database, but the object with
    all its data is still present in the running Ruby program. So could we
    then revive the entire record? The answer is yes, but it will then be a
    new record:<screen>&gt;&gt; <command>Book.create(title: book.title)</command>
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:33:31 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:33:31 UTC +00:00]]
   (1.7ms)  commit transaction
=&gt; #&lt;Book id: 4, title: "Homo faber", created_at: "2013-07-16 13:33:31", updated_at: "2013-07-16 13:33:31"&gt;
&gt;&gt; <command>exit</command>
$</screen></para>
  </section>

  <section xml:id="activerecord_delete">
    <title xml:id="activerecord_delete.title">delete</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>methods</secondary>

      <tertiary>delete()</tertiary>
    </indexterm>

    <para>With <methodname>delete</methodname> you can remove a record
    directly from the database. Any dependencies to other records in the
    <foreignphrase xml:lang="en">model</foreignphrase> are not taken into
    account. The method <methodname>delete</methodname> only deletes that one
    row in the database and nothing else.</para>

    <para>Let's create a book with one author and then remove the book with
    <methodname>delete</methodname>:<screen>$ <command>rake db:reset</command>
  [...]
$ <command>rails console</command>
Loading development environment (Rails 4.0.0)
&gt;&gt; <command>Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')</command>
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00]]
   (2.5ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00]]
   (0.9ms)  commit transaction
=&gt; #&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 13:35:49", updated_at: "2013-07-16 13:35:49"&gt;
&gt;&gt; <command>Author.count</command>
   (0.3ms)  SELECT COUNT(*) FROM "authors"
=&gt; 1
&gt;&gt; <command>Book.last.delete</command>
  Book Load (0.2ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" DESC LIMIT 1
  SQL (2.9ms)  DELETE FROM "books" WHERE "books"."id" = 1
=&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2013-07-16 13:35:49", updated_at: "2013-07-16 13:35:49"&gt;
&gt;&gt; <command>Author.count</command>
   (0.4ms)  SELECT COUNT(*) FROM "authors"
=&gt; 1
&gt;&gt; <command>Book.count</command>
   (0.4ms)  SELECT COUNT(*) FROM "books"
=&gt; 0
&gt;&gt; <command>exit</command>
$</screen></para>

    <para>The record of the book 'Homo faber' is deleted, but the author is
    still in the database.</para>

    <para>As with <methodname>destroy</methodname>, an object also gets frozen
    when you use <methodname>delete</methodname> (see <xref
    linkend="activerecord_destroy"/>). The record is already removed from the
    database, but the object itself is still there.</para>
  </section>
</section>
