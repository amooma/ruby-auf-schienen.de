<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="routes" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="routes.title">Routes</title>

  <indexterm>
    <primary>routes</primary>
  </indexterm>

  <indexterm>
    <primary>routes.rb</primary>

    <see>routes</see>
  </indexterm>

  <section xml:id="routes_einstieg">
    <title xml:id="routes_einstieg.title">Introduction</title>

    <para>In <xref linkend="dynamische_webseiten"/> and <xref
    linkend="scaffolding"/> we have already come across <foreignphrase
    xml:lang="en">routes</foreignphrase>. The routes contained in
    <filename>config/routes.rb</filename> define what happens in the Rails
    application when a user of a Rails application fetches a URL. A route can
    be static and dynamic and pass any dynamic values with variables to the
    controller. If several routes apply to a URL, the one that is listed at
    the top of <filename>config/routes.rb</filename> wins.<tip>
        <para>If you do not have much time, you can skip this chapter for now
        and get back to it later if you have any specific questions.</para>
      </tip></para>

    <para>Let's first build a test Rails application so we can
    experiment:<screen>$ rails new shop
  [...]
$ cd shop
$</screen></para>

    <para>With <command>rake routes</command> we can display the routes of a
    project. Let's try it straight away in the freshly created
    project:<screen>$ rake routes
You don't have any routes defined!

Please add some routes in config/routes.rb.

For more information about routes, see the Rails guide: http://guides.rubyonrails.org/routing.html.
$ </screen></para>

    <para>That's what I call a good error message. It's a new Rails project,
    there are no routes yet.</para>

    <para>In case of a new Rails project, the file
    <filename>config/routes.rb</filename> has many commented out examples. For
    the rest of this chapter we pretend that these examples are not there and
    only display the newly entered routes.</para>
  </section>

  <section xml:id="routes_get">
    <title xml:id="routes_get.title">HTTP GET Requests for Singular
    Resources</title>

    <indexterm>
      <primary>routes</primary>

      <secondary>get</secondary>
    </indexterm>

    <para>As you might know the HTTP protocol uses different so called verbs
    to access content on the webserver (e.g. GET to request a page or POST to
    send a form to the server). First we'll have a look at GET
    requests.</para>

    <para>Create a controller with three pages:<screen>$ rails generate controller Home index ping pong
      create  app/controllers/home_controller.rb
       route  get "home/pong"
       route  get "home/ping"
       route  get "home/index"
       [...]
$</screen></para>

    <para>Now <command>rake routes</command> lists a route for these three
    pages:<screen>$ rake routes
    Prefix Verb URI Pattern           Controller#Action
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
$</screen></para>

    <para>The pages can be accessed at the following URLs after starting the
    Rails server with <command>rails server</command>:<itemizedlist>
        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/index">http://0.0.0.0:300/home/index</uri></para>

          <para>for <code>home_index GET /home/index(.:format)
          home#index</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/ping">http://0.0.0.0:300/home/ping</uri></para>

          <para>for <code>home_ping GET /home/ping(.:format)
          home#ping</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/pong">http://0.0.0.0:300/home/pong</uri></para>

          <para>for <code>home_pong GET /home/pong(.:format)
          home#pong</code></para>
        </listitem>
      </itemizedlist></para>

    <para><screenshot>
        <info>
          <title>http://0.0.0.0:300/home/ping</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/home_ping.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>With the output <code>home#index</code>, Rails tells us that the
    route <uri>/home/index</uri> goes into the controller
    <classname>home</classname> and there to the action/method
    <methodname>index</methodname>. These routes are defined in the file
    <filename>config/routes.rb</filename>. <command>rails generate controller
    Home index ping pong</command> has automatically inserted the following
    lines there:<programlisting>  get "home/index"
  
  get "home/ping"
  
  get "home/pong"
</programlisting></para>

    <section xml:id="namen_der_routen">
      <title xml:id="namen_der_routen.title">Naming a Route</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>names</secondary>
      </indexterm>

      <para>A route should also always have an internal name which doesn't
      change. In <xref linkend="routes_get"/> there is the following
      route:<programlisting>home_pong GET /home/pong(.:format)  home#pong</programlisting></para>

      <para>This route has the automatically created name
      <varname>home_pong</varname>. Generally, you should always try to work
      with the name of the route within a Rails application. So you would
      point a <methodname>link_to</methodname> to <varname>home_pong</varname>
      and not to <uri>/home/pong</uri>. This has the big advantage that you
      can later edit (in the best case, optimize) the routing for visitors
      externally and do not need to make any changes internally in the
      application. Of course, you need to enter the old names with
      <methodname>:as</methodname> in that case.</para>
    </section>

    <section xml:id="routen_as">
      <title xml:id="routen_as.title">as</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>as</secondary>
      </indexterm>

      <indexterm>
        <primary>routen</primary>

        <secondary>names</secondary>

        <tertiary>as</tertiary>
      </indexterm>

      <para>If you want to define the name of a route yourself, you can do so
      with <methodname>:as</methodname>. For example, the line
      <programlisting>get "home/pong", as: 'different_name'</programlisting></para>

      <para>results in the route<screen>different_name GET    /home/pong(.:format)      home#pong</screen></para>
    </section>

    <section xml:id="routen_as">
      <title xml:id="routen_as.title">to</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>to</secondary>
      </indexterm>

      <indexterm>
        <primary>routen</primary>

        <secondary>names</secondary>

        <tertiary>to</tertiary>
      </indexterm>

      <para>With to you can define an other destination for a rout. For
      example, the line <programlisting>get "home/applepie", to: "home#ping"</programlisting></para>

      <para>results in the route<screen>home_applepie GET /home/applepie(.:format) home#ping</screen></para>
    </section>

    <section xml:id="routes_match_parameter">
      <title xml:id="routes_match_parameter.title">Parameters</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>parameters</secondary>
      </indexterm>

      <para>The routing engine can not just assign fixed routes but also pass
      parameters which are part of the URL. A typical example would be date
      specifications (e.g. <uri>http://example.com/2010/12/</uri> for all
      December postings).</para>

      <para>To demonstrate this, let's create a mini blog application:<screen>$ rails new blog
  [...]
$ cd blog
$ rails generate scaffold post subject content published_at:date
  [...]
$ rake db:migrate
  [...]
$</screen></para>

      <para>As example data in the <filename>db/seeds.rb</filename> we
      take:<programlisting>Post.create(subject: 'A test', published_at: '01.10.2011')
Post.create(subject: 'Another test', published_at: '01.10.2011')
Post.create(subject: 'And yet one more test', published_at: '02.10.2011')
Post.create(subject: 'Last test', published_at: '01.11.2011')
Post.create(subject: 'Very final test', published_at: '01.11.2012')</programlisting></para>

      <para>With <command>rake db:seed</command> we populate the database with
      this data:<screen>$ rake db:seed
$</screen></para>

      <para>If we now start the Rails server with <command>rails
      server</command> and go to the page <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>
      in the browser, we will see this:<screenshot>
          <info>
            <title>Index view of all posts</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_index.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>For this kind of blog it would of course be very useful if you
      could render all entries for the year 2010 with the URL <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      and all entries for October 1st 2010 with <uri
      xlink:href="http://0.0.0.0:3000/2010/10/01">http://0.0.0.0:3000/2010/10/01</uri>.
      We can do this by using optional parameters. Please enter the following
      configuration in the
      <filename>config/routes.rb</filename>:<programlisting>Blog::Application.routes.draw do
  resources :posts

  get ':year(/:month(/:day))', to: 'posts#index'
end</programlisting></para>

      <para>The round brackets represent optional parameters. In this case,
      you have to specify the year, but not necessarily the month or day.
      <command>rake routes</command> shows the new route at the last
      line:<screen>$ rake routes
   Prefix Verb   URI Pattern                      Controller#Action
    posts GET    /posts(.:format)                 posts#index
          POST   /posts(.:format)                 posts#create
 new_post GET    /posts/new(.:format)             posts#new
edit_post GET    /posts/:id/edit(.:format)        posts#edit
     post GET    /posts/:id(.:format)             posts#show
          PATCH  /posts/:id(.:format)             posts#update
          PUT    /posts/:id(.:format)             posts#update
          DELETE /posts/:id(.:format)             posts#destroy
          GET    /:year(/:month(/:day))(.:format) posts#index
$ </screen></para>

      <para>If we do not change anything else, we still get the same result
      when calling <uri
      xlink:href="http://0.0.0.0:3000/2011/">http://0.0.0.0:3000/2011/</uri>
      and <uri
      xlink:href="http://0.0.0.0:3000/2011">http://0.0.0.0:3000/2011/10/01</uri>
      as we did with <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>.
      But have a look at the output of rails server for the request
      <uri>http://0.0.0.0:3000/2011</uri><screen>Started GET "/2011" for 127.0.0.1 at 2013-07-17 11:08:58 +0200
  ActiveRecord::SchemaMigration Load (0.1ms)  SELECT "schema_migrations".* FROM "schema_migrations"
Processing by PostsController#index as HTML
  Parameters: {"year"=&gt;"2011"}
  Post Load (0.1ms)  SELECT "posts".* FROM "posts"
  Rendered posts/index.html.erb within layouts/application (21.3ms)
Completed 200 OK in 96ms (Views: 76.3ms | ActiveRecord: 0.5ms)</screen></para>

      <para>The route has been recognised and an <code>"year" =&gt;
      "2011"</code> has been assigned to the hash
      <code><varname>params</varname></code> (written misleadingly as
      <code>Parameters</code> in the output). Going to the URL <uri
      xlink:href="http://0.0.0.0:3000/2010/12/24">http://0.0.0.0:3000/2010/12/24</uri>
      results in the following output, as expected:<screen>Started GET "/2010/12/24" for 127.0.0.1 at 2013-07-17 11:11:21 +0200
Processing by PostsController#index as HTML
  Parameters: {"year"=&gt;"2010", "month"=&gt;"12", "day"=&gt;"24"}
  Post Load (0.2ms)  SELECT "posts".* FROM "posts"
  Rendered posts/index.html.erb within layouts/application (3.4ms)
Completed 200 OK in 9ms (Views: 8.1ms | ActiveRecord: 0.2ms)</screen></para>

      <para>In case of the URL <uri
      xlink:href="http://0.0.0.0:3000/2010/12/24">http://0.0.0.0:3000/2010/12/24</uri>,
      the following values have been saved in the hash
      <varname>params</varname>: <code>"year"=&gt;"2010", "month"=&gt;"12",
      "day"=&gt;"24".</code></para>

      <para>In the controller, we can access <varname>params[]</varname> to
      access the values defined in the URL. We simply need to adapt the
      <methodname>index</methodname> method in
      <filename>app/controllers/posts_controller.rb</filename> to output the
      <varname>posts</varname> entered for the corresponding date, month or
      year:<programlisting># GET /posts
# GET /posts.json
def index
  # Check if the URL requests a date.
  if Date.valid_date? params[:year].to_i, params[:month].to_i, params[:day].to_i 
    start_date = Date.parse("#{params[:day]}.#{params[:month]}.#{params[:year]}")
    end_date = start_date

  # Check if the URL requests a month
  elsif Date.valid_date? params[:year].to_i, params[:month].to_i, 1 
    start_date = Date.parse("1.#{params[:month]}.#{params[:year]}")
    end_date = start_date.end_of_month
      
  # Check if the URL requests a year
  elsif params[:year] &amp;&amp; Date.valid_date?(params[:year].to_i, 1, 1)
    start_date = Date.parse("1.1.#{params[:year]}")
    end_date = start_date.end_of_year
  end

  if start_date &amp;&amp; end_date
    @posts = Post.where(published_at: start_date..end_date)
  else
    @posts = Post.all
  end
end</programlisting></para>

      <para>If we now go to <uri
      xlink:href="http://0.0.0.0:3000/2011/10/01">http://0.0.0.0:3000/2011/10/01</uri>
      , we can see all <varname>posts</varname> of October 1st
      2011.<screenshot>
          <info>
            <title>Index view for 1st Oct 2011</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_2011_10_01.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>
    </section>

    <section xml:id="routes_match_contraints">
      <title xml:id="routes_match_contraints.title">Constraints</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>constraints</secondary>
      </indexterm>

      <para>In <xref linkend="routes_match_parameter"/> I showed you how you
      can read out parameters from the URL and pass them to the controller.
      Unfortunately, the entry defined there in the
      <filename>config/routes.rb</filename> <programlisting>get ':year(/:month(/:day))', to: 'posts#index'</programlisting>has
      one important disadvantage: it does not verify the individual elements.
      For example, the URL <uri
      xlink:href="http://0.0.0.0:3000/ein/beispiel/dafuer">http://0.0.0.0:3000/just/an/example</uri>
      will be matched just the same and then of course results in an
      error:<screenshot>
          <info>
            <title>Error message</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/ein_beispiel_dafuer_fehler.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>In the log output in<filename> log/development.log</filename> we
      can see the following entry:<programlisting>Started GET "/just/an/example" for 127.0.0.1 at 2013-07-17 12:04:01 +0200
Processing by PostsController#index as HTML
  Parameters: {"year"=&gt;"just", "month"=&gt;"an", "day"=&gt;"example"}
Completed 500 Internal Server Error in 2ms

ArgumentError (invalid date):
  app/controllers/posts_controller.rb:19:in `parse'
  app/controllers/posts_controller.rb:19:in `index'</programlisting></para>

      <para>Obviously, <code>Date.parse( "example.an.just")</code> cannot
      work. A date is made up of numbers, not letters.</para>

      <para>Constraints can define the content of the URL more precisely via
      regular expressions. In the case of our blog, the
      <filename>config/routes.rb</filename> with contraints would look like
      this:<programlisting>Blog::Application.routes.draw do
  resources :posts

  get ':year(/:month(/:day))', to: 'posts#index', constraints: { year: /\d{4}/, month: /\d{2}/, day: /\d{2}/ }
end</programlisting></para>

      <warning>
        <para>Please note that you cannot use regex anchors such as "^" in
        regular expressions in a constraint.</para>
      </warning>

      <para>If we go to the URL again with this configuration, Rails gives us
      an error message "No route matches":<screenshot>
          <info>
            <title>Routing Error</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/ein_beispiel_dafuer_no_route_matches.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>
    </section>

    <section xml:id="routes_match_redirects">
      <title xml:id="routes_match_redirects.title">Redirects</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>redirect</secondary>
      </indexterm>

      <indexterm>
        <primary>redirect</primary>

        <secondary>via routes</secondary>
      </indexterm>

      <para>Our current application answers request in the format YYYY/MM/DD
      (4 digits for the year, 2 digits for the month and 2 digits for the
      day). That is ok for machines but maybe a human would request a single
      digit month (like January) and a single digit day without adding the
      extra 0 to make it two digits. We can fix that with a couple of redirect
      rules which catch these URLs and redirect them to the correct
      ones.</para>

      <para><programlisting>Blog::Application.routes.draw do
  resources :posts

  get ':year/:month/:day', to: redirect("/%{year}/0%{month}/0%{day}"), constraints: { year: /\d{4}/, month: /\d{1}/, day: /\d{1}/ }
  get ':year/:month/:day', to: redirect("/%{year}/0%{month}/%{day}"), constraints: { year: /\d{4}/, month: /\d{1}/, day: /\d{2}/ }
  get ':year/:month/:day', to: redirect("/%{year}/%{month}/0%{day}"), constraints: { year: /\d{4}/, month: /\d{2}/, day: /\d{1}/ }
  get ':year/:month', to: redirect("/%{year}/0%{month}"), constraints: { year: /\d{4}/, month: /\d{1}/ }

  get ':year(/:month(/:day))', to: 'posts#index', constraints: { year: /\d{4}/, month: /\d{2}/, day: /\d{2}/ }
end</programlisting></para>

      <para>With this set of redirect rules, we can ensure that a user of the
      page can also enter single-digit days and months and still ends up in
      the right place, or is redirected to the correct format.</para>

      <note>
        <para>Redirects in the <filename>config/routes.rb</filename> are by
        default http redirects with the code 301 ("Moved Permanently"). So
        even search engines will profit from this.</para>
      </note>
    </section>
  </section>

  <section xml:id="routes_root">
    <title xml:id="routes_root.title">root :to =&gt; 'welcome#index'</title>

    <indexterm>
      <primary>routes</primary>

      <secondary>root</secondary>
    </indexterm>

    <para>In the default <filename>config/routes.rb</filename> file you will
    find the following comment quite a long way down:<programlisting># You can have the root of your site routed with "root"
# root 'welcome#index' </programlisting></para>

    <para>If you comment out the last line there, you can define your <uri
    xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri> with it.
    Let's put it on <methodname>home#index</methodname>:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  root 'home#index'
end</programlisting></para>

    <para>Our new routes:<screen>$ rake routes
    Prefix Verb URI Pattern           Controller#Action
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
      root GET /                     home#index
$</screen></para>

    <para>If we go to the root URL <uri
    xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri> we now see
    <code>home#index</code>.</para>

    <para><screenshot>
        <info>
          <title>The route "/" takes us to home#index</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/routes_root_url.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>
  </section>

  <section xml:id="routes_resources">
    <title xml:id="routes_resources.title">resources</title>

    <indexterm>
      <primary>routes</primary>

      <secondary>resources</secondary>
    </indexterm>

    <para><code>resources</code> provides routes for a RESTful resource. Let's
    try it with the mini blog application:<screen>$ rails new blog
  [...]
$ cd blog
$ rails generate scaffold post subject content published_at:date
  [...]
$ rake db:migrate
  [...]
$</screen></para>

    <para>The scaffold generator automatically creates a
    <code>resources</code> route in the
    <filename>config/routes.rb</filename>:<programlisting>Blog::Application.routes.draw do
  resources :posts
end</programlisting></para>

    <note>
      <para>New routes are always added at the beginning of
      <filename>config/routes.rb</filename> by rails generate scripts.</para>
    </note>

    <para>The resulting routes:<screen>$ rake routes
   Prefix Verb   URI Pattern               Controller#Action
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
$</screen></para>

    <para>You have already encountered these RESTful routes in <xref
    linkend="scaffolding"/>. They are required for displaying and editing
    records.</para>

    <section>
      <title>Selecting Specific Routes with only: or except:</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>resources</secondary>

        <tertiary>only</tertiary>
      </indexterm>

      <indexterm>
        <primary>routes</primary>

        <secondary>resources</secondary>

        <tertiary>except</tertiary>
      </indexterm>

      <para>If you only want to use specific routes from the finished set of
      RESTful routes, you can limit them with <code>:only</code> or
      <code>:except</code>.</para>

      <para>The following <filename>conf/routes.rb</filename> defines only the
      routes for <code>index</code> and <code>show</code>:<programlisting>Blog::Application.routes.draw do
  resources :posts, only: [:index, :show]
end</programlisting></para>

      <para>With <command>rake routes</command> we can check the
      result:<screen>$ rake routes
Prefix Verb URI Pattern          Controller#Action
posts GET /posts(.:format)     posts#index
 post GET /posts/:id(.:format) posts#show
$ </screen></para>

      <para><code>except</code> works exactly the other way
      round:<programlisting>Blog::Application.routes.draw do
  resources :posts, except: [:index, :show]
end</programlisting></para>

      <para>Now all routes except for <code>index</code> and <code>show</code>
      are possible:<screen>$ rake routes
   Prefix Verb   URI Pattern               Controller#Action
    posts POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
$</screen></para>

      <warning>
        <para>When using <code>only</code> and <code>except</code>, please
        make sure you also adapt the views generated by the scaffold
        generator. For example, there is a link on the index page to the new
        view with <code>&lt;%= link_to 'New Post', new_post_path %&gt;</code>
        but this view no longer exists in the above only example.</para>
      </warning>
    </section>

    <section xml:id="routes_nested_resources">
      <title xml:id="routes_nested_resources.title">Nested Resources</title>

      <indexterm>
        <primary>routes</primary>

        <secondary>resources</secondary>

        <tertiary>nested</tertiary>
      </indexterm>

      <indexterm>
        <primary>nested routes</primary>

        <see>routes</see>
      </indexterm>

      <para>Nested resources refer to routes of resources that work with a
      association (see <xref linkend="activerecord_has_many"/>). These can be
      addressed precisely via routes. Let's create a second resource,
      <classname>comment</classname>:<screen>$ rails generate scaffold comment post_id:integer content
  [...]
$ rake db:migrate
  [...]
$ </screen></para>

      <para>Now we associate the two resources. In the file
      <filename>app/models/post.rb</filename>, we add a
      <methodname>has_many</methodname>:<programlisting>class Post &lt; ActiveRecord::Base
  has_many :comments
end
</programlisting></para>

      <para>And in the file <filename>app/models/comment.rb</filename>, its
      counterpart <methodname>belongs_to</methodname>:<programlisting>class Comment &lt; ActiveRecord::Base
  belongs_to :post
end
</programlisting></para>

      <para>The routes generated by the scaffold generator look like
      this:<screen>$ rake routes
      Prefix Verb   URI Pattern                  Controller#Action
    comments GET    /comments(.:format)          comments#index
             POST   /comments(.:format)          comments#create
 new_comment GET    /comments/new(.:format)      comments#new
edit_comment GET    /comments/:id/edit(.:format) comments#edit
     comment GET    /comments/:id(.:format)      comments#show
             PATCH  /comments/:id(.:format)      comments#update
             PUT    /comments/:id(.:format)      comments#update
             DELETE /comments/:id(.:format)      comments#destroy
       posts GET    /posts(.:format)             posts#index
             POST   /posts(.:format)             posts#create
    new_post GET    /posts/new(.:format)         posts#new
   edit_post GET    /posts/:id/edit(.:format)    posts#edit
        post GET    /posts/:id(.:format)         posts#show
             PATCH  /posts/:id(.:format)         posts#update
             PUT    /posts/:id(.:format)         posts#update
             DELETE /posts/:id(.:format)         posts#destroy
$ </screen></para>

      <para>So we can get the first post with <uri>/posts/1</uri> and all the
      comments with <uri>/comments</uri>. By using nesting, we can get all
      comments with the ID 1 via <uri>/posts/1/</uri>comments. We need to
      change the <filename>config/routes.rb</filename>:<programlisting>Blog::Application.routes.draw do
  resources :posts do
    resources :comments
  end
end</programlisting></para>

      <para>This gives us the desired routes:<screen>$ rake routes
           Prefix Verb   URI Pattern                                 Controller#Action
    post_comments GET    /posts/:post_id/comments(.:format)          comments#index
                  POST   /posts/:post_id/comments(.:format)          comments#create
 new_post_comment GET    /posts/:post_id/comments/new(.:format)      comments#new
edit_post_comment GET    /posts/:post_id/comments/:id/edit(.:format) comments#edit
     post_comment GET    /posts/:post_id/comments/:id(.:format)      comments#show
                  PATCH  /posts/:post_id/comments/:id(.:format)      comments#update
                  PUT    /posts/:post_id/comments/:id(.:format)      comments#update
                  DELETE /posts/:post_id/comments/:id(.:format)      comments#destroy
            posts GET    /posts(.:format)                            posts#index
                  POST   /posts(.:format)                            posts#create
         new_post GET    /posts/new(.:format)                        posts#new
        edit_post GET    /posts/:id/edit(.:format)                   posts#edit
             post GET    /posts/:id(.:format)                        posts#show
                  PATCH  /posts/:id(.:format)                        posts#update
                  PUT    /posts/:id(.:format)                        posts#update
                  DELETE /posts/:id(.:format)                        posts#destroy
$ </screen></para>

      <para>But we still need to make some changes in the file
      <filename>app/controllers/comments_controller.rb</filename>. This
      ensures that only the <varname>Comments</varname> of the specified
      <varname>Post</varname> can be displayed or changed:<programlisting>class CommentsController &lt; ApplicationController
  before_action :set_post
  before_action :set_comment, only: [:show, :edit, :update, :destroy]

  # GET /comments
  # GET /comments.json
  def index
    @comments = Comment.all
  end

  # GET /comments/1
  # GET /comments/1.json
  def show
  end

  # GET /comments/new
  def new
    @comment = @post.comments.build
  end

  # GET /comments/1/edit
  def edit
  end

  # POST /comments
  # POST /comments.json
  def create
    @comment = @post.comments.build(comment_params)

    respond_to do |format|
      if @comment.save
        format.html { redirect_to @comment, notice: 'Comment was successfully created.' }
        format.json { render action: 'show', status: :created, location: @comment }
      else
        format.html { render action: 'new' }
        format.json { render json: @comment.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /comments/1
  # PATCH/PUT /comments/1.json
  def update
    respond_to do |format|
      if @comment.update(comment_params)
        format.html { redirect_to @comment, notice: 'Comment was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: 'edit' }
        format.json { render json: @comment.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /comments/1
  # DELETE /comments/1.json
  def destroy
    @comment.destroy
    respond_to do |format|
      format.html { redirect_to comments_url }
      format.json { head :no_content }
    end
  end

  private
    def set_post
      @post = Post.find(params[:post_id])
    end

    # Use callbacks to share common setup or constraints between actions.
    def set_comment
      @comment = @post.comments.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def comment_params
      params.require(:comment).permit(:post_id, :content)
    end
end</programlisting></para>

      <para>Unfortunately, this is only half the story, because the views
      still link to the old routes. So we need to adapt each view in
      accordance with the nested route.</para>

      <para><filename>app/views/comments/_form.html.erb</filename></para>

      <para>Please note that you need to change the <code>form_for</code> call
      to <code>form_for([@post, @comment])</code>.</para>

      <para><programlisting>&lt;%= form_for([@post, @comment]) do |f| %&gt;
  &lt;% if @comment.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@comment.errors.count, "error") %&gt; prohibited this comment from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @comment.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= f.label :content %&gt;&lt;br /&gt;
    &lt;%= f.text_field :content %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;</programlisting></para>

      <para><filename>app/views/comments/edit.html.erb</filename><programlisting>&lt;h1&gt;Editing comment&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Show', [@post, @comment] %&gt; |
&lt;%= link_to 'Back', post_comments_path(@post) %&gt;</programlisting></para>

      <para><filename>app/views/comments/index.html.erb</filename><programlisting>&lt;h1&gt;Listing comments&lt;/h1&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Post&lt;/th&gt;
      &lt;th&gt;Content&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
      &lt;th&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;

  &lt;tbody&gt;
    &lt;% @comments.each do |comment| %&gt;
      &lt;tr&gt;
        &lt;td&gt;&lt;%= comment.post_id %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= comment.content %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to 'Show', [@post, comment] %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to 'Edit', edit_post_comment_path(@post, comment) %&gt;&lt;/td&gt;
        &lt;td&gt;&lt;%= link_to 'Destroy', [@post, comment], method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
      &lt;/tr&gt;
    &lt;% end %&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;br&gt;

&lt;%= link_to 'New Comment', new_post_comment_path(@post) %&gt;</programlisting></para>

      <para><filename>app/views/comments/new.html.erb</filename><programlisting>&lt;h1&gt;New comment&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', post_comments_path(@post) %&gt;</programlisting></para>

      <para><filename>app/views/comments/show.html.erb</filename><programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Post:&lt;/b&gt;
  &lt;%= @comment.post_id %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Content:&lt;/b&gt;
  &lt;%= @comment.content %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_post_comment_path(@post, @comment) %&gt; |
&lt;%= link_to 'Back', post_comments_path(@post) %&gt;</programlisting></para>

      <para>Please go ahead and have a go at experimenting with the URLs
      listed under rake routes. You can now generate a new post with
      <uri>/posts/new</uri> and a new comment for this post with
      <uri>/posts/:post_id/comments/new</uri>.</para>

      <para>If you want to see all comments of the first post you can access
      that with the URL <uri
      xlink:href="http://0.0.0.0:3000/posts/1/comments">http://0.0.0.0:3000/posts/1/comments</uri>.
      It would look like this:<screenshot>
          <info>
            <title>Nested comments</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_1_comments.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <section xml:id="shallow_nesting">
        <title xml:id="shallow_nesting.title">Shallow Nesting</title>

        <indexterm>
          <primary>routes</primary>

          <secondary>resources</secondary>

          <tertiary>shallow nesting</tertiary>
        </indexterm>

        <para>Sometimes it is a better option to use shallow nesting. For our
        example the <filename>config/routes.rb</filename> would contain the
        following routes:<programlisting>Blog::Application.routes.draw do
  resources :posts do
    resources :comments, only: [:index, :new, :create]
  end

  resources :comments, except: [:index, :new, :create]
end</programlisting></para>

        <para>That would lead to a less messy <command>rake routes</command>
        output:<screen>$ rake routes
          Prefix Verb   URI Pattern                            Controller#Action
   post_comments GET    /posts/:post_id/comments(.:format)     comments#index
                 POST   /posts/:post_id/comments(.:format)     comments#create
new_post_comment GET    /posts/:post_id/comments/new(.:format) comments#new
           posts GET    /posts(.:format)                       posts#index
                 POST   /posts(.:format)                       posts#create
        new_post GET    /posts/new(.:format)                   posts#new
       edit_post GET    /posts/:id/edit(.:format)              posts#edit
            post GET    /posts/:id(.:format)                   posts#show
                 PATCH  /posts/:id(.:format)                   posts#update
                 PUT    /posts/:id(.:format)                   posts#update
                 DELETE /posts/:id(.:format)                   posts#destroy
    edit_comment GET    /comments/:id/edit(.:format)           comments#edit
         comment GET    /comments/:id(.:format)                comments#show
                 PATCH  /comments/:id(.:format)                comments#update
                 PUT    /comments/:id(.:format)                comments#update
                 DELETE /comments/:id(.:format)                comments#destroy
$</screen></para>

        <para>Shallow nesting trys to combine the best of two worlds. And
        because it is often used there is a shortcut. You can use the
        following <filename>config/routes.rb</filename> to achieve
        it:<programlisting>Blog::Application.routes.draw do
  resources :posts do
    resources :comments, shallow: true
  end
end</programlisting></para>
      </section>

      <section xml:id="bemerkungen_nested_resources">
        <title xml:id="bemerkungen_nested_resources.title">Comments on Nested
        Resources</title>

        <para>Generally, you should never nest more deeply than one level and
        nested resources should feel natural. After a while, you will get a
        feel for it. In my opinion, the most important point about RESTful
        routes is that they should feel logical. If you phone a fellow Rails
        programmer and say "I've got a resource post and a resource comment
        here", then both parties should immediately be clear on how you
        address these resources via REST and how you can nest them.</para>
      </section>
    </section>
  </section>

  <section xml:id="routes_weitere_informationen">
    <title xml:id="routes_weitere_informationen.title">Further Information on
    Routes</title>

    <para>The topic routes is far more complex than we can address here. For
    example, you can also involve other HTTP methods/verbs. The official
    routing documentation <uri
    xlink:href="http://guides.rubyonrails.org/routing.html">http://guides.rubyonrails.org/routing.html</uri>
    will give you a lot of information an examples for these features and edge
    cases.</para>
  </section>
</chapter>
