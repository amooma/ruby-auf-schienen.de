<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="rails_production_webserver"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="rails_production_webserver.title">Web Server in Production
  Mode</title>

  <indexterm>
    <primary>web server</primary>

    <secondary>production</secondary>
  </indexterm>

  <indexterm>
    <primary>Nginx</primary>
  </indexterm>

  <indexterm>
    <primary>Unicorn</primary>
  </indexterm>

  <section xml:id="production_webserver_einleitung">
    <title xml:id="production_webserver_einleitung.title">Introduction</title>

    <para>In the rest of the book, we are always working with the development
    system. So we start Rails with <command>rails server</command>. Let's have
    another close look at the output:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.6 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-07-09 12:19:40] INFO  WEBrick 1.3.1
[2012-07-09 12:19:40] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-07-09 12:19:40] INFO  WEBrick::HTTPServer#start: pid=86773 port=3000</screen></para>

    <para>The second line tells us that we are in "development" mode and that
    the application can be accessed at the URL <uri
    xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri>. The web server
    used here is WEBrick (see <uri
    xlink:href="http://de.wikipedia.org/wiki/WEBrick">http://en.wikipedia.org/wiki/Webrick</uri>).
    WEBrick is a very simple HTTP web server and component of the Ruby
    standard library. But WEBrick is only suitable for development.</para>

    <para>For a production system, you would normally use a standard web
    server such as Apache, lighttpd or Nginx, to serve as reverse proxy and
    load balancer for the Rails system. The Rails system is then not run by
    the slow WEBrick, but by more powerful solutions such as Unicorn (<uri
    xlink:href="http://unicorn.bogomips.org/">http://unicorn.bogomips.org/</uri>),
    Mongrel (<uri
    xlink:href="http://de.wikipedia.org/wiki/Mongrel">http://en.wikipedia.org/wiki/Mongrel_(web_server)</uri>),
    Thin (<uri
    xlink:href="http://code.macournoyer.com/thin/">http://code.macournoyer.com/thin/</uri>)
    or Puma (<uri xlink:href="http://puma.io/">http://puma.io/</uri>).</para>

    <para>For a typical PHP project, you can just place the PHP code in a
    certain directory and in 9 out of 10 cases the available Apache web server
    can already process PHP code automatically (the corresponding module is
    almost always installed). With Rails, it's a different story,
    unfortunately. The obstacles are much bigger and more effort is involved.
    There is a large number of possible combinations (for example, "Apache,
    lighttpd or Nginx?" and "Unicorn, Thin, Puma or Mongrel?"). It is
    impossible to describe all variations in detail here. I decided to pick my
    favorite combination of Nginx and Unicorn. But that does not mean that
    other combinations are worse. It's purely a matter of personal
    choice.</para>

    <section xml:id="production_webserver_debian6">
      <title xml:id="production_webserver_debian6.title">Debian 6</title>

      <para>We build our production web server on a minimal Debian 6
      system.</para>

      <note>
        <para>This description assumes that you have a freshly installed
        Debian GNU/Linux 6.0 (<quote>Squeeze</quote>). You will find an ISO
        image for the installation at <uri
        xlink:href="http://www.debian.org/releases/squeeze/debian-installer/">http://www.debian.org/releases/squeeze/debian-installer/</uri>.
        I recommend the approximately 160 MB net installation CD image. For
        instructions on how to install Debian-GNU/Linux, please go to <uri
        xlink:href="http://www.debian.org/releases/squeeze/i386/">http://www.debian.org/releases/squeeze/i386/</uri>.</para>
      </note>

      <para>We install Ruby 1.9.3 via RVM with the new user
      <code>deployer</code>. The Rails application we use is called
      <code>blog</code>.</para>

      <important>
        <para>To carry out this installation, you need to have root rights on
        the web server!</para>
      </important>
    </section>
  </section>

  <section xml:id="deployment_grundinstallation_webserver">
    <title xml:id="deployment_grundinstallation_webserver.title">Basic
    Installation Web Server</title>

    <para>Please log in as <code>root</code> on the web server.</para>

    <section xml:id="deployment_grundinstallation_webserver_buildsystem">
      <title
      xml:id="deployment_grundinstallation_webserver_buildsystem.title">Buildsystem</title>

      <para>First, we install a few packages we are going to need.<screen>root@debian:~# <command>apt-get -y install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion python</command>
[...]
root@debian:~# </screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_nodejs">
      <title
      xml:id="deployment_grundinstallation_webserver_nodejs.title">Node.js</title>

      <para>To make the most of the asset pipeline, we install Node.js. Please
      go to the homepage of Node.js (<uri
      xlink:href="http://nodejs.org/">http://nodejs.org/</uri>), search for
      the current stable release and adapt the commands listed here
      accordingly.<screen>root@debian:~# <command>cd /usr/src</command>
root@debian:/usr/src# <command>wget http://nodejs.org/dist/v0.8.1/node-v0.8.1.tar.gz</command>
[...]
root@debian:/usr/src# <command>tar xzf node-v0.8.1.tar.gz</command> 
root@debian:/usr/src# <command>cd node-v0.8.1</command>
root@debian:/usr/src/node-v0.8.1# <command>./configure</command> 
[...]
root@debian:/usr/src/node-v0.8.1# <command>make</command>
[...]
root@debian:/usr/src/node-v0.8.1# <command>make install</command>
[...]
root@debian:/usr/src/node-v0.8.1# <command>cd</command>
[...]
root@debian:~# </screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_nginx">
      <title
      xml:id="deployment_grundinstallation_webserver_nginx.title">nginx</title>

      <para>Nginx will be our web server to the outside world. It acts as
      proxy and load balancer. As the Debian distribution includes a rather
      old Nginx version, we install the packages distributed by Nginx directly
      as well.<screen>root@debian:~# <command>curl http://nginx.org/keys/nginx_signing.key | apt-key add -</command>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1561  100  1561    0     0   3887      0 --:--:-- --:--:-- --:--:--  8819
OK
root@debian:~# <command>echo 'deb http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>echo 'deb-src http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>apt-get update</command>
[...]
root@debian:~# <command>apt-get -y install nginx</command>
[...]
root@debian:~# </screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_deployer_anlegen">
      <title
      xml:id="deployment_grundinstallation_webserver_deployer_anlegen.title">Creating
      User Deployer</title>

      <para>Our Rails project is going to run within a Ruby and Rails
      installed via RVM in the user space. So we create a new user with the
      name <code>deployer</code>:<screen>root@debian:~# <command>adduser deployer</command>
Lege Benutzer »deployer« an ...
Lege neue Gruppe »deployer« (1002) an ...
Lege neuen Benutzer »deployer« (1002) mit Gruppe »deployer« an ...
Erstelle Home-Verzeichnis »/home/deployer« ...
Kopiere Dateien aus »/etc/skel« ...
Geben Sie ein neues UNIX-Passwort ein: 
Geben Sie das neue UNIX-Passwort erneut ein: 
passwd: Passwort erfolgreich geändert
Benutzerinformationen für deployer werden geändert.
Geben Sie einen neuen Wert an oder drücken Sie ENTER für den Standardwert
 Vollständiger Name []: Deployer
 Raumnummer []: 
 Telefon geschäftlich []: 
 Telefon privat []: 
 Sonstiges []: 
Sind die Informationen korrekt? [J/n] J
root@debian:~#</screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_verzeichnisstruktur_anlegen">
      <title
      xml:id="deployment_grundinstallation_webserver_verzeichnisstruktur_anlegen.title">Create
      Directory Structure</title>

      <para>We now create a directory <filename>/var/www</filename> and set
      the user rights for it:<screen>root@debian:~# <command>mkdir -p /var/www</command>
root@debian:~# <command>usermod -a -G www-data nginx</command>
root@debian:~# <command>usermod -a -G www-data deployer</command>
root@debian:~# <command>chgrp -R www-data /var/www</command>
root@debian:~# <command>chmod -R 775 /var/www</command>
root@debian:~#</screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_rails_umgebung_deployer">
      <title
      xml:id="deployment_grundinstallation_webserver_rails_umgebung_deployer.title">Setting
      up Rails Environment for User Deployer</title>

      <para>Next, the user <code>deployer</code>:<screen>root@debian:~# <command>su - deployer</command>
deployer@debian:~$ </screen></para>

      <para>As user <code>deployer</code>, please carry out the steps
      described in <xref linkend="rails3-install-debian"/> for installing Ruby
      1.9.3 and Rails 3.2 via rvm. Here is the single line cut-and-paste short
      version:<screen>deployer@debian:~$ <command>curl -L https://get.rvm.io | bash -s stable &amp;&amp; source ~/.rvm/scripts/'rvm' &amp;&amp; rvm install 1.9.3 &amp;&amp; gem install rails</command>
[...]
deployer@debian:~$</screen></para>

      <para>To be able to start Unicorn with the RVM environment from within
      an Init.d script, we now need to generate a corresponding
      wrapper:<screen>deployer@debian:~$ <command>gem install unicorn</command>
[...]
deployer@debian:~$ <command>rvm wrapper 1.9.3 bootup unicorn</command>
deployer@debian:~$ <command>exit</command>
root@debian:~$</screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_datenbank">
      <title
      xml:id="deployment_grundinstallation_webserver_datenbank.title">Database</title>

      <para>Usually, you want to use a "large" database in a production
      system, such as PostgreSQL or MySQL. So here is how to install a MySQL
      database on this system and what you need to adapt in the Rails
      project.</para>

      <section xml:id="deployment_grundinstallation_webserver_mysql_installation">
        <title
        xml:id="deployment_grundinstallation_webserver_mysql_installation.title">MySQL
        Installation</title>

        <para>Next, we install the database MySQL. You will be asked for a
        database password. Please remember this password. Later,
        <code>root</code> can use it to log in to the database.<screen>root@debian:~# <command>apt-get -y install mysql-server libmysql-ruby libmysqlclient-dev</command>
[...]
root@debian:~# </screen></para>
      </section>

      <section xml:id="deployment_grundinstallation_webserver_create_database">
        <title
        xml:id="deployment_grundinstallation_webserver_create_database.title">Creating
        Database with Rights</title>

        <para>In the MySQL database, we need to create the database
        <code>blog</code> with access rights for the user
        <code>deployer</code>:<screen>deployer@debian:~$ <command>mysql -u root -p</command>
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 40
Server version: 5.1.63-0+squeeze1 (Debian)

Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; <command>CREATE DATABASE blog;</command>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <command>GRANT USAGE ON *.* TO deployer@localhost IDENTIFIED BY 'IhrLieblingsPasswort';</command>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <command>GRANT ALL PRIVILEGES ON blog.* TO deployer@localhost;</command>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <command>exit</command>;
Bye
deployer@debian:~$</screen></para>
      </section>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_memcached">
      <title
      xml:id="deployment_grundinstallation_webserver_memcached.title">Installing
      Memcache</title>

      <para>If you are working with a cache server (highly recommended), you
      of course have to install the appropriate software. For memcached (<uri
      xlink:href="http://memcached.org/">http://memcached.org/</uri>) you
      would enter this:<screen>root@debian:~# <command>apt-get -y install memcached</command>
[...]
root@debian:~#</screen></para>
    </section>
  </section>

  <section xml:id="webserver_ohne_deployment">
    <title xml:id="webserver_ohne_deployment.title">Webserver Without
    Deployment</title>

    <para>Please log in as <code>root</code> on the web server.</para>

    <warning>
      <para>When using this installation guide for other Rails projects,
      please note that you need to replace the name "blog" (for the relevant
      Rails application) with the appropriate project name in all
      configuration files and scripts.</para>
    </warning>

    <section xml:id="webserver_ohne_deployment_neues_rails_projekt">
      <title
      xml:id="webserver_ohne_deployment_neues_rails_projekt.title">Setting Up
      New Rails Project</title>

      <para>To keep this guide as simple as possible, we create a simple blog
      directly on the server as user <code>deployer</code>.<screen>root@debian:~# <command>su - deployer</command>
deployer@debian:~$ <command>rails new blog</command>
[...]
deployer@debian:~$ <command>cd blog</command>
deployer@debian:~/blog$ <command>rails generate scaffold post subject content:text</command>
[...]
deployer@debian:~/blog$</screen></para>

      <section>
        <title>Adapting Gemfile</title>

        <para>Please write the following content into the file
        <filename>Gemfile</filename>:<programlisting>source 'https://rubygems.org'

gem 'rails', '3.2.6'

gem 'sqlite3'

# Gems used only for assets and not required
# in production environments by default.
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'

  # See https://github.com/sstephenson/execjs#readme for more supported runtimes
  # gem 'therubyracer', :platforms =&gt; :ruby

  gem 'uglifier', '&gt;= 1.0.3'
end

gem 'jquery-rails'

# To use ActiveModel has_secure_password
# gem 'bcrypt-ruby', '~&gt; 3.0.0'

group :production do
  # Use MySQL as the production database
  gem 'mysql'

  # Use unicorn as the app server
  gem 'unicorn'
end
</programlisting></para>

        <para>Then install all gems with <command>bundle
        install</command>:<screen>deployer@debian:~/blog$ <command>bundle install</command>
[...]
deployer@debian:~/blog$</screen></para>
      </section>

      <section xml:id="production_webserver_database_yml">
        <title xml:id="production_webserver_database_yml.title">Production
        Database Configuration</title>

        <para>In the file<filename> config/database.yml</filename> you need to
        enter the database configuration for the MySQL database for the
        production system. Please make sure you enter the correct
        password.<programlisting># SQLite version 3.x
#   gem install sqlite3
#
#   Ensure the SQLite 3 gem is defined in your Gemfile
#   gem 'sqlite3'
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

<emphasis>production:
  adapter: mysql
  encoding: utf8
  database: blog
  username: deployer
  password: YourFavoritePassword</emphasis></programlisting></para>
      </section>

      <section xml:id="production_webserver_unicorn_gem_installieren">
        <title
        xml:id="production_webserver_unicorn_gem_installieren.title">Unicorn
        Configuration</title>

        <para>For the Unicorn configuration, we use the file <uri
        xlink:href="https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb">https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</uri>
        as basis and save it as follows in the file
        <filename>config/unicorn.rb</filename> after we adapt it to our
        server:<programlisting># Use at least one worker per core if you're on a dedicated server,
# more will usually help for _short_ waits on databases/caches.
worker_processes 4

# Since Unicorn is never exposed to outside clients, it does not need to
# run on the standard HTTP port (80), there is no reason to start Unicorn
# as root unless it's from system init scripts.
# If running the master process as root and the workers as an unprivileged
# user, do this to switch euid/egid in the workers (also chowns logs):
user "deployer", "www-data"

# Help ensure your application will always spawn in the symlinked
# "current" directory that Capistrano sets up.
APP_PATH = "/var/www/blog/current"
working_directory APP_PATH

# listen on both a Unix domain socket and a TCP port,
# we use a shorter backlog for quicker failover when busy
listen "/tmp/unicorn.blog.sock", :backlog =&gt; 64
listen 8080, :tcp_nopush =&gt; true

# nuke workers after 30 seconds instead of 60 seconds (the default)
timeout 30

# feel free to point this anywhere accessible on the filesystem
pid APP_PATH + "/tmp/pids/unicorn.pid"

# By default, the Unicorn logger will write to stderr.
# Additionally, some applications/frameworks log to stderr or stdout,
# so prevent them from going to /dev/null when daemonized here:
stderr_path APP_PATH + "/log/unicorn.blog.stderr.log"
stdout_path APP_PATH + "/log/unicorn.blog.stdout.log"

before_fork do |server, worker|
  # the following is highly recomended for Rails + "preload_app true"
  # as there's no need for the master process to hold a connection
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.connection.disconnect!
  end

  # Before forking, kill the master process that belongs to the .oldbin PID.
  # This enables 0 downtime deploys.
  old_pid = "/tmp/unicorn.my_site.pid.oldbin"
  if File.exists?(old_pid) &amp;&amp; server.pid != old_pid
    begin
      Process.kill("QUIT", File.read(old_pid).to_i)
    rescue Errno::ENOENT, Errno::ESRCH
      # someone else did our job for us
    end
  end
end

after_fork do |server, worker|
  # the following is *required* for Rails + "preload_app true",
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.establish_connection
  end

  # if preload_app is true, then you may also want to check and
  # restart any other shared sockets/descriptors such as Memcached,
  # and Redis.  TokyoCabinet file handles are safe to reuse
  # between any number of forked children (assuming your kernel
  # correctly implements pread()/pwrite() system calls)
end

before_exec do |server|
  ENV["BUNDLE_GEMFILE"] = "/var/www/blog/current/Gemfile"
end</programlisting></para>
      </section>

      <section>
        <title>rake db:migration</title>

        <para>We still need to create the database:<screen>deployer@debian:~/blog$ <command>rake db:migrate RAILS_ENV=production</command>
[...]
deployer@debian:~/blog$ </screen></para>

        <important>
          <para>Please ensure that the <command>rake db:migrate</command>
          concludes with a <command>RAILS_ENV=production</command>. This is to
          migrate the production database.</para>
        </important>
      </section>

      <section>
        <title>rake assets:precompile</title>

        <para><command>rake assets:precompile</command> ensures that all
        assets in the asset pipeline are made available for the production
        environment (see <xref linkend="asset_pipeline"/>).<screen>deployer@debian:~/blog$ <command>rake assets:precompile</command>
/home/deployer/.rvm/rubies/ruby-1.9.3-p194/bin/ruby /home/deployer/.rvm/gems/ruby-1.9.3-p194@global/bin/rake assets:precompile:all RAILS_ENV=production RAILS_GROUPS=assets
deployer@debian:~/blog$</screen></para>
      </section>

      <section xml:id="production_webserver_unicorn_init_script">
        <title xml:id="production_webserver_unicorn_init_script.title">Unicorn
        Init Script</title>

        <para>Now you need to continue working as user
        <code>root</code>:<screen>deployer@debian:~$ <command>exit</command>
Abgemeldet
root@debian:~# </screen></para>

        <para>Create the init script
        <filename>/etc/init.d/unicorn_blog</filename> with the following
        content:<programlisting>#!/bin/bash

### BEGIN INIT INFO
# Provides:          unicorn
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Unicorn webserver
# Description:       Unicorn webserver for the blog
### END INIT INFO

UNICORN=/home/deployer/.rvm/bin/bootup_unicorn
UNICORN_ARGS="-D -c /home/deployer/blog/config/unicorn.rb -E production"
KILL=/bin/kill
PID=/home/deployer/tmp/unicorn.pid

sig () {
  test -s "$PID" &amp;&amp; kill -$1 `cat $PID`
}

case "$1" in
        start)
                echo "Starting unicorn..."
                $UNICORN $UNICORN_ARGS
                ;;
        stop)
                sig QUIT &amp;&amp; exit 0
                echo &gt;&amp;2 "Not running"
                ;;
        restart)
                $0 stop
                $0 start
                ;;
        status)
                ;;
        *)
                echo "Usage: $0 {start|stop|restart|status}"
                ;;
esac</programlisting></para>

        <para>You still have to activate the init script and start
        Unicorn:<screen>root@debian:~# <command>chmod +x /etc/init.d/unicorn_blog</command> 
root@debian:~# <command>update-rc.d -f unicorn_blog defaults</command>
update-rc.d: using dependency based boot sequencing
root@debian:~# <command>/etc/init.d/unicorn_blog start</command>
root@debian:~# </screen></para>

        <para>Your Rails project is now accessible via the IP address of the
        web server.</para>
      </section>

      <section xml:id="production_webserver_nginx_konfiguration">
        <title xml:id="production_webserver_nginx_konfiguration.title">nginx
        Configuration</title>

        <para>For the Rails project, we add a new configuration file
        <filename>/etc/nginx/conf.d/blog.conf</filename> with the following
        content:<programlisting>upstream unicorn {
  server unix:/tmp/unicorn.blog.sock fail_timeout=0;
}

server {
  listen 80 default deferred;
  # server_name example.com;
  root /home/deployer/blog/public;

  location / {
    gzip_static on;
  }

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 4G;
  keepalive_timeout 10;
}</programlisting></para>

        <para>We rename the default configuration file to make sure it is no
        longer executed. Then we restart nginx.<screen>root@debian:~# <command>mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.backup</command>
root@debian:~# <command>/etc/init.d/nginx restart</command>
Restarting nginx: nginx.
root@debian:~#</screen></para>
      </section>
    </section>

    <section xml:id="webserver_ohne_deployment_neues_version_des_rails_projekts_einspielen">
      <title
      xml:id="webserver_ohne_deployment_neues_version_des_rails_projekts_einspielen.title">Loading
      New Version of Rails Project</title>

      <para>As you can see from this heading, we do not have automatic
      deployment mechanisms in this variation. But you can easily implement
      automatic deployment by using a script.</para>

      <para>If you want to activate changes to the Rails project, you need to
      log in as user <code>deployer</code> and use <command>rake
      assets:precompile</command> after a code update to ensure that all
      assets in the asset pipeline are made available once more for the
      production environment (see <xref linkend="asset_pipeline"/>).<screen>deployer@debian:~/blog$ <command>rake assets:precompile</command>
/home/deployer/.rvm/rubies/ruby-1.9.3-p194/bin/ruby /home/deployer/.rvm/gems/ruby-1.9.3-p194@global/bin/rake assets:precompile:all RAILS_ENV=production RAILS_GROUPS=assets
deployer@debian:~/blog$</screen></para>

      <para>If you bring in new migrations, you of course also need to do a
      <command>rake db:migrate RAILS_ENV=production</command>:<screen>deployer@debian:~/blog$ <command>rake db:migrate RAILS_ENV=production</command>
[...]
deployer@debian:~/blog$ </screen></para>

      <para>Then you need to restart Unicorn as user
      <code>root</code>:<screen>root@debian:~# <command>/etc/init.d/unicorn_blog restart</command>
root@debian:~# </screen></para>

      <tip>
        <para>In most cases, it makes more sense to use an installation with
        Capistrano deployment. Initially, this involves a tiny bit more effort
        (see <xref linkend="webserver_mit_capistrano"/>), but then it offers
        greater comfort and security.</para>
      </tip>
    </section>
  </section>

  <section xml:id="webserver_mit_capistrano">
    <title xml:id="webserver_mit_capistrano.title">Web Server with Capistrano
    Deployment</title>

    <indexterm>
      <primary>deployment</primary>
    </indexterm>

    <indexterm>
      <primary>Capistrano</primary>
    </indexterm>

    <para>In <xref linkend="webserver_ohne_deployment"/>, we have created a
    new Rails project on the production system. Logically, this is not the
    normal approach. Normally, one or several developers would develop the
    Rails project on their own computers and then upload it to the production
    server later.</para>

    <para>Especially if you are working with several developers, it makes
    sense to use a version management system. With Capistrano, you can then
    use this version management to distribute updates of the Rails project to
    one or several web servers. In this chapter, we are using Git as
    distributed version management and Github (<uri
    xlink:href="http://github.com">http://github.com</uri>) as server for
    hosting Git.</para>

    <para>For this tutorial, you will need a ready installed production server
    with nginx and a Ruby 1.9.3 and Rails 3.2 installed with RVM with the user
    <code>deployer</code> (for a detailled guide, please read <xref
    linkend="deployment_grundinstallation_webserver"/>).</para>

    <section xml:id="webserver_mit_capistrano_entwicklungssystem">
      <title
      xml:id="webserver_mit_capistrano_entwicklungssystem.title">Development
      System</title>

      <para>We start again with a new Rails application. Please create this
      application on your development computer.</para>

      <section>
        <title>rails new blog</title>

        <para>We create the mini blog Rails application:<screen>Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>rails new blog</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>cd blog</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails generate scaffold post subject content:text</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

        <note>
          <para>If you want to work with this system in the development
          environment, you still need a <screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rake db:migrate</command>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -&gt; 0.0015s
==  CreatePosts: migrated (0.0016s) ===========================================

Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>
        </note>

        <section>
          <title>Required Gems for Deployment</title>

          <para>For the deployment and the web server, we need some gems.
          Please insert this configuration into the file
          <filename>Gemfile</filename>:<programlisting>source 'https://rubygems.org'

gem 'rails', '3.2.6'

gem 'sqlite3'

# Gems used only for assets and not required
# in production environments by default.
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'

  # See https://github.com/sstephenson/execjs#readme for more supported runtimes
  # gem 'therubyracer', :platforms =&gt; :ruby

  gem 'uglifier', '&gt;= 1.0.3'
end

gem 'jquery-rails'

# To use ActiveModel has_secure_password
# gem 'bcrypt-ruby', '~&gt; 3.0.0'

group :production do
  # Use MySQL as the production database
  gem 'mysql'

  # Use unicorn as the app server
  gem 'unicorn'
end


group :development do
  # Use Capistrano for the deployment
  gem 'capistrano'
  gem 'rvm-capistrano'
end
</programlisting></para>

          <para>Then execute a <command>bundle install</command>:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>
        </section>
      </section>

      <section>
        <title>Unicorn Configuration</title>

        <para>For the Unicorn configuration, we use the file <uri
        xlink:href="https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb">https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</uri>
        as basis, adapt it to our server as follows and save it in the file
        <filename>config/unicorn.rb</filename>:<programlisting># Use at least one worker per core if you're on a dedicated server,
# more will usually help for _short_ waits on databases/caches.
worker_processes 4

# Since Unicorn is never exposed to outside clients, it does not need to
# run on the standard HTTP port (80), there is no reason to start Unicorn
# as root unless it's from system init scripts.
# If running the master process as root and the workers as an unprivileged
# user, do this to switch euid/egid in the workers (also chowns logs):
user "deployer", "www-data"

# Help ensure your application will always spawn in the symlinked
# "current" directory that Capistrano sets up.
APP_PATH = "/var/www/blog/current"
working_directory APP_PATH

# listen on both a Unix domain socket and a TCP port,
# we use a shorter backlog for quicker failover when busy
listen "/tmp/unicorn.blog.sock", :backlog =&gt; 64
listen 8080, :tcp_nopush =&gt; true

# nuke workers after 30 seconds instead of 60 seconds (the default)
timeout 30

# feel free to point this anywhere accessible on the filesystem
pid APP_PATH + "/tmp/pids/unicorn.pid"

# By default, the Unicorn logger will write to stderr.
# Additionally, ome applications/frameworks log to stderr or stdout,
# so prevent them from going to /dev/null when daemonized here:
stderr_path APP_PATH + "/log/unicorn.blog.stderr.log"
stdout_path APP_PATH + "/log/unicorn.blog.stdout.log"

before_fork do |server, worker|
  # the following is highly recomended for Rails + "preload_app true"
  # as there's no need for the master process to hold a connection
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.connection.disconnect!
  end

  # Before forking, kill the master process that belongs to the .oldbin PID.
  # This enables 0 downtime deploys.
  old_pid = "/tmp/unicorn.my_site.pid.oldbin"
  if File.exists?(old_pid) &amp;&amp; server.pid != old_pid
    begin
      Process.kill("QUIT", File.read(old_pid).to_i)
    rescue Errno::ENOENT, Errno::ESRCH
      # someone else did our job for us
    end
  end
end

after_fork do |server, worker|
  # the following is *required* for Rails + "preload_app true",
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.establish_connection
  end

  # if preload_app is true, then you may also want to check and
  # restart any other shared sockets/descriptors such as Memcached,
  # and Redis.  TokyoCabinet file handles are safe to reuse
  # between any number of forked children (assuming your kernel
  # correctly implements pread()/pwrite() system calls)
end

before_exec do |server|
  ENV["BUNDLE_GEMFILE"] = "/var/www/blog/current/Gemfile"
end</programlisting></para>
      </section>

      <section>
        <title>Capistrano Configuration</title>

        <para>We set up a Capistrano standard configuration:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>capify .</command>  
[add] writing './Capfile'
[add] writing './config/deploy.rb'
[done] capified!
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

        <para>Then we set up the <filename>config/deploy.rb</filename> with
        the following content. Please remember to replace the text
        ip.address.of.server with the IP address of your web
        server!<programlisting>require "bundler/capistrano"
require "rvm/capistrano"
set :rvm_ruby_string, '1.9.3'

server "ip.address.of.server", :web, :app, :db, primary: true

set :application, "blog"
set :user, "deployer"
set :deploy_to, "/var/www/#{application}"
set :deploy_via, :remote_cache
set :use_sudo, false

set :scm, "git"
set :repository, "git@github.com:your_github_account/#{application}.git"
set :branch, "master"

default_run_options[:pty] = true
ssh_options[:forward_agent] = true

after 'deploy', 'deploy:cleanup'
after 'deploy', 'deploy:migrate'

namespace :deploy do
  %w[start stop restart reload].each do |command|
    desc "#{command} unicorn server"
    task command, roles: :app, except: {no_release: true} do
      run "sudo /etc/init.d/unicorn_#{application} #{command}"
    end
  end

  # Use this if you know what you are doing.
  #
  # desc "Zero-Downtime restart of Unicorn"
  # task :restart, :except =&gt; { :no_release =&gt; true } do
  #   run "sudo /etc/init.d/unicorn_#{application} reload"
  # end
end</programlisting></para>

        <para>Now change the file <filename>Capfile</filename> as
        follows:<programlisting>load 'deploy'
# Uncomment if you are using Rails' asset pipeline
<emphasis>load 'deploy/assets'</emphasis>
Dir['vendor/gems/*/recipes/*.rb','vendor/plugins/*/recipes/*.rb'].each { |plugin| load(plugin) }
load 'config/deploy' # remove this line to skip loading any of the default tasks
</programlisting></para>
      </section>

      <section>
        <title>Setting Up Github as Repository</title>

        <para>Please create a new account at <uri
        xlink:href="https://github.com">https://github.com</uri> or use an
        existing Github account. Use this account to create a new repository
        with the name "<code>blog</code>".</para>

        <tip>
          <para>To simplify your work, I recommend that you enter your SSH key
          in your Github account at <uri
          xlink:href="https://github.com/settings/ssh">https://github.com/settings/ssh</uri>.</para>
        </tip>

        <para>Now you can commit and push your project. Of course, you need to
        replace <code>your_github_account</code> with your own Github
        account:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git init</command>
Initialized empty Git repository in /Users/xyz/blog/.git/
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git add .</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git commit -m 'first commit'</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git remote add origin git@github.com:your_github_account/blog.git</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git push -u origin master</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

        <para>Your Rails project is now hosted in a Github repository and you
        can view it at <uri
        xlink:href="https://github.com/ihr_github_account/blog">https://github.com/your_github_account/blog</uri>.</para>
      </section>
    </section>

    <section>
      <title>Web Server</title>

      <para>You need to carry out the following steps on the web server
      system.</para>

      <section>
        <title>Generate SSH Key</title>

        <para>We create a public SSH key for the user <code>deployer</code>.
        Please log in to the web server as user <code>deployer</code>.
        Deployment is easier later on if you use an empty pass phrase.<screen>deployer@debian:~$ <command>ssh-keygen</command>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/deployer/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/deployer/.ssh/id_rsa.
Your public key has been saved in /home/deployer/.ssh/id_rsa.pub.
The key fingerprint is:
ba:11:90:2a:e3:8f:5b:2e:70:99:50:86:a1:9a:2c:b7 deployer@debian
The key's randomart image is:
+--[ RSA 2048]----+
|.o               |
|o o  .           |
|.o  o            |
|+. . .           |
|*ooo  . S        |
|+++.   o         |
|.oE.  o          |
| .=    o         |
| ooo  .          |
+-----------------+
deployer@debian:~$ <command>cat .ssh/id_rsa.pub</command> 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDJEGixOcPRdBMry7PPG/Rgla50EM+JPKGYGD/yJ8v7bdrfT68t2/eVbj6+YebWh1tRebE3qqouqmZjIlocr1j67SmfXZ/sswBT/pXOhP89JtHPMolx7rUQ8wQF3aDrnVDJG0gdvRm212vN2bou3N5dzhekmWmbS3R0ZGNM9ZgTw8rhTOd1M2QVTzyV1i1PehoFxOu1WIc1gN5C42zihbJ6fGgVb45WeKzXSi6bQ6PMKD1gAMJpXHPvKLhi0wLN0wNOJwa6BKR3pmgICSBuoziAhhCS/7gBDJnqRmx1zax/1CShJD3QEGHvofA9okYuYVqyrJi1hdF8ZgMnQCb31I21 deployer@debian
deployer@debian:~$</screen></para>

        <para>The generated key is located in the file
        <filename>/home/deployer/.ssh/id_rsa.pub</filename>.</para>

        <important>
          <para>Please now log in to your Github account and add this key
          under Deploy Keys in the admin area of your Github project. See <uri
          xlink:href="https://github.com/ihr_github_account/blog/admin/keys">https://github.com/your_github_account/blog/admin/keys</uri></para>
        </important>

        <para>Then use ssh to connect on the console with the Github SSH
        server and confirm the question "Are you sure you want to continue
        connection (yes/no)?" with yes. <screen>deployer@debian:~$ <command>ssh git@github.com</command>
The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)? <command>yes</command>
Warning: Permanently added 'github.com,207.97.227.239' (RSA) to the list of known hosts.
PTY allocation request failed on channel 0
Hi your_github_account/blog! You've successfully authenticated, but GitHub does not provide shell access.
                 Connection to github.com closed.
deployer@debian:~$</screen></para>

        <para>Now you can start deploying on your development system.</para>
      </section>
    </section>

    <section>
      <title>cap deploy:setup</title>

      <para>With <command>cap deploy:setup</command> we can set up the
      necessary directory structure on the target system. If you have not
      stored your SSH key on the target system, the script will ask you for
      the password for the user <code>deployer</code>. Depending on your
      connection and CPU power, this initial setup step may take
      longer.<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>cap deploy:setup</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ </screen></para>

      <para>After the <command>cap deploy:setup</command>, you will find the
      following directory structure on your web server:<screen>/var/www/blog
├── releases
└── shared
    ├── log
    ├── pids
    └── system</screen></para>

      <para>We can start the first deploy with <command>cap
      deploy</command>:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>cap deploy</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ </screen></para>

      <para>We then see the result of the deploy in the web server's directory
      structure:<screen>/var/www/blog
├── current -&gt; /var/www/blog/releases/20120711131031
├── releases
│   └── 20120711131031
└── shared
    ├── assets
    ├── bundle
    ├── cached-copy
    ├── log
    ├── pids
    └── system</screen></para>

      <para>Capistrano has created a new directory for the new application
      version in the subdirectory <filename>/var/www/blog/releases</filename>
      and linked this new directory to the directory
      <filename>/var/www/blog/current</filename>.</para>
    </section>

    <section xml:id="webserver_mit_capistrano_webserver_konfiguration">
      <title
      xml:id="webserver_mit_capistrano_webserver_konfiguration.title">Web
      Server Configuration</title>

      <para>Now we still need to write and activate an init script and
      configuration file on the web server.</para>

      <section xml:id="production_webserver_capistrano_unicorn_init_script">
        <title
        xml:id="production_webserver_capistrano_unicorn_init_script.title">Unicorn
        Init Script</title>

        <para>Please log in to the web server as user <code>root</code> and
        create the init script <filename>/etc/init.d/unicorn_blog</filename>
        with the following content:<programlisting>#!/bin/bash

### BEGIN INIT INFO
# Provides:          unicorn
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Unicorn webserver
# Description:       Unicorn webserver for the blog
### END INIT INFO

UNICORN=/home/deployer/.rvm/bin/bootup_unicorn
UNICORN_ARGS="-D -c /var/www/blog/current/config/unicorn.rb -E production"
KILL=/bin/kill
PID=/var/www/blog/shared/pids/unicorn.pid

sig () {
  test -s "$PID" &amp;&amp; kill -$1 `cat $PID`
}

case "$1" in
        start)
                echo "Starting unicorn..."
                $UNICORN $UNICORN_ARGS
                ;;
        stop)
                sig QUIT &amp;&amp; exit 0
                echo &gt;&amp;2 "Not running"
                ;;
        reload)
                sig USR2 &amp;&amp; exit 0
                ;;
        restart)
                $0 stop
                $0 start
                ;;
        status)
                ;;
        *)
                echo "Usage: $0 {start|stop|reload|restart|status}"
                ;;
esac</programlisting></para>

        <para>Now we need to activate the init script and start
        Unicorn:<screen>root@debian:~# <command>chmod +x /etc/init.d/unicorn_blog</command> 
root@debian:~# <command>update-rc.d -f unicorn_blog defaults</command>
update-rc.d: using dependency based boot sequencing
root@debian:~# <command>/etc/init.d/unicorn_blog start</command>
root@debian:~# </screen></para>

        <para>Your Rails project is now accessible via the web server's IP
        address.</para>
      </section>

      <section xml:id="production_webserver_capistrano_nginx_konfiguration">
        <title
        xml:id="production_webserver_capistrano_nginx_konfiguration.title">nginx
        Configuration</title>

        <para>For the Rails project, we add a new configuration file
        <filename>/etc/nginx/conf.d/blog.conf</filename> with the following
        content:<programlisting>upstream unicorn {
  server unix:/tmp/unicorn.blog.sock fail_timeout=0;
}

server {
  listen 80 default deferred;
  # server_name example.com;
  root /var/www/blog/current/public;

  location / {
    gzip_static on;
  }

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 4G;
  keepalive_timeout 10;
}</programlisting></para>

        <para>We rename the default configuration file to make sure it is no
        longer executed. Then we restart nginx.<screen>root@debian:~# <command>mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.backup</command>
root@debian:~# <command>/etc/init.d/nginx restart</command>
Restarting nginx: nginx.
root@debian:~#</screen></para>
      </section>
    </section>

    <section>
      <title>sudo</title>

      <para>In the Capistrano deploy script, we need a way of stopping and
      starting Unicorn via init script. So we need to install sudo on the web
      server:<screen>root@debian:~# <command>apt-get install sudo</command>
[...]
root@debian:~# </screen></para>

      <para>And in the file <filename>/etc/sudoers</filename> we need to add
      the following line:<programlisting>deployer ALL= NOPASSWD: /etc/init.d/unicorn_blog</programlisting></para>
    </section>

    <section xml:id="webserver_mit_capistrano_webserver_deployment">
      <title
      xml:id="webserver_mit_capistrano_webserver_deployment.title">Deployment</title>

      <para>The big advantage of working with Capistrano is that it makes it
      so easy to install new versions (deployment). You can simply do it from
      the development system via the command <command>cap deploy</command>.
      After a second <command>cap deploy</command>, the directory structure
      looks like this:<screen>/var/www/blog
├── current -&gt; /var/www/blog/releases/20120711132357
├── releases
│   ├── 20120711131031
│   └── 20120711132357
└── shared
    ├── assets
    ├── bundle
    ├── cached-copy
    ├── log
    ├── pids
    └── system</screen></para>

      <para>So the relevant releases are always saved in the directory
      <filename>/var/www/blog/releases</filename>.</para>

      <para>In the directory <filename>/var/www/blog/shared</filename> you
      will find directories that are shared by the relevant release. These are
      always linked automatically within
      <filename>/var/www/blog/current</filename>.</para>

      <para>In the configuration we are using, the last 5 releases are
      automatically saved, any older releases are deleted.</para>

      <tip>
        <para>Capistrano is a very powerful tool. It is well worth it for any
        admin to have a look at the Capistrano Wiki (<uri
        xlink:href="https://github.com/capistrano/capistrano/wiki">https://github.com/capistrano/capistrano/wiki</uri>)
        zu werfen.</para>
      </tip>
    </section>
  </section>

  <section xml:id="production_webserver_sonstiges">
    <title xml:id="production_webserver_sonstiges.title">Other Issues</title>

    <section xml:id="production_webserver_was_noch_zu_tun_ist">
      <title xml:id="production_webserver_was_noch_zu_tun_ist.title">What Else
      There Is To Do</title>

      <para>Please always consider the following points - every admin has to
      decide these for him- or herself and implement them
      accordingly:<itemizedlist>
          <listitem>
            <para>Automatic and regular backup of database and Rails
            project.</para>
          </listitem>

          <listitem>
            <para>Set up log rotations of log files.</para>
          </listitem>

          <listitem>
            <para>Set up monitoring for system load and hard drive
            space.</para>
          </listitem>

          <listitem>
            <para>Regularly install Debian security updates as soon as they
            become available.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="production_webserver_404">
      <title xml:id="production_webserver.title">404 and Co.</title>

      <para>Finally, please look into the <filename>public</filename>
      directory in your Rails project and adapt the HTML pages saved there to
      your own requirements. Primarily, this is about the design of the pages.
      In the default setting, these are somewhat sparse and do not have any
      relation to the rest of your website. If you decide to update your web
      page and shut down your Unicorn server to do so, nginx will deliver the
      web page <filename>public/500.html</filename> in the meantime.</para>

      <para>You will find a list of HTTP error codes at <uri
      xlink:href="http://de.selfhtml.org/servercgi/server/httpstatuscodes.htm">http://en.wikipedia.org/wiki/List_of_HTTP_status_codes</uri></para>
    </section>

    <section xml:id="production_webserver_mehrere_server">
      <title xml:id="production_webserver_mehrere_server.title">Multiple Rails
      Servers on One System</title>

      <para>You can runs several Rails servers on one system without any
      problems. You need to set up a separate Unicorn for each Rails server.
      You can then distribute to it from nginx. With nginx you can also define
      on which IP address a Rails server is accessible from the
      outside.</para>
    </section>
  </section>

  <section xml:id="production_webserver_paas">
    <title xml:id="production_webserver_paas.title">Cloud Platform as Service
    Provider</title>

    <para>If you do not have a web server available on the internet or want to
    deploy to a PaaS (Platform as a Service) system right from the start, you
    should have a look at what the various providers have to offer. The two US
    market leaders are currently Heroku (<uri
    xlink:href="http://www.heroku.com/">http://www.heroku.com/</uri>) and
    Engine Yard (<uri
    xlink:href="http://www.engineyard.com/">http://www.engineyard.com/</uri>).</para>

    <para>PaaS as platform usually offers less options than your own server.
    But you have 7x24 support for this platform if anything does not work
    properly.</para>
  </section>
</chapter>
