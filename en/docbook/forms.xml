<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="forms" xml:lang="en"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="forms.title">Forms</title>

  <section>
    <title>The Data-Input Workflow</title>

    <para>To understand forms we take a look at the data workflow.
    Understanding it better will help to understand the work of forms.</para>

    <para>Example application:<screen>$ <command>rails new testapp</command>
[...]
$ <command>cd testapp</command>
$ <command>rails generate scaffold Person first_name last_name</command>
[...]
$ <command>rake db:migrate</command>
[...]
$ <command>rails s</command>
=&gt; Booting WEBrick
=&gt; Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Run `rails server -h` for more startup options
=&gt; Ctrl-C to shutdown server
[2013-07-20 09:48:23] INFO  WEBrick 1.3.1
[2013-07-20 09:48:23] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-20 09:48:23] INFO  WEBrick::HTTPServer#start: pid=72655 port=3000</screen></para>

    <para>Most times we create forms by using the Scaffold. Let's go through
    the flow the data </para>

    <section>
      <title>Request the people#new form</title>

      <para>Wenn we request the <uri>http://0.0.0.0:3000/people/new</uri> URL
      the router answers the following route:<screen>new_person GET    /people/new(.:format)      people#new</screen></para>

      <para>The controller
      <filename>app/controllers/people_controller.rb</filename> runs this
      code:<programlisting># GET /people/new                                                             
def new
  @person = Person.new
end</programlisting></para>

      <para>So a new Instance of Person is created and stored in the instance
      variable <varname>@person</varname>.</para>

      <para>Rails takes <varname>@person</varname> and starts processing the
      view file
      <filename>app/views/people/new.html.erb</filename><programlisting>&lt;h1&gt;New person&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', people_path %&gt;</programlisting></para>

      <para><code>render 'form'</code> renders the file
      <filename>app/views/people/_form.html.erb</filename><programlisting>&lt;%= form_for(@person) do |f| %&gt;
  [...]
    &lt;%= f.text_field :first_name %&gt;
  [...]
    &lt;%= f.text_field :last_name %&gt;
  [...]
    &lt;%= f.submit %&gt;
  [...]
&lt;% end %&gt;</programlisting></para>

      <para><code>form_for(@person)</code> embeddeds the two text_fields
      <code>:first_name</code> and <code>:last_name</code> plus a
      <code>submit</code> Button. </para>

      <para>The resulting HTML:<programlisting>[...]
&lt;form accept-charset="UTF-8" action="/people" class="new_person" id="new_person" method="post"&gt;
  [...]
    &lt;input id="person_first_name" name="person[first_name]" type="text" /&gt;
  [...]
    &lt;input id="person_last_name" name="person[last_name]" type="text" /&gt;
  [...]
    &lt;input name="commit" type="submit" value="Create Person" /&gt;
  [...]
&lt;/form&gt;
[...]</programlisting></para>

      <para>This form uses the <code>post</code> method to upload the data to
      the server.</para>
    </section>

    <section>
      <title>Push the Data to the Server</title>

      <para>We enter 'Stefan' in the <code>first_name</code> field and
      'Wintermeyer' in the <code>last_name</code> field and click the submit
      button. The browser uses the post method to uploads the data to the URL
      <uri>/people</uri>. The log shows:<screen>Started POST "/people" for 127.0.0.1 at 2013-07-20 10:14:02 +0200
Processing by PeopleController#create as HTML
  Parameters: {"utf8"=&gt;"âœ“", "authenticity_token"=&gt;"cIZ+XFBx75mnXb6WiVv4xj6S88ahPjwVedDg1YgGuJs=", "person"=&gt;{"first_name"=&gt;"Stefan", "last_name"=&gt;"Wintermeyer"}, "commit"=&gt;"Create Person"}
   (0.1ms)  begin transaction
  SQL (4.6ms)  INSERT INTO "people" ("created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Sat, 20 Jul 2013 08:14:02 UTC +00:00], ["first_name", "Stefan"], ["last_name", "Wintermeyer"], ["updated_at", Sat, 20 Jul 2013 08:14:02 UTC +00:00]]
   (0.9ms)  commit transaction
Redirected to http://0.0.0.0:3000/people/1
Completed 302 Found in 10ms (ActiveRecord: 5.5ms)</screen></para>

      <para>What happend in Rails?</para>

      <para>The router answers the request with this route<programlisting>POST   /people(.:format)          people#create</programlisting></para>

      <para>The controller
      <filename>app/controllers/people_controller.rb</filename> runs this
      code<programlisting># POST /people
# POST /people.json
def create
  @person = Person.new(person_params)
  [...]
    if @person.save
      format.html { redirect_to @person, notice: 'Person was successfully created.' }
    [...]
    end
  end
end
[...]

# Never trust parameters from the scary internet, only allow the white list through.
def person_params
  params.require(:person).permit(:first_name, :last_name)
end</programlisting></para>

      <para>A new instance variable <code>@person</code> is created. It
      represense a new Person which was created with the params that were send
      from the browser to the Rails application. The params are checked in the
      person_params method which is a whitelist. That is done so the user can
      not just inject params which we don't want to be injected.</para>

      <para>Once <varname>@person</varname> is saved a <code>redirect_to
      @person</code> is triggered. That would be
      <uri>http://0.0.0.0:3000/people/1</uri> in this example.</para>
    </section>

    <section>
      <title>Present the new Data</title>

      <para>The redirect to <uri>http://0.0.0.0:3000/people/1</uri> is
      traceable in the log file<screen>Started GET "/people/1" for 127.0.0.1 at 2013-07-20 10:14:02 +0200
Processing by PeopleController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Person Load (0.2ms)  SELECT "people".* FROM "people" WHERE "people"."id" = ? LIMIT 1  [["id", "1"]]
  Rendered people/show.html.erb within layouts/application (1.1ms)
Completed 200 OK in 9ms (Views: 5.3ms | ActiveRecord: 0.2ms)</screen></para>

      <para>The router answers to this request with<screen>person GET    /people/:id(.:format)      people#show</screen></para>

      <para>Which gets handled be the show method in
      <filename>app/controllers/people_controller.rb</filename></para>
    </section>
  </section>

  <section>
    <title>Generic Forms</title>

    <para>A form doesn't have to be hardwired to an ActiveRecord object. You
    can use the <code>form_tag</code> helper to create a form by youself. I
    use the example of <uri>http://guides.rubyonrails.org/form_helpers.html
    </uri>(which is the official Rails guide about forms) to show how to
    create a search form which is not connected to a model:<programlisting>&lt;%= form_tag("/search", method: "get") do %&gt;
  &lt;%= label_tag(:q, "Search for:") %&gt;
  &lt;%= text_field_tag(:q) %&gt;
  &lt;%= submit_tag("Search") %&gt;
&lt;% end %&gt;</programlisting></para>

    <para>It results in this HTML code:<programlisting>&lt;form accept-charset="UTF-8" action="/search" method="get"&gt;
  &lt;label for="q"&gt;Search for:&lt;/label&gt;
  &lt;input id="q" name="q" type="text" /&gt;
  &lt;input name="commit" type="submit" value="Search" /&gt;
&lt;/form&gt;</programlisting></para>

    <para>To handle this you'd have to create a new route in
    <filename>config/routes.rb</filename> and write a method in a controller
    to handle it.</para>
  </section>

  <section>
    <title>FormTagHelper</title>

    <para>There is not just a helper for text fields. Have a look at the
    offical API documentation for all FormTagHelpers at
    <uri>http://api.rubyonrails.org/classes/ActionView/Helpers/FormTagHelper.html</uri>
    to get an overview. Because normaly we use Scaffold to create a form there
    is no need to memorize them. It is just important to know where to look in
    case you need something else.</para>
  </section>

  <section>
    <title>Alternatives</title>

    <para>Many Rails developer use Simple Form as an alternative to the
    standard way of defining forms. It is worth a try because you can really
    safe time and most of the times it is just easier. Simple Form is
    available as a Gem at
    <uri>https://github.com/plataformatec/simple_form</uri></para>
  </section>
</chapter>
