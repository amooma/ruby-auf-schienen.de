<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="scaffolding"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="scaffolding.title">Scaffolding and REST</title>

  <indexterm>
    <primary>scaffolding</primary>
  </indexterm>

  <indexterm>
    <primary>REST</primary>

    <secondary>Representational State Transfer</secondary>
  </indexterm>

  <indexterm>
    <primary>CRUD</primary>
  </indexterm>

  <section xml:id="scaffolding_einleitung">
    <title xml:id="scaffolding_einleitung.title">Introduction</title>

    <para>In this chapter, we will move on to scaffolding. I am going to show
    you a simple scaffold and you will then need to apply the previously
    gained knowledge on your own (in other words, work through the controller
    and the views).</para>

    <para>Scaffolding means purely and simply that a basic <foreignphrase
    xml:lang="en">scaffold</foreignphrase> for an application is created via a
    generator. This scaffold not only contains the <foreignphrase
    xml:lang="en">model</foreignphrase> but also a simple Web GUI
    (<foreignphrase xml:lang="en">views</foreignphrase>) and of course a
    <foreignphrase xml:lang="en">controller</foreignphrase>. The programming
    paradigm used for this is REST (Representational State Transfer).</para>

    <para>You can find a definition of REST at <uri
    xlink:href="http://de.wikipedia.org/wiki/Representational_State_Transfer">http://en.wikipedia.org/wiki/Representational_state_transfer</uri>.
    My super short version: the inventor Roy Fielding described in 2000 how
    you can access data with a simple set of rules within the concept of CRUD
    (see <uri
    xlink:href="http://de.wikipedia.org/wiki/CRUD">http://en.wikipedia.org/wiki/Create,_read,_update_and_delete</uri>)
    and the specification of the Hypertext Transfer Protocol (HTTP). CRUD is
    the abbreviation for Create (SQL: INSERT), Read (SQL: SELECT), Update
    (SQL: UPDATE) and Delete (SQL: Delete). This created URLs that are easy to
    read for humans and have a certain logic. In this chapter, you will see
    examples showing the individual paths for the different CRUD
    functions.</para>

    <para>I think the greatest frustration with Rail arises regularly from the
    fact that many beginners use scaffolding to get quick results without
    having proper basic knowledge of Ruby and without knowing what
    ActiveRecord is. But then they don't know what to do next. Fortunately,
    you have worked your way through <xref linkend="ruby-grundlagen"/>, <xref
    linkend="erste_schritte_mit_rails"/> and <xref
    linkend="activerecord_chapter"/>, so you will be able to understand and
    use scaffolding straight away.</para>

    <note>
      <para>This chapter is only an introduction to scaffolding, not an
      encyclopedia that covers all variations. Our focus is on the basic idea
      and on getting beginners started. The same applies to REST.</para>
    </note>
  </section>

  <section xml:id="scaffold_anlegen">
    <title>Generating a Scaffold</title>

    <indexterm>
      <primary>scaffolding</primary>

      <secondary>Rails 3.2</secondary>
    </indexterm>

    <para>Let's first use scaffolding to create a list of German federal
    chancellors. First, we need to create a new Rails application:<screen>MacBook:~ xyz$ <command>rails new history </command>
[...]
MacBook:~ xyz$ <command>cd history</command> 
MacBook:history xyz$</screen></para>

    <para>Let's look at the scaffolding options:<screen>MacBook:history xyz$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field[:type][:index] field[:type][:index]] [options]

Options:
      [--skip-namespace]                        # Skip namespace (affects only isolated applications)
      [--old-style-hash]                        # Force using old style hash (:foo =&gt; 'bar') on Ruby &gt;= 1.9
  -o, --orm=NAME                                # Orm to be invoked
                                                # Default: active_record
      [--force-plural]                          # Forces the use of a plural ModelName
  -y, [--stylesheets]                           # Generate Stylesheets
                                                # Default: true
  -se, [--stylesheet-engine=STYLESHEET_ENGINE]  # Engine for Stylesheets
                                                # Default: scss
  -c, --scaffold-controller=NAME                # Scaffold controller to be invoked
                                                # Default: scaffold_controller
      [--assets]                                # Indicates when to generate assets
                                                # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
      [--indexes]              # Add indexes for references and belongs_to columns
                               # Default: true
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attributes are field arguments specifying the model's attributes. You can
    optionally pass the type and an index to each field. For instance:
    "title body:text tracking_id:integer:uniq" will generate a title field of
    string type, a body with text type and a tracking_id as an integer with an
    unique index. "index" could also be given instead of "uniq" if one desires
    a non unique index.

    Timestamps are added by default, so you don't have to specify them by hand
    as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title body:text published:boolean' gives
    you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a resources :posts declaration
    in config/routes.rb.

    If you want to remove all the generated files, run
    'rails destroy scaffold ModelName'.

Examples:
    `rails generate scaffold post`
    `rails generate scaffold post title body:text published:boolean`
    `rails generate scaffold purchase amount:decimal tracking_id:integer:uniq`
MacBook:history xyz$</screen></para>

    <para>I'll keep it short: for our current state of knowledge, we can use
    <command>rails generate scaffold</command> just like <command>rails
    generate model</command> (see <xref
    linkend="activerecord_datenbank_anlegen"/>). Let's now create the scaffold
    for the chancellors:<screen>MacBook:history xyz$ <command>rails generate scaffold chancellor first_name last_name birthday:date day_of_death:date inauguration:date</command>
      invoke  active_record
      create    db/migrate/20120508171951_create_chancellors.rb
      create    app/models/chancellor.rb
      invoke    test_unit
      create      test/unit/chancellor_test.rb
      create      test/fixtures/chancellors.yml
       route  resources :chancellors
      invoke  scaffold_controller
      create    app/controllers/chancellors_controller.rb
      invoke    erb
      create      app/views/chancellors
      create      app/views/chancellors/index.html.erb
      create      app/views/chancellors/edit.html.erb
      create      app/views/chancellors/show.html.erb
      create      app/views/chancellors/new.html.erb
      create      app/views/chancellors/_form.html.erb
      invoke    test_unit
      create      test/functional/chancellors_controller_test.rb
      invoke    helper
      create      app/helpers/chancellors_helper.rb
      invoke      test_unit
      create        test/unit/helpers/chancellors_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/chancellors.js.coffee
      invoke    scss
      create      app/assets/stylesheets/chancellors.css.scss
      invoke  scss
      create    app/assets/stylesheets/scaffolds.css.scss
MacBook:history xyz$</screen></para>
  </section>

  <section xml:id="scaffold_migrate_und_seed">
    <title>Creating the Database with Sample Data</title>

    <para>As you can see, <command>rails generate scaffold</command> has
    already created the model. So we can directly call <command>rake
    db:migrate</command>:<screen>MacBook:history xyz$ <command>rake db:migrate</command>
==  CreateChancellors: migrating ==============================================
-- create_table(:chancellors)
   -&gt; 0.0018s
==  CreateChancellors: migrated (0.0019s) =====================================

MacBook:history xyz$</screen></para>

    <para>Let's create the first six chancellors in the
    <filename>db/seeds.rb</filename>. I am not quite sure about Walter Scheel,
    but after all, this book is all about Rails, not German post-war
    history.<programlisting>Chancellor.create(:first_name =&gt; 'Konrad', :last_name =&gt; 'Adenauer', :birthday =&gt; '05.01.1876', :day_of_death =&gt; '19.04.1967', :inauguration =&gt; '15.09.1949')
Chancellor.create(:first_name =&gt; 'Ludwig', :last_name =&gt; 'Erhard', :birthday =&gt; '04.02.1897', :day_of_death =&gt; '05.05.1977', :inauguration =&gt; '16.10.1963')
Chancellor.create(:first_name =&gt; 'Kurt Georg', :last_name =&gt; 'Kiesinger', :birthday =&gt; '06.04.1904', :day_of_death =&gt; '09.03.1988', :inauguration =&gt; '01.12.1966')
Chancellor.create(:first_name =&gt; 'Willy', :last_name =&gt; 'Brandt', :birthday =&gt; '18.12.1913', :day_of_death =&gt; '08.10.1992', :inauguration =&gt; '21.10.1969')
Chancellor.create(:first_name =&gt; 'Walter', :last_name =&gt; 'Scheel', :birthday =&gt; '08.09.1919', :inauguration =&gt; '07.05.1974')
Chancellor.create(:first_name =&gt; 'Helmut', :last_name =&gt; 'Schmidt', :birthday =&gt; '23.12.1918', :inauguration =&gt; '16.05.1974')</programlisting></para>

    <para>Populate with the example data:<screen>MacBook:history xyz$ <command>rake db:seed</command>
MacBook:history xyz$ </screen></para>
  </section>

  <section xml:id="scaffold_routen">
    <title>The Routes</title>

    <para><command>rails generate scaffold</command> has created a route (more
    on this later in <xref linkend="routes"/>), a controller and several views
    for us (see <xref linkend="dynamische_webseiten"/>). We could also have
    done all of this manually. Scaffolding is merely an automatism that does
    the work for us for some basic things. This is assuming that you always
    want to view, create and delete records.</para>

    <para>Without diving too deeply into the topic routes, let's just have a
    quick look at the available routes for our example. You need to enter
    <command>rake routes</command>:<screen>MacBook:history xyz$ <command>rake routes</command>
    chancellors GET    /chancellors(.:format)          chancellors#index
                POST   /chancellors(.:format)          chancellors#create
 new_chancellor GET    /chancellors/new(.:format)      chancellors#new
edit_chancellor GET    /chancellors/:id/edit(.:format) chancellors#edit
     chancellor GET    /chancellors/:id(.:format)      chancellors#show
                PUT    /chancellors/:id(.:format)      chancellors#update
                DELETE /chancellors/:id(.:format)      chancellors#destroy
MacBook:history xyz$</screen></para>

    <para>These are all the routes and consequently URLs available in this
    Rails application. All routes invoke actions (in other words, methods) in
    the <classname>ChancellorsController</classname>.</para>
  </section>

  <section xml:id="scaffold_controller">
    <title>The Controller</title>

    <para>Now it's about time we had a look at the file
    <filename>app/controllers/chancellors_controller.rb</filename>. Scaffold
    automatically creates the methods <methodname>index</methodname>,
    <methodname>show</methodname>, <methodname>new</methodname>,
    <methodname>create</methodname>, <methodname>update</methodname> and
    <methodname>destroy</methodname>. These methods or actions are called by
    the routes.</para>

    <para>Before we go any further: you do not need to work your way through
    the controller line by line. What is important is that you know where the
    file is and that the individual methods for the calls by the routes are
    located there. Then you can go back later and look it up there if anything
    is unclear.<programlisting>class ChancellorsController &lt; ApplicationController
  # GET /chancellors
  # GET /chancellors.json
  def index
    @chancellors = Chancellor.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @chancellors }
    end
  end

  # GET /chancellors/1
  # GET /chancellors/1.json
  def show
    @chancellor = Chancellor.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.json { render json: @chancellor }
    end
  end

  # GET /chancellors/new
  # GET /chancellors/new.json
  def new
    @chancellor = Chancellor.new

    respond_to do |format|
      format.html # new.html.erb
      format.json { render json: @chancellor }
    end
  end

  # GET /chancellors/1/edit
  def edit
    @chancellor = Chancellor.find(params[:id])
  end

  # POST /chancellors
  # POST /chancellors.json
  def create
    @chancellor = Chancellor.new(params[:chancellor])

    respond_to do |format|
      if @chancellor.save
        format.html { redirect_to @chancellor, notice: 'Chancellor was successfully created.' }
        format.json { render json: @chancellor, status: :created, location: @chancellor }
      else
        format.html { render action: "new" }
        format.json { render json: @chancellor.errors, status: :unprocessable_entity }
      end
    end
  end

  # PUT /chancellors/1
  # PUT /chancellors/1.json
  def update
    @chancellor = Chancellor.find(params[:id])

    respond_to do |format|
      if @chancellor.update_attributes(params[:chancellor])
        format.html { redirect_to @chancellor, notice: 'Chancellor was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: "edit" }
        format.json { render json: @chancellor.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /chancellors/1
  # DELETE /chancellors/1.json
  def destroy
    @chancellor = Chancellor.find(params[:id])
    @chancellor.destroy

    respond_to do |format|
      format.html { redirect_to chancellors_url }
      format.json { head :no_content }
    end
  end
end
</programlisting></para>
  </section>

  <section xml:id="scaffold_views">
    <title>The Views</title>

    <para>Now we start the Rails web server:<screen>MacBook:history xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.3 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-05-08 19:26:14] INFO  WEBrick 1.3.1
[2012-05-08 19:26:14] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.3.0]
[2012-05-08 19:26:14] INFO  WEBrick::HTTPServer#start: pid=43118 port=3000</screen></para>

    <note>
      <para>If you get a warning from your built-in firewall now, this shows
      that you have not read <xref linkend="erste_schritte_mit_rails"/>
      properly. ;-)</para>
    </note>

    <para>Now a little drum roll... dramatic suspense... launch the web
    browser and go to the URL <uri
    xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>.
    You can see the list of chancellors as simple web page.<screenshot>
        <info>
          <title>Index of Listed Chancellors</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_index.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>If you now click the link "New Chancellor", you will see an input
    form for a new record:<screenshot>
        <info>
          <title>Input Form for New Record</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_new.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Use your browser's Back button to go back and click on the "Show"
    link in the line for Konrad Adenauer. You will then see the following
    page:<screenshot>
        <info>
          <title>Viewing an Individual Record</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_show.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>If you now click "Edit", you will see the editing view for this
    record:<screenshot>
        <info>
          <title>Editing Form for an Existing Record</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_edit.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>And if you click "Destroy" on the Index page, you can delete a
    record after confirming the message that pops up. Isn't that cool?! Within
    less than 10 minutes, you have written a Web application that allows you
    to <emphasis role="bold">c</emphasis>reate, <emphasis
    role="bold">r</emphasis>ead/<emphasis role="bold">r</emphasis>etrieve,
    <emphasis role="bold">u</emphasis>pdate and <emphasis
    role="bold">d</emphasis>elete/<emphasis role="bold">d</emphasis>estroy
    records (CRUD)<indexterm>
        <primary>CRUD</primary>
      </indexterm>. That is the scaffolding magic.</para>

    <section xml:id="scaffold_wo_liegen_die_views">
      <title>Where Are the Views?</title>

      <para>You can probably guess, but let's have a look at the directory
      <filename>app/views/chancellors</filename> anyway:<screen>MacBook:history xyz$ <command>ls app/views/chancellors</command> 
_form.html.erb
edit.html.erb
index.html.erb
new.html.erb
show.html.erb
MacBook:history xyz$</screen></para>

      <para>For <methodname>index</methodname>, <methodname>edit</methodname>,
      <methodname>new</methodname> and <methodname>show</methodname> the
      corresponding views are located there. As <methodname>new</methodname>
      and <methodname>edit</methodname> both require a form for editing the
      data, this is stored in the partial <filename>_form.html.erb</filename>
      (see <xref linkend="partials"/>) in accordance with the principle of DRY
      (<emphasis role="bold">D</emphasis>on't <emphasis
      role="bold">R</emphasis>epeat <emphasis role="bold">Y</emphasis>ourself)
      and integrated in <filename>new.html.erb</filename> and
      <filename>edit.html.erb</filename> with a <code>&lt;%= render 'form'
      %&gt;</code>.</para>

      <para>Let's open the file
      <filename>app/views/chancellors/index.html.erb</filename>:<programlisting>&lt;h1&gt;Listing chancellors&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;First name&lt;/th&gt;
    &lt;th&gt;Last name&lt;/th&gt;
    &lt;th&gt;Birthday&lt;/th&gt;
    &lt;th&gt;Day of death&lt;/th&gt;
    &lt;th&gt;Inauguration&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @chancellors.each do |chancellor| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= chancellor.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.birthday %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_chancellor_path(chancellor) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', chancellor, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Chancellor', new_chancellor_path %&gt;
</programlisting></para>

      <para>You are now an old hand when it comes to ERB, so you'll be able to
      read and understand the code without any problems. If in doubt, have a
      quick look at <xref linkend="erb-programmieren"/>.</para>
    </section>

    <section xml:id="link_to">
      <title xml:id="link_to.title">link_to</title>

      <indexterm>
        <primary>link_to</primary>
      </indexterm>

      <para>In the views generated by the scaffold generator, you first came
      across the helper <code>link_to</code>. This creates <code>&lt;a href
      ...&gt;</code> links. You can of course also enter a link manually via
      <code>&lt;a href="..."&gt;</code> in the erb, but for links within a
      Rails project, <code>link_to</code> is more practical, because you can
      use the names of the routes as target. The code becomes much easier to
      read. In the above example, there are the following routes:<screen>MacBook:history xyz$ <command>rake routes</command>
    chancellors GET    /chancellors(.:format)          chancellors#index
                POST   /chancellors(.:format)          chancellors#create
 new_chancellor GET    /chancellors/new(.:format)      chancellors#new
edit_chancellor GET    /chancellors/:id/edit(.:format) chancellors#edit
     chancellor GET    /chancellors/:id(.:format)      chancellors#show
                PUT    /chancellors/:id(.:format)      chancellors#update
                DELETE /chancellors/:id(.:format)      chancellors#destroy
MacBook:history xyz$</screen></para>

      <para>The first part of this route is the name of the route. With a new
      call, this is <code>new_chancellor</code>. A link to
      <code>new_chancellor</code> looks like this in the erb code (you can see
      it at the end of the file
      <filename>app/views/chancellors/index.html.erb</filename>):<programlisting>&lt;%= link_to 'New Chancellor', new_chancellor_path %&gt;</programlisting></para>

      <para>In the HTML code of the generated page (<uri
      xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>)
      you can see the result:<programlisting>&lt;a href="/chancellors/new"&gt;New Chancellor&lt;/a&gt;</programlisting></para>

      <para>With <code>link_to</code> you can also link to resources within a
      RESTful resource. Again, you can find examples for this in
      <filename>app/views/chancellors/index.html.erb</filename>. In the table,
      a <code>show</code>, an <code>edit</code> and a <code>destroy</code>
      link is rendered for each <varname>chancellor</varname>:<programlisting>&lt;% @chancellors.each do |chancellor| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= chancellor.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.birthday %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
<emphasis>    &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_chancellor_path(chancellor) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', chancellor, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
</emphasis>  &lt;/tr&gt;
&lt;% end %&gt;</programlisting></para>

      <para>From the resource and the selected route, Rails automatically
      determines the required URL and the required HTTP verb (in other words,
      whether it is a POST, GET, PUT or DELETE). For index and show calls, you
      need to observe the difference between singular and plural.
      <code>link_to 'Show', chancellor</code> links to a single record and
      <code>link_to 'Show', chancellors_path</code> links to the index
      view.</para>

      <para>Whether the name of the route is used with or without the suffix
      <code>_path</code> in <code>link_to</code> depends on whether Rails can
      "derive" the route from the other specified information. If only one
      object is specified (in our example, the variable
      <varname>chancellor</varname>), then Rails automatically assumes that it
      is a show route.</para>

      <para>Examples:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><code>link_to 'Show', Chancellor.first</code></entry>

              <entry>Link to the first chancellor item.</entry>
            </row>

            <row>
              <entry><code>link_to 'New Chancellor',
              new_chancellor_path</code></entry>

              <entry>Link to the Web interface where a new item can be
              created.</entry>
            </row>

            <row>
              <entry><code>link_to 'Edit',
              edit_chancellor_path(Chancellor.first)</code></entry>

              <entry>Link to the form where the first chancellor item can be
              edited.</entry>
            </row>

            <row>
              <entry><code>link_to 'Destroy', Chancellor.first, method:
              :delete</code></entry>

              <entry>Link to deleting the first chancellor item.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id="form_for">
      <title xml:id="form_for.title">form_for</title>

      <indexterm>
        <primary>form_for</primary>
      </indexterm>

      <para>In the partial used by <code>new</code> and <code>edit</code>,
      <filename>app/views/chancellors/_form.html.erb</filename>, you will find
      the following code for the chancellor form:<programlisting>&lt;%= form_for(@chancellor) do |f| %&gt;
  &lt;% if @chancellor.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@chancellor.errors.count, "error") %&gt; prohibited this chancellor from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @chancellor.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= f.label :first_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :first_name %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :last_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :last_name %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :birthday %&gt;&lt;br /&gt;
    &lt;%= f.date_select :birthday %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :day_of_death %&gt;&lt;br /&gt;
    &lt;%= f.date_select :day_of_death %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :inauguration %&gt;&lt;br /&gt;
    &lt;%= f.date_select :inauguration %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</programlisting></para>

      <para>In a block, the helper <code>form_for</code> takes care of
      creating the HTML form via which the user can enter the data for the
      record or edit it. If you delete a <code>&lt;div
      class="field"&gt;</code> element here, this can no longer be used for
      input in the web interface. I am not going to comment on all possible
      form field variations at this point. The most frequently used ones will
      appear in examples later on and be explained then (if they are not
      self-explanatory).</para>

      <note>
        <para>You can find an overview of all form helpers at <uri
        xlink:href="http://guides.rubyonrails.org/form_helpers.html">http://guides.rubyonrails.org/form_helpers.html</uri></para>
      </note>

      <para>When using validations in the model, any validation errors that
      occur are displayed in the following code at the head of the
      form:<programlisting>  &lt;% if @chancellor.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@chancellor.errors.count, "error") %&gt; prohibited this chancellor from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @chancellor.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;</programlisting></para>

      <para>This kind of error would be spotted by the controller and be
      displayed on the web page via a flash message as follows.</para>

      <para><screenshot>
          <info>
            <title>Flash Error for a New Record</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/chancellor_error_flash.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>
    </section>

    <section xml:id="scaffold_json_und_xml">
      <title>Access via XML or JSON</title>

      <indexterm>
        <primary>web API</primary>

        <secondary>XML format</secondary>
      </indexterm>

      <indexterm>
        <primary>web API</primary>

        <secondary>JSON format</secondary>
      </indexterm>

      <indexterm>
        <primary>XML</primary>

        <see>web API</see>
      </indexterm>

      <indexterm>
        <primary>JSON</primary>

        <see>web API</see>
      </indexterm>

      <indexterm>
        <primary>API</primary>

        <see>web API</see>
      </indexterm>

      <para>By default, Rails' scaffolding generates not just access via HTML
      for "human" users, but also a direct interface for machines. The same
      methods <methodname>index</methodname>, <methodname>show</methodname>,
      <methodname>new</methodname>, <methodname>create</methodname>,
      <methodname>update</methodname> and <methodname>destroy</methodname> can
      be called via this interface, but in a format that is easier to read for
      machines. As an example, we will demonstrate the
      <methodname>index</methodname> action via which all data can be read in
      one go. With the same idea, data can be removed
      (<methodname>destroy</methodname>) or edited
      (<methodname>update</methodname>).</para>

      <para>Currently popular formats are XML (see <link
      xlink:href="http://de.wikipedia.org/wiki/Extensible_Markup_Language">http://en.wikipedia.org/wiki/Xml</link>)
      and JSON (see <link
      xlink:href="http://de.wikipedia.org/wiki/JavaScript_Object_Notation">http://en.wikipedia.org/wiki/Json</link>).</para>

      <para>If you do not require machine-readable access to data, you can
      skip these examples. But then you should also delete all lines with
      <code>format.xml</code> or <code>format.json</code> in the
      <code>respond_to</code> blocks of your controllers, to be on the safe
      side. Otherwise you still have an interface to the data that you may
      just forget and that constitutes a potential security gap.</para>

      <section xml:id="scaffold_json">
        <title xml:id="scaffold_json_default.title">JSON as Default</title>

        <indexterm>
          <primary>web API</primary>

          <secondary>JSON format</secondary>
        </indexterm>

        <para>Right at the beginning of
        <filename>app/controllers/chancellors_controller.rb</filename> you
        will find the entry for the <methodname>index</methodname>
        action:<programlisting>class ChancellorsController &lt; ApplicationController
<emphasis>  # GET /chancellors
  # GET /chancellors.json
  def index
    @chancellors = Chancellor.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @chancellors }
    end
  end
</emphasis><replaceable>[...]</replaceable></programlisting></para>

        <para>The code is straightforward. In the instance variable
        <varname>@chancellors</varname>, all chancellors are saved. Then
        something happens with a format. Hmmm… it says something about
        <code>json</code>. Let's try this: start the Rails server again with
        <command>rails server</command> and use your web browser to go to the
        URL <uri
        xlink:href="http://0.0.0.0:3000/chancellors.json">http://0.0.0.0:3000/chancellors.json</uri>.
        Heureka! You will see this:<screenshot>
            <info>
              <title>Index JSON View</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/chancellors_index_json.jpg"/>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>The URL <uri
        xlink:href="http://0.0.0.0:3000/chancellors.json">http://0.0.0.0:3000/chancellors.json</uri>
        gives us all chancellors in JSON format. In Rails 3.0, the default was
        still XML. But ultimately, it does not matter whether it's XML or
        JSON. The cool JavaScript programmers simply prefer JSON, and as an
        AJAX element can be found at every corner these days, it made sense to
        change the default from XML to JSON.</para>

        <para>If you do not want the JSON output, you need to delete this line
        in the
        <filename>app/controllers/chancellors_controller.rb</filename>.</para>
      </section>

      <section xml:id="scaffold_json_und_xml_zusammen">
        <title>JSON and XML Together</title>

        <para>If you ever need a JSON and XML interface in a Rails
        application, you just need to specify both variants in the controller
        in the block <code>respond_to</code>. Here is an example with the
        <filename>app/controllers/chancellors_controller.rb</filename> in the
        <methodname>index</methodname> action:<programlisting>class ChancellorsController &lt; ApplicationController
  # GET /chancellors
  # GET /chancellors.json
  def index
    @chancellors = Chancellor.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @chancellors }
      <emphasis>format.xml { render xml: @chancellors }</emphasis>
    end
  end
[...]</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="wann_sollte_man_scaffold_benutzen">
    <title>When Should You Use Scaffolding?</title>

    <para>You should never use scaffolding just for the sake of it. There are
    many Rails developers who never use scaffolding and always build
    everything manually. I find scaffolding quite useful for quickly getting
    into a new project. But it is always just the beginning.</para>

    <section xml:id="scaffold_minimal_beispiel_read_only">
      <title>Example for a Minimal Project</title>

      <para>Let's assume we need a web page quickly with which we can list
      chancellors and represent them individually. But we do not require an
      editing or deleting function. In that case, a large part of the code
      created via scaffold would be useless and have to be deleted. Let's try
      it out as follows:</para>

      <para><screen>MacBook:~ xyz$ <command>rails new history2</command>  
[...]
MacBook:~ xyz$ <command>cd history2</command>
MacBook:history2 xyz$ <command>rails generate scaffold chancellor first_name last_name birthday:date day_of_death:date inauguration:date</command>
[...]
MacBook:history2 xyz$ <command>rake db:migrate</command>
[...]
MacBook:history2 xyz$</screen></para>

      <para>Now create the <filename>db/seeds.rb</filename> with the first six
      chancellors:<programlisting>Chancellor.create(:first_name =&gt; 'Konrad', :last_name =&gt; 'Adenauer', :birthday =&gt; '05.01.1876', :day_of_death =&gt; '19.04.1967', :inauguration =&gt; '15.09.1949')
Chancellor.create(:first_name =&gt; 'Ludwig', :last_name =&gt; 'Erhard', :birthday =&gt; '04.02.1897', :day_of_death =&gt; '05.05.1977', :inauguration =&gt; '16.10.1963')
Chancellor.create(:first_name =&gt; 'Kurt Georg', :last_name =&gt; 'Kiesinger', :birthday =&gt; '06.04.1904', :day_of_death =&gt; '09.03.1988', :inauguration =&gt; '01.12.1966')
Chancellor.create(:first_name =&gt; 'Willy', :last_name =&gt; 'Brandt', :birthday =&gt; '18.12.1913', :day_of_death =&gt; '08.10.1992', :inauguration =&gt; '21.10.1969')
Chancellor.create(:first_name =&gt; 'Walter', :last_name =&gt; 'Scheel', :birthday =&gt; '08.09.1919', :inauguration =&gt; '07.05.1974')
Chancellor.create(:first_name =&gt; 'Helmut', :last_name =&gt; 'Schmidt', :birthday =&gt; '23.12.1918', :inauguration =&gt; '16.05.1974')</programlisting></para>

      <para>And populate it with this data:<screen>MacBook:history2 xyz$ <command>rake db:seed</command>
MacBook:history2 xyz$</screen></para>

      <para>As we only need <methodname>index</methodname> and
      <methodname>show</methodname>, we should delete the not required
      views:<screen>MacBook:history2 xyz$ <command>rm app/views/chancellors/_form.html.erb</command> 
MacBook:history2 xyz$ <command>rm app/views/chancellors/new.html.erb</command> 
MacBook:history2 xyz$ <command>rm app/views/chancellors/edit.html.erb</command> 
MacBook:history2 xyz$</screen></para>

      <para>The file
      <filename>app/controllers/chancellors_controller.rb</filename> can be
      simplified with an editor. It should look like this:<programlisting>class ChancellorsController &lt; ApplicationController
  # GET /chancellors
  def index
    @chancellors = Chancellor.all
  end

  # GET /chancellors/1
  def show
    @chancellor = Chancellor.find(params[:id])
  end
end</programlisting></para>

      <para>As we only need HTML and not JSON output, we can manage without
      the <code>respond_to do |format|</code> construct. Rails then
      automatically renders HTML.</para>

      <para>We only need the routes for <methodname>index</methodname> and
      <methodname>show</methodname>. Please open the file
      <filename>config/routes.rb</filename> and edit it as
      follows:<programlisting>History2::Application.routes.draw do
  resources :chancellors, :only =&gt; [ :index, :show ]
end</programlisting></para>

      <para>A <command>rake routes</command> shows us that really only
      <methodname>index</methodname> and <methodname>show</methodname> are
      routed now:<screen>MacBook:history2 xyz$ <command>rake routes</command>
chancellors GET /chancellors(.:format)     chancellors#index
 chancellor GET /chancellors/:id(.:format) chancellors#show
MacBook:history2 xyz$</screen></para>

      <para>If we now start the server <command>rails server</command> and go
      to the URL <uri
      xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>,
      we get an error message:<screen>MacBook:history2 xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.3 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-05-08 22:46:28] INFO  WEBrick 1.3.1
[2012-05-08 22:46:28] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.3.0]
[2012-05-08 22:46:28] INFO  WEBrick::HTTPServer#start: pid=43440 port=3000


Started GET "/chancellors" for 127.0.0.1 at 2012-05-08 22:46:41 +0200
Processing by ChancellorsController#index as HTML
  Chancellor Load (0.1ms)  SELECT "chancellors".* FROM "chancellors" 
  Rendered chancellors/index.html.erb within layouts/application (17.6ms)
Completed 500 Internal Server Error in 81ms

ActionView::Template::Error (undefined method `edit_chancellor_path' for #&lt;#&lt;Class:0x007fc9150437c0&gt;:0x007fc915047b18&gt;):
    20:     &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    21:     &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
    22:     &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
    23:     &lt;td&gt;&lt;%= link_to 'Edit', edit_chancellor_path(chancellor) %&gt;&lt;/td&gt;
    24:     &lt;td&gt;&lt;%= link_to 'Destroy', chancellor, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
    25:   &lt;/tr&gt;
    26: &lt;% end %&gt;
  app/views/chancellors/index.html.erb:23:in `block in _app_views_chancellors_index_html_erb__3473545449794762094_70250803843160'
  app/views/chancellors/index.html.erb:15:in `each'
  app/views/chancellors/index.html.erb:15:in `_app_views_chancellors_index_html_erb__3473545449794762094_70250803843160'


  Rendered /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/actionpack-3.2.3/lib/action_dispatch/middleware/templates/rescues/_trace.erb (27.7ms)
  Rendered /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/actionpack-3.2.3/lib/action_dispatch/middleware/templates/rescues/_request_and_response.erb (1.5ms)
  Rendered /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/actionpack-3.2.3/lib/action_dispatch/middleware/templates/rescues/template_error.erb within rescues/layout (40.6ms)
</screen></para>

      <para>The error message states that we call a method
      <methodname>edit_chancellor_path</methodname> in the view
      <filename>app/views/chancellors/index.html.erb</filename>. But as we
      only route <methodname>index</methodname> and
      <methodname>show</methodname> now, there are no more
      <methodname>edit</methodname>, <methodname>destroy</methodname> or
      <methodname>new</methodname> methods any more. So we need to adapt the
      file <filename>app/views/chancellors/index.html.erb</filename> in the
      editor as follows:<programlisting>&lt;h1&gt;Listing chancellors&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;First name&lt;/th&gt;
    &lt;th&gt;Last name&lt;/th&gt;
    &lt;th&gt;Birthday&lt;/th&gt;
    &lt;th&gt;Day of death&lt;/th&gt;
    &lt;th&gt;Inauguration&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @chancellors.each do |chancellor| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= chancellor.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.birthday %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</programlisting></para>

      <para>And while we are at it, we also edit the
      <filename>app/views/chancellors/show.html.erb</filename>
      accordingly:<programlisting>&lt;p&gt;
  &lt;b&gt;First name:&lt;/b&gt;
  &lt;%= @chancellor.first_name %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Last name:&lt;/b&gt;
  &lt;%= @chancellor.last_name %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Birthday:&lt;/b&gt;
  &lt;%= @chancellor.birthday %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Day of death:&lt;/b&gt;
  &lt;%= @chancellor.day_of_death %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Inauguration:&lt;/b&gt;
  &lt;%= @chancellor.inauguration %&gt;
&lt;/p&gt;</programlisting></para>

      <para>Now our application is finished. Start the Rails server with
      <command>rails server</command> and open the URL <uri
      xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>
      in the browser.</para>

      <note>
        <para>In this example, I am not commenting on the required changes in
        the tests, as this is not an exercise for test driven development but
        meant to demonstrate a way of working with scaffolding. TDD developers
        will quickly be able to adapt the tests.</para>
      </note>
    </section>

    <section xml:id="scaffold_fazit">
      <title>Conclusion</title>

      <para>Have a go and try it out. Try working with scaffolds one time and
      without them the next. Then you will soon get a feel for whether it fits
      into your working method or not. I find that scaffolding makes my work
      much easier for standard applications.</para>

      <para/>
    </section>
  </section>
</chapter>
