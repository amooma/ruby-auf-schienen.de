\documentclass[a4paper]{book}
\usepackage[
	%urlbordercolor = {1 1 1},
	%linkbordercolor = {1 1 1},
	%citebordercolor = {1 1 1},
	urlcolor = blue,
	colorlinks = true,
	citecolor = black,
	linkcolor = black]{hyperref}
\usepackage{graphicx}
\usepackage{xltxtra}
\usepackage{fancyhdr}
\usepackage{booktabs}
\usepackage{indentfirst}
\usepackage{framed,color}
\usepackage{caption}
\usepackage{longtable}
\captionsetup{font=bf,position=below}

\usepackage{ctable}

\definecolor{shadecolor}{gray}{0.90}

\setromanfont[Mapping=tex-text,BoldFont={* Bold}]{Helvetica}
\setmonofont[Scale=.85]{Andale Mono}

\XeTeXlinebreaklocale{en}


\settowidth{\parindent}{\qquad}

\title{Pro Git}
\author{Scott Chacon}

\makeatletter
\let\savedauthor=\@author
\let\savedtitle=\@title
\def\imgwidth{.6\linewidth}
\def\maxwidth{\ifdim\Gin@nat@width>\imgwidth\imgwidth
\else\Gin@nat@width\fi}
\makeatother

\title{\textbf{\savedtitle}}
\author{\textbf{\savedauthor}\thanks{This is the PDF file for the Pro Git book contents. It is licensed under the Creative Commons Attribution-Non Commercial-Share Alike 3.0 license. I hope you enjoy it, I hope it helps you learn Git, and I hope you'll support Apress and me by purchasing a print copy of the book at Amazon: \url{http://tinyurl.com/amazonprogit}}}
\def\w3cdtfymd{\the\year-\ifnum\month<10 0\fi\the\month-\ifnum\day<10 0\fi\the\day}
\date{\w3cdtfymd}
\renewcommand{\thefootnote}{\fnsymbol{footnote}}

\makeatletter
  \setlength\headheight{12\p@}
  \setlength\headsep   {.25in}
  \setlength\topskip   {10\p@}
  \setlength\footskip{.35in}
  \setlength\textwidth{400\p@}
  
  \setlength\@tempdima{\paperheight}
  \addtolength\@tempdima{-2in}
  \divide\@tempdima\baselineskip
  \@tempcnta=\@tempdima
  \setlength\textheight{\@tempcnta\baselineskip}
  \addtolength\textheight{\topskip}
  
  \setlength\@tempdima        {\paperwidth}
  \addtolength\@tempdima      {-\textwidth}
  \setlength\oddsidemargin    {\paperwidth}
  \addtolength\oddsidemargin  {-2.35in}
  \addtolength\oddsidemargin  {-\textwidth}
  \setlength\marginparwidth   {0pt}
  \@settopoint\oddsidemargin
  \@settopoint\marginparwidth
  \setlength\evensidemargin  {\paperwidth}
  \addtolength\evensidemargin{-2.35in}
  \addtolength\evensidemargin{-\textwidth}
  \@settopoint\evensidemargin
  
  \setlength\topmargin{\paperheight}
  \addtolength\topmargin{-2in}
  \addtolength\topmargin{-\headheight}
  \addtolength\topmargin{-\headsep}
  \addtolength\topmargin{-\textheight}
  \addtolength\topmargin{-\footskip}     % this might be wrong!
  \addtolength\topmargin{-.5\topmargin}
  \@settopoint\topmargin
\makeatother

\fancypagestyle{plain}{\fancyhf{}\fancyfoot[LE,RO]{\footnotesize\textbf\thepage}}
\pagestyle{plain}

\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrulewidth}{0pt}

\newcounter{img}[chapter]
\renewcommand{\theimg}{\thechapter.\arabic{img}}
\newcommand{\img}[1]{\begin{figure}[ht!]
	\refstepcounter{img}
	\label{img:\theimg}
	\centering\IfFileExists{figures/\theimg.pdf}{\includegraphics[width=\maxwidth]{figures/\theimg.pdf}}{\includegraphics[width=\maxwidth]{figures/\theimg.png}}

	\caption{#1}
\end{figure}}

\newcounter{tab}[chapter]
\renewcommand{\thetab}{\thechapter.\arabic{tab}}

\newcommand{\prechap}{Chapter }
\newcommand{\postchap}{}
\newcommand{\presect}{Section }
\newcommand{\postsect}{}
\renewcommand{\chaptermark}[1]{\markboth{\textbf{\prechap \thechapter \postchap}\hspace*{1ex}#1}{}}
\renewcommand{\sectionmark}[1]{\markright{\textbf{\presect \thesection \postsect}\hspace*{1ex}#1}}
\newcommand{\chap}[1]{\newpage\thispagestyle{empty}\chapter{#1}\label{chap:\thechapter}}
\newcommand{\chapref}[1]{\hyperref[chap:#1]{\prechap #1\postchap}}
\newcommand{\imgref}[1]{\hyperref[img:#1]{Figure #1}}
\newcommand{\tabref}[1]{\hyperref[tab:#1]{Table #1}}
\newcommand{\e}[1]{$ \times 10^{#1}$}
\renewcommand{\contentsname}{Contents}
\renewcommand{\figurename}{Figure }
\renewcommand{\tablename}{Table }

\makeatletter
\def\@makechapterhead#1{%
  \vspace*{50\p@}%
  {\parindent \z@ \raggedright \normalfont
    \ifnum \c@secnumdepth >\m@ne
      \if@mainmatter
        \huge\bfseries \prechap \thechapter \postchap
        \par\nobreak
        \vskip 20\p@
      \fi
    \fi
    \interlinepenalty\@M
    \Huge \bfseries #1\par\nobreak
    \vskip 40\p@
  }}
\makeatother

\linespread{1.3}

\begin{document}
\frontmatter
\maketitle
\thispagestyle{empty}
\setcounter{tocdepth}{4}
\tableofcontents\newpage\thispagestyle{empty}

\mainmatter
\fancyhf{}
\fancyhead[LE]{{\small\leftmark}}
\fancyhead[RO]{{\small\rightmark}}
\fancyhead[RE,LO]{{\small\savedauthor\hspace*{1ex}\textbf{\savedtitle}}}
\fancyfoot[LE,RO]{\small\textbf\thepage}
\pagestyle{fancy}

\chap{Preface}\label{preface}

Do not let people fool you into believing that Ruby on Rails is easly to learn. It is not! It is probably the best and most effective Framework to develop webapplications but it is hard to understand in the beginning. The worst mistake of all is to not learn Ruby before diving into Ruby on Rails. I made this one myself. This book starts with the basics of Ruby. You will not become a Ruby guru after reading it but you'll understand the basic ideas and that is important.

The book is written in a way that you can and actually should read it from the first to the last page. But is is also written like a cookbook with a lot of photos of the process. The photos are of course not photos but code examples. Anyhow each recipe works for it self. Once you understand the concept of cooking you don't have to start with the first recipe. You can dive into baking a cheesecake right away.

If you like this book: Please do me a favour and rate it on Amazon.com. Thank you!

Stefan Wintermeyer

\chap{Ruby on Rails Install How-to}\label{ruby-on-rails-install-how-to}

\section{Development System}\label{development-system}

This chapter's installation methods described are intended for development systems. If you are looking for instructions on installing a web server in the production system, please have a look at \hyperref[railsux5fproductionux5fwebserver]{Chapter~16, \emph{Web Server in Production Mode}}.

Both types of installation are very different.

\section{After the Installation?}\label{after-the-installation}

If you have never worked with Ruby before, you should first read \hyperref[ruby-grundlagen]{Chapter~2, \emph{Ruby Basics}}. If you are already a Ruby master and want to move on to Rails now, then I recommend reading \hyperref[ersteux5fschritteux5fmitux5frails]{Chapter~3, \emph{First Steps with Rails}}.

\section{Ruby on Rails 4.0 on Debian 7.1 (Wheeze)}\label{ruby-on-rails-4.0-on-debian-7.1-wheeze}

There are two main reasons for installing a Ruby on Rails system with RVM (Ruby Version Manager):

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  You simply do not have any root rights on the system. In that case, you have no other option.
\item
  You want to run several Rails systems that are separated cleanly, and perhaps also separate Ruby versions. This can be easily done with RVM on the Linux system. Then you can run Ruby 1.9.3 with Rails 3.2 and in parallel Ruby 2.0.0 with Rails 4.0 on the same computer.
\end{itemize}

\subsection{Note}\label{note}

Detailled information on RVM can be found on the RVM homepage at \texttt{https://rvm.io/}.

This description assumes that you have a freshly installed Debian GNU/Linux 7.1 (“Wheeze”). You will find an ISO image for the installation at \url{http://www.debian.org}\{.uri\}. I recommend the approximately 250 MB net installation CD image. For instructions on how to install Debian-GNU/Linux, please go to \url{http://www.debian.org/distrib/netinst}\{.uri\}.

\subsection{Preparations}\label{preparations}

If you have root rights on the target system, you can use the following commands to ensure that all required programs for a successful installation of RVM are available. If you do not have root rights, you have to either hope that your admin has already installed everything you need, or send them a quick e-mail with the corresponding lines.

First, an update of the package lists:

\begin{shaded}\begin{verbatim}
root@debian:~# aptitude update
[...]
root@debian:~#
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-1}

Of course, you can optionally install a SSH server on the system, so you can work on the system via SSH instead of on the console:

\begin{shaded}\begin{verbatim}
root@debian:~# aptitude -y install openssh-server
\end{verbatim}\end{shaded}

And now the installation of the packages required for the RVM installation:

\begin{shaded}\begin{verbatim}
root@debian:~# apt-get -y install gawk libgdbm-dev pkg-config libffi-dev build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion python
[...]
root@debian:~#
\end{verbatim}\end{shaded}

Now is a good time to log out as root:

\begin{shaded}\begin{verbatim}
root@debian:~# exit
Abgemeldet
\end{verbatim}\end{shaded}

\subsection{Installing Ruby 2.0.0 and Ruby on Rails 4.0 with RVM}\label{installing-ruby-2.0.0-and-ruby-on-rails-4.0-with-rvm}

Log in with your normal user account (in our case, it's the user \texttt{xyz}).

RVM, Ruby, and Ruby on Rails can be installed in various ways. I recommend using the following commands and get at least one cup of tea/coffee/favorite drink:

\begin{shaded}\begin{verbatim}
deployer@debian:~$ curl -L https://get.rvm.io | bash -s stable --rails
[...]
deployer@debian:~$ source /home/deployer/.rvm/scripts/rvm
[...]
deployer@debian:~$
\end{verbatim}\end{shaded}

RVM, Ruby 2.0.0 and Rails 4.0 are now fully installed.

\section{Ruby on Rails 4 on Windows}\label{ruby-on-rails-4-on-windows}

At \url{http://railsinstaller.org/}\{.uri\} there is a simple, all-inclusive Ruby on Rails installer for Windows for Ruby 2.0.0 and Rails 4.0. Optionally, you can also install SSH and Git.

\section{Ruby on Rails 4 on Mac OS X 10.7}\label{ruby-on-rails-4-on-mac-os-x-10.7}

Mac OS 10.7 includes Ruby version 1.8.7 as standard. Not interesting for our purposes. We want Ruby 2.0.0 and Rails 4.0. To avoid interfering with the existing Ruby and Rails installation and therefore the packet management of Mac OS X, we install Ruby 2.0.0 and Rails 4.0 with RVM (Ruby Version Manager).

With RVM, you can install and run any number of Ruby and Rails versions as normal user (without root rights and in your home directory). So you can work in parallel on old projects that may still use Ruby 1.9.3 and new projects that use Ruby 2.0.0.

\subsection{Note}\label{note-2}

Detailled information on RVM can be found at the RVM homepage at \texttt{https://rvm.io/}.

\subsection{Xcode Installation or Upgrade}\label{xcode-installation-or-upgrade}

Before you start installing Ruby on Rails, you must install the \emph{latest} Apple Xcode tools on your system. The easiest way is via the Mac App Store (search for “xcode”) or via the website \texttt{https://developer.apple.com/xcode/}. Please take care to install all the command line tools.

\subsection{Installing Ruby 2.0.0 and Ruby on Rails 4.0 with RVM}\label{installing-ruby-2.0.0-and-ruby-on-rails-4.0-with-rvm-1}

RVM can be installed in various ways. I recommend using the following monster command (please copy it exactly) that installs the latest RVM, Ruby and Ruby on Rails in your home directory:

\begin{shaded}\begin{verbatim}
$ curl -L https://get.rvm.io | bash -s stable --rails
[...]
$ source ~/.rvm/scripts/rvm
[...]
$
\end{verbatim}\end{shaded}

\chap{Ruby Introduction}\label{ruby-introduction}

This book requires basic knowledge of HTML, plus the reader - you, in other words - should also have a basic understanding of programming.

A couple of years ago I made the mistake of trying to understand Ruby on Rails without knowing anything about Ruby. Ruby just looked so simple, so I didn't give it another thought. But because I did not have a basic understanding of Ruby, I was not able to understand Rails properly. So I kept shunting it into a virtual corner and carried on working with PHP instead. One can only feel the magic of Rails after understanding the basics of Ruby.

The inventor of Ruby, Yukihiro Matsumoto, states in his book “\emph{The Ruby Programming Language}” that:

“It is easy to program in Ruby, but Ruby is not a simple language.”

This chapter is a tightrope walk between oversimplification and a degree of detail that is unnecessary for a Rails newbie. After all, the objective is not becoming a Ruby guru, but understanding Ruby on Rails. I am going to elaborate on the most important points. The rest is then up to you. If you would like to know more about Ruby, then I recommend the book “The Ruby Programming Language” by David Flanagan and Yukihiro Matsumoto.

Because Ruby version 2.0 is the way to go we use it. Please take care to update your current Ruby if you are running older versions. The command \textbf{ruby -v} will print the current running Ruby version:

\begin{shaded}\begin{verbatim}
$ ruby -v
ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin12.4.0]
$
\end{verbatim}\end{shaded}

\subsection{Warning}\label{warning}

The beginning of this chaper is going to be a bit boring. Bear with me. It is worth it.

\section{Hello World}\label{hello-world}

Ruby is a scripting language. So it is not compiled and then executed, but read by an interpreter and then processed line by line.

A simple Ruby program \texttt{hello-world.rb} consist of the following line:

\begin{shaded}\begin{verbatim}
puts 'Hello World!'
\end{verbatim}\end{shaded}

Use your favorite editor to open a new file with the filename \texttt{hello-world.rb} and insert the above line into it. You can then execute this Ruby program in the command line as follows:

\begin{shaded}\begin{verbatim}
$ ruby hello-world.rb
Hello World!
$
\end{verbatim}\end{shaded}

A program line in a Ruby program does not have to end with a semicolon. The Ruby interpreter is even so intelligent that is recognizes if a program line was split over two or more lines for the sake of readability. I will spare you the corresponding examples and am only mentioning this so you don't say or think later, “is it okay like this?”

Indenting code is also not necessary. But it does make it much easier to read for human beings!

\section{puts and print}\label{puts-and-print}

If you go looking for examples on Ruby on the Internet, you will find two typical ways of printing text on the screen:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{puts} Prints a string, followed by a newline.
\item
  \texttt{print} Prints a string (without newline). If the string itself contains a newline, this will be printed as normal.
\end{itemize}

Example program (an extension of the program \texttt{hello-world.rb}):

\begin{shaded}\begin{verbatim}
puts 'Hello World!'
puts
puts '------------'
print 'Hello World!'
print
puts '------------'
\end{verbatim}\end{shaded}

On the screen, you will see this:

\begin{shaded}\begin{verbatim}
$ ruby hello-world.rb
Hello World!

------------
Hello World!------------
$
\end{verbatim}\end{shaded}

\section{Comments}\label{comments}

A comment in a Ruby program starts with a \texttt{\#}-sign and ends with a newline. As an example, I can add a comment to the \texttt{hello-world.rb} above:

\begin{shaded}\begin{verbatim}
## Program for displaying "Hello World!"
## by Stefan Wintermeyer

puts 'Hello World!'
\end{verbatim}\end{shaded}

A comment can also follow a program line:

\begin{shaded}\begin{verbatim}
## Program for displaying "Hello World!"
## by Stefan Wintermeyer

puts 'Hello World!'  # output
\end{verbatim}\end{shaded}

A \texttt{\#}-sign within strings in inverted commas is not treated as the start of a comment. Example program:

\begin{shaded}\begin{verbatim}
## Example program
## by Stefan Wintermeyer

puts 'Hello World!'
puts '############'
puts
puts '1#2#3#4#5#6#'  # Comment on this
\end{verbatim}\end{shaded}

On the screen, you will see this:

\begin{shaded}\begin{verbatim}
$ ruby hello-world.rb
Hello World!
############

1#2#3#4#5#6#
$
\end{verbatim}\end{shaded}

\section{Help via ri}\label{help-via-ri}

When programming, you do not always have a Ruby handbook available. Fortunately, the Ruby developers thought of this and provided a built-in help feature in form of the program \texttt{ri} (of course only if you have installed the documentation). ri is the abbreviation for “\textbf{R}uby \textbf{I}ndex”. The output gets opend in a so called pager (z.B. \textbf{less}). The parameter \emph{\texttt{-T}} sets the output directly to stdout.

This is a typical chicken and egg situation. How can I explain the Ruby help feature, if we are only just getting started with Ruby? So I am going to jump ahead a little and show you how you can search for information on the class \texttt{String}:

\begin{shaded}\begin{verbatim}
$ ri String
String < Object

------------------------------------------------------------------------------
Includes:
Comparable (from ruby site)

(from ruby site)
------------------------------------------------------------------------------


Rake extension methods for String.

A String object holds and manipulates an arbitrary sequence of bytes,
typically representing characters. String objects may be created using
String::new or as literals.

Because of aliasing issues, users of strings should be aware of the methods
that modify the contents of a String object.  Typically, methods with
names ending in “!” modify their receiver, while those without a “!”
return a new String.  However, there are exceptions, such as
String#[]=.
------------------------------------------------------------------------------
[...]
$
\end{verbatim}\end{shaded}

If we are looking for information on a specific method (chicken-egg!), then we can also use \texttt{ri}. Let's take \texttt{gsub} as an example. This is a method for replacing parts of a \texttt{String} (that is useful now and again).

\begin{shaded}\begin{verbatim}
$ ri String.size
= String.size

(from ruby site)
------------------------------------------------------------------------------
  str.size     -> integer

------------------------------------------------------------------------------

Returns the character length of str.

$
\end{verbatim}\end{shaded}

The program \textbf{ri} always prints the output in the pager program defined by the shell (for example \textbf{less}). You can also use the command option \textbf{-T} to output everything directly to STDOUT. In the book I am going to be using both variations.

\hyperdef{}{irb}{\section{irb}\label{irb}}

irb stands for “\textbf{I}nteractive \textbf{R}u\textbf{b}y” and is a kind of sandbox where you can play around with Ruby at your leisure. irb is launched by entering \textbf{irb} on the shell and ends if you enter \textbf{exit}.

An example is worth a thousand words:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> puts 'Hello World!'
Hello World!
=> nil
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-3}

I use \textbf{irb --simple-prompt} to generate shorter lines which make it easier to read this book on mobile devises.

In this chapter, we develop many examples within irb. It is so wonderfully quick and easy.

\section{Comments in irb}\label{comments-in-irb}

Having comments within \texttt{irb} would obviously rarely make sense because code developed in \texttt{irb} is more or less code for the bin. But within this book, we occasionally use comments even in \texttt{irb} to make things clearer. You can copy these comments along with everything else and insert them into the \texttt{irb} without any problems, or you can simply omit them.

\section{Ruby is Object-Oriented}\label{ruby-is-object-oriented}

Ruby only knows objects. Everything is an object (sounds almost like Zen). Every object is an instance of a class. You can find out the class of an object via the method \texttt{.class}.

An object in Ruby is encapsulated and can only be reached from the outside via the methods of the corresponding object. What does this mean? I cannot change any property of an object directly from the outside. The corresponding object has to offer a method with which I can do so.

\subsection{Note}\label{note-4}

Please do not panic if you have no idea what a class and an object is. I won't tell anyone and you can still work with it just fine without worrying too much. This topic alone could fill whole volumes. Roughly speaking, an object is a container for something and a method changes something in that container.

Please go on reading and have a look at the examples. The puzzle will gradually get clearer.

\section{Methods}\label{methods}

In other programming languages, the terms you would use for Ruby methods would be: functions, procedures, subroutines and of course methods.

\subsection{Note}\label{note-5}

Here we go with the oversimplification. We can not compare non-Object oriented programming languages with OO onces. Plus there are two kinds of methods (class methods and instance methods). At this point, I do not want to make it too complicated and am simply ignoring this “fine” distinctions for now.

At this point you start looking for a good example, but all you can think of are silly ones. The problem is the premisse that we are only allowed to use knowledge that has already been described previously in this book.

So let's assume that we use the following code sequence repeatedly - for whatever reason:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> puts 'Hello World!'
Hello World!
=> nil
>> puts 'Hello World!'
Hello World!
=> nil
>> puts 'Hello World!'
Hello World!
=> nil
>> exit
$
\end{verbatim}\end{shaded}

So we want to output the string “Hello World!” three times in a row. As this makes our daily work routine much longer, we are now going to define a method (with the meaningless name \texttt{three\_times}), with which this can all be done in one go.

\subsection{Important}\label{important}

Names of methods are always written in lower case.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def three_times
>>   puts 'Hello World!'
>>   puts 'Hello World!'
>>   puts 'Hello World!'
>> end
=> nil
>> three_times
Hello World!
Hello World!
Hello World!
=> nil
>> exit
$
\end{verbatim}\end{shaded}

When defining a method, you can define required parameters and use them within the method. This enables us to create a method to which we pass a string as parameter and we can then output it three times.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def three_times(value)
>>   puts value
>>   puts value
>>   puts value
>> end
=> nil
>> three_times('Hello World!')
Hello World!
Hello World!
Hello World!
=> nil
>>
\end{verbatim}\end{shaded}

Incidentally, you can omit the brackets when calling the method.

\begin{shaded}\begin{verbatim}
>> three_times 'Hello World!'
Hello World!
Hello World!
Hello World!
=> nil
>>
\end{verbatim}\end{shaded}

\subsection{Tip}\label{tip}

Ruby gurus and would-be gurus are going to turn up their noses on the subject of “unnecessary” brackets in your programs and will probably pepper you with more or less stupid comments with comparisons to Java and other programming languages.

There is one simple rule in the Ruby community: the fewer brackets, the cooler you are! \texttt{;-)}

But you won't get a medal for using fewer brackets. Decide for yourself what makes you happy.

If you do not specify a parameter with the above method, you will get the error message: “\texttt{wrong number of arguments (0 for       1)}”:

\begin{shaded}\begin{verbatim}
>> three_times
ArgumentError: wrong number of arguments (0 for 1)
 from (irb):1:in `three_times'
 from (irb):7
 from /Users/xyz/.rvm/rubies/ruby-2.0.0-p247/bin/irb:16:in `<main>'
>> exit
$
\end{verbatim}\end{shaded}

You can give the variable \texttt{value} a default value and then you can also call the method without parameter:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def three_times(value = 'blue')
>>   puts value
>>   puts value
>>   puts value
>> end
=> nil
>> three_times('Hello World!')
Hello World!
Hello World!
Hello World!
=> nil
>> three_times
blue
blue
blue
=> nil
>> exit
$
\end{verbatim}\end{shaded}

\section{Classes}\label{classes}

A class is a collection of methods. The name of a class always starts with an upper case letter. Let's assume that the method belongs to the new class \texttt{This\_and\_that}. It would then be defined as follows in a Ruby program:

\begin{shaded}\begin{verbatim}
class This_and_that
  def three_times
    puts 'Hello World!'
    puts 'Hello World!'
    puts 'Hello World!'
  end
end
\end{verbatim}\end{shaded}

Let's play it through in \texttt{irb}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class This_and_that
>>   def three_times
>>     puts 'Hello World!'
>>     puts 'Hello World!'
>>     puts 'Hello World!'
>>   end
>> end
=> nil
>>
\end{verbatim}\end{shaded}

Now we try to call the method \texttt{three\_times}:

\begin{shaded}\begin{verbatim}
>> This_and_that.three_times
NoMethodError: undefined method `three_times' for This_and_that:Class
 from (irb):8
 from /Users/xyz/.rvm/rubies/ruby-2.0.0-p247/bin/irb:16:in `<main>'
>>
\end{verbatim}\end{shaded}

This results in an error message, because \texttt{This\_and\_that} is a class and not an instance. As we are working with instance methods, it only works if we have first created a new object (a new instance) of the class \texttt{This\_and\_that} with the class method \texttt{new}:

\begin{shaded}\begin{verbatim}
>> abc = This_and_that.new
=> #<This_and_that:0x007f819412c768>
>> abc.three_times
Hello World!
Hello World!
Hello World!
=> nil
>> exit
$
\end{verbatim}\end{shaded}

I will explain the difference between instance and class methods in more detail in \hyperref[classux5fmethodsux5fvsux5finstanceux5fmethods]{the section called “Class Methods and Instance Methods”}. Another chicken and egg problem.

\section{Private Methods}\label{private-methods}

Quite often it makes sense to only call a method within its own class or own instance. Such methods are referred to as private methods (as opposed to public methods), and they are listed below the keyword \texttt{private} within a class.

irb example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Example
>>   def a
>>     puts 'a'
>>   end
>>   private
>>   def b
>>     puts 'b'
>>   end
>> end
=> nil
>> test = Example.new
=> #<Example:0x007ff1e10756b8>
>> test.a
a
=> nil
>> test.b
NoMethodError: private method `b' called for #<Example:0x007ff1e10756b8>
 from (irb):12
 from /Users/xyz/.rvm/rubies/ruby-2.0.0-p247/bin/irb:16:in `<main>'
>> exit
$
\end{verbatim}\end{shaded}

\section{Method initialize()}\label{method-initialize}

If a new instance is created (by calling the method \texttt{new}), the method that is processed first and automatically is the method \texttt{initialize}. The method is automatically a private method, even if it not listed explicitly under \texttt{private}.

irb example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Room
>>   def initialize
>>     puts 'abc'
>>   end
>> end
=> nil
>> kitchen = Room.new
abc
=> #<Room:0x007faec50402d8>
>> exit
$
\end{verbatim}\end{shaded}

The instance \texttt{kitchen} is created with \texttt{Room.new} and the method \texttt{initialize} is processed automatically.

The method \texttt{new} accepts the parameters specified for the method \texttt{initialize}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Example
>>   def initialize(value)
>>     puts value
>>   end
>> end
=> nil
>> test = Example.new('Hello World!')
Hello World!
=> #<Example:0x007fa9f98ba240>
>> exit
$
\end{verbatim}\end{shaded}

\section{return}\label{return}

puts is nice to demonstrate an example in this book but normally you need a way to return the result of something. The \texttt{return} statement can be used for that:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def area_of_a_cirle(radius)
>>   pi = 3.14
>>   area = pi * radius * radius
>>   return area
>> end
=> nil
>> area_of_a_cirle(10)
=> 314.0
>> exit
$
\end{verbatim}\end{shaded}

But it wouldn't be Ruby if you couldn't do it shorter. You can simply skip return:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def area_of_a_cirle(radius)
>>   pi = 3.14
>>   area = pi * radius * radius
>>   area
>> end
=> nil
>> area_of_a_cirle(10)
=> 314.0
>> exit
$
\end{verbatim}\end{shaded}

You can actually even skip the last line because Ruby returns the value of the last expression as a default:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def area_of_a_cirle(radius)
>>   pi = 3.14
>>   area = pi * radius * radius
>> end
=> nil
>> area_of_a_cirle(10)
=> 314.0
>> exit
$
\end{verbatim}\end{shaded}

\texttt{return} is sometimes useful to make a method easier to read. But you don't have to use it in case you feel more comfortable with out.

\section{Inheritance}\label{inheritance}

A class can inherit from another class. When defining the class, the parent class must be added with a \texttt{\textless{}} (smaller than) sign:

\begin{shaded}\begin{verbatim}
class Example < ParentClass
\end{verbatim}\end{shaded}

Rails makes use of this approach very frequently (otherwise I would not be bothering you with it).

In the following example, we define the class \texttt{Abc} and which contains the methods \texttt{a}, \texttt{b} and \texttt{c}. Then we define a class \texttt{Abcd} and let it inherit the class \texttt{Abc} and add a new method \texttt{d}. The new instances \texttt{example1} and \texttt{example2} are created with the Class-Methods new and show that \texttt{example2} has access to the methods \texttt{a}, \texttt{b}, \texttt{c} and \texttt{d} but \texttt{example1} only to \texttt{a}, \texttt{b} and \texttt{c}.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Abc
>>   def a
>>     'a'
>>   end
>>   def b
>>     'b'
>>   end
>>   def c
>>     'c'
>>   end
>> end
=> nil
>> class Abcd < Abc
>>   def d
>>     'd'
>>   end
>> end
=> nil
>> example1 = Abc.new
=> #<Abc:0x007fb463023928>
>> example2 = Abcd.new
=> #<Abcd:0x007fb46302f020>
>> example2.d
=> "d"
>> example2.a
=> "a"
>> example1.d
NoMethodError: undefined method `d' for #<Abc:0x007fb463023928>
 from (irb):21
 from /Users/xyz/.rvm/rubies/ruby-2.0.0-p247/bin/irb:16:in `<main>'
>> example1.a
=> "a"
>> exit
$
\end{verbatim}\end{shaded}

\section{Tip}\label{tip-1}

It is important to read the Error-Messages. They tell you what happend and where to search for the problem. In this example Ruby said that there is an \texttt{undefined method `d' for             \#\textless{}Abc:0x007fb463023928\textgreater{}}. With that information you know that the Class Abc is missing the method d which you were trying to use.

\section{Class Methods and Instance Methods}\label{class-methods-and-instance-methods}

There are two important kinds of methods: class methods and instance methods.

You now already know what a class it. And an instance of such a class is created via the class method \texttt{new}. A class method can only be called in connection with the class (for example, the method \texttt{new} is a class method). An instance method is a method that only works with an instance. So you cannot apply the method \texttt{new} to an instance.

Let's first try to call an instance method as class method:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Knowledge
>>   def pi
>>     3.14
>>   end
>> end
=> nil
>> Knowledge.pi
NoMethodError: undefined method `pi' for Knowledge:Class
 from (irb):6
 from /Users/xyz/.rvm/rubies/ruby-2.0.0-p247/bin/irb:16:in `<main>'
>>
\end{verbatim}\end{shaded}

So that does not work. Well, then let's create a new instance of the class and try again:

\begin{shaded}\begin{verbatim}
>> example = Knowledge.new
=> #<Knowledge:0x007fd81b0866f0>
>> example.pi
=> 3.14
>> exit
$
\end{verbatim}\end{shaded}

Now we just need to find out how to define a class method. Hardcore Rails gurus would now whisk you away into the depths of the source code and pick out examples from the ActiveRecord. I will spare you this and show an abstract example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Knowledge
>>   def self.pi
>>     3.14
>>   end
>> end
=> nil
>> Knowledge.pi
=> 3.14
>>
\end{verbatim}\end{shaded}

And the proof to the contrary:

\begin{shaded}\begin{verbatim}
>> example = Knowledge.new
=> #<Knowledge:0x007fb339078d90>
>> example.pi
NoMethodError: undefined method `pi' for #<Knowledge:0x007fb339078d90>
 from (irb):8
 from /Users/xyz/.rvm/rubies/ruby-2.0.0-p247/bin/irb:16:in `<main>'
>> exit
$
\end{verbatim}\end{shaded}

There are different notations for defining class methods. The two most common ones are:

\begin{itemize}
\item
  \texttt{self.xyz}

\begin{shaded}\begin{verbatim}
# Variant 1
# with self.xyz
#
class Knowledge
  def self.pi
    3.14
  end
end
\end{verbatim}\end{shaded}
\item
  \texttt{class \textless{}\textless{} self}

\begin{shaded}\begin{verbatim}
# Variant 2
# with class << self
#
class Knowledge
  class << self
    def pi
      3.14
    end
  end
end
\end{verbatim}\end{shaded}
\end{itemize}

The result is always the same.

Of course you can use the same methodname for a class and an instance method. Obviously that doesn't make any code easier to understand. Here is an example with \texttt{pi} as a class and an instance method:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Knowledge
>>   def pi
>>     3.14
>>   end
>>   def self.pi
>>     3.14159265359
>>   end
>> end
=> nil
>> Knowledge.pi
=> 3.14159265359
>> example = Knowledge.new
=> #<Knowledge:0x007f8ccc8786a0>
>> example.pi
=> 3.14
>> exit
$
\end{verbatim}\end{shaded}

\section{List of All Instance Methods}\label{list-of-all-instance-methods}

You can read out all defined methods for a class with the method \texttt{instance\_methods}. We try it out with the class \texttt{This\_and\_that} (first we create it once again in the irb):

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Knowledge
>>   def pi
>>     3.14
>>   end
>> end
=> nil
>> Knowledge.instance_methods
=> [:pi, :nil?, :===, :=~, :!~, :eql?, :hash, :<=>, :class, :singleton_class, :clone, :dup, :initialize_dup, :initialize_clone, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :respond_to_missing?, :extend, :display, :method, :public_method, :define_singleton_method, :object_id, :to_enum, :enum_for, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__, :__id__]
>>
\end{verbatim}\end{shaded}

But that is much more than we have defined! Why? It's because Ruby gives every new class a basic set of methods by default. If we only want to list the methods that we have defined, then we can do it like this:

\begin{shaded}\begin{verbatim}
>> Knowledge.instance_methods(false)
=> [:pi]
>> exit
$
\end{verbatim}\end{shaded}

\section{Variables}\label{variables}

You already know that everything in Ruby is an object. So a variable must also be an object.

\section{Naming Conventions}\label{naming-conventions}

Normal variables are written in lower case. Constants start with an upper case letter.

\subsection{Important}\label{important-1}

A constant can also be overwritten with a new value in Ruby (but you will get a warning message). So please do not rely on the constancy of a constant.

You are on the safe side if you are using only ASCII symbols. But with Ruby 1.9 and the right encoding, you could also use special characters (for example German umlauts) more or less without any problems in a variable name. But if you want to be polite towards other programmers who probably do not have those characters directly available on their keyboards, it is better to use only pure ASCII.

\section{Strings}\label{strings}

Let's experiment a little bit in the \texttt{irb}. The method \texttt{.class} tells us which class we are dealing with.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 'First test'
=> "First test"
>> a.class
=> String
\end{verbatim}\end{shaded}

That was easy. As you can see, Ruby “automagically” creates an object of the class \texttt{String}. We could also do this by explicitly calling the method \texttt{new}:

\begin{shaded}\begin{verbatim}
>> b = String.new('Second test')
=> "Second test"
>> b.class
=> String
\end{verbatim}\end{shaded}

If we call \texttt{String.new} without a parameter, this also creates an object of the class \texttt{String}. But it is an empty String:

\begin{shaded}\begin{verbatim}
>> c = String.new
=> ""
>> c.class
=> String
>> exit
$
\end{verbatim}\end{shaded}

\section{Single and Double Quotations Marks}\label{single-and-double-quotations-marks}

\section{Note}\label{note-6}

Please note: if we mention single or double quotation marks in the context of strings, we do not mean typographically correct curly quotation marks (see \url{http://en.wikipedia.org/wiki/Quotation_mark}\{.uri\}), but the ASCII symbols referred to as \emph{apostrophe} (\texttt{'}) or \emph{quotation mark} (\texttt{"}).

Strings can be defined either in single quotes or double quotes. There is a special feature for the double quotes: you can integrate expressions with the construct \texttt{\#\{\}}. The result is then automatically inserted in the corresponding place in the string.

Example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 'blue'
=> "blue"
>> b = "Color: #{a}"
=> "Color: blue"
>> b.class
=> String
>> exit
$
\end{verbatim}\end{shaded}

If the result of the expression is not a string, Ruby tries to apply the method \texttt{to\_s} in order to convert the value of the object into a string.

\section{Integers}\label{integers}

\section{Fixnum and Bignum}\label{fixnum-and-bignum}

\texttt{Fixnum} and \texttt{Bignum} are \texttt{Integer} classes. A \texttt{Fixnum} is an \texttt{Integer} that can be saved in a “Word”. If a \texttt{Fixnum} gets bigger, it automatically becomes a \texttt{Bignum}. Here is an example where a becomes larger and by that becomes a \texttt{Bignum}.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 20.class
=> Fixnum
>> a = 20
=> 20
>> a.class
=> Fixnum
>> a = a * 5555555555
=> 111111111100
>> a.class
=> Fixnum
>> a = a * 5555555555
=> 617283950493827160500
>> a.class
=> Bignum
>> exit
$
\end{verbatim}\end{shaded}

\section{Floats}\label{floats}

\texttt{Float} is a class for real numbers (“floating point numbers”). The decimal separator is a point (not a comma, as in some European countries).

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 20.424
=> 20.424
>> a.class
=> Float
>> 42.2.class
=> Float
>> exit
$
\end{verbatim}\end{shaded}

\section{Simple Calculations}\label{simple-calculations}

Calculating with integers and floats is so easy that you can describe everything with just a few lines of code in the \texttt{irb}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 10
=> 10
>> b = 23
=> 23
>> a + b
=> 33
>> (a + b).class
=> Fixnum
>> c = a + b
=> 33
>> c.class
=> Fixnum
>> d = 3.14
=> 3.14
>> e = a + d
=> 13.14
>> e.class
=> Float
>> a * b
=> 230
>> (a * b).class
=> Fixnum
>> (a * b * d).class
=> Float
>> exit
$
\end{verbatim}\end{shaded}

\section{Boolean Values and nil}\label{boolean-values-and-nil}

For boolean values (\texttt{true} and \texttt{false}) and for \texttt{nil} (no value) there are separate classes:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> true.class
=> TrueClass
>> false.class
=> FalseClass
>> nil.class
=> NilClass
>> exit
$
\end{verbatim}\end{shaded}

\texttt{nil} (no value) is, by the way, the contraction of the Latin word \emph{nihil} (nothing) or, if you look at it in terms of programming history, the term derives from “\emph{not in list}” from the legacy of the programming language Lisp (the name is an acronym of \emph{List Processing}).

\section{Scope of Variables}\label{scope-of-variables}

Variables have a different scope (or “reach”) within the Ruby application and therefore also within a Ruby on Rails application.

\subsection{Important}\label{important-2}

You need to keep this scope in mind while programming. Otherwise you can end up with odd effects.

\section{Local Variables (aaa or \_aaa)}\label{local-variables-aaa-or-ux5faaa}

Local variables either start with a lower case letter or an underscore (\texttt{\_}). Their scope is limited to the current environment (for example the current method). The follwing example defines two methods which use the same local variable radius. Because they are local they don't interact with each other:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> def area(radius)
>>   3.14 * radius * radius
>> end
=> nil
>> def circumference(radius)
>>   2 * 3.14 * radius
>> end
=> nil
>> area(10)
=> 314.0
>> circumference(1)
=> 6.28
>> exit
$
\end{verbatim}\end{shaded}

\section{Global Variables (\$aaa)}\label{global-variables-aaa}

A global variable starts with a \texttt{\$}-sign and is accessible in the entire programm. Example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> $value = 10
=> 10
>> puts $value
10
=> nil
>> def example
>>   $value = 20
>> end
=> nil
>> puts $value
10
=> nil
>> example
=> 20
>> puts $value
20
=> nil
>> exit
$
\end{verbatim}\end{shaded}

Global variables are used very rarely.

\section{Instance Variables (@aaa)}\label{instance-variables-aaa}

Instance variables (“\textbf{A}ttributes”, hence the \texttt{@}) only apply within a class, but everywhere in it -- a mini version of global variables, so to speak. Unlike global variables, you will find instance variables all over the place in a Rails application. Let's tackle them in form of an example program with the name \texttt{color.rb}:

\begin{shaded}\begin{verbatim}
class Wall
  def initialize
    @color = 'white'
  end

  def color
    @color
  end

  def paint_it(value)
    @color = value
  end
end

my_wall = Wall.new
puts my_wall.color

my_wall.paint_it('red')
puts my_wall.color
\end{verbatim}\end{shaded}

If you start this program, the following output will appear:

\begin{shaded}\begin{verbatim}
$ ruby color.rb
white
red
$
\end{verbatim}\end{shaded}

In the method \texttt{initialize} we set the instance variable \texttt{@color} to the value “white”. The method \texttt{paint\_it(value)} changes this instance variable.

With the method \texttt{color} we can access the value of \texttt{@color} outside of the instance. This kind of method is called a setter method.

\section{Methods Once Again}\label{methods-once-again}

In order to keep the amount of chicken and egg problems in this chapter at a manageable level, we need to go back to the topic Methods and combine what we have learned so far.

\section{Getters and Setters}\label{getters-and-setters}

As instance variables (“attributes”) only exist within the relevant instance, you always need to write a “getter” method for exporting such a variable. If we define a class \texttt{Room} that has the instance variables \texttt{@doors} and \texttt{@windows} (for the number of doors and windows in the room), then we can create the getter methods \texttt{doors} und \texttt{windows} (example program \texttt{room.rb}):

\begin{shaded}\begin{verbatim}
class Room
  def initialize
    @doors  = 1
    @windows = 1
  end

  def doors
    @doors
  end

  def windows
    @windows
  end
end

kitchen = Room.new

puts "D: #{kitchen.doors}"
puts "W: #{kitchen.windows}"
\end{verbatim}\end{shaded}

The execution of the program:

\begin{shaded}\begin{verbatim}
$ ruby room.rb
D: 1
W: 1
$
\end{verbatim}\end{shaded}

As this scenario -- wanting to simply return a value in identical form -- is so common, there is already a ready-made getter method for it with the name \texttt{attr\_reader}, which you would apply as follows in the program \texttt{room.rb}:

\begin{shaded}\begin{verbatim}
class Room
  def initialize
    @doors  = 1
    @windows = 1
  end

  attr_reader :doors, :windows
end

kitchen = Room.new

puts "D: #{kitchen.doors}"
puts "W: #{kitchen.windows}"
\end{verbatim}\end{shaded}

\texttt{attr\_reader} is a method which is called on the \texttt{Room} class. That is the reason why we use Symbols (e.g. :doors and :windows) instead of variables (e.g. @doors and @windows) as parameter.

\section{Note}\label{note-7}

\texttt{attr\_reader} is a good example for meta programming in Ruby. When working with Rails, you will frequently come across meta programming and be grateful for how it works automagically.

If you want to change the number of doors or windows from the outside, you need a “setter” method. It can be implemented as follows:

\begin{shaded}\begin{verbatim}
class Room
  def initialize
    @doors  = 1
    @windows = 1
  end

  attr_reader :doors, :windows

  def doors=(value)
    @doors = value
  end

  def windows=(value)
    @windows = value
  end
end

kitchen = Room.new

kitchen.windows = 2

puts "D: #{kitchen.doors}"
puts "W: #{kitchen.windows}"
\end{verbatim}\end{shaded}

The corresponding output is this:

\begin{shaded}\begin{verbatim}
$ ruby room.rb
D: 1
W: 2
$
\end{verbatim}\end{shaded}

As you can probably imagine, there is of course also a ready-made and easier way of doing this. Via the setter method \texttt{attr\_writer} you can simplify the code of \texttt{room.rb} further:

\begin{shaded}\begin{verbatim}
class Room
  def initialize
    @doors  = 1
    @windows = 1
  end

  attr_reader :doors, :windows
  attr_writer :doors, :windows
end

kitchen = Room.new

kitchen.windows = 2

puts "D: #{kitchen.doors}"
puts "W: #{kitchen.windows}"
\end{verbatim}\end{shaded}

And (who would have thought!) there is even a method \texttt{attr\_accessor} that combines getters and setters. The code for \texttt{room.rb} would then look like this:

\begin{shaded}\begin{verbatim}
class Room
  def initialize
    @doors  = 1
    @windows = 1
  end

  attr_accessor :doors, :windows
end


kitchen = Room.new

kitchen.windows = 2

puts "D: #{kitchen.doors}"
puts "W: #{kitchen.windows}"
\end{verbatim}\end{shaded}

\section{Built-In Methods for String}\label{built-in-methods-for-string}

Most classes already come with a bundle of very useful methods. These methods are always written after the relevant object, separated by a point.

Here are a few examples for methods of the class \texttt{String}.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 'A dog'
=> "A dog"
>> a.class
=> String
>> a.size
=> 5
>> a.downcase
=> "a dog"
>> a.upcase
=> "A DOG"
>> a.reverse
=> "god A"
>> exit
$
\end{verbatim}\end{shaded}

With \texttt{instance\_methods(false)} you can get a list of the build in methods:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> String.instance_methods(false)
=> [:<=>, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :byteslice, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :<<, :prepend, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c]
>> exit
$
\end{verbatim}\end{shaded}

If you are not sure what one of these methods does you can use \textbf{ri} to look it up:

\begin{shaded}\begin{verbatim}
$ ri -T String.size
String.size

(from ruby site)
------------------------------------------------------------------------------
  str.length   -> integer
  str.size     -> integer


------------------------------------------------------------------------------

Returns the character length of str.


$
\end{verbatim}\end{shaded}

\section{Method Chaining}\label{method-chaining}

You may not think of it straight away, but once you have got used to working with Ruby, then it makes perfect sense (and is perfectly logical) to chain different methods.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 'A dog'
=> "A dog"
>> a.upcase.reverse
=> "GOD A"
>> exit
$
\end{verbatim}\end{shaded}

\section{Converting from One to the Other: Casting}\label{converting-from-one-to-the-other-casting}

There is a whole range of useful instance methods for converting (“casting”) objects from one class to another. First, let's use the method \texttt{.to\_s} to convert a \texttt{Fixnum} to a \texttt{String}.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 10
=> 10
>> a.class
=> Fixnum
>> b = a.to_s
=> "10"
>> b.class
=> String
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-8}

Incidentally, that is exactly what \texttt{puts} does if you use \texttt{puts} to output a \texttt{Fixnum} or a \texttt{Float} (for non-strings, it simply implicitly adds the method \texttt{.to\_s} and outputs the result).

Now we use the method \texttt{.to\_i} to change a \texttt{Float} to a \texttt{Fixnum}.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> c = 10.0
=> 10.0
>> c.class
=> Float
>> d = c.to_i
=> 10
>> d.class
=> Fixnum
>> exit
$
\end{verbatim}\end{shaded}

\section{Method to\_s for Your Own Classes}\label{method-toux5fs-for-your-own-classes}

You should always integrate a method \texttt{to\_s}for your own custom classes, even if it is just for the sake of easier debugging. Then you can simply output a corresponding object via \texttt{puts} (\texttt{puts} automatically outputs an object via the method \texttt{to\_s}).

Here is an example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> class Person
>>   def initialize(first_name, last_name)
>>     @first_name = first_name
>>     @last_name = last_name
>>   end
>>   def to_s
>>     "#{@first_name} #{@last_name}"
>>   end
>> end
=> nil
>> sw = Person.new('Stefan', 'Wintermeyer')
=> Stefan Wintermeyer
>> puts sw
Stefan Wintermeyer
=> nil
>> exit
$
\end{verbatim}\end{shaded}

\section{Is “+” a Method?}\label{is-a-method}

Why is there also a plus symbol in the list of methods for \texttt{String}? Let's find out by looking it up in \texttt{ri}:

\begin{shaded}\begin{verbatim}
$ ri -T String.+
String.+

(from ruby site)
------------------------------------------------------------------------------
  str + other_str   -> new_str


------------------------------------------------------------------------------

Concatenation---Returns a new String containing other_str
concatenated to str.

  "Hello from " + self.to_s   #=> "Hello from main"


$
\end{verbatim}\end{shaded}

hmmm \ldots{} Let's see what it says for \texttt{Fixnum}:

\begin{shaded}\begin{verbatim}
$ ri -T Fixnum.+
Fixnum.+

(from ruby site)
------------------------------------------------------------------------------
  fix + numeric  ->  numeric_result


------------------------------------------------------------------------------

Performs addition: the class of the resulting object depends on the class of
numeric and on the magnitude of the result.


$
\end{verbatim}\end{shaded}

Let's have a go and play around with this in \texttt{irb}. So we should be able to add the \texttt{+} to an object, just as any other method, separated by a dot and add the second number in brackets as parameter:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 10 + 10
=> 20
>> 10+10
=> 20
>> 10.+10
=> 20
>> 10.+(10)
=> 20
>> exit
$
\end{verbatim}\end{shaded}

Aha! The plus symbol is indeed a method, and this method takes the next value as parameter. Really we should put this value in brackets, but thanks to Ruby's well thought-out syntax this is not necessary.

\section{Can I Overwrite the Method +?}\label{can-i-overwrite-the-method}

Yes, you can overwrite any method. Logically, this does not make much sense for methods such as \texttt{+}, unless you want to drive your fellow programmers mad. I am going to show you a little demo in \texttt{irb} so you will believe me.

The aim is overwriting the method \texttt{+} for \texttt{Fixnum}. We want the result of every addition to be the number 42.

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 10 + 10
=> 20
>> class Fixnum
>>   def +(name, *args, &blk)
>>     42
>>   end
>> end
=> nil
>> 10 + 10
=> 42
>> exit
$
\end{verbatim}\end{shaded}

First we perform a normal addition. Than we redefine the method \texttt{+} for the class \texttt{Fixnum}, and after that we do the calculation again. But this time, with different results.

\section{if-Condition}\label{if-condition}

An abstract \texttt{if}-condition looks like this:

\begin{shaded}\begin{verbatim}
if expression
  program
end
\end{verbatim}\end{shaded}

The program between the expression and \texttt{end} is executed if the result of the expression is not \texttt{false} and not \texttt{nil}.

\subsection{Note}\label{note-9}

You can also use a \texttt{then} after the expression:

\begin{shaded}\begin{verbatim}
if expression then
  program
end
\end{verbatim}\end{shaded}

The construct for a simple \texttt{if}-branch in a Ruby program looks like the following example program:

\begin{shaded}\begin{verbatim}
a = 10

if a == 10
  puts 'a is 10'
end
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-10}

The `==' is used to compare two values. Please don't mix it up with the single `='.

You can try an \emph{expression} really well in \texttt{irb}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 10
=> 10
>> a == 10
=> true
>> exit
$
\end{verbatim}\end{shaded}

\section{Shorthand}\label{shorthand}

A frequently used shorthand notation of an \texttt{if}-condition can be found in the following code:

\begin{shaded}\begin{verbatim}
a = 10

## long version
##
if a == 10 then
  puts 'a is 10'
end

## short version
##
puts 'a is 10' if a == 10
\end{verbatim}\end{shaded}

\section{else}\label{else}

You can probably imagine how this works, but for the sake of completeness, here is a little example:

\begin{shaded}\begin{verbatim}
a = 10

if a == 10 then
  puts 'a is 10'
else
  puts 'a is not 10'
end
\end{verbatim}\end{shaded}

\section{elsif}\label{elsif}

Again, most programmers will know what this is all about. Example:

\begin{shaded}\begin{verbatim}
a = 10

if a == 10 then
  puts 'a is 10'
elsif a == 20 then
  puts 'a is 20'
end
\end{verbatim}\end{shaded}

\section{Loops}\label{loops}

There are different ways of implementing loops in Ruby. The iterator variation is used particularly often in the Rails environment.

\section{while and until}\label{while-and-until}

An abstract while loop looks like this:

\begin{shaded}\begin{verbatim}
while expression do
  program
end
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-11}

The \texttt{do} that follows the \texttt{expression} is optional. Often you will also see this:

\begin{shaded}\begin{verbatim}
while expression
  program
end
\end{verbatim}\end{shaded}

Here is a practical \texttt{irb} example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> i = 0
=> 0
>> while i < 3 do
?>   puts i
>>   i = i + 1
>> end
0
1
2
=> nil
>> exit
$
\end{verbatim}\end{shaded}

Until loops are built similarly:

\begin{shaded}\begin{verbatim}
until expression
  program
end
\end{verbatim}\end{shaded}

Again, here is the corresponding \texttt{irb} example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> i = 5
=> 5
>> until i == 0
>>   i = i - 1
>>   puts i
>> end
4
3
2
1
0
=> nil
>> exit
$
\end{verbatim}\end{shaded}

\section{Blocks and Iterators}\label{blocks-and-iterators}

“Block” and “iterator” are some of the favorite words of many Ruby programmers. Now I am going to show you why.

In the loop

\begin{shaded}\begin{verbatim}
5.times { |i| puts i }
\end{verbatim}\end{shaded}

\texttt{i} is the iterator and \texttt{puts i} is the block.

You can also express the whole thing in the following syntax:

\begin{shaded}\begin{verbatim}
5.times do |i|
  puts i
end
\end{verbatim}\end{shaded}

\section{Iterators}\label{iterators}

Iterators are just a specific type of method. As you probably know, the word “\emph{iterate}” means to repeat something. For example, the class \texttt{Fixnum} has the iterator \texttt{times}. Let's see what help \texttt{ri} offers us:

\begin{shaded}\begin{verbatim}
$ ri -T Fixnum.times
Fixnum.times

(from ruby site)
Implementation from Integer
------------------------------------------------------------------------------
  int.times {|i| block }  ->  self
  int.times               ->  an_enumerator


------------------------------------------------------------------------------

Iterates block int times, passing in values from zero to int -
1.

If no block is given, an enumerator is returned instead.

  5.times do |i|
    print i, " "
  end

produces:

  0 1 2 3 4


$
\end{verbatim}\end{shaded}

And it also gives a nice example that we are going to try out in irb:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 5.times do |i|
?>   puts i
>> end
0
1
2
3
4
=> 5
>> exit
$
\end{verbatim}\end{shaded}

There is also a single-line notation for small blocks:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 5.times { |i| puts i }
0
1
2
3
4
=> 5
>> exit
$
\end{verbatim}\end{shaded}

By the way, an iterator does not necessarily have to pass a variable to the block:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 5.times { puts 'example' }
example
example
example
example
example
=> 5
>> exit
$
\end{verbatim}\end{shaded}

\section{Blocks}\label{blocks}

A block is the code that is triggered by an iterator. In the block, you have access to the local variable(s) passed by the iterator.

\section{Method upto}\label{method-upto}

Apart from \texttt{times} there is also the method \texttt{upto}, for easily implementing a loop. \texttt{ri} offers a nice example for this, too:

\begin{shaded}\begin{verbatim}
$ ri -T Fixnum.upto
Fixnum.upto

(from ruby site)
Implementation from Integer
------------------------------------------------------------------------------
  int.upto(limit) {|i| block }  ->  self
  int.upto(limit)               ->  an_enumerator


------------------------------------------------------------------------------

Iterates block, passing in integer values from int up to and
including limit.

If no block is given, an enumerator is returned instead.

  5.upto(10) { |i| print i, " " }

produces:

  5 6 7 8 9 10


$
\end{verbatim}\end{shaded}

\section{Arrays and Hashes}\label{arrays-and-hashes}

As in many programming languages, \emph{arrays} and \emph{hashes} are popular structures in Ruby for storing data.

\section{Arrays}\label{arrays}

An array is a list of objects. Let's play around in \texttt{irb:}

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = [1,2,3,4,5]
=> [1, 2, 3, 4, 5]
>> a.class
=> Array
>> exit
$
\end{verbatim}\end{shaded}

That is simple and easy to understand.

Let's see if it also works with strings in the array:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = ['Test', 'Banana', 'blue']
=> ["Test", "Banana", "blue"]
>> a.class
=> Array
>> a[1]
=> "Banana"
>> a[1].class
=> String
>> exit
$
\end{verbatim}\end{shaded}

That also works.

So all that's missing now is an array with a mixture of both. Obviously that will work, too, because the array stores objects and it does not matter which kind of objects they are (i.e. \texttt{String}, \texttt{Fixnum}, \texttt{Float}, \ldots{}). But a little test can't hurt:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = [1, 2.2, 'House', nil]
=> [1, 2.2, "House", nil]
>> a.class
=> Array
>> a[0]
=> 1
>> a[0].class
=> Fixnum
>> a[2]
=> "House"
>> a[2].class
=> String
>> exit
$
\end{verbatim}\end{shaded}

Next, let's have a look at what the \texttt{ri} help page says for \texttt{Array}:

\begin{shaded}\begin{verbatim}
$ ri -T Array
Array < Object

------------------------------------------------------------------------------
Includes:
Enumerable (from ruby site)

(from ruby site)
------------------------------------------------------------------------------
Arrays are ordered, integer-indexed collections of any object. Array indexing
starts at 0, as in C or Java.  A negative index is assumed to be relative to
the end of the array---that is, an index of -1 indicates the last element of
the array, -2 is the next to last element in the array, and so on.
------------------------------------------------------------------------------
Class methods:

  []
  new
  try_convert

Instance methods:

  &
  *
  +
  -
  <<

[...]

$
\end{verbatim}\end{shaded}

As you can see, arrays can also be created via the method \texttt{new} (like any class). Individual new elements can then be added at the end of an array via the method \texttt{\textless{}\textless{}}. Here is the corresponding example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = Array.new
=> []
>> a << 'first item'
=> ["first item"]
>> a << 'second item'
=> ["first item", "second item"]
>> exit
$
\end{verbatim}\end{shaded}

\section{Iterator each}\label{iterator-each}

You can work your way through an array piece by piece via the method \texttt{each}. Example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> cart = ['eggs', 'butter']
=> ["eggs", "butter"]
>> cart.each do |item|
?>   puts item
>> end
eggs
butter
=> ["eggs", "butter"]
>> exit
$
\end{verbatim}\end{shaded}

Once more, \texttt{ri} provides help and an example in case you forget how to use \texttt{each}:

\begin{shaded}\begin{verbatim}
$ ri -T Array.each
Array.each

(from ruby site)
------------------------------------------------------------------------------
  ary.each {|item| block }   -> ary
  ary.each                   -> an_enumerator


------------------------------------------------------------------------------

Calls block once for each element in self, passing that element
as a parameter.

If no block is given, an enumerator is returned instead.

  a = [ "a", "b", "c" ]
  a.each {|x| print x, " -- " }

produces:

  a -- b -- c --


$
\end{verbatim}\end{shaded}

\section{Hashes}\label{hashes}

A “\emph{Hash}” is a list of \emph{key/value pairs}. Here is an example with strings as keys:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> prices = { 'egg' => 0.1, 'butter' => 0.99 }
=> {"egg"=>0.1, "butter"=>0.99}
>> prices['egg']
=> 0.1
>> prices.count
=> 2
>> exit
$
\end{verbatim}\end{shaded}

Of course, hashes can store not just strings as objects in the values, but - as with arrays - also classes that you define yourself (see \hyperref[rubyux5farray]{the section called “Arrays”}).

\section{Symbols}\label{symbols}

\emph{Symbols} are a strange concept and difficult to explain. But they are very useful and used frequently, amongst others with hashes. Normally, variables always create new objects:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> a = 'Example 1'
=> "Example 1"
>> a.object_id
=> 70260036330560
>> a = 'Example 2'
=> "Example 2"
>> a.object_id
=> 70260036391520
>> exit
$
\end{verbatim}\end{shaded}

In both cases, we have the variable \texttt{a}, but object ID is different. We could carry on in this way indefinitely. Each time, it would generate a different object ID and therefore a new object. In principle, this is no big deal and entirely logical in terms of object orientation. But it is also rather a waste of memory space.

A symbol is defined by a colon before the name and cannot store any values itself, but it always has the same object ID, so it is very well suited to be a \emph{key}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> :a.class
=> Symbol
>> :a.object_id
=> 413928
>> exit
$
\end{verbatim}\end{shaded}

Let's do another little experiment to make the difference clearer. We use a string object with the content “\texttt{white}” three times in a row and then the symbol \texttt{:white} three times in a row. For \texttt{"white"}, a new object is created each time. For the symbol \texttt{:white}, only the first time:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 'white'.object_id
=> 70209583052020
>> 'white'.object_id
=> 70209583082240
>> 'white'.object_id
=> 70209583088920
>> :white.object_id
=> 413928
>> :white.object_id
=> 413928
>> :white.object_id
=> 413928
>> exit
$
\end{verbatim}\end{shaded}

Using symbols as key for hashes is much more memory efficient:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> colors = { black: '#000000', white: '#FFFFFFFF' }
=> {:black=>"#000000", :white=>"#FFFFFFFF"}
>> puts colors[:white]
##FFFFFFFF
=> nil
>> exit
$
\end{verbatim}\end{shaded}

You will frequently see symbols in Rails. If you want to find out more about symbols, go to the help page about the class \texttt{Symbol} via \textbf{ri Symbol}.

\section{Iterator each}\label{iterator-each-1}

With the method \texttt{each} you can work your way through a \texttt{Hash} step by step. Example:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> colors = { black: '#000000', white: '#FFFFFFFF' }
=> {:black=>"#000000", :white=>"#FFFFFFFF"}
>> colors.each do |key,value|
?>   puts "#{key} #{value}"
>> end
black #000000
white #FFFFFFFF
=> {:black=>"#000000", :white=>"#FFFFFFFF"}
>> exit
$
\end{verbatim}\end{shaded}

Again, \textbf{ri} offers help and an example, in case you cannot remember one day how to use \texttt{each}:

\begin{shaded}\begin{verbatim}
$ ri -T Hash.each
Hash.each

(from ruby site)
------------------------------------------------------------------------------
  hsh.each      {| key, value | block } -> hsh
  hsh.each_pair {| key, value | block } -> hsh
  hsh.each                              -> an_enumerator
  hsh.each_pair                         -> an_enumerator


------------------------------------------------------------------------------

Calls block once for each key in hsh, passing the key-value pair
as parameters.

If no block is given, an enumerator is returned instead.

  h = { "a" => 100, "b" => 200 }
  h.each {|key, value| puts "#{key} is #{value}" }

produces:

  a is 100
  b is 200


$
\end{verbatim}\end{shaded}

\section{Miscellaneous}\label{miscellaneous}

\section{Range}\label{range}

The class \texttt{Range} represents an interval. The start and end points of the interval are defined enclosed in normal brackets and separated by two dots in between them. Here is an example in which we use a range like an iterator with \texttt{each}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> (0..3)
=> 0..3
>> (0..3).class
=> Range
>> (0..3).each do |i|
?>   puts i
>> end
0
1
2
3
=> 0..3
>>
\end{verbatim}\end{shaded}

Via the method \texttt{to\_a} you can generate an array from a \texttt{Range}:

\begin{shaded}\begin{verbatim}
>> (0..3).to_a
=> [0, 1, 2, 3]
>>
\end{verbatim}\end{shaded}

A range can be generated from objects of any type. Important is only that the objects can be compared via \texttt{\textless{}=\textgreater{}} and use the method \texttt{succ} for counting on to the next value. So you can also use Range to represent letters:

\begin{shaded}\begin{verbatim}
>> ('a'..'h').to_a
=> ["a", "b", "c", "d", "e", "f", "g", "h"]
>>
\end{verbatim}\end{shaded}

As alternative notation, you may sometimes come across \texttt{Range.new()}. In this case, the start and end points are not separated by two dots, but by a comma. This is what it looks like:

\begin{shaded}\begin{verbatim}
>> (0..3) == Range.new(0,3)
=> true
>> exit
$
\end{verbatim}\end{shaded}

\chap{First Steps with Rails}\label{first-steps-with-rails}

\section{Introduction}\label{introduction}

Now that you have painstakingly read your way through “Ruby Basics” we can move on to a more exciting bit. In this chapter, we will start our first Ruby on Rails project and find our way into the topic step by step.

We will use Ruby on Rails version 4.0. Please update to this version in case have installed an older one.

\subsection{Note}\label{note-12}

In this chapter, we will also move on the double in some cases. Once more, there will be some typical chicken and egg problems.

\section{Environment (Development)}\label{environment-development}

By default a Rails project offers three different environments:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Development
\item
  Test
\item
  Production
\end{itemize}

In this chapter, we are only working with the Development environment. Once you have gained a better feeling for Rails, we will start using tests and then we will need the corresponding environment (where, for example, the Test database is populated when you start a test and then cleared). Later, I will explain the various scenarios to show how you can roll out your Rails application from the Development environment to the Production environment.

The Development environment has everything you need for developing, apart from an editor and a web browser. So you do not need to install a special web server, but can use the integrated Rails web server. It does not exactly have extremely high performance, but you do not need that for developing. Later, you can switch to big web servers like Apache or Nginx. The same applies to the database.

In order to work in the Development environment, you do not need to make any changes to start with - all commands work by default.

\section{SQLite-3 Database}\label{sqlite-3-database}

In terms of the database, the main focus in this chapter is once more not on optimum performance, but on showing you a simple way of getting started. That's why we are using the SQLite-3 database. You already have everything you need fully installed and you don't need to worry about anything. Later I will explain how you can use other databases (for example MySQL).

\section{Why Is It All in English?}\label{why-is-it-all-in-english}

If you are a native English speaker, you may not find it surprising that Rails apparently loves the English language. Even if you are not a native English speaker, you should try to accept and even adopt Rails' love for the English language. Much of it will then be much easier and more logical. Most of the code then reads just like a normal English sentence. For example, many mechanisms automagically use plural or singular forms of normal English words. If you get used to naming database fields and tables with English terms (even if you are programming in a different language), then you can make use of the whole power of this magic. This mechanism is referred to as \texttt{Inflector} or \emph{Inflections} (inflexions).

If you are programming in a language other than English, it still makes sense to use English names for variables, classes and methods. You can write the comments in your own language, but if you take part in international projects, you should obviously write the comments in English as well. Yeah, sure \ldots{} well written code does not need any comments. ;-)

\section{Static Content (HTML and Graphics Files)}\label{static-content-html-and-graphics-files}

If you are reading this text, you will already know that you can use Rails to somehow output web pages. The question is just how it's done. Let's first create a new Rails project.

\section{Create Rails Project}\label{create-rails-project}

Before we even get going, please check that you are using Ruby version 2.0:

\begin{shaded}\begin{verbatim}
$ ruby -v
ruby 2.0.0p247 (2013-06-27 revision 41674) [x86_64-darwin12.4.0]
$
\end{verbatim}\end{shaded}

Next, check if Rails 4.0 is also installed:

\begin{shaded}\begin{verbatim}
$ rails -v
Rails 4.0.0
$
\end{verbatim}\end{shaded}

That's looking good. If you have an older version of Ruby or Rails installed, please install the 4.0 version before you read any further.

Now we start by creating a new Rails project with the name \texttt{testproject}. Ruby on Rails is a framework, so we first need to set up the corresponding directory structure and basic configuration, including several scripts. Easy as pie, just use the command \textbf{rails new testproject}:

\begin{shaded}\begin{verbatim}
$ rails new testproject
      create  
      create  README.rdoc
      create  Rakefile
      create  config.ru
      [...]
$
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-13}

In previous versions of Rails, you had to do a \textbf{bundle install} first. With Rails 3.2 onwards, this is done automatically when you create a new Rails project. The Rails project then has all required \emph{gems} available. A \emph{gem} is a kind of software library. You can integrate certain ready-made functionalities with it, without having to reinvent the wheel.

Next, we check if the new Rails application is working by launching the integrated web server.

\subsection{Tip}\label{tip-2}

Depending on the operating system (for example, Mac OS X) and on your firewall settings, you may see a popup window when first starting a Rails application, asking you if the firewall should permit the corresponding connection. As we are only working locally, you can safely confirm.

\begin{shaded}\begin{verbatim}
$ cd testproject
$ rails server
=> Booting WEBrick
=> Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=> Run `rails server -h` for more startup options
=> Ctrl-C to shutdown server
[2013-07-15 13:58:48] INFO  WEBrick 1.3.1
[2013-07-15 13:58:48] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-15 13:58:48] INFO  WEBrick::HTTPServer#start: pid=98552 port=3000
\end{verbatim}\end{shaded}

The start of the Rails application is looking good. It tells us:

\begin{shaded}\begin{verbatim}
Rails 4.0.0 application starting in development on http://0.0.0.0:3000
\end{verbatim}\end{shaded}

So let's go to the URL \texttt{http://0.0.0.0:3000} or \texttt{http://localhost:3000} in the web browser.

Insert virgin\_rails\_app.png New Rails Application

Looks good. Rails seems to be working fine. The log of it tells what just happend:

\begin{shaded}\begin{verbatim}
Started GET "/" for 127.0.0.1 at 2013-07-15 13:59:35 +0200
Processing by Rails::WelcomeController#index as HTML
  Rendered /Users/xyz/.rvm/gems/ruby-2.0.0-p247/gems/railties-4.0.0/lib/rails/templates/rails/welcome/index.html.erb (1.1ms)
Completed 200 OK in 21ms (Views: 5.3ms | ActiveRecord: 0.0ms)
\end{verbatim}\end{shaded}

If we now click the link “\emph{About your application's environment}”, we can more information on the current environment.

\subsection{Important}\label{important-3}

With \textbf{Ctrl}+\textbf{C} you can stop the web server.

\section{Static Pages}\label{static-pages}

There are certain static pages, images and JavaScript files that are automatically output by Rails. Remember part of the output of the command \textbf{rails new testproject}:

\begin{shaded}\begin{verbatim}
$ rails new testproject
      [...]
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/robots.txt
      [...]
\end{verbatim}\end{shaded}

The directory name \texttt{public} and the files it contains already look very much like static pages. Let's have a go and create the file \texttt{public/hello-world.html} with the following content:

\begin{shaded}\begin{verbatim}
<html>
<head>
  <title>Hello World!</title>
</head>
<body>
  <h1>Hello World!</h1>
  <p>An example page.</p>
</body>
</html>
\end{verbatim}\end{shaded}

Now start the Rails web server with \textbf{rails server}

\begin{shaded}\begin{verbatim}
$ rails server
=> Booting WEBrick
=> Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=> Run `rails server -h` for more startup options
=> Ctrl-C to shutdown server
[2013-07-15 14:05:57] INFO  WEBrick 1.3.1
[2013-07-15 14:05:57] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-15 14:05:57] INFO  WEBrick::HTTPServer#start: pid=98564 port=3000
\end{verbatim}\end{shaded}

We can have a look at this web page at the URL \texttt{http://0.0.0.0:3000/hello-world}:

Insert hello-world-html.png Hello World

No output in the log means: This page was not handled by the Rails framework. It was delivered directly from the webserver.

\section{Note}\label{note-14}

We can of course also use the URL \texttt{http://0.0.0.0:3000/hello-world.html}. But Rails regards HTML and therefore the file ending \texttt{.html} as standard output format, so you can omit the “\texttt{.html}” here.

Now you know how you can integrate fully static pages in Rails. This is useful for pages that never change and that you want to work even if Rails is not currently working, for example because of an update. In a production environment, you would usually put a classic web server such as Apache or Nginx infront of the Rails server. Which is capable of autonomously delivering static files from the \texttt{public} directory. You'll learn how to set up a production webserver in \hyperref[railsux5fproductionux5fwebserver]{Chapter~16, \emph{Web Server in Production Mode}}.

With \textbf{Ctrl}+\textbf{C} you can stop the Rails server.

\chap{Creating HTML Dynamically with erb}\label{creating-html-dynamically-with-erb}

The the content of an \texttt{erb} file will propably seem familiar to you. It is a mixture of HTML and Ruby code (\texttt{erb} stands for \emph{\textbf{e}mbedded \textbf{R}u\textbf{b}y}). erb pages are rendered as Views. This is the first time for us to get in touch with the MVC model. We need a controller to use a view. That can be created it via the generator \textbf{rails generate controller}. Let's have a look at the onboard help of this generator:

\begin{shaded}\begin{verbatim}
$ rails generate controller
Usage:
  rails generate controller NAME [action action] [options]

Options:
      [--skip-namespace]        # Skip namespace (affects only isolated applications)
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
  -t, [--test-framework=NAME]   # Test framework to be invoked
                                # Default: test_unit
      [--helper]                # Indicates when to generate helper
                                # Default: true
      [--assets]                # Indicates when to generate assets
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Suppress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Stubs out a new controller and its views. Pass the controller name, either
    CamelCased or under_scored, and a list of views as arguments.

    To create a controller within a module, specify the controller name as a
    path like 'parent_module/controller_name'.

    This generates a controller class in app/controllers and invokes helper,
    template engine, assets, and test framework generators.

Example:
    `rails generate controller CreditCards open debit credit close`

    CreditCards controller with URLs like /credit_cards/debit.
        Controller: app/controllers/credit_cards_controller.rb
        Test:       test/controllers/credit_cards_controller_test.rb
        Views:      app/views/credit_cards/debit.html.erb [...]
        Helper:     app/helpers/credit_cards_helper.rb
$
\end{verbatim}\end{shaded}

Nice! We are kindly provided with an example further down:

\begin{shaded}\begin{verbatim}
rails generate controller CreditCard open debit credit close
\end{verbatim}\end{shaded}

Doesn't really fit the bill for our case but I am feeling brave and suggest that we simply try \textbf{rails generate controller Example test}

\begin{shaded}\begin{verbatim}
$ rails generate controller Example test
      create  app/controllers/example_controller.rb
       route  get "example/test"
      invoke  erb
      create    app/views/example
      create    app/views/example/test.html.erb
      invoke  test_unit
      create    test/controllers/example_controller_test.rb
      invoke  helper
      create    app/helpers/example_helper.rb
      invoke    test_unit
      create      test/helpers/example_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/example.js.coffee
      invoke    scss
      create      app/assets/stylesheets/example.css.scss
$
\end{verbatim}\end{shaded}

Phew\ldots{} that's a lot of stuff being created. Amongst others, the file \texttt{app/views/example/test.html.erb}. Let's have a closer look at it:

\begin{shaded}\begin{verbatim}
$ cat app/views/example/test.html.erb
<h1>Example#test</h1>
<p>Find me in app/views/example/test.html.erb</p>
$
\end{verbatim}\end{shaded}

It's HTML, but for it to be a valid HTML page, something is “missing” at the top and bottom (the missing HTML “rest” will be explained in \hyperref[erbux5flayouts]{the section called “Layouts”}). We launch the web server to test it

\begin{shaded}\begin{verbatim}
$ rails server
\end{verbatim}\end{shaded}

and have a look at the web page in the browser at the URL \texttt{http://0.0.0.0:3000/example/test}:

Insert example-test-erb.png Example Test ERB

In the log \texttt{log/development.log} we find the following lines:

\begin{shaded}\begin{verbatim}
Started GET "/example/test" for 127.0.0.1 at 2013-07-15 14:32:07 +0200
Processing by ExampleController#test as HTML
  Rendered example/test.html.erb within layouts/application (0.8ms)
Completed 200 OK in 768ms (Views: 751.0ms | ActiveRecord: 0.0ms)

Started GET "/assets/example.css?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/example.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/application.css?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/jquery_ujs.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/jquery.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/application.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
Started GET "/assets/turbolinks.js?body=1" for 127.0.0.1 at 2013-07-15 14:32:08 +0200
\end{verbatim}\end{shaded}

That almost reads like normal English. Let us analyse the first part:

\begin{shaded}\begin{verbatim}
Started GET "/example/test" for 127.0.0.1 at 2013-07-15 14:32:07 +0200
Processing by ExampleController#test as HTML
  Rendered example/test.html.erb within layouts/application (0.8ms)
\end{verbatim}\end{shaded}

\texttt{localhost} (127.0.0.1) sent in an HTTP GET request for the URI “\texttt{/example/test}”. That was then apparently rendered as HTML by the controller \texttt{ExampleController} using the method \texttt{test}.

\section{Note}\label{note-15}

The other lines tell us that a bunch of CSS and JavaScript files are compiled and than delivered. In production mode these would be precompiled and delivered as one CSS and one J

Now we just need to find the controller. Good thing you bough this book. ;-) All controllers are in the directory \texttt{app/controllers}, and there you go, we indeed find the corresponding file \texttt{app/controllers/example\_controller.rb.}

\begin{shaded}\begin{verbatim}
$ ls -l app/controllers/
total 16
-rw-r-r--  1 xyz  staff  204 15 Jul 13:56 application_controller.rb
drwxr-xr-x  3 xyz  staff  102 15 Jul 13:56 concerns
-rw-r-r--  1 xyz  staff   69 15 Jul 14:31 example_controller.rb
$
\end{verbatim}\end{shaded}

Please open the file \texttt{app/controllers/example\_controller.rb} with your favorite editor:

\begin{shaded}\begin{verbatim}
class ExampleController < ApplicationController
  def test
  end
end
\end{verbatim}\end{shaded}

That is very clear. The controller \texttt{ExampleController} is a descendant of the \texttt{ApplicationController} and contains currently just one method with the name \texttt{test}. This method contains currently no program logic.

You will probably ask yourself how Rails knows that for the URL path \texttt{/example/test} it should process the controller \texttt{ExampleController} and the method \texttt{test}. This is not determined by some magical logic, but by a \emph{routing} configuration. The current routings can be listed with the command \textbf{rake routes}

\begin{shaded}\begin{verbatim}
$ rake routes
      Prefix Verb URI Pattern             Controller#Action
example_test GET /example/test(.:format) example#test
$
\end{verbatim}\end{shaded}

These routes are configured in the file \texttt{config/routes.rb} which has been auto-filled by the controller generator with a route to \texttt{example/test}. The one line which is important for us right now is the second one:

\begin{shaded}\begin{verbatim}
$ head -n 2 config/routes.rb
Testproject::Application.routes.draw do
  get "example/test"
$
\end{verbatim}\end{shaded}

The \texttt{config/routes.rb} file includes a lot of examples. Give it a read when you have time. We'll dive into that later (\hyperref[routes]{Chapter~6, \emph{Routes}}).

\subsection{Important}\label{important-4}

A static file in the directory \texttt{public} always has higher priority than a route in the \texttt{config/routes.rb}! So if we were to save a static file \texttt{public/example/test} that file will be delivered.

\section{Programming in an erb File}\label{programming-in-an-erb-file}

\texttt{Erb} pages can contain Ruby code. You can use it to program and give these page dynamic content.

Let's start with something very simple: adding 1 and 1. First we try out the code in \texttt{irb}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 1 + 1
=> 2
>> exit
$
\end{verbatim}\end{shaded}

That was easy. We fill the \texttt{erb} file \texttt{app/views/example/test.html.erb} as follows:

\begin{shaded}\begin{verbatim}
<h1>First experiment with erb</h1>
<p>Addition:
<%= 1 + 1 %>
</p>
\end{verbatim}\end{shaded}

Then use \textbf{rails server} to launch the web server.

\begin{shaded}\begin{verbatim}
$ rails server
\end{verbatim}\end{shaded}

Visit that page with the URL \texttt{http://0.0.0.0:3000/example/test}

Insert erb\_einfache\_addition.png Einfache Addition

\section{Important}\label{important-5}

If you want to output the result of Ruby code, enclose the code within a \texttt{\textless{}\%=} \ldots{} \texttt{\%\textgreater{}}.

You may ask yourself: how can the result of adding two \texttt{Fixnums} be displayed as a String? Let's first look up in \texttt{irb} if it really is a \texttt{Fixnum}:

\begin{shaded}\begin{verbatim}
$ irb --simple-prompt
>> 1.class
=> Fixnum
>> (1 + 1).class
=> Fixnum
\end{verbatim}\end{shaded}

Yes, both the number 1 and the result of 1 + 1 is a \texttt{Fixnum}. What happened? Rails is so intelligent that it automatically calls all objects in a view (that is the file \texttt{test.html.erb}) that are not already a string via the method \texttt{.to\_s}, which always converts the content of the object to a string (\hyperref[ruby-toux5fs]{the section called “Method to\_s for Your Own Classes”}). Once more, a brief trip to \texttt{irb}:

\begin{shaded}\begin{verbatim}
>> (1 + 1).to_s
=> "2"
>> (1 + 1).to_s.class
=> String
>> exit
$
\end{verbatim}\end{shaded}

You are now going to learn the finer points of \texttt{erb} step by step. Don't worry, it's neither magic nor rocket science.

\section{Syntax}\label{syntax}

In a \texttt{.html.erb}file, there are two kinds of Ruby code instructions in addition to the HTML elements:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \textless{}\% \ldots{} \%\textgreater{} Executes the Ruby code it contains, but does not output anything (unless you explicitly use something like \texttt{print} or \texttt{puts}).
\item
  \textless{}\%= \ldots{} \%\textgreater{} Executes the Ruby code it contains and outputs the result as a String. If is is not a String the methode \texttt{to\_s} will be called.
\end{itemize}

\subsection{Important}\label{important-6}

The output of \textless{}\%= \ldots{} \%\textgreater{} is automatically escaped. So you don't need to worry about “dangerous” HTML.

Let's use an example, to make sure it all makes sense. We use \texttt{each} to iterate through the \texttt{Range} \texttt{(0..5)}. Edit the \texttt{app/views/example/test.html.erb} as follows:

\begin{shaded}\begin{verbatim}
<p>Loop from 0 to 5:
<% (0..5).each do |i| %>
<%= "#{i}, " %>
<% end %>
</p>
\end{verbatim}\end{shaded}

Open this view In the browser:

Insert erb\_einfache\_schleife.png Einfache Schleife

Let's now have a look at the HTML source code in the browser:

\begin{shaded}\begin{verbatim}
<!DOCTYPE html>
<html>
<head>
  <title>Testproject</title>
  <link data-turbolinks-track="true" href="/assets/application.css?body=1" media="all" rel="stylesheet" />
<link data-turbolinks-track="true" href="/assets/example.css?body=1" media="all" rel="stylesheet" />
  <script data-turbolinks-track="true" src="/assets/jquery.js?body=1"></script>
<script data-turbolinks-track="true" src="/assets/jquery_ujs.js?body=1"></script>
<script data-turbolinks-track="true" src="/assets/turbolinks.js?body=1"></script>
<script data-turbolinks-track="true" src="/assets/example.js?body=1"></script>
<script data-turbolinks-track="true" src="/assets/application.js?body=1"></script>
  <meta content="authenticity_token" name="csrf-param" />
<meta content="FjIAd8nQGbKSAdbXdY47d3dhW1ZNLhe4eWJYYOgVdes=" name="csrf-token" />
</head>
<body>

<p>Loop from 0 to 5:
  0,
  1,
  2,
  3,
  4,
  5,
</p>


</body>
</html>
\end{verbatim}\end{shaded}

Now you have the important tools to use Ruby code in a view.

\chap{Q \& A}\label{q-a}

Potentially, there are two open questions:

\textbf{Q:}

I don't understand anything. I can't cope with the Ruby code. Could you please explain that again?

\textbf{A:}

Is it possible that you have not completely worked your way through \hyperref[ruby-grundlagen]{Chapter~2, \emph{Ruby Basics}}? Please do take your time with it and have another thorough look. Otherwise, the rest won't make any sense here.

\textbf{Q:}

I can understand the Ruby code and the HTML output. But I don't get why some HTML code was rendered around it if I didn't even write that HTML code. Where does it come from, and can I influence it?

\textbf{A:}

Excellent question! We will get to that next (see \hyperref[erbux5flayouts]{the section called “Layouts”}).

\chap{Layouts}\label{layouts}

The \texttt{erb} file in the directory \texttt{app/views/example/} only forms the core of the later HTML page. By default, an automatically generated \texttt{app/views/layouts/application.html.erb} is always rendered around it. Let's have a closer look at it:

\begin{shaded}\begin{verbatim}
<!DOCTYPE html>
<html>
<head>
  <title>Testproject</title>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
</head>
<body>

<%= yield %>

</body>
</html>
\end{verbatim}\end{shaded}

The interesting bit is the line

\begin{shaded}\begin{verbatim}
<%= yield %>
\end{verbatim}\end{shaded}

With \texttt{\textless{}\%= yield \%\textgreater{}} the View file is included here. The lines with the stylesheets, the JavaScript and the csrf\_meta\_tags can stay as they are for now. They integrate default CSS and JavaScript files. We'll have a look into that in \hyperref[assetux5fpipeline]{Chapter~12, \emph{Asset Pipeline}}. No need to bother with that right now.

The file \texttt{app/views/layouts/application.html.erb} enables you to determine the basic layout for the entire Rails application. If you want to enter a \texttt{\textless{}hr\textgreater{}} for each page and above it a text, then you can do this between the \texttt{\textless{}\%= yield \%\textgreater{}} and the \texttt{\textless{}body\textgreater{}} tag:

\begin{shaded}\begin{verbatim}
<!DOCTYPE html>
<html>
<head>
  <title>Testproject</title>
  <%= stylesheet_link_tag    "application", :media => "all" %>
  <%= javascript_include_tag "application" %>
  <%= csrf_meta_tags %>
</head>
<body>

<h1>My Header</h1>
<hr>

<%= yield %>

</body>
</html>
\end{verbatim}\end{shaded}

You can also create other layouts in the directory \texttt{app/views/layouts/} and apply these layouts depending on the relevant situation. But let's leave it for now. The important thing is that you understand the basic concept.

\chap{Passing Instance Variables from a Controller to a View}\label{passing-instance-variables-from-a-controller-to-a-view}

One of the cardinal sins in the MVC model is to put too much program logic into the view. That's more or less what used to be done frequently in PHP programming in the past. I'm guilty of having done it myself. But one of the aims of MVC is that any HTML designer can create a view without having to worry about the programming. Yeah, yeah, \ldots{} if only it was always that easy. But let's just play it through in our minds: if I have a value in the controller that I want to display in the view, then I need a mechanism for this. This is referred to as \emph{instance variable} and always starts with a \texttt{@}. If you are not 100 \% sure any more which variable has which \emph{scope}, then please have another quick look at \hyperref[scopeux5fvonux5fvariablen]{the section called “Scope of Variables”}.

In the following example, we insert an instance variable for the current time in the controller and then insert it in the view. So we are taking programming intelligence from the view to the controller.

The controller file \texttt{app/controllers/example\_controller.rb} looks like this:

\begin{shaded}\begin{verbatim}
class ExampleController < ApplicationController
  def test
    @current_time = Time.now
  end
end
\end{verbatim}\end{shaded}

In the view file \texttt{app/views/example/test.html.erb} we can then access this instance variable:

\begin{shaded}\begin{verbatim}
<p>
The current time is
<%= @current_time %>
</p>
\end{verbatim}\end{shaded}

With the controller and the view, we now have a clear separation of programming logic and presentation logic. So now we can automatically adjust the time in the controller in accordance with the user's time zone, without the designer of the page having to worry about it. As always, the method \texttt{to\_s} is automatically applied in the view.

I am well aware that no-one will now jump up from their chair and shout: “Thank you for enlightening me! From now on, I will only program neatly in accordance with MVC.” The above example is just the first small step in the right direction and shows how we can easily get values from the controller to the view with instance variables.

\hyperdef{}{partials}{\section{Partials}\label{partials}}

Even with small web projects, there are often elements that appear repeatedly, for example a \emph{footer} on the page with contact info or a menu. Rails gives us the option of encapsulate this HTML code in form of \emph{partials} and then integrating it within a view. A partial is also stored in the directory \texttt{app/views/example/}. But the file name must start with an underscore (\texttt{\_}).

As an example, we now add a mini footer to our page in a separate partial. Copy the following content into the new file \texttt{app/views/example/\_footer.html.erb}:

\begin{shaded}\begin{verbatim}
<hr>
<p>
Copyright 2009 - <%= Date.today.year %> the Easter Bunny.
</p>
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-16}

Yes, this is not the MVC way of doing it. Date.today.year should be defined in the Controller. I'm glad that you caught this mistake. I made it to show the use of a partial.

We edit the file \texttt{app/views/example/test.html.erb} as follows and insert the partial via the command\texttt{render}:

\begin{shaded}\begin{verbatim}
<p>Loop from 0 to 5:
<% (0..5).each do |i| %>
<%= "#{i}, " %>
<% end %>
</p>

<%= render "footer" %>
\end{verbatim}\end{shaded}

So now we have the following files in the directory \texttt{app/views/example}:

\begin{shaded}\begin{verbatim}
$ ls app/views/example
_footer.html.erb
test.html.erb
$
\end{verbatim}\end{shaded}

The new web page now looks like this:

Insert partials\_footer.png Partial Footer

\subsection{Important}\label{important-7}

The name of a partial in the code is always specified \emph{without} the preceding underscore (\texttt{\_}) and \emph{without} the file extension \texttt{.erb} and \texttt{.html}. But the actual file must have the underscore at the beginning of the file name and end with the file extension \texttt{.erb} and \texttt{.html}.

Partials can also be integrated from other areas of the subdirectory \texttt{app/views}. For example, you can create a directory \texttt{app/views/shared} for recurring and shared content and create a file \texttt{\_footer.html.erb} in this directory. You would then integrate this file into the \texttt{erb} code via the line:

\begin{shaded}\begin{verbatim}
<%= render "shared/footer" %>
\end{verbatim}\end{shaded}

\section{Passing Variables to a Partial}\label{passing-variables-to-a-partial}

Partials are great in the sense of the DRY (\emph{\textbf{D}on't \textbf{R}epeat \textbf{Y}ourself}) concept. But what makes them really useful is the option of passing variables. Let's stick with the copyright example. If we want to pass the start year as value, we can integrate this by adding the following in the file \texttt{app/views/example/\_footer.html.erb}:

\begin{shaded}\begin{verbatim}
<hr>
<p>
Copyright <%= start_year %> - <%= Date.today.year %> the Easter Bunny.
</p>
\end{verbatim}\end{shaded}

So let's change the file \texttt{app/views/example/test.html.erb} as follows:

\begin{shaded}\begin{verbatim}
<p>Loop from 0 to 5:
<% (0..5).each do |i| %>
<%= "#{i}, " %>
<% end %>
</p>

<%= render "footer", :start_year => '2000' %>
\end{verbatim}\end{shaded}

If we now go to the URL \texttt{http://0.0.0.0:3000/example/test}, we see the 2000:

Insert partial\_start\_year\_2000.png Partial Start Year

Sometimes you need a partial that partially uses a local variable and somewhere else you may need the same partial, but without the local variable. We can take care of this in the partial itself with an if statement:

\begin{shaded}\begin{verbatim}
<hr>
<p>
Copyright
<%= "#{start_year} - " if defined? start_year %>
<%= Date.today.year %>
the Easter Bunny.
</p>
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-17}

\texttt{defined?} can be used to check if an expression has been defined.

You can call this partial with \texttt{\textless{}\%= render 'footer',         :start\_year =\textgreater{} '2000' \%\textgreater{}} and with \texttt{\textless{}\%= render         'footer' \%\textgreater{}}.

\section{Alternative Notation}\label{alternative-notation}

In \hyperref[partialsux5flocaleux5fvariables]{the section called “Passing Variables to a Partial”} we only use the short form for rendering partials. Often, you will also see this long version:

\begin{shaded}\begin{verbatim}
<%= render :partial => "footer", :locals => { :start_year => '2000' } %>
\end{verbatim}\end{shaded}

\chap{Further Documentation on Partials}\label{further-documentation-on-partials}

We have really only barely scratched the surface here. Partials are very powerful tools. You can find the official Ruby on Rails documentation on partials at \url{http://guides.rubyonrails.org/layouts_and_rendering.html\#using-partials}\{.uri\}.

\hyperdef{}{redirects}{\section{Redirects}\label{redirects}}

The name says it all, really: \emph{redirects} are commands that you can use within the controller to “skip”, i.e.~redirect, to other to other web pages.

\subsection{Note}\label{note-18}

A redirect returns to the browser the response “302 Moved” with the new target. So each redirect does a roundtrip to the browser and back.

Let's create a new Rails project for a suitable example:

\begin{shaded}\begin{verbatim}
$ rails new redirect_example
[...]
$ cd redirect_example
$
\end{verbatim}\end{shaded}

Before we can redirect, we need a controller with at least two different methods. Off we go then:

\begin{shaded}\begin{verbatim}
$ rails generate controller Game ping pong
      create  app/controllers/game_controller.rb
       route  get "game/pong"
       route  get "game/ping"
      invoke  erb
      create    app/views/game
      create    app/views/game/ping.html.erb
      create    app/views/game/pong.html.erb
      invoke  test_unit
      create    test/controllers/game_controller_test.rb
      invoke  helper
      create    app/helpers/game_helper.rb
      invoke    test_unit
      create      test/helpers/game_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/game.js.coffee
      invoke    scss
      create      app/assets/stylesheets/game.css.scss
$
\end{verbatim}\end{shaded}

The controller \texttt{app/controllers/game\_controller.rb} has the following content:

\begin{shaded}\begin{verbatim}
class GameController < ApplicationController
  def ping
  end

  def pong
  end
end
\end{verbatim}\end{shaded}

Now for the redirect: how can we achieve that we get immediately redirected to the method \texttt{pong} when we go to \texttt{http://0.0.0.0:3000/game/ping}? Easy, you will say, we just change the route in \texttt{config/routes.rb}. And you are right. So we don't necessarily need a redirect. But if we want to process something else in the method \texttt{ping} before redirecting, then this is only possible by using a \texttt{redirect\_to} in the controller \texttt{app/controllers/game\_controller.rb}:

\begin{shaded}\begin{verbatim}
class GameController < ApplicationController
  def ping
   logger.info '+++  Example  +++'
   redirect_to game_pong_path
  end

  def pong
  end
end
\end{verbatim}\end{shaded}

But what is \texttt{game\_pong\_path}? Let's have a look a the routes generated for this Rails application:

\begin{shaded}\begin{verbatim}
$ rake routes
   Prefix Verb URI Pattern          Controller#Action
game_ping GET /game/ping(.:format) game#ping
game_pong GET /game/pong(.:format) game#pong
$
\end{verbatim}\end{shaded}

\section{Note}\label{note-19}

As you can see, the route to the \emph{action}\texttt{ping} of the controller \texttt{GameController} now gets the name \texttt{game\_ping} (see beginning of the line). We could also write the redirect like this:

\begin{shaded}\begin{verbatim}
redirect_to :action => 'pong'
\end{verbatim}\end{shaded}

I will explain the details and the individual options of the redirect later in the context of each specific case. For now, you just need to know that you can redirect not just to another method, but also to another controller or an entirely different web page.

When we try to go to \texttt{http://0.0.0.0:3000/game/ping} we are automatically redirected to \texttt{http://0.0.0.0:3000/game/pong} and in the log output we see this:

\begin{shaded}\begin{verbatim}
Started GET "/game/ping" for 127.0.0.1 at 2013-07-15 18:49:01 +0200
Processing by GameController#ping as HTML
+++  Example  +++
Redirected to http://0.0.0.0:3000/game/pong
Completed 302 Found in 19ms (ActiveRecord: 0.0ms)


Started GET "/game/pong" for 127.0.0.1 at 2013-07-15 18:49:01 +0200
Processing by GameController#pong as HTML
  Rendered game/pong.html.erb within layouts/application (1.3ms)
Completed 200 OK in 743ms (Views: 741.9ms | ActiveRecord: 0.0ms)
\end{verbatim}\end{shaded}

\section{redirect\_to :back}\label{redirectux5fto-back}

If you want to redirect the user of your webapplication to the page he has just been you can use \texttt{redirect\_to :back}. This is very useful in a scenario where your user first has to login to get access to a specific page.

\section{Flash Messages}\label{flash-messages}

In my eyes, the term “\emph{flash messages}” is somewhat misleading. Almost anyone would associate the term “\emph{Flash}” with more or less colorful web pages that were implemented with the Adobe Shockwave Flash Plug-in. But in Ruby on Rails, flash messages are something completely different. They are messages that are displayed, for example on the new page after a redirect (see \hyperref[redirects]{the section called “Redirects”}).

Flash messages are good friends with redirects. The two often work together in a team to give the user feedback on an action he just carried out. A typical example of a flash message is the system feedback when a user has logged in. Often the user is redirected back to the original page and gets the message “You are now logged in.”

As an example, we are once more constructing the ping pong scenario from \hyperref[redirects]{the section called “Redirects”}:

\begin{shaded}\begin{verbatim}
$ rails new pingpong
      [...]
$ cd pingpong
$ rails generate controller Game ping pong
      [...]
$
\end{verbatim}\end{shaded}

We fill the \texttt{app/controllers/game\_controller.rb} with the following content:

\begin{shaded}\begin{verbatim}
class GameController < ApplicationController
  def ping
   redirect_to game_pong_path, notice: 'Ping-Pong!'
  end

  def pong
  end
end
\end{verbatim}\end{shaded}

Now we start the Rails web server with \textbf{rails server} and use the browser to go to \texttt{http://0.0.0.0:3000/game/ping}. We are redirected from \texttt{ping} to \texttt{pong}. But the flash message “Ping-Pong!” is nowhere to be seen. We first need to expand \texttt{app/views/layouts/application.html.erb}:

\begin{shaded}\begin{verbatim}
<html>
<head>
  <title>Pingpong</title>
  <%= stylesheet_link_tag    "application", media: "all", "data-turbolinks-track" => true %>
  <%= javascript_include_tag "application", "data-turbolinks-track" => true %>
  <%= csrf_meta_tags %>
</head>
<body>

<%- flash.each do |name, message| %>
<p><i><%= "#{name}: #{message}" %></i></p>
<% end %>

<%= yield %>

</body>
</html>
\end{verbatim}\end{shaded}

Now we see the flash message at the top of the page when we go to \texttt{http://0.0.0.0:3000/game/ping} in the browser:

Insert flash\_pong\_notice.png Pong Flash Notice

If we go to \texttt{http://0.0.0.0:3000/game/pong} we still see the normal Pong page. But if we go to \texttt{http://0.0.0.0:3000/game/ping} we are redirected to the Pong page and then the flash message is displayed at the top.

\subsection{Tip}\label{tip-3}

If you do not see a flash message that you were expecting, first check in the view to see if the flash message is output there.

\section{Different Types of Flash Message}\label{different-types-of-flash-message}

Flash messages are automagically passed to the view in a hash. By default, there are three different types: \texttt{error}, \texttt{warning} and \texttt{notice}. You can also invent your own category and then get it in the view later.

\chap{Different Syntaxes}\label{different-syntaxes}

Depending on the programmer's preferences, you will find different syntaxes of flash messages in practice. I am not going to take part in the discussion about which is the best syntax, but just show you briefly the two most common variations:

\begin{itemize}
\item
  \texttt{\{.programlisting\}     redirect\_to game\_pong\_path, notice: 'Ping-Pong!'}
\item
  \texttt{\{.programlisting\}     flash{[}:notice{]} = 'Ping-Pong!'     redirect\_to action: pong}
\end{itemize}

Please have a look at the official documentation at \url{http://guides.rubyonrails.org/action_controller_overview.html\#the-flash}\{.uri\} for more information.

\section{Why Are There Flash Messages At All?}\label{why-are-there-flash-messages-at-all}

You may wonder why there are flash messages in the first place. Couldn't you just build them yourself if you need them? Yes, indeed. But flash messages have the advantage that they offer a defined approach that is the same for any programmer. So you don't need to start from scratch every single time you need one.

\section{The Rails Console}\label{the-rails-console}

The \emph{console} in Rails is nothing more than an \texttt{irb} (see \hyperref[irb]{the section called “irb”}) built around the Rails environment. The console is very useful both for developing and for administration purposes, because the whole Rails environment is represented and available.

For our working environment, we again use a variation of the ping pong scenario from \hyperref[redirects]{the section called “Redirects”}:

\begin{shaded}\begin{verbatim}
$ rails new pingpong
      [...]
$ cd pingpong
$ rails generate controller Game ping pong
      [...]
$
\end{verbatim}\end{shaded}

Start the Rails console with the command \textbf{rails console}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
2.0.0-p247 :001 >
\end{verbatim}\end{shaded}

And you can use \textbf{exit} to get back out:

\begin{shaded}\begin{verbatim}
2.0.0-p247 :001 > exit
$
\end{verbatim}\end{shaded}

Many readers use this document on mobile devises. For them I try to keep any code or terminal output width to a minimum. To save the real estate which is by default occupied by \texttt{2.0.0-p247 :001 \textgreater{}} we can start \textbf{rails console} with the parameter \emph{\texttt{-{}- -{}-simple-prompt}}.

\begin{shaded}\begin{verbatim}
$ rails console -- --simple-prompt
Loading development environment (Rails 4.0.0)
>> exit
$
\end{verbatim}\end{shaded}

Alternativly you can change the IRB configuration in the file \texttt{.irbrc} which is located in your home directory. If you want to have the simple prompt you have to add the following line in that file.

\begin{shaded}\begin{verbatim}
IRB.conf[:PROMPT_MODE] = :SIMPLE
\end{verbatim}\end{shaded}

In the console, you have access to all variables that are also available later in the proper application:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Rails.env
=> "development"
>> Rails.root
=> #<Pathname:/Users/xyz/pingpong>
>> exit
$
\end{verbatim}\end{shaded}

Already in \hyperref[activerecordux5fchapter]{Chapter~4, \emph{ActiveRecord}} we are going to be working lots with the console and will soon begin to appreciate the possibilities it offers.

\subsection{Tip}\label{tip-4}

One of my best buddies when developing Rails applications is the Tab key. Whenever you are looking for a method for a particular problem, recreate it in the Rails console and then press the Tab key twice to list all available methods. The names of the methods are usually self-exlanatory.

\section{app}\label{app}

\textbf{app} is useful if you want to analyze things to do with routing:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> app.url_for(:controller => 'game', :action => 'ping')
=> "http://www.example.com/game/ping"
>> app.get 'game/ping'


Started GET "/game/ping" for 127.0.0.1 at 2013-07-15 19:19:36 +0200
Processing by GameController#ping as HTML
Redirected to http://www.example.com/game/pong
Completed 302 Found in 16ms (ActiveRecord: 0.0ms)
=> 302
>> app.get 'game/pong'


Started GET "/game/pong" for 127.0.0.1 at 2013-07-15 19:19:39 +0200
Processing by GameController#pong as HTML
  Rendered game/pong.html.erb within layouts/application (0.9ms)
Completed 200 OK in 50ms (Views: 49.2ms | ActiveRecord: 0.0ms)
=> 200
>> exit
$
\end{verbatim}\end{shaded}

\section{Misc}\label{misc}

You have now already created a simple Rails application and in the next chapter you will dive deeply into the topic ActiveRecord. So now is a good time to very briefly introduce a few terms that often surface in the world of Rails.

\section{“Model View Controller” Architecture (MVC)}\label{model-view-controller-architecture-mvc}

According to Wikipedia (\texttt{http://en.wikipedia.org/wiki/Model–view–controller}), MVC is a design pattern that separates the representation of information from the user's interaction with it.

MVC is a structure for software development. It was agreed that it makes sense to have one part of the software in one place and another part of the software in another place. Nothing more, nothing less. This agreement has the enormous advantage that once you are used to this concept, you know exactly where you can find or need to integrate a certain functionaity in a Rails project.

\chap{Model}\label{model}

“Model” in this case means data model. By default, Rails applications are an ActiveRecord data model (see \hyperref[activerecordux5fchapter]{Chapter~4, \emph{ActiveRecord}}).

All models can be found in the directory \texttt{app/models/.}

\section{View}\label{view}

The “view” is responsible for the presentation of the application. It takes care of rendering the web page, an XML or JSON file. A view could also render a PDF or an ASCII text. It depends entirely on your application.

You will find all the views in the directory \texttt{app/views/.}

\section{Controller}\label{controller}

Once a web page call has ended up in a route (see \hyperref[routes]{Chapter~6, \emph{Routes}}), it goes from there to the controller. The route specifies a certain method (action) as target. This method can then fulfil the desired tasks (such as finding a specific set of data and saving it in an instance variable) and then renders the desired view.

All controllers can be found in the directory \texttt{app/controllers/.}

\section{What is a Generator?}\label{what-is-a-generator}

We have already used the command \textbf{rails generate controller}. It starts the generator with the name \texttt{controller}. There are other generators as well. You can use the command \textbf{rails generate} to display a list of available generators:

\begin{shaded}\begin{verbatim}
$ rails generate
Usage: rails generate GENERATOR [args] [options]

General options:
  -h, [--help]     ## Print generator's options and usage
  -p, [--pretend]  # Run but do not make any changes
  -f, [--force]    # Overwrite files that already exist
  -s, [--skip]     # Skip files that already exist
  -q, [--quiet]    # Suppress status output

Please choose a generator below.

Rails:
  assets
  controller
  generator
  helper
  integration_test
  jbuilder
  mailer
  migration
  model
  resource
  scaffold
  scaffold_controller
  task

Coffee:
  coffee:assets

Jquery:
  jquery:install

Js:
  js:assets

TestUnit:
  test_unit:plugin

$
\end{verbatim}\end{shaded}

What does a generator do? A generator makes a programmer's job easier by doing some of the mindless tasks for you. It creates files and fills them with content, depending on the parameters passed. You could do the same manually, without the generator. So you do not have to use a generator. It is primarily intended to save you work and avoid potential errors that can easily arise from mindless repetitive tasks.

\subsection{Tip}\label{tip-5}

Someday you might want to create your own generator. Have a look at \url{http://guides.rubyonrails.org/generators.html}\{.uri\} to find a description of how to do that.

\section{Helper}\label{helper}

A helper method takes care of recurring tasks in a view. For example, if you want to display stars (*) for rating a restaurant and not a number from 1 to 5, you can define the following helper in the file \texttt{app/helpers/application\_helper.rb} :

\begin{shaded}\begin{verbatim}
module ApplicationHelper

  def render_stars(value)
    output = ''
    if (1..5).include?(value)
      value.times { output += '*'}
    end
    output
  end

end
\end{verbatim}\end{shaded}

With this helper, we can then apply the following code in a view:

\begin{shaded}\begin{verbatim}
<p>
<b>Rating:</b> <%= render_stars(5) %>
</p>
\end{verbatim}\end{shaded}

You can also try out the helper in the console:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> helper.render_stars(5)
=> "*****"
>> helper.render_stars(3)
=> "***"
>> exit
$
\end{verbatim}\end{shaded}

There are lots of predefined helpers in Rails and we will use some of them in the next chapters. But you can also define your own custom helpers. Any of the helpers from the file \texttt{app/helpers/application\_helper.rb} can be used in any view. Helpers that you want to be only available in certain views must be defined for each controller. When creating a controller, a file for helpers of that controller is automatically created in \texttt{app/helpers}. This gives you the option of defining helpers only for this controller or for the views of this controller.

All helpers are in the directory \texttt{app/helpers/.}

\section{Rails Lingo}\label{rails-lingo}

Here you find a couple of words which you'll often find in the Ruby on Rails universe.

\section{DRY - Don't repeat yourself}\label{dry---dont-repeat-yourself}

Many Rails programmers are big fans of DRY. DRY means purely and simply that you should try to place repeated programming logic into separate methods.

\section{Refactoring}\label{refactoring}

You often hear the word refactoring in the context of DRY. This involves functioning applications that are further improved. The application in itself remains unchanged in its interface. But its core is optimized, amongst others through DRY.

\section{Convention Over Configuration}\label{convention-over-configuration}

Convention over configuration (also known as coding by convention, see \url{http://en.wikipedia.org/wiki/Convention_over_configuration}\{.uri\}) is an important pillar of a Rails application. It states that the programmer does not need to decide in favour of certain features when starting a project and set these via configuration parameters. It specifies an underlying basic consensus and this is set by default. But if you want to work outside of this conventional basic consensus, then you will need to change the corresponding parameters.

\chap{ActiveRecord}\label{activerecord}

\texttt{ActiveRecord} is a level of abstraction that offers access to a SQL database. \texttt{ActiveRecord} implements the architectural pattern \emph{Active Record} \textsuperscript{{[}\hyperref[ftn.idp2940224]{9}{]}}.

\section{Note}\label{note-20}

This is referred to as \emph{object-relational mapping}, \emph{ORM}. I find it rather dry and boring, but in case you have trouble going to sleep tonight, have a look at \url{http://en.wikipedia.org/wiki/Object_relational_mapping}\{.uri\}.

One of the recipes for the success of Rails is surely the fact that is uses \texttt{ActiveRecord}. The programming and use “feels Ruby like” and it is much less susceptible to errors than pure SQL. When working with this chapter, it helps if you have some knowledge of SQL, but this is not required and also not essential for working with \texttt{ActiveRecord}.

Just as an aside, let me mention that you are not obliged to work with ActiveRecord when working with Rails. You can also use other ORMs. ActiveRecord is the default and is used by the majority of all Rails developers.

\section{Howto for this Chapter}\label{howto-for-this-chapter}

This chapter is a self-contained unit. But the knowledge provided in \hyperref[ruby-grundlagen]{Chapter~2, \emph{Ruby Basics}} and \hyperref[ersteux5fschritteux5fmitux5frails]{Chapter~3, \emph{First Steps with Rails}} is required. Without these basics, you will not have any fun with this chapter!

Rails newbies should read this chapter once from beginning to end. Please take your time. This chapter is important!

\subsection{Note}\label{note-21}

This chapter is only about ActiveRecord. So I am not going to integrate any tests (see \hyperref[testing]{Chapter~7, \emph{Tests}}), to keep the examples as simple as possible.

\section{Not in the Mood for SQL?}\label{not-in-the-mood-for-sql}

Occasionally, I will discuss SQL code created by ActiveRecord methods. If you are not interested in SQL: just read over it and don't worry. The beauty of ActiveRecord is that you do not need to think about it. For everyone else, my comments provide better understanding of the optimization processes going on in the background.

\section{Creating Database/“Model”}\label{creating-databasemodel}

\subsection{Note}\label{note-22}

\emph{Model} in this context refers to the data model of \emph{Model-View-Controller} (MVC).

As a first example, let's take a list of countries in Europe. First, we create a new Rails project:

\begin{shaded}\begin{verbatim}
$ rails new europe
  [...]
$ cd europe
$
\end{verbatim}\end{shaded}

Next, let's have a look at the help page for \textbf{rails generate model}:

\begin{shaded}\begin{verbatim}
$ rails generate model
Usage:
  rails generate model NAME [field[:type][:index] field[:type][:index]] [options]

Options:
      [--skip-namespace]  ## Skip namespace (affects only isolated applications)
  -o, --orm=NAME          # Orm to be invoked
                          # Default: active_record

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
      [--indexes]              # Add indexes for references and belongs_to columns
                               # Default: true
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Suppress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Stubs out a new model. Pass the model name, either CamelCased or
    under_scored, and an optional list of attribute pairs as arguments.

    Attribute pairs are field:type arguments specifying the
    model's attributes. Timestamps are added by default, so you don't have to
    specify them by hand as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the model immediately.

    This generator invokes your configured ORM and test framework, which
    defaults to ActiveRecord and TestUnit.

    Finally, if --parent option is given, it's used as superclass of the
    created model. This allows you create Single Table Inheritance models.

    If you pass a namespaced model name (e.g. admin/account or Admin::Account)
    then the generator will create a module with a table_name_prefix method
    to prefix the model's table name with the module name (e.g. admin_account)

Available field types:

    Just after the field name you can specify a type like text or boolean.
    It will generate the column with the associated SQL type. For instance:

        `rails generate model post title:string body:text`

    will generate a title column with a varchar type and a body column with a text
    type. You can use the following types:

        integer
        primary_key
        decimal
        float
        boolean
        binary
        string
        text
        date
        time
        datetime
        timestamp

    You can also consider `references` as a kind of type. For instance, if you run:

        `rails generate model photo title:string album:references`

    It will generate an album_id column. You should generate this kind of fields when
    you will use a `belongs_to` association for instance. `references` also support
    the polymorphism, you could enable the polymorphism like this:

        `rails generate model product supplier:references{polymorphic}`

    For integer, string, text and binary fields an integer in curly braces will
    be set as the limit:

        `rails generate model user pseudo:string{30}`

    For decimal two integers separated by a comma in curly braces will be used
    for precision and scale:

        `rails generate model product price:decimal{10,2}`

    You can add a `:uniq` or `:index` suffix for unique or standard indexes
    respectively:

        `rails generate model user pseudo:string:uniq`
        `rails generate model user pseudo:string:index`

    You can combine any single curly brace option with the index options:

        `rails generate model user username:string{30}:uniq`
        `rails generate model product supplier:references{polymorphic}:index`


Examples:
    `rails generate model account`

        For ActiveRecord and TestUnit it creates:

            Model:      app/models/account.rb
            Test:       test/models/account_test.rb
            Fixtures:   test/fixtures/accounts.yml
            Migration:  db/migrate/XXX_create_accounts.rb

    `rails generate model post title:string body:text published:boolean`

        Creates a Post model with a string title, text body, and published flag.

    `rails generate model admin/account`

        For ActiveRecord and TestUnit it creates:

            Module:     app/models/admin.rb
            Model:      app/models/admin/account.rb
            Test:       test/models/admin/account_test.rb
            Fixtures:   test/fixtures/admin/accounts.yml
            Migration:  db/migrate/XXX_create_admin_accounts.rb

$
\end{verbatim}\end{shaded}

The usage description \texttt{rails generate model NAME   {[}field{[}:type{]}{[}:index{]} field{[}:type{]}{[}:index{]}{]} {[}options{]}} tells us that after \texttt{rails generate model} comes the name of the model and then the table fields. If you do not put \texttt{:type} after a table field name, it is assumed to be a string by default. Let's create the \emph{model} \texttt{country}:

\begin{shaded}\begin{verbatim}
$ rails generate model Country name population:integer
      invoke  active_record
      create    db/migrate/20130715174248_create_countries.rb
      create    app/models/country.rb
      invoke    test_unit
      create      test/models/country_test.rb
      create      test/fixtures/countries.yml
$
\end{verbatim}\end{shaded}

The generator has created a database migration file with the name \texttt{db/migrate/20130715174248\_create\_countries.rb}. It provides the following code:

\begin{shaded}\begin{verbatim}
class CreateCountries < ActiveRecord::Migration
  def change
    create_table :countries do |t|
      t.string :name
      t.integer :population

      t.timestamps
    end
  end
end
\end{verbatim}\end{shaded}

A migration contains database changes. In this migration, a class \texttt{CreateCountries} is defined as a child of \texttt{ActiveRecord::Migration}. The class method \texttt{change} is used to define a migration and the associated roll-back.

With \textbf{rake db:migrate} we can apply the migrations, in other words, create the corresponding database table:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
==  CreateCountries: migrating ================================================
-- create_table(:countries)
   -> 0.0010s
==  CreateCountries: migrated (0.0011s) =======================================

$
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-23}

You will find more details on migrations in \hyperref[activerecordux5fmigration]{the section called “Migrations”}.

Let's have a look at the file \texttt{app/models/country.rb}:

\begin{shaded}\begin{verbatim}
class Country < ActiveRecord::Base
end
\end{verbatim}\end{shaded}

Hmmm \ldots{} the class \texttt{Country} is a child of \texttt{ActiveRecord::Base}. Makes sense, as we are discussing ActiveRecord in this chapter. ;-)

\subsection{The Attributes id, created\_at and updated\_at}\label{the-attributes-id-createdux5fat-and-updatedux5fat}

Even if you cannot see it in the migration, we also get the attributes \texttt{id}, \texttt{created\_at} und \texttt{updated\_at} by default for each ActiveRecord model. In the Rails console, we can output the attributes of the class \texttt{Country} by entering the class name:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Country
=> Country(id: integer, name: string, population: integer, created_at: datetime, updated_at: datetime)
>> exit
$
\end{verbatim}\end{shaded}

The attribute \texttt{created\_at} stores the time when the record was initially created. \texttt{updated\_at} shows the time of the last update for this record.

\texttt{id} is used a central identification of the record (primary key). The \texttt{id} is automatically incremented by 1 for each record.

\subsection{Getters and Setters}\label{getters-and-setters-1}

To read and write values of a SQL table row you can use by ActiveRecord provided getters and setters (\hyperref[rubyux5fgetterux5fandux5fsetter]{the section called “Getters and Setters”}). These attr\_accessors are automatically created. The getter of the field \texttt{updated\_at} for a given \texttt{Country} with the name \texttt{germany} would be \texttt{germany.updated\_at}.

\subsection{Possible Data Types in ActiveRecord}\label{possible-data-types-in-activerecord}

ActiveRecord is a \emph{layer} between Ruby and various relational databases. Unfortunately, many SQL databases have different perspectives regarding the definition of columns and their content. But you do not need to worry about this, because ActiveRecord solves this problem transparently for you.

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Advantage: We can replace the database behind a Rails application without having to touch the program code.
\item
  Disadvantage: We cannot use all the features of the database concerned. We have to use the least common denominator, so to speak.
\end{itemize}

To generate a \emph{model}, you can use the following field types:

\begin{itemize}
\item
  \texttt{binary} This is a BLOB (\emph{Binary Large Object}) in the classical sense. Never heard of it? Then you probably won't need it. See also \url{http://en.wikipedia.org/wiki/Binary_large_object}\{.uri\}
\item
  \texttt{boolean} A Boolean value. Can be either \texttt{true} or \texttt{false}. See also \url{http://en.wikipedia.org/wiki/Boolean_data_type}\{.uri\}
\item
  \texttt{date} You can store a date here.
\item
  \texttt{datetime} Here you can store a date including a time.
\item
  \texttt{float} For storing a floating point number. See also \url{http://en.wikipedia.org/wiki/Floating_point}\{.uri\}
\item
  \texttt{integer} For storing an integer. See also \url{http://en.wikipedia.org/wiki/Integer_(computer_science)}\{.uri\}
\item
  \texttt{decimal}

  For storing a decimal number.

  \subsection{Tip}\label{tip-6}

  You can also enter a decimal directly with the model generator. But you need to observe the special syntax. Example for creating a price with a decimal:

\begin{shaded}\begin{verbatim}
$ rails generate model product name 'price:decimal{7,2}'
      invoke  active_record
      create    db/migrate/20121114110808_create_products.rb
      create    app/models/product.rb
      invoke    test_unit
      create      test/unit/product_test.rb
      create      test/fixtures/products.yml
$
\end{verbatim}\end{shaded}

  That would generate the following migration (\texttt{db/migrate/20121114110808\_create\_products.rb}):

\begin{shaded}\begin{verbatim}
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.decimal :price, :precision => 7, :scale => 2

      t.timestamps
    end
  end
end
\end{verbatim}\end{shaded}
\item
  \texttt{primary\_key} This is an integer that is automatically incremented by 1 by the database for each new entry. This field type is often used as key for linking different database tables or \emph{models}. See also \url{http://en.wikipedia.org/wiki/Unique_key}\{.uri\}
\item
  \texttt{string} A string, in other words a sequence of any characters, up to a maximum of 2\textsuperscript{8}-1 (= 255) characters. See also \url{http://en.wikipedia.org/wiki/String_(computer_science)}\{.uri\}
\item
  \texttt{text} Also a string - but considerably bigger. By default, up to 2\textsuperscript{16} (=

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi})}
  \setcounter{enumi}{65535}
  \itemsep1pt\parskip0pt\parsep0pt
  \item
    characters can be saved here.
  \end{enumerate}
\item
  \texttt{time} A time.
\item
  \texttt{timestamp} A time with date, filled in automatically by the database.
\end{itemize}

In \hyperref[activerecordux5fmigration]{the section called “Migrations”} we will provide more information on the individual data types and discuss available options. Don't forget, this is a book for beginners, so this section just gives a brief overview. If you want to find out more about the various datatypes, please refer to the documentation listed in \hyperref[weiterfuehrendeux5fdoku]{Appendix~A, \emph{Further Rails Documentation}}.

\section{Naming Conventions (Country vs.~country vs.~countries)}\label{naming-conventions-country-vs.country-vs.countries}

Rails newbies often find it hard to figure out when to use upper and lower case, for example, \texttt{Country} or \texttt{country} (one is a class, the other one a model). The problem is usually not the class itself, but purely the spelling or wording. For now, let's just say: it's all very logical and you will quickly get the hang of it. The important thing is that you keep using English words, even if you would normally be programming in another language (see \hyperref[warumux5fenglish]{the section called “Why Is It All in English?”}).

Originally, my plan was to now start philosophizing at great length on naming conventions. But then I thought: “Jeez, the readers want to get going and not sit here for ages reading about theory.” So I am now going to introduce the methods with which you can find out the naming conventions yourself in the Rails \emph{console}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> 'country'.classify
=> "Country"
>> 'country'.tableize
=> "countries"
>> 'country'.foreign_key
=> "country_id"
>>
\end{verbatim}\end{shaded}

ActiveRecord automatically uses the English plural forms. So for the class \texttt{Country}, it's \texttt{countries}. If you are not sure about a term, you can also work with the class and method \texttt{name}.

\begin{shaded}\begin{verbatim}
>> Country.name.tableize
=> "countries"
>> Country.name.foreign_key
=> "country_id"
>> exit
$
\end{verbatim}\end{shaded}

You will find a complete list of the corresponding methods at \url{http://rails.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html}\{.uri xml:lang=“en” lang=“en”\}. But I would recommend that, for now, you just go with the flow. If you are not sure, you can find out the correct notation with the methods shown above.

\subsection{Database Configuration}\label{database-configuration}

Which database is used by default? Let's have a quick look at the configuration file for the database (\texttt{config/database.yml}):

\begin{shaded}\begin{verbatim}
### SQLite version 3.x
##   gem install sqlite3
###
###   Ensure the SQLite 3 gem is defined in your Gemfile
###   gem 'sqlite3'
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

### Warning: The database defined as "test" will be erased and
### re-generated from your development database when you run "rake".
### Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
\end{verbatim}\end{shaded}

As we are working in \texttt{development} mode, Rails has created a new SQLite3 database \texttt{db/development.sqlite3} as a result of \textbf{rake db:migrate} and saved all data there.

Fans of command line clients can use \texttt{sqlite3} for viewing this database:

\begin{shaded}\begin{verbatim}
$ sqlite3 db/development.sqlite3
SQLite version 3.7.12 2012-04-03 19:43:07
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> .tables
countries          schema_migrations
sqlite> .schema countries
CREATE TABLE "countries" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(255), "population" integer, "created_at" datetime, "updated_at" datetime);
sqlite> .exit
$
\end{verbatim}\end{shaded}

\subsection{Adding Records}\label{adding-records}

Actually, I would like to show you first how to view records, but there we have another chicken and egg problem. So first, here is how you can create a new record with \texttt{ActiveRecord}.

\subsection{create}\label{create}

The most frequently used method for creating a new record is \texttt{create}. Let's try creating a country in the console with the command \textbf{Country.create(name: `Germany', population: 81831000)}

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Country.create(name: 'Germany', population: 81831000)
   (0.1ms)  begin transaction
  SQL (5.8ms)  INSERT INTO "countries" ("created_at", "name", "population", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 15 Jul 2013 17:58:19 UTC +00:00], ["name", "Germany"], ["population", 81831000], ["updated_at", Mon, 15 Jul 2013 17:58:19 UTC +00:00]]
   (1.0ms)  commit transaction
=> #<Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 17:58:19", updated_at: "2013-07-15 17:58:19">
>> exit
$
\end{verbatim}\end{shaded}

ActiveRecord saves the new record and outputs the executed SQL command in the development environment. But to make absolutely sure it works, let's have a quick look with the command line client \texttt{sqlite3}:

\begin{shaded}\begin{verbatim}
$ sqlite3 db/development.sqlite3
SQLite version 3.7.12 2012-04-03 19:43:07
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> SELECT * FROM countries;
1|Germany|81831000|2013-07-15 17:58:19.600948|2013-07-15 17:58:19.600948
sqlite> .exit
$
\end{verbatim}\end{shaded}

\subsection{Syntax}\label{syntax-1}

The method \texttt{create} can handle a number of different syntax constructs. If you want to create a single record, you can do this with or without \{\}-brackets within the the ()-brackets:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{Country.create(name: 'Germany', population:             81831000)}
\item
  \texttt{Country.create(\{name: 'Germany', population:             81831000\})}
\end{itemize}

Similarly, you can describe the attributes differently:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{Country.create(:name =\textgreater{} 'Germany', :population             =\textgreater{} 81831000)}
\item
  \texttt{Country.create('name' =\textgreater{} 'Germany', 'population'             =\textgreater{} 81831000)}
\item
  \texttt{Country.create( name: 'Germany', population: 81831000             )}
\end{itemize}

You can also pass an array of hashes to \texttt{create} and use this approach to create several records at once:

\begin{shaded}\begin{verbatim}
Country.create([{name: 'Germany'}, {name: 'France'}])
\end{verbatim}\end{shaded}

\subsection{new}\label{new}

In addition to \texttt{create} there is also \texttt{new}. But you have to use \texttt{save} to save an object created with \texttt{new} (which has both advantages and disadvantages):

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> france = Country.new
=> #<Country id: nil, name: nil, population: nil, created_at: nil, updated_at: nil>
>> france.name = 'France'
=> "France"
>> france.population = 65447374
=> 65447374
>> france.save
   (0.2ms)  begin transaction
  SQL (2.3ms)  INSERT INTO "countries" ("created_at", "name", "population", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 15 Jul 2013 18:07:03 UTC +00:00], ["name", "France"], ["population", 65447374], ["updated_at", Mon, 15 Jul 2013 18:07:03 UTC +00:00]]
   (3.0ms)  commit transaction
=> true
>> france
=> #<Country id: 2, name: "France", population: 65447374, created_at: "2013-07-15 18:07:03", updated_at: "2013-07-15 18:07:03">
>>
\end{verbatim}\end{shaded}

You can also pass parameters for the new record directly to the method \texttt{new}, just as with \texttt{create}:

\begin{shaded}\begin{verbatim}
>> belgium = Country.new(name: 'Belgium', population: 10839905)
=> #<Country id: nil, name: "Belgium", population: 10839905, created_at: nil, updated_at: nil>
>> belgium.save
   (0.2ms)  begin transaction
  SQL (1.3ms)  INSERT INTO "countries" ("created_at", "name", "population", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 15 Jul 2013 18:08:07 UTC +00:00], ["name", "Belgium"], ["population", 10839905], ["updated_at", Mon, 15 Jul 2013 18:08:07 UTC +00:00]]
   (2.1ms)  commit transaction
=> true
>> exit
$
\end{verbatim}\end{shaded}

\section{new\_record?}\label{newux5frecord}

With the method \texttt{new\_record?} you can find out if a record has already been saved or not. If a new object has been created with \texttt{new} and not yet been saved, then the result of \texttt{new\_record?} is \texttt{true}. After a \texttt{save} it is \texttt{false}.

Example:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> netherlands = Country.new(name: 'Netherlands')
=> #<Country id: nil, name: "Netherlands", population: nil, created_at: nil, updated_at: nil>
>> netherlands.new_record?
=> true
>> netherlands.save
   (0.2ms)  begin transaction
  SQL (2.3ms)  INSERT INTO "countries" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Mon, 15 Jul 2013 18:08:52 UTC +00:00], ["name", "Netherlands"], ["updated_at", Mon, 15 Jul 2013 18:08:52 UTC +00:00]]
   (3.1ms)  commit transaction
=> true
>> netherlands.new_record?
=> false
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Tip}\label{tip-7}

For already existing records, you can also check for changes with the method \texttt{changed?} (see \hyperref[activerecordux5fchanged]{the section called “changed?”}).

\section{first, last and all}\label{first-last-and-all}

In certain cases, you may need the first record, or the last one, or perhaps even all records. Conveniently, there is a ready-made method for each case. Let's start with the easiest ones: \texttt{first} and \texttt{last}.

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Country.first
  Country Load (0.1ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=> #<Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20">
>> Country.last
  Country Load (0.3ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" DESC LIMIT 1
=> #<Country id: 4, name: "Netherlands", population: nil, created_at: "2013-07-15 18:08:52", updated_at: "2013-07-15 18:08:52">
>>
\end{verbatim}\end{shaded}

And now all at once with \texttt{all}:

\begin{shaded}\begin{verbatim}
>> Country.all
  Country Load (0.2ms)  SELECT "countries".* FROM "countries"
=> #<ActiveRecord::Relation [#<Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20">, #<Country id: 2, name: "France", population: 65447374, created_at: "2013-07-15 18:07:03", updated_at: "2013-07-15 18:07:03">, #<Country id: 3, name: "Belgium", population: 10839905, created_at: "2013-07-15 18:08:07", updated_at: "2013-07-15 18:08:07">, #<Country id: 4, name: "Netherlands", population: nil, created_at: "2013-07-15 18:08:52", updated_at: "2013-07-15 18:08:52">]>
>>
\end{verbatim}\end{shaded}

But the objects created by \texttt{first}, \texttt{last} and \texttt{all} are different. \texttt{first} and \texttt{last} return an object of the class \texttt{Country} and \texttt{all} of course returns an array of such objects:

\begin{shaded}\begin{verbatim}
>> Country.first.class
  Country Load (0.3ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=> Country(id: integer, name: string, population: integer, created_at: datetime, updated_at: datetime)
>> Country.all.class
=> ActiveRecord::Relation::ActiveRecord_Relation_Country
>>
\end{verbatim}\end{shaded}

So \texttt{Country.first} is a \texttt{Country} which makes sense. But \texttt{Country.all} is something we haven't had yet. Let's use the console to get a better idea of it:

\begin{shaded}\begin{verbatim}
>> puts Country.all.to_yaml
  Country Load (0.4ms)  SELECT "countries".* FROM "countries"
---
- !ruby/object:Country
  attributes:
    id: 1
    name: Germany
    population: 81831000
    created_at: 2013-07-15 18:03:20.814776000 Z
    updated_at: 2013-07-15 18:03:20.814776000 Z
- !ruby/object:Country
  attributes:
    id: 2
    name: France
    population: 65447374
    created_at: 2013-07-15 18:07:03.227571000 Z
    updated_at: 2013-07-15 18:07:03.227571000 Z
- !ruby/object:Country
  attributes:
    id: 3
    name: Belgium
    population: 10839905
    created_at: 2013-07-15 18:08:07.125974000 Z
    updated_at: 2013-07-15 18:08:07.125974000 Z
- !ruby/object:Country
  attributes:
    id: 4
    name: Netherlands
    population:
    created_at: 2013-07-15 18:08:52.736007000 Z
    updated_at: 2013-07-15 18:08:52.736007000 Z
=> nil
>>
\end{verbatim}\end{shaded}

hmmm\ldots{} by using the \texttt{to\_yaml} method suddenly the database has work to do. The reason for this behavior is optimization. Let's assume that you want to chain a couple of methods. Than it might be better for ActiveRecord to wait till the very last second which it does. It only requests the data from the SQL database when it has to do it. Until than it stores the request in a \texttt{ActiveRecord::Relation}.

The result of \texttt{Country.all} is actually an \texttt{Array} of \texttt{Country}.

If \texttt{Country.all} returns an array, then we should also be able to use iterators (see \hyperref[iterator]{the section called “Iterators”} and \hyperref[arrayux5fiterator]{the section called “Iterator each”}), right? Yes, of course! That is the beauty of it. Here is a little experiment with \texttt{each}:

\begin{shaded}\begin{verbatim}
>> Country.all.each do |country|
?> puts country.name
>> end
  Country Load (0.3ms)  SELECT "countries".* FROM "countries"
Germany
France
Belgium
Netherlands
=> [#<Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20">, #<Country id: 2, name: "France", population: 65447374, created_at: "2013-07-15 18:07:03", updated_at: "2013-07-15 18:07:03">, #<Country id: 3, name: "Belgium", population: 10839905, created_at: "2013-07-15 18:08:07", updated_at: "2013-07-15 18:08:07">, #<Country id: 4, name: "Netherlands", population: nil, created_at: "2013-07-15 18:08:52", updated_at: "2013-07-15 18:08:52">]
>>
\end{verbatim}\end{shaded}

So can we also use \texttt{.all.first} as an alternative for \texttt{.first}? Yes, but it does not make much sense. Have a look for yourself:

\begin{shaded}\begin{verbatim}
>> Country.first
  Country Load (0.3ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=> #<Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20">
>> Country.all.first
  Country Load (0.4ms)  SELECT "countries".* FROM "countries" ORDER BY "countries"."id" ASC LIMIT 1
=> #<Country id: 1, name: "Germany", population: 81831000, created_at: "2013-07-15 18:03:20", updated_at: "2013-07-15 18:03:20">
>>
\end{verbatim}\end{shaded}

\texttt{Country.first} and \texttt{Country.all.first} result in exact the same SQL query.

\section{Populating the Database with seeds.rb}\label{populating-the-database-with-seeds.rb}

With the file \texttt{db/seeds.rb}, the Rails gods have given us a way of feeding default values easily and quickly to a fresh installation. This is a normal Ruby program within the Rails environment. You have full access to all classes and methods of your application.

So you do not need to enter everything manually with \textbf{rails console} in order to make the records created in \hyperref[activerecordux5fcreate]{the section called “create”} available in a new Rails application, but you can simply use the following file \texttt{db/seeds.rb}:

\begin{shaded}\begin{verbatim}
Country.create(name: 'Germany', population: 81831000)
Country.create(name: 'France', population: 65447374)
Country.create(name: 'Belgium', population: 10839905)
Country.create(name: 'Netherlands', population: 16680000)
\end{verbatim}\end{shaded}

You then populate it with data via \textbf{rake db:seed}. To be on the safe side, you should always set up the database from scratch with \textbf{rake db:setup} in the context of this book and then automatically populate it with the file \texttt{db/seeds.rb}. Here is what is looks like:

\begin{shaded}\begin{verbatim}
$ rake db:setup
db/development.sqlite3 already exists
-- create_table("countries", {:force=>true})
   -> 0.0101s
-- create_table("products", {:force=>true})
   -> 0.0030s
-- initialize_schema_migrations_table()
   -> 0.0010s
$
\end{verbatim}\end{shaded}

I use the file \texttt{db/seeds.rb} at this point because it offers a simple mechanism for filling an empty database with default values. In the course of this book, this will make it easier for us to set up quick example scenarios.

\subsection{It's all just Ruby code}\label{its-all-just-ruby-code}

The \texttt{db/seeds.rb} is a Ruby program. Correspondingly, we can also use the following approach as an alternative:

\begin{shaded}\begin{verbatim}
country_list = [
  [ "Germany", 81831000 ],
  [ "France", 65447374 ],
  [ "Belgium", 10839905 ],
  [ "Netherlands", 16680000 ]
]

country_list.each do |name, population|
  Country.create( name: name, population: population )
end
\end{verbatim}\end{shaded}

The result is the same. I am showing you this example to make it clear that you can program completely normally within the file \texttt{db/seeds.rb}.

\subsection{Generating seeds.rb From Existing Data}\label{generating-seeds.rb-from-existing-data}

Sometimes it can be useful to export the current data pool of a Rails application into a \texttt{db/seeds.rb}. While writing this book, I encountered this problem in almost every chapter. Unfortunately, there is no standard approach for this. I am showing you what you can do in this case. There are other, more complex scenarios that can be derived from my approach.

We create our own little rake task for that. That can be done by creating the file \texttt{lib/tasks/export.rake} with the following content:

\begin{shaded}\begin{verbatim}
namespace :export do
  desc "Prints Country.all in a seeds.rb way."
  task :seeds_format => :environment do
    Country.order(:id).all.each do |country|
      puts "Country.create(#{country.serializable_hash.delete_if {|key, value| ['created_at','updated_at','id'].include?(key)}.to_s.gsub(/[{}]/,'')})"
    end
  end
end
\end{verbatim}\end{shaded}

Then you can call the corresponding rake task with the command \textbf{rake export:seeds\_format}:

\begin{shaded}\begin{verbatim}
$ rake export:seeds_format
Country.create("name"=>"Germany", "population"=>81831000)
Country.create("name"=>"France", "population"=>65447374)
Country.create("name"=>"Belgium", "population"=>10839905)
Country.create("name"=>"Netherlands", "population"=>16680000)
$
\end{verbatim}\end{shaded}

You can either expand this program so that the output is written directly into the \texttt{db/seeds.rb} or you can simply use the shell:

\begin{shaded}\begin{verbatim}
$ rake export:seeds_format > db/seeds.rb
$
\end{verbatim}\end{shaded}

\subsection{Searching and Finding with Queries}\label{searching-and-finding-with-queries}

The methods \texttt{first} and \texttt{all} are already quite nice, but usually you want to search for something specific with a query.

For describing queries, we create a new Rails project:

\begin{shaded}\begin{verbatim}
$ rails new jukebox
  [...]
$ cd jukebox
$ rails generate model Album name release_year:integer
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

For the examples uses here, use a \texttt{db/seeds.rb} with the following content:

\begin{shaded}\begin{verbatim}
Album.create(name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967)
Album.create(name: "Pet Sounds", release_year: 1966)
Album.create(name: "Revolver", release_year: 1966)
Album.create(name: "Highway 61 Revisited", release_year: 1965)
Album.create(name: "Rubber Soul", release_year: 1965)
Album.create(name: "What's Going On", release_year: 1971)
Album.create(name: "Exile on Main St.", release_year: 1972)
Album.create(name: "London Calling", release_year: 1979)
Album.create(name: "Blonde on Blonde", release_year: 1966)
Album.create(name: "The Beatles", release_year: 1968)
\end{verbatim}\end{shaded}

Then, set up the new database with \textbf{rake db:setup}:

\begin{shaded}\begin{verbatim}
$ rake db:setup
db/development.sqlite3 already exists
-- create_table("albums", {:force=>true})
   -> 0.0085s
-- initialize_schema_migrations_table()
   -> 0.0010s
$
\end{verbatim}\end{shaded}

\subsection{find}\label{find}

The simplest case is searching for a record via a primary key (by default, the \texttt{id} field in the database table). If I know the ID of an object (here: a record line), then I can search for the individual object or several objects at once via the ID:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.find(2)
  Album Load (1.7ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 2]]
=> #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">
>> Album.find([1,3,7])
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" IN (1, 3, 7)
=> [#<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]
>>  
\end{verbatim}\end{shaded}

If you always want to have an array as result, you also always have to pass an array as parameter:

\begin{shaded}\begin{verbatim}
>> Album.find(5).class
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 5]]
=> Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime)
>> Album.find([5]).class
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 5]]
=> Array
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Warning}\label{warning-1}

The method\texttt{find} generates an exception if the ID you are searching for does not have a record in the database. If in doubt, you should use \texttt{where} (see \hyperref[activerecordux5fwhere]{the section called “where”}).

\section{where}\label{where}

With the method \texttt{where}, you can search for specific values in the database. Let's search for all albums from the year 1966:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1966)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
=> #<ActiveRecord::Relation [#<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> Album.where(release_year: 1966).count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE "albums"."release_year" = 1966
=> 3
>>
\end{verbatim}\end{shaded}

You can also use \texttt{where} to search for \emph{ranges} (see \hyperref[rangeux5fclass]{the section called “Range”}):

\begin{shaded}\begin{verbatim}
>> Album.where(release_year: 1960..1966)
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
=> #<ActiveRecord::Relation [#<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> Album.where(release_year: 1960..1966).count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
=> 5
>>
\end{verbatim}\end{shaded}

And you can also specify several search factors simultaneously, separated by commas:

\begin{shaded}\begin{verbatim}
>> Album.where(release_year: 1960..1966, id: 1..5)
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966) AND ("albums"."id" BETWEEN 1 AND 5)
=> #<ActiveRecord::Relation [#<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>>
\end{verbatim}\end{shaded}

Or an array of parameters:

\begin{shaded}\begin{verbatim}
>> Album.where(release_year: [1966, 1968])
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968)
=> #<ActiveRecord::Relation [#<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>>
\end{verbatim}\end{shaded}

The result of \texttt{where} is always an array. Even if it only contains one hit or if no hits are returned. If you are looking for the first hit, you need to combine the method \texttt{where} with the method \texttt{first}:

\begin{shaded}\begin{verbatim}
>> Album.where(release_year: [1966, 1968]).first
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968) ORDER BY "albums"."id" ASC LIMIT 1
=> #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">
>> Album.where(release_year: [1966, 1968]).first.class
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968) ORDER BY "albums"."id" ASC LIMIT 1
=> Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime)
>> exit
$
\end{verbatim}\end{shaded}

\subsection{SQL Queries with where}\label{sql-queries-with-where}

Sometimes there is no other way and you just have to define and execute your own SQL query. In ActiveRecord, there are two different ways of doing this. One \emph{sanitizes} each query before executing it and the other passes the query on to the SQL database 1 to 1 as it is. Normally, you should always use the sanitized version because otherwise you can easily fall victim to an \emph{SQL injection} attack (see \url{http://en.wikipedia.org/wiki/Sql_injection}\{.uri\}).

If you do not know much about SQL, you can safely skip this section. The SQL commands used here are not explained further.

\subsection{Sanitized Queries}\label{sanitized-queries}

In this variant, all dynamic search parts are replaced by a question mark as placeholder and only listed as parameters after the SQL string.

In this example, we are searching for all albums whose name contains the string “on”:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where( 'name like ?', '%on%' )
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE (name like '%on%')
=> #<ActiveRecord::Relation [#<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 8, name: "London Calling", release_year: 1979, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>>
\end{verbatim}\end{shaded}

Now the number of albums that were published from 1965 onwards:

\begin{shaded}\begin{verbatim}
>> Album.where( 'release_year > ?', 1964 ).count
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE (release_year > 1964)
=> 10
>>
\end{verbatim}\end{shaded}

The number of albums that are more recent than 1970 and whose name contains the string “on”:

\begin{shaded}\begin{verbatim}
>> Album.where( 'name like ? AND release_year > ?', '%on%', 1970 ).count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%' AND release_year > 1970)
=> 3
>>
\end{verbatim}\end{shaded}

If the variable \texttt{search\_string} contains the desired string, you can search for it as follows:

\begin{shaded}\begin{verbatim}
>> search_string = 'ing'
=> "ing"
>> Album.where( 'name like ?', "%#{search_string}%").count
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%ing%')
=> 2
>> exit
$
\end{verbatim}\end{shaded}

\subsection{“Dangerous” SQL Queries}\label{dangerous-sql-queries}

If you really know what you are doing, you can of course also define the SQL query completely and forego the \emph{sanitizing} of the query.

Let's count all albums whose name contain the string “on”:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where( "name like '%on%'" ).count
   (0.1ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%')
=> 5
>> exit
$
\end{verbatim}\end{shaded}

Please only use this variation if you know exactly what you are doing and once you have familiarized yourself with the topic SQL injections (see \url{http://en.wikipedia.org/wiki/Sql_injection}\{.uri\}).

\subsection{Lazy Loading}\label{lazy-loading}

Lazy Loading is a mechanism that only carries out a database query if the program flow cannot be realised without the result of this query. Until then, the query is saved as \texttt{ActiveRecord::Relation}. (Incidentally, the opposite of \emph{lazy loading} is referred to as \emph{eager loading}.)

Does it make sense in principle, but you are not sure what the point of it all is? Then let's cobble together a query where we nest several methods. In the following example, \texttt{a} is defined more and more closely and only at the end (when calling the method \texttt{all}) the database query would really be executed in a production system. With the method \texttt{to\_sql} you can display the current SQL query.

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> a = Album.where(release_year: 1965..1968)
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968)
=> #<ActiveRecord::Relation [#<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> a.class
=> ActiveRecord::Relation::ActiveRecord_Relation_Album
>> a = a.order(:release_year)
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968) ORDER BY "albums".release_year ASC
=> #<ActiveRecord::Relation [#<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> a = a.limit(3)
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968) ORDER BY "albums".release_year ASC LIMIT 3
=> #<ActiveRecord::Relation [#<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> exit
$
\end{verbatim}\end{shaded}

The console can be a bit tricky about this. It tries to help the developer by actually showing the result but in a non-console environment this would would only happen at the very last time.

\subsection{Automatic Optimization}\label{automatic-optimization}

One of the great advantages of \emph{lazy loading} is the automatic optimization of the SQL query through ActiveRecord.

Let's take the sum of all release years of the albums that came out in the 70s. Then we sort the albums alphabetically and then calculate the sum.

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1970..1979).sum(:release_year)
   (2.7ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
=> 5922
>> Album.where(release_year: 1970..1979).order(:name).sum(:release_year)
   (0.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
=> 5922
>> exit
$
\end{verbatim}\end{shaded}

Logically, the result is the same for both queries. But the interesting thing is that ActiveRecord uses the same SQL code for both queries. It has detected that \texttt{order} is completely irrelevant for \texttt{sum} and therefore taken it out altogether.

\paragraph{Note}\label{note-24}

In case you are asking yourself why the first query took 2.7ms and the second 0.2ms: ActiveRecord cached the results of the first SQL request.

\section{order and reverse\_order}\label{order-and-reverseux5forder}

To sort a database query, you can use the method \texttt{order}. Example: all albums from the 60s, sorted by name:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1960..1969).order(:name)
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY "albums".name ASC
=> #<ActiveRecord::Relation [#<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>>
\end{verbatim}\end{shaded}

With the method reverse\_order you can reverse an order previously defined via \texttt{order}:

\begin{shaded}\begin{verbatim}
>> Album.where(release_year: 1960..1969).order(:name).reverse_order
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY "albums".name DESC
=> #<ActiveRecord::Relation [#<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> exit
$
\end{verbatim}\end{shaded}

\section{limit}\label{limit}

The result of any search can be limited to a certain range via the method \texttt{limit}.

The first 5 albums from the 60s:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1960..1969).limit(5)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) LIMIT 5
=> #<ActiveRecord::Relation [#<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>>
\end{verbatim}\end{shaded}

All albums sorted by name, then the first 5 of those:

\begin{shaded}\begin{verbatim}
>> Album.order(:name).limit(5)
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" ORDER BY "albums".name ASC LIMIT 5
=> #<ActiveRecord::Relation [#<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 8, name: "London Calling", release_year: 1979, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> exit
$
\end{verbatim}\end{shaded}

\section{offset}\label{offset}

With the method \texttt{offset}, you can define the starting position of the method \texttt{limit}.

First, we return the first two records and then the first two records with an offset of 5:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.limit(2)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 2
=> #<ActiveRecord::Relation [#<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> Album.limit(2).offset(5)
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" LIMIT 2 OFFSET 5
=> #<ActiveRecord::Relation [#<Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> exit
$
\end{verbatim}\end{shaded}

\section{group}\label{group}

With the method \texttt{group}, you can return the result of a query in grouped form.

Let's return all albums, grouped by their release year:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.group(:release_year)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" GROUP BY release_year
=> #<ActiveRecord::Relation [#<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 8, name: "London Calling", release_year: 1979, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> exit
$
\end{verbatim}\end{shaded}

\subsection{pluck}\label{pluck}

Normally, ActiveRecord pulls all table columns from the database and leaves it up to the programmer to later pick out the components he is interested in. But in case of large amounts of data, it can be useful and above all much quicker to define a specific database field directly for the query. You can do this via the method \texttt{pluck}.

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1960..1969).pluck(:name)
   (0.1ms)  SELECT "albums"."name" FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> ["Sgt. Pepper's Lonely Hearts Club Band", "Pet Sounds", "Revolver", "Highway 61 Revisited", "Rubber Soul", "Blonde on Blonde", "The Beatles"]
>> Album.where(release_year: 1960..1969).pluck(:name, :release_year)
   (0.1ms)  SELECT "albums"."name", "albums"."release_year" FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> [["Sgt. Pepper's Lonely Hearts Club Band", 1967], ["Pet Sounds", 1966], ["Revolver", 1966], ["Highway 61 Revisited", 1965], ["Rubber Soul", 1965], ["Blonde on Blonde", 1966], ["The Beatles", 1968]]
>> exit
$
\end{verbatim}\end{shaded}

As a result, \texttt{pluck} returns an array.

\subsection{first\_or\_create and first\_or\_initialize}\label{firstux5forux5fcreate-and-firstux5forux5finitialize}

The methods \texttt{first\_or\_create} and \texttt{first\_or\_initialize} are create ways to search for a specific entry in your database or create one if the entry doesn't exist already. Both can be chained to a where search.

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(name: 'Test')
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'Test'
=> #<ActiveRecord::Relation []>
>> test = Album.where(name: 'Test').first_or_create
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'Test' ORDER BY "albums"."id" ASC LIMIT 1
   (0.1ms)  begin transaction
  SQL (5.0ms)  INSERT INTO "albums" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 08:00:59 UTC +00:00], ["name", "Test"], ["updated_at", Tue, 16 Jul 2013 08:00:59 UTC +00:00]]
   (3.7ms)  commit transaction
=> #<Album id: 11, name: "Test", release_year: nil, created_at: "2013-07-16 08:00:59", updated_at: "2013-07-16 08:00:59">
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Calculations}\label{calculations}

\subsection{average}\label{average}

With the method \texttt{average}, you can calculate the average of the values in a particular column of the table. Our data material is of course not really suited to this. But as an example, let's calculate the average release year of all albums and then the same for albums from the 60s:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.average(:release_year)
   (0.1ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums"
=> #<BigDecimal:7fbf9bbe1fb0,'0.19685E4',18(45)>
>> Album.average(:release_year).to_s
   (0.4ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums"
=> "1968.5"
>> Album.where( :release_year => 1960..1969 ).average(:release_year)
   (0.2ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> #<BigDecimal:7fbf9f002510,'0.1966142857 142857E4',27(45)>
>> Album.where( :release_year => 1960..1969 ).average(:release_year).to_s
   (0.3ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> "1966.142857142857"
>> exit
$
\end{verbatim}\end{shaded}

\subsection{count}\label{count}

The name says it all: the method \texttt{count} counts the number of records.

First, we return the number of all albums in the database and then the number of albums from the 60s:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.count
   (0.1ms)  SELECT COUNT(*) FROM "albums"
=> 10
>> Album.where(release_year: 1960..1969).count
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> 7
>> exit
$
\end{verbatim}\end{shaded}

\subsection{maximum}\label{maximum}

With the method \texttt{maximum}, you can output the item with the highest value within a query.

Let's look for the highest release year:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.maximum(:release_year)
   (0.1ms)  SELECT MAX("albums"."release_year") AS max_id FROM "albums"
=> 1979
>> exit
$
\end{verbatim}\end{shaded}

\subsection{minimum}\label{minimum}

With the method \texttt{minimum}, you can output the item with the lowest value within a query.

Let's find the lowest release year:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.minimum(:release_year)
   (0.1ms)  SELECT MIN("albums"."release_year") AS min_id FROM "albums"
=> 1965
>> exit
$
\end{verbatim}\end{shaded}

\subsection{sum}\label{sum}

With the method sum, you can calculate the sum of all items in a specific column of the database query.

Let's find the sum of all release years:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.sum(:release_year)
   (0.1ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums"
=> 19685
>> exit
$
\end{verbatim}\end{shaded}

\section{SQL EXPLAIN}\label{sql-explain}

Most SQL databases can provide detailled information on a SQL query with the command EXPLAIN. This does not make much sense for our mini application, but if you are working with a large database one day, then EXPLAIN is a good debugging method, for example to find out where to place an index. SQL EXPLAIN can be called with the method \texttt{explain} (it will be displayed in prettier form if you add a \texttt{puts}):

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1960..1969)
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> #<ActiveRecord::Relation [#<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 3, name: "Revolver", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">, #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">]>
>> Album.where(release_year: 1960..1969).explain
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
=> EXPLAIN for: SELECT "albums".* FROM "albums"  WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
0|0|0|SCAN TABLE albums (~500000 rows)

>> exit
$
\end{verbatim}\end{shaded}

\subsection{Batches}\label{batches}

ActiveRecord stores the results of a query in Memory. With very large tables and results that can become a performance issue. To address this you can use the find\_each method which splits up the query into batches with the size of 1,000 (can be configured with the \texttt{:batch\_size} option). Our example Album table is too small to show the effect but the method would be used like this:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Album.where(release_year: 1960..1969).find_each do |album|
?> puts album.name.upcase
>> end
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY "albums"."id" ASC LIMIT 1000
SGT. PEPPER'S LONELY HEARTS CLUB BAND
PET SOUNDS
REVOLVER
HIGHWAY 61 REVISITED
RUBBER SOUL
BLONDE ON BLONDE
THE BEATLES
=> nil
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Editing a Record}\label{editing-a-record}

Adding data is quite nice, but often you want to edit a record. To show how that's done I use the album database from \hyperref[queries]{the section called “Searching and Finding with Queries”}.

\section{Simple Editing}\label{simple-editing}

Simple editing of a record takes place in the following steps:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\itemsep1pt\parskip0pt\parsep0pt
\item
  Finding the record and creating a corresponding instance
\item
  Changing the attribute
\item
  Saving the record via the method \texttt{save}
\end{enumerate}

We are now searching for the album “The Beatles” and changing its name to “A Test”:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> beatles_album = Album.where(name: 'The Beatles').first
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'The Beatles' ORDER BY "albums"."id" ASC LIMIT 1
=> #<Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">
>> beatles_album.name
=> "The Beatles"
>> beatles_album.name = 'A Test'
=> "A Test"
>> beatles_album.save
   (0.2ms)  begin transaction
  SQL (2.1ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 10  [["name", "A Test"], ["updated_at", Tue, 16 Jul 2013 08:08:00 UTC +00:00]]
   (2.6ms)  commit transaction
=> true
>> exit
$
\end{verbatim}\end{shaded}

\section{changed?}\label{changed}

If you are not sure if a record has been changed and not yet saved, you can check via the method \texttt{changed?}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> beatles_album = Album.where(id: 10).first
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = 10 ORDER BY "albums"."id" ASC LIMIT 1
=> #<Album id: 10, name: "A Test", release_year: 1968, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-16 08:08:00">
>> beatles_album.changed?
=> false
>> beatles_album.name = 'The Beatles'
=> "The Beatles"
>> beatles_album.changed?
=> true
>> beatles_album.save
   (0.2ms)  begin transaction
  SQL (2.3ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 10  [["name", "The Beatles"], ["updated_at", Tue, 16 Jul 2013 08:23:52 UTC +00:00]]
   (2.9ms)  commit transaction
=> true
>> beatles_album.changed?
=> false
>> exit
$
\end{verbatim}\end{shaded}

\section{update\_attributes}\label{updateux5fattributes}

With the method \texttt{update\_attributes} you can change several attributes of an object in one go and then immediately save them automatically.

Let's use this method within the example used in \hyperref[activerecordux5feinfachesux5feditieren]{the section called “Simple Editing”}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> first_album = Album.first
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" ASC LIMIT 1
=> #<Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-15 18:59:50">
>> first_album.changed?
=> false
>> first_album.update_attributes(name: 'Another Test')
   (0.2ms)  begin transaction
  SQL (2.2ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 1  [["name", "Another Test"], ["updated_at", Tue, 16 Jul 2013 08:25:24 UTC +00:00]]
   (3.0ms)  commit transaction
=> true
>> first_album.changed?
=> false
>> Album.first
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" ASC LIMIT 1
=> #<Album id: 1, name: "Another Test", release_year: 1967, created_at: "2013-07-15 18:59:50", updated_at: "2013-07-16 08:25:24">
>>
\end{verbatim}\end{shaded}

This kind of update can also be chained with a \texttt{where} method:

\begin{shaded}\begin{verbatim}
>> Album.where(name: 'Another Test').first.update_attributes(name: "Sgt. Pepper's Lonely Hearts Club Band")
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'Another Test' ORDER BY "albums"."id" ASC LIMIT 1
   (0.1ms)  begin transaction
  SQL (0.9ms)  UPDATE "albums" SET "name" = ?, "updated_at" = ? WHERE "albums"."id" = 1  [["name", "Sgt. Pepper's Lonely Hearts Club Band"], ["updated_at", Tue, 16 Jul 2013 08:27:25 UTC +00:00]]
   (3.0ms)  commit transaction
=> true
>> exit
$
\end{verbatim}\end{shaded}

\section{Locking}\label{locking}

There are many ways of locking a database. By default, Rails uses “optimistic locking” of records. To activate locking you need to have an attribute with the name \texttt{lock\_version} which has to be an integer. To show how it works I'll create a new Rails project with a \texttt{Product} model. Than I'll try to change the price of the first \texttt{Product} on two different instances. The second change will raise an ActiveRecord::StaleObjectError.

Example setup:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$ rails generate model Product name 'price:decimal{8,2}' lock_version:integer
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Raising an ActiveRecord::StaleObjectError:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.create(name: 'Orange', price: 0.5)
   (0.1ms)  begin transaction
  SQL (4.7ms)  INSERT INTO "products" ("created_at", "lock_version", "name", "price", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 11:24:56 UTC +00:00], ["lock_version", 0], ["name", "Orange"], ["price", #<BigDecimal:7f958e0f5de0,'0.5E0',9(45)>], ["updated_at", Tue, 16 Jul 2013 11:24:56 UTC +00:00]]
   (3.2ms)  commit transaction
=> #<Product id: 1, name: "Orange", price: #<BigDecimal:7f958e0f5de0,'0.5E0',9(45)>, lock_version: 0, created_at: "2013-07-16 11:24:56", updated_at: "2013-07-16 11:24:56">
>> a = Product.first
  Product Load (0.3ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
=> #<Product id: 1, name: "Orange", price: #<BigDecimal:7f958d098768,'0.5E0',9(45)>, lock_version: 0, created_at: "2013-07-16 11:24:56", updated_at: "2013-07-16 11:24:56">
>> b = Product.first
  Product Load (0.4ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
=> #<Product id: 1, name: "Orange", price: #<BigDecimal:7f958e1268a0,'0.5E0',9(45)>, lock_version: 0, created_at: "2013-07-16 11:24:56", updated_at: "2013-07-16 11:24:56">
>> a.price = 0.6
=> 0.6
>> a.save
   (0.2ms)  begin transaction
   (0.5ms)  UPDATE "products" SET "price" = 0.6, "updated_at" = '2013-07-16 11:25:41.931401', "lock_version" = 1 WHERE ("products"."id" = 1 AND "products"."lock_version" = 0)
   (2.0ms)  commit transaction
=> true
>> b.price = 0.7
=> 0.7
>> b.save
   (0.1ms)  begin transaction
   (0.2ms)  UPDATE "products" SET "price" = 0.7, "updated_at" = '2013-07-16 11:25:49.170722', "lock_version" = 1 WHERE ("products"."id" = 1 AND "products"."lock_version" = 0)
   (0.1ms)  rollback transaction
ActiveRecord::StaleObjectError: Attempted to update a stale object: Product
[...]
>> exit
$
\end{verbatim}\end{shaded}

You have to deal with the conflict by rescuing the exception and fix the conflict depending on your business logic. Please make sure to add a \texttt{lock\_version} hidden field in your forms while using this mechanism with a WebGUI.

\subsection{has\_many -- 1:n Association}\label{hasux5fmany-1n-association}

In order to explain \texttt{has\_many}, let's create a bookshelf application. In this database, there is a model with books and a model with authors. As a book can have multiple authors, we need a 1:n association (\emph{one-to-many association}) to represent it.

\paragraph{Note}\label{note-25}

Associations are also sometimes referred to as \emph{relations} or \emph{relationships}.

First, we create a Rails application:

\begin{shaded}\begin{verbatim}
$ rails new bookshelf
  [...]
$ cd bookshelf
$
\end{verbatim}\end{shaded}

Now we create the model for the books:

\begin{shaded}\begin{verbatim}
$ rails generate model book title
  [...]
$
\end{verbatim}\end{shaded}

And finally, we create the database table for the authors. In this, we need an assignment field to the books table. This \emph{foreign key} is always set by default as name of the referenced object (here: \texttt{book}) with an attached \texttt{\_id}:

\begin{shaded}\begin{verbatim}
$ rails generate model author book_id:integer first_name last_name
  [...]
$
\end{verbatim}\end{shaded}

Then execute a \textbf{rake db:migrate} so that the database tables are actually created:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Let's have a look at this on the \emph{console}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book
=> Book(id: integer, title: string, created_at: datetime, updated_at: datetime)
>> Author
=> Author(id: integer, book_id: integer, first_name: string, last_name: string, created_at: datetime, updated_at: datetime)
>> exit
$
\end{verbatim}\end{shaded}

The two database tables are set up and can be used with ActiveRecord. But ActiveRecord does not yet know anything of the 1:n relation between them. But this can be done in two small steps.

First we add the line \texttt{has\_many :authors} in the \texttt{app/models/book.rb} file to set the 1:n relationship:

\begin{shaded}\begin{verbatim}
class Book < ActiveRecord::Base
  has_many :authors
end
\end{verbatim}\end{shaded}

Than we add \texttt{belongs\_to :book} in the \texttt{app/models/author.rb} file to get the other way around configured (this is not always needed but often comes in handy):

\begin{shaded}\begin{verbatim}
class Author < ActiveRecord::Base
  belongs_to :book
end
\end{verbatim}\end{shaded}

These two simple definitions form the basis for a good deal of ActiveRecord magic. It will generate a bunch of cool new methods for us to link both models.

\subsection{Creating Records}\label{creating-records}

In this example, we want to save a record for the book “Homo faber” by Max Frisch.

\subsection{Manually}\label{manually}

We drop the database with \textbf{rake db:reset}

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$  
\end{verbatim}\end{shaded}

Befor using the magic we'll insert a book with an author manually. For that we have to use the book's id in the \texttt{book\_id} attribute to create the author.

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> book = Book.create(title: 'Homo faber')
   (0.1ms)  begin transaction
  SQL (2.3ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 11:58:17 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 11:58:17 UTC +00:00]]
   (3.0ms)  commit transaction
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 11:58:17", updated_at: "2013-07-16 11:58:17">
>> author = Author.create(book_id: book.id, first_name: 'Max', last_name: 'Frisch')
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 11:58:21 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 11:58:21 UTC +00:00]]
   (3.1ms)  commit transaction
=> #<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 11:58:21", updated_at: "2013-07-16 11:58:21">
>> exit
$
\end{verbatim}\end{shaded}

Entering the \texttt{book\_id} manually in this way is of course not very practical and susceptible to errors. That's why there is the method \hyperref[activerecordux5fhasux5fmanyux5fcreate]{the section called “create”}.

\section{create}\label{create-1}

Now we try doing the same as in \hyperref[activerecordux5fhinzufuegenux5fmanuell]{the section called “Manually”}, but this time we use a bit of ActiveRecord magic. We can use the method \texttt{create} of \texttt{authors} to add new authors to each \texttt{Book} object. These automatically get the correct \texttt{book\_id}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$ rails console
Loading development environment (Rails 4.0.0)
>> book = Book.create(title: 'Homo faber')
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:01:01 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 12:01:01 UTC +00:00]]
   (3.1ms)  commit transaction
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 12:01:01", updated_at: "2013-07-16 12:01:01">
>> author = book.authors.create(first_name: 'Max', last_name: 'Frisch')
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 12:01:23 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 12:01:23 UTC +00:00]]
   (0.8ms)  commit transaction
=> #<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 12:01:23", updated_at: "2013-07-16 12:01:23">
>> exit
$
\end{verbatim}\end{shaded}

You could also place the \texttt{authors.create()} directly behind the \texttt{Book.create()}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:02:36 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 12:02:36 UTC +00:00]]
   (2.6ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 12:02:36 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 12:02:36 UTC +00:00]]
   (0.9ms)  commit transaction
=> #<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 12:02:36", updated_at: "2013-07-16 12:02:36">
>> exit
$
\end{verbatim}\end{shaded}

As \texttt{create} also accepts an array of hashes as an alternative to a single hash, you can also create multiple authors for a book in one go:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.create(title: 'Example').authors.create([{last_name: 'A'}, {last_name: 'B'}])
   (0.1ms)  begin transaction
  SQL (2.1ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:03:30 UTC +00:00], ["title", "Example"], ["updated_at", Tue, 16 Jul 2013 12:03:30 UTC +00:00]]
   (3.0ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "last_name", "updated_at") VALUES (?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 12:03:30 UTC +00:00], ["last_name", "A"], ["updated_at", Tue, 16 Jul 2013 12:03:30 UTC +00:00]]
   (0.8ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.3ms)  INSERT INTO "authors" ("book_id", "created_at", "last_name", "updated_at") VALUES (?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 12:03:30 UTC +00:00], ["last_name", "B"], ["updated_at", Tue, 16 Jul 2013 12:03:30 UTC +00:00]]
   (0.8ms)  commit transaction
=> [#<Author id: 1, book_id: 1, first_name: nil, last_name: "A", created_at: "2013-07-16 12:03:30", updated_at: "2013-07-16 12:03:30">, #<Author id: 2, book_id: 1, first_name: nil, last_name: "B", created_at: "2013-07-16 12:03:30", updated_at: "2013-07-16 12:03:30">]
>> exit
$
\end{verbatim}\end{shaded}

\section{build}\label{build}

The method \texttt{build} resembles \texttt{create}. But the record is not saved. This only happens after a \texttt{save}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$ rails console
Loading development environment (Rails 4.0.0)
>> book = Book.create(title: 'Homo faber')
   (0.1ms)  begin transaction
  SQL (24.5ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 18 Nov 2012 11:35:35 UTC +00:00], ["title", "Homo faber"], ["updated_at", Sun, 18 Nov 2012 11:35:35 UTC +00:00]]
   (3.0ms)  commit transaction
=> #<Book id: 1, title: "Homo faber", created_at: "2012-11-18 11:35:35", updated_at: "2012-11-18 11:35:35">
>> author = book.authors.build(first_name: 'Max', last_name: 'Frisch')
=> #<Author id: nil, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: nil, updated_at: nil>
>> author.new_record?
=> true
>> author.save
   (0.1ms)  begin transaction
  SQL (0.7ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 18 Nov 2012 11:36:12 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Sun, 18 Nov 2012 11:36:12 UTC +00:00]]
   (2.5ms)  commit transaction
=> true
>> author.new_record?
=> false
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Warning}\label{warning-2}

When using \texttt{create} and \texttt{build}, you of course have to observe logical dependencies, otherwise there will be an error. For example, you cannot chain two \texttt{build} methods. Example:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.build(title: 'Example').authors.build(last_name: 'A')
NoMethodError: undefined method `build' for #<Class:0x007fcc6ce71ab8>
[...]
>> exit
$
\end{verbatim}\end{shaded}

\section{Accessing Records}\label{accessing-records}

First we need example data. Please populate the file \texttt{db/seeds.rb} with the following content:

\begin{shaded}\begin{verbatim}
Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')
Book.create(title: 'Der Besuch der alten Dame').authors.create(first_name: 'Friedrich', last_name: 'Dürrenmatt')
Book.create(title: 'Julius Shulman: The Last Decade').authors.create([
  {first_name: 'Thomas', last_name: 'Schirmbock'},
  {first_name: 'Julius', last_name: 'Shulman'},
  {first_name: 'Jürgen', last_name: 'Nogai'}
  ])
Book.create(title: 'Julius Shulman: Palm Springs').authors.create([
  {first_name: 'Michael', last_name: 'Stern'},
  {first_name: 'Alan', last_name: 'Hess'}
  ])
Book.create(title: 'Photographing Architecture and Interiors').authors.create([
  {first_name: 'Julius', last_name: 'Shulman'},
  {first_name: 'Richard', last_name: 'Neutra'}
  ])
Book.create(title: 'Der Zauberberg').authors.create(first_name: 'Thomas', last_name: 'Mann')
Book.create(title: 'In einer Familie').authors.create(first_name: 'Heinrich', last_name: 'Mann')
\end{verbatim}\end{shaded}

Now drop the database and refill it with the \texttt{db/seeds.rb}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$
\end{verbatim}\end{shaded}

The convenient feature of the 1:n assignment in ActiveRecord is the particularly easy access to the n instances. Let's look at the first record:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.first
  Book Load (0.1ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT 1
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 12:05:49", updated_at: "2013-07-16 12:05:49">
>> Book.first.authors
  Book Load (0.3ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT 1
  Author Load (1.4ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 1]]
=> #<ActiveRecord::Associations::CollectionProxy [#<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">]>
>>
\end{verbatim}\end{shaded}

Isn't that cool?! You can access the records simply via the plural form of the n model. The result is returned as array. Hm, maybe it also works the other way round?

\begin{shaded}\begin{verbatim}
>> Author.first.book
  Author Load (0.4ms)  SELECT "authors".* FROM "authors" ORDER BY "authors"."id" ASC LIMIT 1
  Book Load (0.2ms)  SELECT "books".* FROM "books" WHERE "books"."id" = ? ORDER BY "books"."id" ASC LIMIT 1  [["id", 1]]
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 12:05:49", updated_at: "2013-07-16 12:05:49">
>> exit
$
\end{verbatim}\end{shaded}

Bingo! Accessing the associated \texttt{Book} class is also very easy. And as it's only a single record (\texttt{belongs\_to}), the singular form is used in this case.

\paragraph{Note}\label{note-26}

If there was no author for this book, the result would be an empty array. If no book is associated with an author, then ActiveRecord outputs the value \texttt{nil} as \texttt{Book}.

\subsection{Searching For Records}\label{searching-for-records}

Before we can start searching, we again need defined example data. Please fill the file \texttt{db/seeds.rb} with the following content (its the same as we used in \hyperref[activerecordux5f1nux5fzugreifen]{the section called “Accessing Records”}):

\begin{shaded}\begin{verbatim}
Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')
Book.create(title: 'Der Besuch der alten Dame').authors.create(first_name: 'Friedrich', last_name: 'Dürrenmatt')
Book.create(title: 'Julius Shulman: The Last Decade').authors.create([
  {first_name: 'Thomas', last_name: 'Schirmbock'},
  {first_name: 'Julius', last_name: 'Shulman'},
  {first_name: 'Jürgen', last_name: 'Nogai'}
  ])
Book.create(title: 'Julius Shulman: Palm Springs').authors.create([
  {first_name: 'Michael', last_name: 'Stern'},
  {first_name: 'Alan', last_name: 'Hess'}
  ])
Book.create(title: 'Photographing Architecture and Interiors').authors.create([
  {first_name: 'Julius', last_name: 'Shulman'},
  {first_name: 'Richard', last_name: 'Neutra'}
  ])
Book.create(title: 'Der Zauberberg').authors.create(first_name: 'Thomas', last_name: 'Mann')
Book.create(title: 'In einer Familie').authors.create(first_name: 'Heinrich', last_name: 'Mann')
\end{verbatim}\end{shaded}

Now drop the database and refill it with the \texttt{db/seeds.rb}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$
\end{verbatim}\end{shaded}

And off we go. First we check how many books are in the database:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.count
   (0.1ms)  SELECT COUNT(*) FROM "books"
=> 7
>>
\end{verbatim}\end{shaded}

And how many authors?

\begin{shaded}\begin{verbatim}
>> Author.count
   (0.1ms)  SELECT COUNT(*) FROM "authors"
=> 11
>> exit
$
\end{verbatim}\end{shaded}

\section{joins}\label{joins}

To find all books that have at least one author with the surname `Mann' we use a \emph{join}.

\textsuperscript{{[}\hyperref[ftn.idp4450352]{10}{]}}

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.joins(:authors).where(:authors => {last_name: 'Mann'})
  Book Load (0.5ms)  SELECT "books".* FROM "books" INNER JOIN "authors" ON "authors"."book_id" = "books"."id" WHERE "authors"."last_name" = 'Mann'
=> #<ActiveRecord::Relation [#<Book id: 6, title: "Der Zauberberg", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">, #<Book id: 7, title: "In einer Familie", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">]>
>>
\end{verbatim}\end{shaded}

The database contains two books with the author `Mann'. In the SQL, you can see that the method \texttt{joins} executes an \texttt{INNER JOIN}.

Of course, we can also do it the other way round. We could search for the author of the book `Homo faber':

\begin{shaded}\begin{verbatim}
>> Author.joins(:book).where(:books => {title: 'Homo faber'})
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" INNER JOIN "books" ON "books"."id" = "authors"."book_id" WHERE "books"."title" = 'Homo faber'
=> #<ActiveRecord::Relation [#<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">]>
>> exit
$
\end{verbatim}\end{shaded}

\section{includes}\label{includes}

\texttt{includes} is very similar to the method \texttt{joins} (see \hyperref[activerecordux5f1nux5fjoins]{the section called “joins”}). Again, you can use it to search within a 1:n association. Let's once more search for all books with an author whose surname is `Mann':

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.includes(:authors).where(:authors => {last_name: 'Mann'})
  SQL (0.3ms)  SELECT "books"."id" AS t0_r0, "books"."title" AS t0_r1, "books"."created_at" AS t0_r2, "books"."updated_at" AS t0_r3, "authors"."id" AS t1_r0, "authors"."book_id" AS t1_r1, "authors"."first_name" AS t1_r2, "authors"."last_name" AS t1_r3, "authors"."created_at" AS t1_r4, "authors"."updated_at" AS t1_r5 FROM "books" LEFT OUTER JOIN "authors" ON "authors"."book_id" = "books"."id" WHERE "authors"."last_name" = 'Mann'
=> #<ActiveRecord::Relation [#<Book id: 6, title: "Der Zauberberg", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">, #<Book id: 7, title: "In einer Familie", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">]>
>> exit
$
\end{verbatim}\end{shaded}

In the console output, you can see that the SQL code is different from the \texttt{joins} query.

\texttt{joins} only reads in the \texttt{Book} records and \texttt{includes} also reads the associated \texttt{Authors}. As you can see even in our little example, this obviously takes longer (0.2 ms vs.~0.3 ms).

\subsection{join vs.~includes}\label{join-vs.includes}

Why would you want to use \texttt{includes} at all? Well, if you already know before the query that you will later need all author data, then it makes sense to use \texttt{includes}, because then you only need one database query. That is a lot faster than starting a seperate query for each n.

In that case, would it not be better to always work with \texttt{includes}? No, it depends on the specific case. When you are using \texttt{includes}, a lot more data is transported initially. This has to be cached and processed by ActiveRecord, which takes longer and requires more resources.

\subsection{delete and destroy}\label{delete-and-destroy}

With the methods \texttt{destroy}, \texttt{destroy\_all}, \texttt{delete} and \texttt{delete\_all} you can delete records, as described in \hyperref[datensatz-loeschen]{the section called “Delete/Destroy a Record”}. In the context of \texttt{has\_many}, this means that you can delete the \texttt{Author} records associated with a \texttt{Book} in one go:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> book = Book.where(title: 'Julius Shulman: The Last Decade').first
  Book Load (0.1ms)  SELECT "books".* FROM "books" WHERE "books"."title" = 'Julius Shulman: The Last Decade' ORDER BY "books"."id" ASC LIMIT 1
=> #<Book id: 3, title: "Julius Shulman: The Last Decade", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">
>> book.authors.count
   (1.7ms)  SELECT COUNT(*) FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 3]]
=> 3
>> book.authors.destroy_all
  Author Load (0.4ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 3]]
   (0.1ms)  begin transaction
  SQL (0.5ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 3]]
  SQL (0.1ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 4]]
  SQL (0.0ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 5]]
   (2.4ms)  commit transaction
=> [#<Author id: 3, book_id: 3, first_name: "Thomas", last_name: "Schirmbock", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">, #<Author id: 4, book_id: 3, first_name: "Julius", last_name: "Shulman", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">, #<Author id: 5, book_id: 3, first_name: "Jürgen", last_name: "Nogai", created_at: "2013-07-16 12:05:50", updated_at: "2013-07-16 12:05:50">]
>> book.authors.count
   (0.2ms)  SELECT COUNT(*) FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 3]]
=> 0
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Options}\label{options}

I can't comment on all possible options at this point. But I'd like to show you the most often used ones. For all others, please refer to the Ruby on Rails documentation that you can find on the Internet at \url{http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html}\{.uri\}.

\subsection{belongs\_to}\label{belongsux5fto}

The most important option for \texttt{belongs\_to} is.

\subsection{touch: true}\label{touch-true}

It automatically sets the field \texttt{updated\_at} of the entry in the table \texttt{Book} to the current time when an \texttt{Author} is edited. In the \texttt{app/models/author.rb}, it would look like this:

\begin{shaded}\begin{verbatim}
class Author < ActiveRecord::Base
  belongs_to :book, touch: true
end
\end{verbatim}\end{shaded}

\subsection{has\_many}\label{hasux5fmany}

The most important options for \texttt{has\_many are}.

\section{order: :last\_name}\label{order-lastux5fname}

If you want to sort the authors by surname, you can do this via the following \texttt{app/models/book.rb}:

\begin{shaded}\begin{verbatim}
class Book < ActiveRecord::Base
  has_many :authors, order: :last_name
end
\end{verbatim}\end{shaded}

As an example, let's create a new book with new authors and see how ActiveRecord sorts them:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.create(title: 'Test').authors.create([{last_name: 'Z'}, {last_name: 'A'}])
   (0.1ms)  begin transaction
  SQL (23.5ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 18 Nov 2012 12:04:31 UTC +00:00], ["title", "Test"], ["updated_at", Sun, 18 Nov 2012 12:04:31 UTC +00:00]]
   (2.6ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 8], ["created_at", Sun, 18 Nov 2012 12:04:31 UTC +00:00], ["first_name", nil], ["last_name", "Z"], ["updated_at", Sun, 18 Nov 2012 12:04:31 UTC +00:00]]
   (0.8ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 8], ["created_at", Sun, 18 Nov 2012 12:04:31 UTC +00:00], ["first_name", nil], ["last_name", "A"], ["updated_at", Sun, 18 Nov 2012 12:04:31 UTC +00:00]]
   (0.8ms)  commit transaction
=> [#<Author id: 12, book_id: 8, first_name: nil, last_name: "Z", created_at: "2012-11-18 12:04:31", updated_at: "2012-11-18 12:04:31">, #<Author id: 13, book_id: 8, first_name: nil, last_name: "A", created_at: "2012-11-18 12:04:31", updated_at: "2012-11-18 12:04:31">]
>> Book.last.authors
  Book Load (0.3ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" DESC LIMIT 1
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 8 ORDER BY last_name
=> [#<Author id: 13, book_id: 8, first_name: nil, last_name: "A", created_at: "2012-11-18 12:04:31", updated_at: "2012-11-18 12:04:31">, #<Author id: 12, book_id: 8, first_name: nil, last_name: "Z", created_at: "2012-11-18 12:04:31", updated_at: "2012-11-18 12:04:31">]
>> exit
$
\end{verbatim}\end{shaded}

And if we want to sort in descending order for a change:

\begin{shaded}\begin{verbatim}
has_many :authors, :order => 'title DESC'
\end{verbatim}\end{shaded}

\section{dependent: :destroy}\label{dependent-destroy}

If a book is removed, then it usually makes sense to also automatically remove all authors dependent on this book. This can be done via \texttt{:dependent =\textgreater{} :destroy} in the \texttt{app/models/book.rb}:

\begin{shaded}\begin{verbatim}
class Book < ActiveRecord::Base
  has_many :authors, dependent: :destroy
end
\end{verbatim}\end{shaded}

In the following example, we destroy the first book in the database table. All authors of this book are also automatically destroyed:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.first
  Book Load (0.1ms)  SELECT "books".* FROM "books" LIMIT 1
=> #<Book id: 1, title: "Homo faber", created_at: "2012-11-18 11:46:29", updated_at: "2012-11-18 11:46:29">
>> Book.first.authors
  Book Load (0.3ms)  SELECT "books".* FROM "books" LIMIT 1
  Author Load (0.1ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 1
=> [#<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-11-18 11:46:29", updated_at: "2012-11-18 11:46:29">]
>> Book.first.destroy
  Book Load (0.3ms)  SELECT "books".* FROM "books" LIMIT 1
   (0.1ms)  begin transaction
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 1
  SQL (4.8ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 1]]
  SQL (0.1ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 1]]
   (3.0ms)  commit transaction
=> #<Book id: 1, title: "Homo faber", created_at: "2012-11-18 11:46:29", updated_at: "2012-11-18 11:46:29">
>> Author.exists?(1)
  Author Exists (0.2ms)  SELECT 1 AS one FROM "authors" WHERE "authors"."id" = 1 LIMIT 1
=> false
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Important}\label{important-8}

Please always remember the difference between the methods \texttt{destroy} (see \hyperref[activerecordux5fdestroy]{the section called “destroy”}) and \texttt{delete} (see \hyperref[activerecordux5fdelete]{the section called “delete”}). This association only works with the method \texttt{destroy}.

\section{has\_many .., through: ..}\label{hasux5fmany-..-through-..}

Here I need to elaborate a bit: you will probably have noticed that in our book-author example we have sometimes been entering authors several times in the \texttt{authors} table. Normally, you would of course not do this. It would be better to enter each author only once in the authors table and take care of the association with the books via an intermediary table. For this purpose, there is \texttt{has\_many \ldots{}}, through: =\textgreater{} \emph{\texttt{\ldots{}}}.

This kind of association is called Many-to-Many (n:n) and we'll discuss it in detail in \hyperref[ar-manyux5ftoux5fmany]{the section called “Many-to-Many -- n:n Association”}.

\subsection{Many-to-Many -- n:n Association}\label{many-to-many-nn-association}

Up to now, we have always associated a database table directly with another table. For many-to-many, we will associate two tables via a third table. As example for this kind of relation, we use an order in a very basic online shop. In this type of shop system, a \texttt{Product} can appear in several orders (\texttt{Order}) and at the same time an order can contain several products. This is referred to as many-to-many. Let's recreate this scenario with code.

\subsection{Preparation}\label{preparation}

Create the shop application:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
\end{verbatim}\end{shaded}

A model for products:

\begin{shaded}\begin{verbatim}
$ rails generate model product name 'price:decimal{7,2}'
  [...]
$
\end{verbatim}\end{shaded}

A model for an order:

\begin{shaded}\begin{verbatim}
$ rails generate model order delivery_address
  [...]
$
\end{verbatim}\end{shaded}

And a model for individual items of an order:

\begin{shaded}\begin{verbatim}
$ rails generate model line_item order_id:integer product_id:integer quantity:integer
  [...]
$
\end{verbatim}\end{shaded}

Then, create the database:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

\subsection{The Association}\label{the-association}

An order (\texttt{Order}) consists of one or several items (\texttt{LineItem}). This \texttt{LineItem} consists of the \texttt{order\_id}, a \texttt{product\_id} and the number of items ordered (\texttt{quantity}). The individual product is defined in the product database (\texttt{Product}).

Associating the models happens as always in the directory \texttt{app/models}. First, in the file \texttt{app/models/order.rb:}

\begin{shaded}\begin{verbatim}
class Order < ActiveRecord::Base
  has_many :line_items
  has_many :products, :through => :line_items
end
\end{verbatim}\end{shaded}

Then in the counterpart in the file \texttt{app/models/product.rb:}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  has_many :line_items
  has_many :orders, :through => :line_items
end
\end{verbatim}\end{shaded}

Finally, the file \texttt{app/models/line\_item.rb:}

\begin{shaded}\begin{verbatim}
class LineItem < ActiveRecord::Base
  belongs_to :order
  belongs_to :product
end
\end{verbatim}\end{shaded}

\subsection{The Association Works Transparent}\label{the-association-works-transparent}

As we implement the associations via \texttt{has\_many}, most things will already be familiar to you from \hyperref[activerecordux5fhasux5fmany]{the section called “has\_many -- 1:n Association”}. I am going to discuss a few examples. For more details, see \hyperref[activerecordux5fhasux5fmany]{the section called “has\_many -- 1:n Association”}.

First we populate our product database with the following values:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> milk = Product.create(name: 'Milk (1 liter)', price: 0.45)
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:30:29 UTC +00:00], ["name", "Milk (1 liter)"], ["price", #<BigDecimal:7fb985120d18,'0.45E0',9(45)>], ["updated_at", Tue, 16 Jul 2013 12:30:29 UTC +00:00]]
   (2.5ms)  commit transaction
=> #<Product id: 1, name: "Milk (1 liter)", price: #<BigDecimal:7fb985120d18,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29">
>> butter = Product.create(name: 'Butter (250 gr)', price: 0.75)
   (0.1ms)  begin transaction
  SQL (0.9ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:30:36 UTC +00:00], ["name", "Butter (250 gr)"], ["price", #<BigDecimal:7fb98281fe28,'0.75E0',9(45)>], ["updated_at", Tue, 16 Jul 2013 12:30:36 UTC +00:00]]
   (2.3ms)  commit transaction
=> #<Product id: 2, name: "Butter (250 gr)", price: #<BigDecimal:7fb98281fe28,'0.75E0',9(45)>, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36">
>> flour = Product.create(name: 'Flour (1 kg)', price: 0.45)
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:30:43 UTC +00:00], ["name", "Flour (1 kg)"], ["price", #<BigDecimal:7fb98520b9f8,'0.45E0',9(45)>], ["updated_at", Tue, 16 Jul 2013 12:30:43 UTC +00:00]]
   (2.0ms)  commit transaction
=> #<Product id: 3, name: "Flour (1 kg)", price: #<BigDecimal:7fb98520b9f8,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:43", updated_at: "2013-07-16 12:30:43">
>>  
\end{verbatim}\end{shaded}

Now we create a new \texttt{Order} object with the name \texttt{order}:

\begin{shaded}\begin{verbatim}
>> order = Order.new(delivery_address: '123 Acme Street, ACME STATE 12345')
=> #<Order id: nil, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: nil, updated_at: nil>
>>
\end{verbatim}\end{shaded}

Logically, this new order does not yet contain any products:

\begin{shaded}\begin{verbatim}
>> order.products.count
=> 0
>>
\end{verbatim}\end{shaded}

As often, there are several ways of adding products to the order. The simplest way: as the products are integrated as array, you can simply insert them as elements of an array:

\begin{shaded}\begin{verbatim}
>> order.products << milk
=> #<ActiveRecord::Associations::CollectionProxy [#<Product id: 1, name: "Milk (1 liter)", price: #<BigDecimal:7fb985120d18,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29">]>
>>
\end{verbatim}\end{shaded}

But if the customer wants to buy three liters of milk instead of one liter, we need to enter it in the \texttt{LineItem} (in the linking element) table. ActiveRecord already build an object for us:

\begin{shaded}\begin{verbatim}
>> order.line_items
=> #<ActiveRecord::Associations::CollectionProxy [#<LineItem id: nil, order_id: nil, product_id: 1, quantity: nil, created_at: nil, updated_at: nil>]>
>>
\end{verbatim}\end{shaded}

But the object is not yet saved in the database. After we do this via \texttt{save}, we can change the quantity in the \texttt{LineItem} object:

\begin{shaded}\begin{verbatim}
>> order.save
   (0.1ms)  begin transaction
  SQL (0.9ms)  INSERT INTO "orders" ("created_at", "delivery_address", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00], ["delivery_address", "123 Acme Street, ACME STATE 12345"], ["updated_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00]]
  SQL (0.3ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00], ["order_id", 1], ["product_id", 1], ["updated_at", Tue, 16 Jul 2013 12:34:08 UTC +00:00]]
   (2.6ms)  commit transaction
=> true
>> order.line_items.first.update_attributes(quantity: 3)
   (0.2ms)  begin transaction
  SQL (1.0ms)  UPDATE "line_items" SET "quantity" = ?, "updated_at" = ? WHERE "line_items"."id" = 1  [["quantity", 3], ["updated_at", Tue, 16 Jul 2013 12:34:49 UTC +00:00]]
   (3.0ms)  commit transaction
=> true
>>
\end{verbatim}\end{shaded}

Alternatively, we can also buy butter twice directly by adding a \texttt{LineItem}:

\begin{shaded}\begin{verbatim}
>> order.line_items.create(product_id: butter.id, quantity: 2)
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "quantity", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:35:38 UTC +00:00], ["order_id", 1], ["product_id", 2], ["quantity", 2], ["updated_at", Tue, 16 Jul 2013 12:35:38 UTC +00:00]]
   (2.3ms)  commit transaction
=> #<LineItem id: 2, order_id: 1, product_id: 2, quantity: 2, created_at: "2013-07-16 12:35:38", updated_at: "2013-07-16 12:35:38">
>>
\end{verbatim}\end{shaded}

\subsection{Warning}\label{warning-3}

When creating a line\_item we bypass the has\_many: \ldots{} :through .. logic. The database table contains all the correct information but order hasn't been updated:

\begin{shaded}\begin{verbatim}
>> order.products
=> #<ActiveRecord::Associations::CollectionProxy [#<Product id: 1, name: "Milk (1 liter)", price: #<BigDecimal:7fb985120d18,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29">]>
>>
\end{verbatim}\end{shaded}

But in the database table, it is of course correct:

\begin{shaded}\begin{verbatim}
>> Order.first.products
  Order Load (0.3ms)  SELECT "orders".* FROM "orders" ORDER BY "orders"."id" ASC LIMIT 1
  Product Load (0.2ms)  SELECT "products".* FROM "products" INNER JOIN "line_items" ON "products"."id" = "line_items"."product_id" WHERE "line_items"."order_id" = ?  [["order_id", 1]]
=> #<ActiveRecord::Associations::CollectionProxy [#<Product id: 1, name: "Milk (1 liter)", price: #<BigDecimal:7fb985148ac0,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29">, #<Product id: 2, name: "Butter (250 gr)", price: #<BigDecimal:7fb985153c90,'0.75E0',9(45)>, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36">]>
>>
\end{verbatim}\end{shaded}

In this specific case, you would need to reload the object from the database via the method \texttt{reload}:

\begin{shaded}\begin{verbatim}
>> order.reload
  Order Load (0.4ms)  SELECT "orders".* FROM "orders" WHERE "orders"."id" = ? LIMIT 1  [["id", 1]]
=> #<Order id: 1, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: "2013-07-16 12:34:08", updated_at: "2013-07-16 12:34:08">
>> order.products
  Product Load (0.3ms)  SELECT "products".* FROM "products" INNER JOIN "line_items" ON "products"."id" = "line_items"."product_id" WHERE "line_items"."order_id" = ?  [["order_id", 1]]
=> #<ActiveRecord::Associations::CollectionProxy [#<Product id: 1, name: "Milk (1 liter)", price: #<BigDecimal:7fb98516a2d8,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29">, #<Product id: 2, name: "Butter (250 gr)", price: #<BigDecimal:7fb985169540,'0.75E0',9(45)>, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36">]>
>>
\end{verbatim}\end{shaded}

Let's enter a second order with all available products into the system:

\begin{shaded}\begin{verbatim}
>> order2 = Order.create(delivery_address: '2, Test Road')
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "orders" ("created_at", "delivery_address", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:27 UTC +00:00], ["delivery_address", "2, Test Road"], ["updated_at", Tue, 16 Jul 2013 12:39:27 UTC +00:00]]
   (2.7ms)  commit transaction
=> #<Order id: 2, delivery_address: "2, Test Road", created_at: "2013-07-16 12:39:27", updated_at: "2013-07-16 12:39:27">
>> order2.products << Product.all
  Product Load (0.3ms)  SELECT "products".* FROM "products"
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00], ["order_id", 2], ["product_id", 1], ["updated_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00]]
  SQL (0.1ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00], ["order_id", 2], ["product_id", 2], ["updated_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00]]
  SQL (0.1ms)  INSERT INTO "line_items" ("created_at", "order_id", "product_id", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00], ["order_id", 2], ["product_id", 3], ["updated_at", Tue, 16 Jul 2013 12:39:33 UTC +00:00]]
   (2.6ms)  commit transaction
  Product Load (0.1ms)  SELECT "products".* FROM "products" INNER JOIN "line_items" ON "products"."id" = "line_items"."product_id" WHERE "line_items"."order_id" = ?  [["order_id", 2]]
=> #<ActiveRecord::Associations::CollectionProxy [#<Product id: 1, name: "Milk (1 liter)", price: #<BigDecimal:7fb9851c32c0,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:29", updated_at: "2013-07-16 12:30:29">, #<Product id: 2, name: "Butter (250 gr)", price: #<BigDecimal:7fb9851c1538,'0.75E0',9(45)>, created_at: "2013-07-16 12:30:36", updated_at: "2013-07-16 12:30:36">, #<Product id: 3, name: "Flour (1 kg)", price: #<BigDecimal:7fb9851cafe8,'0.45E0',9(45)>, created_at: "2013-07-16 12:30:43", updated_at: "2013-07-16 12:30:43">]>
>> order2.save
   (0.1ms)  begin transaction
   (0.1ms)  commit transaction
=> true
>>
\end{verbatim}\end{shaded}

Now we can try out the oposite direction of this many-to-many association. Let's search for all orders that contain the first product:

\begin{shaded}\begin{verbatim}
>> Product.first.orders
  Product Load (0.3ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
  Order Load (0.2ms)  SELECT "orders".* FROM "orders" INNER JOIN "line_items" ON "orders"."id" = "line_items"."order_id" WHERE "line_items"."product_id" = ?  [["product_id", 1]]
=> #<ActiveRecord::Associations::CollectionProxy [#<Order id: 1, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: "2013-07-16 12:34:08", updated_at: "2013-07-16 12:34:08">, #<Order id: 2, delivery_address: "2, Test Road", created_at: "2013-07-16 12:39:27", updated_at: "2013-07-16 12:39:27">]>
>>
\end{verbatim}\end{shaded}

Of course, we can also work with a \texttt{joins} (see \hyperref[activerecordux5f1nux5fjoins]{the section called “joins”}) and search for all orders that contain the product “Milk (1 liter)”:

\begin{shaded}\begin{verbatim}
>> Order.joins(:products).where(:products => {name: 'Milk (1 liter)'})
  Order Load (0.2ms)  SELECT "orders".* FROM "orders" INNER JOIN "line_items" ON "line_items"."order_id" = "orders"."id" INNER JOIN "products" ON "products"."id" = "line_items"."product_id" WHERE "products"."name" = 'Milk (1 liter)'
=> #<ActiveRecord::Relation [#<Order id: 1, delivery_address: "123 Acme Street, ACME STATE 12345", created_at: "2013-07-16 12:34:08", updated_at: "2013-07-16 12:34:08">, #<Order id: 2, delivery_address: "2, Test Road", created_at: "2013-07-16 12:39:27", updated_at: "2013-07-16 12:39:27">]>
>> exit
$
\end{verbatim}\end{shaded}

\section{has\_one -- 1:1 Association}\label{hasux5fone-11-association}

Similar to \texttt{has\_many} (see \hyperref[activerecordux5fhasux5fmany]{the section called “has\_many -- 1:n Association”}), the method \texttt{has\_one} also creates a logical relation between two models. But in contrast to \texttt{has\_many,} one record is only ever associated with exactly one other record in \texttt{has\_one}. In most practical cases of application, it logically makes sense to put both into the same model and therefore the same database table, but for the sake of completeness I also want to discuss has\_one here.

\subsection{Tip}\label{tip-8}

You can probably safely skip \texttt{has\_one} without losing any sleep.

In the examples, I assume that you have already read and understood \hyperref[activerecordux5fhasux5fmany]{the section called “has\_many -- 1:n Association”}. I am not going to explain methods like \texttt{build} (\hyperref[activerecordux5fhinzufuegenux5fbuild]{the section called “build”}) again but assume that you already know the basics.

\subsection{Preparation}\label{preparation-1}

We use the example from the Rails documentation (see \url{http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html}\{.uri\}) and create an application containing employees and offices. Each employee has an office. First the application:

\begin{shaded}\begin{verbatim}
$ rails new office-space
  [...]
$ cd office-space
$
\end{verbatim}\end{shaded}

And now the two models:

\begin{shaded}\begin{verbatim}
$ rails generate model employee last_name
  [...]
$ rails generate model office location employee_id:integer
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

\subsection{Association}\label{association}

The association in the file \texttt{app/model/employee.rb:}

\begin{shaded}\begin{verbatim}
class Employee < ActiveRecord::Base
  has_one :office
end
\end{verbatim}\end{shaded}

And its counterpart in the file \texttt{app/model/office.rb:}

\begin{shaded}\begin{verbatim}
class Office < ActiveRecord::Base
  belongs_to :employee
end
\end{verbatim}\end{shaded}

\section{Options}\label{options-1}

The options of \texttt{has\_one} are similar to those of \texttt{has\_many}. So for details, please refer to \hyperref[activerecordux5f1nux5foptionen]{the section called “Options”} or \url{http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html\#method-i-has_one}\{.uri\}.

\section{Console Examples}\label{console-examples}

Let's start the console and create two employees:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Employee.create(last_name: 'Udelhoven')
   (0.1ms)  begin transaction
  SQL (2.3ms)  INSERT INTO "employees" ("created_at", "last_name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:44:24 UTC +00:00], ["last_name", "Udelhoven"], ["updated_at", Tue, 16 Jul 2013 12:44:24 UTC +00:00]]
   (1.0ms)  commit transaction
=> #<Employee id: 1, last_name: "Udelhoven", created_at: "2013-07-16 12:44:24", updated_at: "2013-07-16 12:44:24">
>> Employee.create(last_name: 'Meier')
   (0.2ms)  begin transaction
  SQL (0.7ms)  INSERT INTO "employees" ("created_at", "last_name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:44:32 UTC +00:00], ["last_name", "Meier"], ["updated_at", Tue, 16 Jul 2013 12:44:32 UTC +00:00]]
   (2.2ms)  commit transaction
=> #<Employee id: 2, last_name: "Meier", created_at: "2013-07-16 12:44:32", updated_at: "2013-07-16 12:44:32">
>>
\end{verbatim}\end{shaded}

Now the first employee gets his own office:

\begin{shaded}\begin{verbatim}
>> Office.create(location: '2nd floor', employee_id: Employee.first.id)
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT 1
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "offices" ("created_at", "employee_id", "location", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:45:13 UTC +00:00], ["employee_id", 1], ["location", "2nd floor"], ["updated_at", Tue, 16 Jul 2013 12:45:13 UTC +00:00]]
   (2.2ms)  commit transaction
=> #<Office id: 1, location: "2nd floor", employee_id: 1, created_at: "2013-07-16 12:45:13", updated_at: "2013-07-16 12:45:13">
>>
\end{verbatim}\end{shaded}

Both directions can be accessed the normal way:

\begin{shaded}\begin{verbatim}
>> Employee.first.office
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT 1
  Office Load (0.2ms)  SELECT "offices".* FROM "offices" WHERE "offices"."employee_id" = ? ORDER BY "offices"."id" ASC LIMIT 1  [["employee_id", 1]]
=> #<Office id: 1, location: "2nd floor", employee_id: 1, created_at: "2013-07-16 12:45:13", updated_at: "2013-07-16 12:45:13">
>> Office.first.employee
  Office Load (0.3ms)  SELECT "offices".* FROM "offices" ORDER BY "offices"."id" ASC LIMIT 1
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" WHERE "employees"."id" = ? ORDER BY "employees"."id" ASC LIMIT 1  [["id", 1]]
=> #<Employee id: 1, last_name: "Udelhoven", created_at: "2013-07-16 12:44:24", updated_at: "2013-07-16 12:44:24">
>>
\end{verbatim}\end{shaded}

For the second employee, we use the automatically generated method \texttt{create\_office} (with \texttt{has\_many}, we would use \texttt{offices.create} here):

\begin{shaded}\begin{verbatim}
>> Employee.last.create_office(location: '1st floor')
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" DESC LIMIT 1
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "offices" ("created_at", "employee_id", "location", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:46:58 UTC +00:00], ["employee_id", 2], ["location", "1st floor"], ["updated_at", Tue, 16 Jul 2013 12:46:58 UTC +00:00]]
   (2.3ms)  commit transaction
  Office Load (0.1ms)  SELECT "offices".* FROM "offices" WHERE "offices"."employee_id" = ? ORDER BY "offices"."id" ASC LIMIT 1  [["employee_id", 2]]
=> #<Office id: 2, location: "1st floor", employee_id: 2, created_at: "2013-07-16 12:46:58", updated_at: "2013-07-16 12:46:58">
>>
\end{verbatim}\end{shaded}

Removing is intuitively done via \texttt{destroy}:

\begin{shaded}\begin{verbatim}
>> Employee.first.office.destroy
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT 1
  Office Load (0.1ms)  SELECT "offices".* FROM "offices" WHERE "offices"."employee_id" = ? ORDER BY "offices"."id" ASC LIMIT 1  [["employee_id", 1]]
   (0.1ms)  begin transaction
  SQL (0.3ms)  DELETE FROM "offices" WHERE "offices"."id" = ?  [["id", 1]]
   (2.4ms)  commit transaction
=> #<Office id: 1, location: "2nd floor", employee_id: 1, created_at: "2013-07-16 12:45:13", updated_at: "2013-07-16 12:45:13">
>>>> Employee.first.office
  Employee Load (0.4ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" ASC LIMIT 1
  Office Load (0.1ms)  SELECT "offices".* FROM "offices" WHERE "offices"."employee_id" = ? ORDER BY "offices"."id" ASC LIMIT 1  [["employee_id", 1]]
=> nil
>>>>
\end{verbatim}\end{shaded}

\subsection{Warning}\label{warning-4}

If you create a new \texttt{Office} for an \texttt{Employee} with an existing \texttt{Office} then you will not get an error message:

\begin{shaded}\begin{verbatim}
>> Employee.last.create_office(location: 'Basement')
  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" DESC LIMIT 1
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "offices" ("created_at", "employee_id", "location", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 12:48:44 UTC +00:00], ["employee_id", 2], ["location", "Basement"], ["updated_at", Tue, 16 Jul 2013 12:48:44 UTC +00:00]]
   (1.9ms)  commit transaction
  Office Load (0.1ms)  SELECT "offices".* FROM "offices" WHERE "offices"."employee_id" = ? ORDER BY "offices"."id" ASC LIMIT 1  [["employee_id", 2]]
   (0.1ms)  begin transaction
  SQL (0.4ms)  UPDATE "offices" SET "employee_id" = ?, "updated_at" = ? WHERE "offices"."id" = 2  [["employee_id", nil], ["updated_at", Tue, 16 Jul 2013 12:48:44 UTC +00:00]]
   (0.8ms)  commit transaction
=> #<Office id: 3, location: "Basement", employee_id: 2, created_at: "2013-07-16 12:48:44", updated_at: "2013-07-16 12:48:44">
>> Employee.last.office
  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY "employees"."id" DESC LIMIT 1
  Office Load (0.2ms)  SELECT "offices".* FROM "offices" WHERE "offices"."employee_id" = ? ORDER BY "offices"."id" ASC LIMIT 1  [["employee_id", 2]]
=> #<Office id: 3, location: "Basement", employee_id: 2, created_at: "2013-07-16 12:48:44", updated_at: "2013-07-16 12:48:44">
>>
\end{verbatim}\end{shaded}

The old \texttt{Office} is even still in the database (the \texttt{employee\_id} was automatically set to \texttt{nil}):

\begin{shaded}\begin{verbatim}
>> Office.all
  Office Load (0.3ms)  SELECT "offices".* FROM "offices"
=> #<ActiveRecord::Relation [#<Office id: 2, location: "1st floor", employee_id: nil, created_at: "2013-07-16 12:46:58", updated_at: "2013-07-16 12:48:44">, #<Office id: 3, location: "Basement", employee_id: 2, created_at: "2013-07-16 12:48:44", updated_at: "2013-07-16 12:48:44">]>
>> exit
$
\end{verbatim}\end{shaded}

\subsection{has\_one vs.~belongs\_to}\label{hasux5fone-vs.belongsux5fto}

Both \texttt{has\_one} and \texttt{belongs\_to} offer the option of representing a 1:1 relationship. The difference in practice is in the programmer's personal preference and the location of the foreign key. In general, \texttt{has\_one} tends to be used very rarely and depends on the degree of normalization of the data schema.

\subsection{Polymorphic Associations}\label{polymorphic-associations}

Already the word “polymorphic” will probably make you tense up. What can it mean? Here is what the website \url{http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html}\{.uri\} tells us: “Polymorphic associations on models are not restricted on what types of models they can be associated with.” Well, there you go - as clear as mud! ;-)

I am showing you an example in which we create a model for cars (\texttt{Car}) and a model for bicycles (\texttt{Bike}). To describe a car or bike, we use a model to tag it (\texttt{Tag}). A car and a bike can have any number of \texttt{tags}. The application:

\begin{shaded}\begin{verbatim}
$ rails new example
  [...]
$ cd example
$
\end{verbatim}\end{shaded}

Now the three required models:

\begin{shaded}\begin{verbatim}
$ rails generate model Car name
  [...]
$ rails generate model Bike name
  [...]
$ rails generate model Tag name taggable:references{polymorphic}
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

\texttt{Car} and \texttt{Bike} are clear. For \texttt{Tag} we use the migration shortcut \texttt{taggable:references\{polymorphic\}} to generate the fields \texttt{taggable\_type} and \texttt{taggable\_id}, to give ActiveRecord an opportunity to save the assignment for the polymorphic association. We have to enter it accordingly in the model.

The model generator already filed the \texttt{app/models/tag.rb} file with the configuration for the polymorphic association:

\texttt{app/models/tag.rb}

\begin{shaded}\begin{verbatim}
class Tag < ActiveRecord::Base
  belongs_to :taggable, polymorphic: true
end
\end{verbatim}\end{shaded}

For the other models we have to add the polymorphic association manually:

\texttt{app/models/car.rb}

\begin{shaded}\begin{verbatim}
class Car < ActiveRecord::Base
  has_many :tags, as: :taggable
end
\end{verbatim}\end{shaded}

\texttt{app/models/bike.rb}

\begin{shaded}\begin{verbatim}
class Bike < ActiveRecord::Base
  has_many :tags, as: :taggable
end
\end{verbatim}\end{shaded}

For Car and Bike we use an additional \texttt{:as: :taggable} when defining has\_many. For \texttt{Tag} we use \texttt{belongs\_to   :taggable, polymorphic: true} to indicate the polymorphic association to ActiveRecord.

\subsection{Tip}\label{tip-9}

The suffix “\emph{able}” in the name “\emph{taggable}” is commonly used in Rails, but not obligatory. For creating the association we now not only need the ID of the entry, but also need to know which \emph{model} it actually is. So the term “\emph{taggable\_type}” makes sense.

Let's go into the \emph{console} and create a car and a bike:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> beetle = Car.create(name: 'Beetle')
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "cars" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:04:50 UTC +00:00], ["name", "Beetle"], ["updated_at", Tue, 16 Jul 2013 13:04:50 UTC +00:00]]
   (0.9ms)  commit transaction
=> #<Car id: 1, name: "Beetle", created_at: "2013-07-16 13:04:50", updated_at: "2013-07-16 13:04:50">
>> mountainbike = Bike.create(name: 'Mountainbike')
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "bikes" ("created_at", "name", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:04:57 UTC +00:00], ["name", "Mountainbike"], ["updated_at", Tue, 16 Jul 2013 13:04:57 UTC +00:00]]
   (2.5ms)  commit transaction
=> #<Bike id: 1, name: "Mountainbike", created_at: "2013-07-16 13:04:57", updated_at: "2013-07-16 13:04:57">
>>
\end{verbatim}\end{shaded}

Now we define for each a tag with the color of the corresponding object:

\begin{shaded}\begin{verbatim}
>> beetle.tags.create(name: 'blue')
   (0.0ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "tags" ("created_at", "name", "taggable_id", "taggable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:05:19 UTC +00:00], ["name", "blue"], ["taggable_id", 1], ["taggable_type", "Car"], ["updated_at", Tue, 16 Jul 2013 13:05:19 UTC +00:00]]
   (3.0ms)  commit transaction
=> #<Tag id: 1, name: "blue", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:19", updated_at: "2013-07-16 13:05:19">
>> mountainbike.tags.create(name: 'black')
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "tags" ("created_at", "name", "taggable_id", "taggable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:05:27 UTC +00:00], ["name", "black"], ["taggable_id", 1], ["taggable_type", "Bike"], ["updated_at", Tue, 16 Jul 2013 13:05:27 UTC +00:00]]
   (2.3ms)  commit transaction
=> #<Tag id: 2, name: "black", taggable_id: 1, taggable_type: "Bike", created_at: "2013-07-16 13:05:27", updated_at: "2013-07-16 13:05:27">
>>
\end{verbatim}\end{shaded}

For the \texttt{beetle}, we add another \texttt{Tag}:

\begin{shaded}\begin{verbatim}
>> beetle.tags.create(name: 'Automatic')
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "tags" ("created_at", "name", "taggable_id", "taggable_type", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:05:56 UTC +00:00], ["name", "Automatic"], ["taggable_id", 1], ["taggable_type", "Car"], ["updated_at", Tue, 16 Jul 2013 13:05:56 UTC +00:00]]
   (2.1ms)  commit transaction
=> #<Tag id: 3, name: "Automatic", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:56", updated_at: "2013-07-16 13:05:56">
>>
\end{verbatim}\end{shaded}

Let's have a look at all \texttt{Tag} items:

\begin{shaded}\begin{verbatim}
>> Tag.all
  Tag Load (0.3ms)  SELECT "tags".* FROM "tags"
=> #<ActiveRecord::Relation [#<Tag id: 1, name: "blue", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:19", updated_at: "2013-07-16 13:05:19">, #<Tag id: 2, name: "black", taggable_id: 1, taggable_type: "Bike", created_at: "2013-07-16 13:05:27", updated_at: "2013-07-16 13:05:27">, #<Tag id: 3, name: "Automatic", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:56", updated_at: "2013-07-16 13:05:56">]>
>>
\end{verbatim}\end{shaded}

And now all tags of the beetle:

\begin{shaded}\begin{verbatim}
>> beetle.tags
  Tag Load (0.4ms)  SELECT "tags".* FROM "tags" WHERE "tags"."taggable_id" = ? AND "tags"."taggable_type" = ?  [["taggable_id", 1], ["taggable_type", "Car"]]
=> #<ActiveRecord::Associations::CollectionProxy [#<Tag id: 1, name: "blue", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:19", updated_at: "2013-07-16 13:05:19">, #<Tag id: 3, name: "Automatic", taggable_id: 1, taggable_type: "Car", created_at: "2013-07-16 13:05:56", updated_at: "2013-07-16 13:05:56">]>
>>
\end{verbatim}\end{shaded}

Of course you can also check which object the last \texttt{Tag} belongs to:

\begin{shaded}\begin{verbatim}
>> Tag.last.taggable
  Tag Load (0.3ms)  SELECT "tags".* FROM "tags" ORDER BY "tags"."id" DESC LIMIT 1
  Car Load (0.2ms)  SELECT "cars".* FROM "cars" WHERE "cars"."id" = ? ORDER BY "cars"."id" ASC LIMIT 1  [["id", 1]]
=> #<Car id: 1, name: "Beetle", created_at: "2013-07-16 13:04:50", updated_at: "2013-07-16 13:04:50">
>> exit
$
\end{verbatim}\end{shaded}

Polymorphic associations are always useful if you want to normalize the database structure. In this example, we could also have defined a model \texttt{CarTag} and \texttt{BikeTag}, but as \texttt{Tag} is the same for both, a polymorphic association makes more sense in this case.

\section{Options}\label{options-2}

Polymorphic associations can be configured with the same options as a normal \hyperref[activerecordux5fhasux5fmany]{the section called “has\_many -- 1:n Association”} model.

\subsection{Delete/Destroy a Record}\label{deletedestroy-a-record}

To remove a database record, you can use the methods \texttt{destroy} and \texttt{delete}. It's quite easy to confuse these two terms, but they are different and after a while you get used to it.

As an example, we use the following Rails application:

\begin{shaded}\begin{verbatim}
$ rails new bookshelf
  [...]
$ cd bookshelf
$ rails generate model book title
  [...]
$ rails generate model author book_id:integer first_name last_name
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

\texttt{app/models/book.rb}

\begin{shaded}\begin{verbatim}
class Book < ActiveRecord::Base
  has_many :authors, dependent: :destroy
end
\end{verbatim}\end{shaded}

\texttt{app/models/author.rb}

\begin{shaded}\begin{verbatim}
class Author < ActiveRecord::Base
  belongs_to :book
end
\end{verbatim}\end{shaded}

\subsection{destroy}\label{destroy}

With \texttt{destroy} you can remove a record and any existing dependencies are also taken into account (see for example \texttt{:dependent =\textgreater{} :destroy} in \hyperref[activerecordux5f1nux5foptionen]{the section called “Options”}). Simply put: to be on the safe side, it's better to use \texttt{destroy} because then the Rails system does more for you.

Let's create a record and then destroy it again:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> book = Book.create(title: 'Homo faber')
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:30:24 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:30:24 UTC +00:00]]
   (2.2ms)  commit transaction
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 13:30:24", updated_at: "2013-07-16 13:30:24">
>> Book.count
   (0.3ms)  SELECT COUNT(*) FROM "books"
=> 1
>> book.destroy
   (0.2ms)  begin transaction
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 1]]
  SQL (0.3ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 1]]
   (0.6ms)  commit transaction
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 13:30:24", updated_at: "2013-07-16 13:30:24">
>> Book.count
   (0.4ms)  SELECT COUNT(*) FROM "books"
=> 0
>>
\end{verbatim}\end{shaded}

As we are using the option \texttt{dependent: :destroy} in the Book model, we can also automatically remove all authors:

\begin{shaded}\begin{verbatim}
>> Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00]]
   (1.9ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 2], ["created_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 13:31:11 UTC +00:00]]
   (1.0ms)  commit transaction
=> #<Author id: 1, book_id: 2, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 13:31:11", updated_at: "2013-07-16 13:31:11">
>> Author.count
   (0.4ms)  SELECT COUNT(*) FROM "authors"
=> 1
>> Book.first.destroy
  Book Load (0.3ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" ASC LIMIT 1
   (0.1ms)  begin transaction
  Author Load (0.1ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 2]]
  SQL (0.3ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 1]]
  SQL (0.1ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 2]]
   (2.1ms)  commit transaction
=> #<Book id: 2, title: "Homo faber", created_at: "2013-07-16 13:31:11", updated_at: "2013-07-16 13:31:11">
>> Author.count
   (0.4ms)  SELECT COUNT(*) FROM "authors"
=> 0
>>
\end{verbatim}\end{shaded}

When removing records, please always consider the difference between the content of the database table and the value of the currently removed object. The instance is \emph{frozen} after removing the database field. So it is no longer in the database, but still present in the program, yet it can no longer be modified there. It is read-only. To check, you can use the method \texttt{frozen?}:

\begin{shaded}\begin{verbatim}
>> book = Book.create(title: 'Homo faber')
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:32:30 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:32:30 UTC +00:00]]
   (2.0ms)  commit transaction
=> #<Book id: 3, title: "Homo faber", created_at: "2013-07-16 13:32:30", updated_at: "2013-07-16 13:32:30">
>> book.destroy
   (0.1ms)  begin transaction
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = ?  [["book_id", 3]]
  SQL (0.4ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 3]]
   (1.9ms)  commit transaction
=> #<Book id: 3, title: "Homo faber", created_at: "2013-07-16 13:32:30", updated_at: "2013-07-16 13:32:30">
>> Book.count
   (0.2ms)  SELECT COUNT(*) FROM "books"
=> 0
>> book
=> #<Book id: 3, title: "Homo faber", created_at: "2013-07-16 13:32:30", updated_at: "2013-07-16 13:32:30">
>> book.frozen?
=> true
>>
\end{verbatim}\end{shaded}

The record has been removed from the database, but the object with all its data is still present in the running Ruby program. So could we then revive the entire record? The answer is yes, but it will then be a new record:

\begin{shaded}\begin{verbatim}
>> Book.create(title: book.title)
   (0.1ms)  begin transaction
  SQL (0.5ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:33:31 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:33:31 UTC +00:00]]
   (1.7ms)  commit transaction
=> #<Book id: 4, title: "Homo faber", created_at: "2013-07-16 13:33:31", updated_at: "2013-07-16 13:33:31">
>> exit
$
\end{verbatim}\end{shaded}

\section{delete}\label{delete}

With \texttt{delete} you can remove a record directly from the database. Any dependencies to other records in the \emph{model} are not taken into account. The method \texttt{delete} only deletes that one row in the database and nothing else.

Let's create a book with one author and then remove the book with \texttt{delete}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$ rails console
Loading development environment (Rails 4.0.0)
>> Book.create(title: 'Homo faber').authors.create(first_name: 'Max', last_name: 'Frisch')
   (0.1ms)  begin transaction
  SQL (2.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00], ["title", "Homo faber"], ["updated_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00]]
   (2.5ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Tue, 16 Jul 2013 13:35:49 UTC +00:00]]
   (0.9ms)  commit transaction
=> #<Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2013-07-16 13:35:49", updated_at: "2013-07-16 13:35:49">
>> Author.count
   (0.3ms)  SELECT COUNT(*) FROM "authors"
=> 1
>> Book.last.delete
  Book Load (0.2ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" DESC LIMIT 1
  SQL (2.9ms)  DELETE FROM "books" WHERE "books"."id" = 1
=> #<Book id: 1, title: "Homo faber", created_at: "2013-07-16 13:35:49", updated_at: "2013-07-16 13:35:49">
>> Author.count
   (0.4ms)  SELECT COUNT(*) FROM "authors"
=> 1
>> Book.count
   (0.4ms)  SELECT COUNT(*) FROM "books"
=> 0
>> exit
$
\end{verbatim}\end{shaded}

The record of the book `Homo faber' is deleted, but the author is still in the database.

As with \texttt{destroy}, an object also gets frozen when you use \texttt{delete} (see \hyperref[activerecordux5fdestroy]{the section called “destroy”}). The record is already removed from the database, but the object itself is still there.

\subsection{Transactions}\label{transactions}

In the world of databases, the term transaction refers to a block of SQL statements that must be executed together and without interruption. If an error should occur within the transaction, the database is reset to the state before the start of the transaction.

Now and again, there are areas of application where you need to carry out a database transaction. The classic example is transferring money from one account to another. That only makes sense if both actions (debiting one account and crediting the recipient's account) are executed.

A transaction follows this pattern:

\begin{shaded}\begin{verbatim}
ActiveRecord::Base.transaction do
  Book.create(:title => 'A')
  Book.create(:title => 'B')
  Book.create(:title => 'C').authors.create(:last_name => 'Z')
end
\end{verbatim}\end{shaded}

Transactions are a complex topic. If you want to find out more, you can consult the ri help on the shell via \textbf{ri ActiveRecord::Transactions::ClassMethods}.

\paragraph{Important}\label{important-9}

The methods \texttt{save} and \texttt{destroy} are automatically executed within the transaction \emph{wrapper}. That way, Rails ensures that no undefined state can arise for these two methods.

\paragraph{Warning}\label{warning-5}

Transactions are not natively supported by all databases. In that case, the code will still work, but you no longer have the security of the transaction.

\subsection{Scopes}\label{scopes}

When programming Rails applications, it is sometimes clearer and simpler to define frequent searches as separate methods. In Rails speak, these are referred to as \emph{NamedScope}. These NamedScopes can be chained, just like other methods.

\subsection{Preparation}\label{preparation-2}

We are building our own little online shop:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$ rails generate model product name 'price:decimal{7,2}' weight:integer in_stock:boolean expiration_date:date
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Please populate the file \texttt{db/seeds.rb} with the following content:

\begin{shaded}\begin{verbatim}
Product.create(name: 'Milk (1 liter)', weight: 1000, in_stock: true, price: 0.45, expiration_date: Date.today + 14.days)
Product.create(name: 'Butter (250 g)', weight: 250, in_stock: true, price: 0.75, expiration_date: Date.today + 14.days)
Product.create(name: 'Flour (1 kg)', weight: 1000, in_stock: false, price: 0.45, expiration_date: Date.today + 100.days)
Product.create(name: 'Jelly Babies (6 x 300 g)', weight: 1500, in_stock: true, price: 4.96, expiration_date: Date.today + 1.year)
Product.create(name: 'Super-Duper Cake Mix', in_stock: true, price: 11.12, expiration_date: Date.today + 1.year)
Product.create(name: 'Eggs (12)', in_stock: true, price: 2, expiration_date: Date.today + 7.days)
Product.create(name: 'Peanuts (8 x 200 g bag)', in_stock: false, weight: 1600, price: 17.49, expiration_date: Date.today + 1.year)
\end{verbatim}\end{shaded}

Now drop the database and repopulate it with the \texttt{db/seeds.rb}:

\begin{shaded}\begin{verbatim}
$ rake db:reset
  [...]
$
\end{verbatim}\end{shaded}

\subsection{Defining a Scope}\label{defining-a-scope}

If we want to count products that are in stock in our online shop, then we can use the following query each time:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.where(in_stock: true).count
   (0.1ms)  SELECT COUNT(*) FROM "products" WHERE "products"."in_stock" = 't'
=> 5
>> exit
$
\end{verbatim}\end{shaded}

But we could also define a NamedScope \texttt{available} in the \texttt{app/models/product.rb}:

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  scope :available, -> { where(in_stock: true) }
end
\end{verbatim}\end{shaded}

And then use it:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.available.count
   (0.2ms)  SELECT COUNT(*) FROM "products" WHERE "products"."in_stock" = 't'
=> 5
>> exit
$
\end{verbatim}\end{shaded}

Let's define a second NamedScope for this example in the \texttt{app/models/product.rb}:

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  scope :available, -> { where(in_stock: true) }
  scope :cheap, -> { where(price: 0..1) }
end
\end{verbatim}\end{shaded}

Now we can chain both named scopes to output all cheap products that are in stock:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.cheap.count
   (0.1ms)  SELECT COUNT(*) FROM "products" WHERE ("products"."price" BETWEEN 0 AND 1)
=> 3
>> Product.cheap.available.count
   (0.2ms)  SELECT COUNT(*) FROM "products" WHERE "products"."in_stock" = 't' AND ("products"."price" BETWEEN 0 AND 1)
=> 2
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Passing in Arguments}\label{passing-in-arguments}

If you need a NamedScope that can also process parameters, then that is no problem either. The following example outputs products that are cheaper than the specified value. The \texttt{app/models/product.rb} looks like this:

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  scope :cheaper_than, ->(price) { where("price < ?", price) }
end
\end{verbatim}\end{shaded}

Now we can count all products that cost less than 50 cent:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.cheaper_than(0.5).count
   (0.2ms)  SELECT COUNT(*) FROM "products" WHERE (price < 0.5)
=> 2
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Creating New Records with Scopes}\label{creating-new-records-with-scopes}

Let's use the following \texttt{app/models/product.rb}:

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  scope :available, -> { where(in_stock: true) }
end
\end{verbatim}\end{shaded}

With this NamedScope we can not only find all products that are in stock, but also create new products that contain the value \texttt{true} in the field \texttt{in\_stock}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> product = Product.available.build
=> #<Product id: nil, name: nil, price: nil, weight: nil, in_stock: true, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.in_stock
=> true
>> exit
$
\end{verbatim}\end{shaded}

This works with the method \texttt{build} (see \hyperref[activerecordux5fhinzufuegenux5fbuild]{the section called “build”}) and \texttt{create} (see \hyperref[activerecordux5fcreate]{the section called “create”}).

\subsection{Validation}\label{validation}

Non-valid records are frequently a source of errors in programs. With \texttt{validates}, Rails offers a quick and easy way of validating them. That way you can be sure that only meaningful records will find their way into your database.

\subsection{Preparation}\label{preparation-3}

Let's create a new application for this chapter:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$ rails generate model product name 'price:decimal{7,2}' weight:integer in_stock:boolean expiration_date:date
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

\section{The Basic Idea}\label{the-basic-idea}

For each model, there is a matching model file in the directory \texttt{app/models/}. In this Ruby code, we can not only define database dependencies, but also implement all validations. The advantage: Every programmer knows where to find it.

Without any validation, we can create an empty record in a model without a problem:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.create
   (0.1ms)  begin transaction
  SQL (2.6ms)  INSERT INTO "products" ("created_at", "updated_at") VALUES (?, ?)  [["created_at", Tue, 16 Jul 2013 17:50:34 UTC +00:00], ["updated_at", Tue, 16 Jul 2013 17:50:34 UTC +00:00]]
   (3.4ms)  commit transaction
=> #<Product id: 1, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: "2013-07-16 17:50:34", updated_at: "2013-07-16 17:50:34">
>> puts Product.first.to_yaml
  Product Load (0.3ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" ASC LIMIT 1
--- !ruby/object:Product
attributes:
  id: 1
  name:
  price:
  weight:
  in_stock:
  expiration_date:
  created_at: 2013-07-16 17:50:34.791368000 Z
  updated_at: 2013-07-16 17:50:34.791368000 Z
=> nil
>> exit
$
\end{verbatim}\end{shaded}

But in practice, this record with no content doesn't make any sense. A \texttt{Product} needs to have a \texttt{name} and a \texttt{price}. That's why we can define validations in ActiveRecord. Then you can ensure as programmer that only records that are valid for you are saved in your database.

To make the mechanism easier to understand, I am going to jump ahead a bit and use the \texttt{presence} helper. Please fill your \texttt{app/model/product.rb} with the following content:

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  validates :name,
            presence: true

  validates :price,
            presence: true
end
\end{verbatim}\end{shaded}

Now we try again to create an empty record in the console:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> product = Product.create
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
=> #<Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>>
\end{verbatim}\end{shaded}

Watch out for the \texttt{rollback transaction} part and the misssing \texttt{id} of the \texttt{Product} object! Rails began the transaction of creating a new record but for some reason it couldn't do it. So it had to rollback the transaction. The validation method intervened before the record was saved. So validating happens before saving.

Can we access the errors? Yes, via the method \texttt{errors} or with \texttt{errors.messages} we can look at the errors that occurred:

\begin{shaded}\begin{verbatim}
>> product.errors
=> #<ActiveModel::Errors:0x007fec75067a20 @base=#<Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>, @messages={:name=>["can't be blank"], :price=>["can't be blank"]}>
>> product.errors.messages
=> {:name=>["can't be blank"], :price=>["can't be blank"]}
>>
\end{verbatim}\end{shaded}

This error message was defined for a human and English-speaking user (more on this and how the errors can be translated into another language in \hyperref[i18n]{Chapter~10, \emph{Internationalization}}).

Only once we assign a value to the attributes \texttt{name} and \texttt{price}, we can save the object:

\begin{shaded}\begin{verbatim}
>> product.name = 'Milk (1 liter)'
=> "Milk (1 liter)"
>> product.price = 0.45
=> 0.45
>> product.save
   (0.2ms)  begin transaction
  SQL (2.9ms)  INSERT INTO "products" ("created_at", "name", "price", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Tue, 16 Jul 2013 17:52:50 UTC +00:00], ["name", "Milk (1 liter)"], ["price", #<BigDecimal:7fec739394c0,'0.45E0',9(45)>], ["updated_at", Tue, 16 Jul 2013 17:52:50 UTC +00:00]]
   (2.9ms)  commit transaction
=> true
>>
\end{verbatim}\end{shaded}

\section{valid?}\label{valid}

The method \texttt{valid?} indicates in boolean form if an object is valid. So you can check the validity already before you save:

\begin{shaded}\begin{verbatim}
>> product = Product.new
=> #<Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.valid?
=> false
>>
\end{verbatim}\end{shaded}

\section{save( validate: false )}\label{save-validate-false}

As so often in life, you can find a way around everything. If you pass the parameter \texttt{:validate =\textgreater{} false} to the method \texttt{save}, the data of \texttt{Validation} is saved:

\begin{shaded}\begin{verbatim}
>> product = Product.new
=> #<Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.valid?
=> false
>> product.save
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
=> false
>> product.save(validate: false)
   (0.1ms)  begin transaction
  SQL (0.8ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Mon, 19 Nov 2012 09:28:29 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", nil], ["price", nil], ["updated_at", Mon, 19 Nov 2012 09:28:29 UTC +00:00], ["weight", nil]]
   (2.3ms)  commit transaction
=> true
>> exit
$
\end{verbatim}\end{shaded}

\paragraph{Warning}\label{warning-6}

I assume that you understand the problems involved here. Please only use this option if there is a good reason to do so. Otherwise you might as well do without the whole validation process.

\subsection{presence}\label{presence}

In our model \texttt{product} there are a few fields that must be filled in in any case. We can achieve this via \texttt{presence}.

\texttt{app/models/product.rb}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  validates :name,
            presence: true

  validates :price,
            presence: true
end
\end{verbatim}\end{shaded}

If we try to create an empty user record with this, we get lots of validation errors:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> product = Product.create
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
=> #<Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.errors.messages
=> {:name=>["can't be blank"], :price=>["can't be blank"]}
>>
\end{verbatim}\end{shaded}

Only once we have entered all the data, the record can be saved:

\begin{shaded}\begin{verbatim}
>> product.name = 'Milk (1 liter)'
=> "Milk (1 liter)"
>> product.price = 0.45
=> 0.45
>> product.save
   (0.2ms)  begin transaction
  SQL (6.3ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Mon, 19 Nov 2012 09:30:21 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", "Milk (1 liter)"], ["price", #<BigDecimal:7fc7044fad08,'0.45E0',9(45)>], ["updated_at", Mon, 19 Nov 2012 09:30:21 UTC +00:00], ["weight", nil]]
   (2.5ms)  commit transaction
=> true
>> exit
$
\end{verbatim}\end{shaded}

\section{length}\label{length}

With \texttt{length} you can limit the length of a specific attribute. It's easiest to explain using an example. Let us limit the maximum length of the name to 20 and the minimum to 2.

\texttt{app/models/product.rb}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  validates :name,
            presence: true,
            length: { in: 2..20 }

  validates :price,
            :presence => true
end
\end{verbatim}\end{shaded}

If we now try to save a \texttt{Product} with a \texttt{name} that consists in one letter, we get an error message:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> product = Product.create(:name => 'M', :price => 0.45)
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
=> #<Product id: nil, name: "M", price: #<BigDecimal:7f9f3d0943c0,'0.45E0',9(45)>, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.errors.messages
=> {:name=>["is too short (minimum is 2 characters)"]}
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Options}\label{options-3}

\texttt{length} can be called with the following options.

\subsection{minimum}\label{minimum-1}

The minimum length of an attribute. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          length: { minimum: 2 }
\end{verbatim}\end{shaded}

\subsection{too\_short}\label{tooux5fshort}

Defines the error message of \texttt{:minimum}. Default: “is too short (min is \%d characters)”. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          length: { minimum: 5 ,
          too_short: "must have at least %{count} characters"}
\end{verbatim}\end{shaded}

\paragraph{Note}\label{note-27}

For all error messages, please note \hyperref[i18n]{Chapter~10, \emph{Internationalization}}.

\subsection{maximum}\label{maximum-1}

The maximum length of an attribute. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          length: { maximum: 20 }
\end{verbatim}\end{shaded}

\subsection{too\_long}\label{tooux5flong}

Defines the error message of \texttt{:maximum}. Default: “is too long (maximum is \%d characters)”. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          length: { maximum: 20 ,
          too_long: "must have at most %{count} characters" }
\end{verbatim}\end{shaded}

\subsection{Note}\label{note-28}

For all error messages, please note \hyperref[i18n]{Chapter~10, \emph{Internationalization}}.

\subsection{is}\label{is}

Is exactly the specified number of characters long. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          length: { is: 8 }
\end{verbatim}\end{shaded}

\subsection{:in or :within}\label{in-or-within}

Defines a length interval. The first number specifies the minimum number of the range and the second the maximum. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          length: { in: 2..20 }
\end{verbatim}\end{shaded}

\subsection{tokenizer}\label{tokenizer}

You can use this to define how the attribute should be split for counting. Default: \texttt{lambda\{ \textbar{}value\textbar{} value.split(//) \}} (individual characters are counted). Example (for counting words):

\begin{shaded}\begin{verbatim}
validates :content,
          presence: true,
          length: { in: 2..20 },
          tokenizer: lambda {|str| str.scan(/\w+/)}
\end{verbatim}\end{shaded}

\subsection{numericality}\label{numericality}

With \texttt{numericality} you can check if an attribute is a number. It's easier to explain if we use an example.

\texttt{app/models/product.rb}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  validates :name,
            presence: true,
            length: { in: 2..20 }

  validates :price,
            presence: true

  validates :weight,
            numericality: true
end
\end{verbatim}\end{shaded}

If we now use a \texttt{weight} that consists of letters or contains letters instead of numbers, we will get an error message:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> product = Product.create(name: 'Milk (1 liter)', price: 0.45, weight: 'abc')
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
=> #<Product id: nil, name: "Milk (1 liter)", price: #<BigDecimal:7ff4a4380b30,'0.45E0',9(45)>, weight: 0, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.errors.messages
=> {:weight=>["is not a number"]}
>> exit
$
\end{verbatim}\end{shaded}

\paragraph{Tip}\label{tip-10}

You can use \texttt{numericality} to define the content as number even if an attribute is saved as string in the database.

\subsection{Options}\label{options-4}

\texttt{numericality} can be called with the following options.

\subsection{only\_integer}\label{onlyux5finteger}

The attribute can only contain an integer. Default: false. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { only_integer: true }
\end{verbatim}\end{shaded}

\subsection{greater\_than}\label{greaterux5fthan}

The number saved in the attribute must be greater than the specified value. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { greater_than: 100 }
\end{verbatim}\end{shaded}

\subsection{greater\_than\_or\_equal\_to}\label{greaterux5fthanux5forux5fequalux5fto}

The number saved in the attribute must be greater than or equal to the specified value. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { greater_than_or_equal_to: 100 }
\end{verbatim}\end{shaded}

\subsection{equal\_to}\label{equalux5fto}

Defines a specific value that the attribute must have. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { equal_to: 100 }
\end{verbatim}\end{shaded}

\subsection{less\_than}\label{lessux5fthan}

The number saved in the attribute must be less than the specified value. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { less_than: 100 }
\end{verbatim}\end{shaded}

\subsection{less\_than\_or\_equal\_to}\label{lessux5fthanux5forux5fequalux5fto}

The number saved in the attribute must be less than or equal to the specified value. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { less_than_or_equal_to: 100 }
\end{verbatim}\end{shaded}

\subsection{odd}\label{odd}

The number saved in the attribute must be an odd number. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { odd: true }
\end{verbatim}\end{shaded}

\subsection{even}\label{even}

The number saved in the attribute must be an even number. Example:

\begin{shaded}\begin{verbatim}
validates :weight,
          numericality: { even: true }
\end{verbatim}\end{shaded}

\section{uniqueness}\label{uniqueness}

With \texttt{uniqueness} you can define that the value of this attribute must be unique in the database. If you want a product in the database to have a unique name that appears nowhere else, then you can use this validation:

\texttt{app/models/product.rb}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  validates :name,
            presence: true,
            uniqueness: true
end
\end{verbatim}\end{shaded}

If we now try to create a new \texttt{Product} with a \texttt{name} that already exists, then we get an error message:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product.last
  Product Load (1.9ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" DESC LIMIT 1
=> #<Product id: 4, name: "Milk (1 liter)", price: #<BigDecimal:7f90649840a8,'0.45E0',9(45)>, weight: nil, in_stock: nil, expiration_date: nil, created_at: "2012-11-19 09:30:21", updated_at: "2012-11-19 09:30:21">
>> product = Product.create(name: 'Milk (1 liter)')
   (0.1ms)  begin transaction
  Product Exists (0.1ms)  SELECT 1 AS one FROM "products" WHERE "products"."name" = 'Milk (1 liter)' LIMIT 1
   (0.1ms)  rollback transaction
=> #<Product id: nil, name: "Milk (1 liter)", price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.errors.messages
=> {:name=>["has already been taken"]}
>> exit
$
\end{verbatim}\end{shaded}

\paragraph{Warning}\label{warning-7}

The validation via \texttt{uniqueness} is no absolute guarantee that the attribute is unique in the database. A race condition could occur (see \url{http://en.wikipedia.org/wiki/Race_condition}\{.uri\}). A detailled discussion of this effect would go beyond the scope of book aimed at beginners (this phenomenon is extremely rare).

\subsection{Options}\label{options-5}

\texttt{uniqueness} can be called with the following options.

\subsection{scope}\label{scope}

Defines a scope for the uniqueness. If we had a differently structured phone number database (with just one field for the phone number), then we could use this option to specify that a phone number must only be saved once per user. Here is what it would look like:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          uniqueness: { scope: :user_id }
\end{verbatim}\end{shaded}

\subsection{case\_sensitive}\label{caseux5fsensitive}

Checks for uniqueness of upper and lower case as well. Default: false. Example:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          uniqueness: { case_sensitive: true }
\end{verbatim}\end{shaded}

\section{inclusion}\label{inclusion}

With \texttt{inclusion} you can define from which values the content of this attribute can be created. For our example, we can demonstrate it using the attribute \texttt{in\_stock}.

\texttt{app/models/product.rb}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            presence: true

  validates :in_stock,
            inclusion: { in: [true, false] }
end
\end{verbatim}\end{shaded}

In our data model, a \texttt{Product} must be either \texttt{true} or \texttt{false} for \texttt{in\_stock} (there must not be a nil). If we enter a different value than \texttt{true} or \texttt{false}, a validation error is returned:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> product = Product.create(name: 'Milk low-fat (1 liter)')
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
=> #<Product id: nil, name: "Milk low-fat (1 liter)", price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil>
>> product.errors.messages
=> {:in_stock=>["is not included in the list"]}
>> exit
$
\end{verbatim}\end{shaded}

\paragraph{Tip}\label{tip-11}

Always remember the power of Ruby! For example, you can generate the enumerable object always live from another database. In other words, the validation is not defined statically.

\subsection{Options}\label{options-6}

\texttt{inclusion} can be called with the following option.

\subsection{message}\label{message}

For outputting custom error messages. Default: “is not included in the list”. Example:

\begin{shaded}\begin{verbatim}
validates :in_stock,
          inclusion: { in: [true, false],
                          message: 'this one is not allowed' }
\end{verbatim}\end{shaded}

\paragraph{Note}\label{note-29}

For all error messages, please note \hyperref[i18n]{Chapter~10, \emph{Internationalization}}.

\section{exclusion}\label{exclusion}

\texttt{exclusion} is the inversion of \hyperref[validatesux5finclusionux5fof]{the section called “inclusion”}. You can define from which values the content of this attribute must not be created.

\texttt{app/models/product.rb}

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            presence: true

  validates :in_stock,
            exclusion: { in: [nil] }
end
\end{verbatim}\end{shaded}

\paragraph{Tip}\label{tip-12}

Always remember the power of Ruby! For example, you can generate the enumerable object always live from another database. In other words, the validation does not have to be defined statically.

\subsection{Options}\label{options-7}

\texttt{exclusion} can be called with the following option.

\subsection{message}\label{message-1}

For outputting custom error messages. Example:

\begin{shaded}\begin{verbatim}
validates :in_stock,
          inclusion: { in: [nil],
                          message: 'this one is not allowed' }
\end{verbatim}\end{shaded}

\paragraph{Note}\label{note-30}

For all error messages, please note \hyperref[i18n]{Chapter~10, \emph{Internationalization}}.

\subsection{format}\label{format}

With \texttt{format} you can define via a regular expression (see \url{http://en.wikipedia.org/wiki/Regular_expression}\{.uri\}) how the content of an attribute can be structured.

With \texttt{format} you can for example carry out a simple validation of the syntax of an e-mail address:

\begin{shaded}\begin{verbatim}
validates :email,
          format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i }
\end{verbatim}\end{shaded}

\paragraph{Warning}\label{warning-8}

It should be obvious that the e-mail address validation shown here is not complete. It is just meant to be an example. You can only use it to check the syntactic correctness of an e-mail address.

\subsection{Options}\label{options-8}

\texttt{validates\_format\_of} can be called with the following options:

\begin{itemize}
\item
  \texttt{:message}

  For outputting a custom error message. Default: “is invalid”. Example:

\begin{shaded}\begin{verbatim}
validates :email,
          format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i,
                       message: 'is not a valid email address' }
\end{verbatim}\end{shaded}

  \subsection{Note}\label{note-31}

  For all error messages, please note \hyperref[i18n]{Chapter~10, \emph{Internationalization}}.
\end{itemize}

\subsection{General Validation Options}\label{general-validation-options}

There are some options that can be used for all validations.

\subsection{allow\_nil}\label{allowux5fnil}

Allows the value \texttt{nil}. Example:

\begin{shaded}\begin{verbatim}
validates :email,
          format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i },
          allow_nil: true
\end{verbatim}\end{shaded}

\subsection{allow\_blank}\label{allowux5fblank}

As \texttt{allow\_nil}, but additionally with an empty string. Example:

\begin{shaded}\begin{verbatim}
validates :email,
          format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i },
          allow_blank: true
\end{verbatim}\end{shaded}

\subsection{on}\label{on}

With \texttt{on}, a validation can be limited to the events \texttt{create}, \texttt{update} or \texttt{safe}. In the following example, the validation only takes effect when the record is initially created (during the \texttt{create}):

\begin{shaded}\begin{verbatim}
validates :email,
          format: { with: /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i },
          on: :create
\end{verbatim}\end{shaded}

\subsection{\texttt{if} and \texttt{unless}}\label{if-and-unless}

\texttt{if} or \texttt{unless} call the specified method and only execute the validation if the result of the method is true:

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          if: :today_is_monday?

def today_is_monday?
  Date.today.monday?
end
\end{verbatim}\end{shaded}

\subsection{proc}\label{proc}

\texttt{:}\texttt{proc} calls a \texttt{Proc} object.

\begin{shaded}\begin{verbatim}
validates :name,
          presence: true,
          if: Proc.new { |a| a.email == 'test@test.com' }
\end{verbatim}\end{shaded}

\subsection{Writing Custom Validations}\label{writing-custom-validations}

Now and then, you want to do a validation where you need custom program logic. For such cases, you can define custom validations.

\subsection{Defining Validations with Your Own Methods}\label{defining-validations-with-your-own-methods}

Let's assume you are a big shot hotel mogul and need a reservation system.

\begin{shaded}\begin{verbatim}
$ rails new my_hotel
  [...]
$ cd my_hotel
$ rails generate model reservation start_date:date end_date:date room_type
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Then we specify in the \texttt{app/model/reservation.rb} that the attributes \texttt{start\_date} and \texttt{end\_date} must be present in any case, plus we use the method \texttt{reservation\_dates\_must\_make\_sense} to make sure that the \texttt{start\_date} is before the \texttt{end\_date}:

\begin{shaded}\begin{verbatim}
class Reservation < ActiveRecord::Base
  validates :start_date,
            presence: true

  validates :end_date,
            presence: true

  validate :reservation_dates_must_make_sense

  private
  def reservation_dates_must_make_sense
    if end_date <= start_date
      errors.add(:start_date, 'has to be before the end date')
    end
  end
end
\end{verbatim}\end{shaded}

With \texttt{errors.add} we can add error messages for individual attributes. With \texttt{errors.add\_to\_base} you can add error messages for the whole object.

Let's test the validation in the console:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> reservation = Reservation.new(start_date: Date.today, end_date: Date.today)
=> #<Reservation id: nil, start_date: "2012-11-19", end_date: "2012-11-19", room_type: nil, created_at: nil, updated_at: nil>
>> reservation.valid?
=> false
>> reservation.errors.messages
=> {:start_date=>["has to be before the end date"]}
>> reservation.end_date = Date.today + 1.day
=> Tue, 20 Nov 2012
>> reservation.valid?
=> true
>> reservation.save
   (0.1ms)  begin transaction
  SQL (8.7ms)  INSERT INTO "reservations" ("created_at", "end_date", "room_type", "start_date", "updated_at") VALUES (?, ?, ?, ?, ?)  [["created_at", Mon, 19 Nov 2012 14:00:50 UTC +00:00], ["end_date", Tue, 20 Nov 2012], ["room_type", nil], ["start_date", Mon, 19 Nov 2012], ["updated_at", Mon, 19 Nov 2012 14:00:50 UTC +00:00]]
   (3.4ms)  commit transaction
=> true
>> exit
$
\end{verbatim}\end{shaded}

\subsection{Further Documentation}\label{further-documentation}

The topic validations is described very well in the official Rails documentation at \url{http://guides.rubyonrails.org/active_record_validations.html}\{.uri\}.

\subsection{Migrations}\label{migrations}

SQL database tables are generated in Rails with \emph{migrations} and they should also be changed with \emph{migrations}. If you create a model with \textbf{rails generate model}, a corresponding migration file is automatically created in the directory \texttt{db/migrate/}. I am going to show you the principle using the example of a shop application. Let's create one first:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$
\end{verbatim}\end{shaded}

Then we create a \texttt{Product} model:

\begin{shaded}\begin{verbatim}
$ rails generate model product name 'price:decimal{7,2}' weight:integer in_stock:boolean expiration_date:date
      invoke  active_record
      create    db/migrate/20121119143522_create_products.rb
      create    app/models/product.rb
      invoke    test_unit
      create      test/unit/product_test.rb
      create      test/fixtures/products.yml
$
\end{verbatim}\end{shaded}

The migrations file \texttt{db/migrate/20121119143522\_create\_products.rb} was created. Let's have a closer look at it:

\begin{shaded}\begin{verbatim}
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.decimal :price, :precision => 7, :scale => 2
      t.integer :weight
      t.boolean :in_stock
      t.date :expiration_date

      t.timestamps
    end
  end
end
\end{verbatim}\end{shaded}

The method \texttt{change} creates and deletes the database table in case of a rollback. The migration files have embedded the current time in the file name and are processed in chronological order during a migration (in other words, when you call \textbf{rake db:migrate}).

\begin{shaded}\begin{verbatim}
$ rake db:migrate
==  CreateProducts: migrating =================================================
-- create_table(:products)
   -> 0.0017s
==  CreateProducts: migrated (0.0018s) ========================================

$
\end{verbatim}\end{shaded}

Only those migrations that have not been executed yet are processed. If we call \textbf{rake db:migrate} again, nothing happens, because the corresponding migration has already been executed:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
$
\end{verbatim}\end{shaded}

But if we manually delete the database with \textbf{rm} and then call \textbf{rake db:migrate} again, the migration is repeated:

\begin{shaded}\begin{verbatim}
$ rm db/development.sqlite3
$ rake db:migrate
==  CreateProducts: migrating =================================================
-- create_table(:products)
   -> 0.0016s
==  CreateProducts: migrated (0.0017s) ========================================

$  
\end{verbatim}\end{shaded}

After a while we realise that we want to save not just the weight for some products, but also the height. So we need another database field. There is an easy to remember syntax for this, \textbf{rails generate migration add\_*}:

\begin{shaded}\begin{verbatim}
$ rails generate migration add_height_to_product height:integer
      invoke  active_record
      create    db/migrate/20121119143758_add_height_to_product.rb
$
\end{verbatim}\end{shaded}

In the migration file \texttt{db/migrate/20121119143758\_add\_height\_to\_product.rb} we once again find a change method:

\begin{shaded}\begin{verbatim}
class AddHeightToProduct < ActiveRecord::Migration
  def change
    add_column :products, :height, :integer
  end
end
\end{verbatim}\end{shaded}

With \textbf{rake db:migrate} we can start in the new migration:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
==  AddHeightToProduct: migrating =============================================
-- add_column(:products, :height, :integer)
   -> 0.0007s
==  AddHeightToProduct: migrated (0.0008s) ====================================

$
\end{verbatim}\end{shaded}

In the \emph{console} we can look at the new field. It was added after the field \texttt{updated\_at}:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> Product
=> Product(id: integer, name: string, price: decimal, weight: integer, in_stock: boolean, expiration_date: date, created_at: datetime, updated_at: datetime, height: integer)
>> exit
$
\end{verbatim}\end{shaded}

\paragraph{Warning}\label{warning-9}

Please note that you need to add the new field in \texttt{attr\_accessible} in \texttt{app/models/product.rb}, otherwise you will not have access to the \texttt{height} attribute.

What if you want to look at the previous state of things? No problem. You can easily go back to the previous version with \textbf{rake db:rollback}:

\begin{shaded}\begin{verbatim}
$ rake db:rollback
==  AddHeightToProduct: reverting =============================================
-- remove_column("products", :height)
   -> 0.0151s
==  AddHeightToProduct: reverted (0.0152s) ====================================

$
\end{verbatim}\end{shaded}

Each migration has its own version number. You can find out the version number of the current status via \textbf{rake db:version}:

\begin{shaded}\begin{verbatim}
$ rake db:version
Current version: 20121119143522
$
\end{verbatim}\end{shaded}

\paragraph{Important}\label{important-10}

Please note that all version numbers and timestamps only apply to the example printed here. If you recreate the example, you will of course get a different timestamp for your own example.

You will find the corresponding version in the directory \texttt{db/migrate}:

\begin{shaded}\begin{verbatim}
$ ls db/migrate/
20121119143522_create_products.rb
20121119143758_add_height_to_product.rb
$
\end{verbatim}\end{shaded}

You can go to a specific migration via \textbf{rake db:migrate VERSION=} and add the appropriate version number after the equals sign. The zero represents the version zero, in other words the start. Let's try it out:

\begin{shaded}\begin{verbatim}
$ rake db:migrate VERSION=0
==  CreateProducts: reverting =================================================
-- drop_table("products")
   -> 0.0005s
==  CreateProducts: reverted (0.0006s) ========================================

$
\end{verbatim}\end{shaded}

The table was deleted with all data. We are back to square one.

\subsection{Which Database is Used?}\label{which-database-is-used}

The database table is created through the migration. As you can see, the table names automatically get the plural of the \emph{model}s (\texttt{Person} vs. \texttt{people}). But in which database are the tables created? This is defined in the configuration file \texttt{config/database.yml}:

\begin{shaded}\begin{verbatim}
### SQLite version 3.x
##   gem install sqlite3
###
###   Ensure the SQLite 3 gem is defined in your Gemfile
###   gem 'sqlite3'
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

### Warning: The database defined as "test" will be erased and
### re-generated from your development database when you run "rake".
### Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
\end{verbatim}\end{shaded}

Three different databases are defined there in YAML format (see \url{http://www.yaml.org/}\{.uri\} or \url{http://en.wikipedia.org/wiki/YAML}\{.uri\}). For us, only the \texttt{development} database is relevant for now (first item). By default, Rails uses SQLite3 there. SQLite3 may not be the correct choice for the analysis of the weather data collected worldwide, but for a quick and straightforward development of Rails applications you will quickly learn to appreciate it. In the production environment, you can later still switch to “big” databases such as MySQL or PostgreSQL.\textsuperscript{{[}\hyperref[ftn.idp5093968]{11}{]}}

To satisfy your curiosity, we have a quick look at the database with the command line tool \textbf{sqlite3}:

\begin{shaded}\begin{verbatim}
$ sqlite3 db/development.sqlite3
SQLite version 3.7.12 2012-04-03 19:43:07
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> .tables
schema_migrations
sqlite> .quit
$
\end{verbatim}\end{shaded}

Nothing in it. Of course not, as we have not yet run the migration:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
==  CreateProducts: migrating =================================================
-- create_table(:products)
   -> 0.0142s
==  CreateProducts: migrated (0.0143s) ========================================

==  AddHeightToProduct: migrating =============================================
-- add_column(:products, :height, :integer)
   -> 0.0011s
==  AddHeightToProduct: migrated (0.0012s) ====================================

$ sqlite3 db/development.sqlite3
SQLite version 3.7.12 2012-04-03 19:43:07
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite> .tables
products           schema_migrations
sqlite> .schema products
CREATE TABLE "products" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(255), "price" decimal(7,2), "weight" integer, "in_stock" boolean, "expiration_date" date, "created_at" datetime NOT NULL, "updated_at" datetime NOT NULL, "height" integer);
sqlite> .quit
$
\end{verbatim}\end{shaded}

The table \texttt{schema\_migrations} is used for the versioning of the migrations. This table is created during the first migration carried out by Rails, if it does not yet exist.

\subsection{Creating Index}\label{creating-index}

I assume that you know what a database index is. If not, you will find a brief introduction at \url{http://en.wikipedia.org/wiki/Database_index}\{.uri\}. In brief: you can use it to quickly search for a specific table column.

In our production database, we should index the field \texttt{name} in the \texttt{products} table. We create a new migration for that purpose:

\begin{shaded}\begin{verbatim}
$ rails generate migration create_index
      invoke  active_record
      create    db/migrate/20121120142002_create_index.rb
$
\end{verbatim}\end{shaded}

In the file \texttt{db/migrate/20121120142002\_create\_index.rb} we create the index with \texttt{add\_index} in the method \texttt{self.up}, and in the method \texttt{self.down} we delete it again with \texttt{remove\_index}:

\begin{shaded}\begin{verbatim}
class CreateIndex < ActiveRecord::Migration
  def up
    add_index :products, :name
  end

  def down
    remove_index :products, :name
  end
end
\end{verbatim}\end{shaded}

With \textbf{rake db:migrate} we create the index:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
==  CreateIndex: migrating ====================================================
-- add_index(:products, :name)
   -> 0.0010s
==  CreateIndex: migrated (0.0011s) ===========================================

$
\end{verbatim}\end{shaded}

Of course we don't have to use the \texttt{up} and \texttt{down} method. We can use \texttt{change} too. The migration for the new index would look like this:

\begin{shaded}\begin{verbatim}
class CreateIndex < ActiveRecord::Migration
  def change
    add_index :products, :name
  end
end
\end{verbatim}\end{shaded}

\paragraph{Tip}\label{tip-13}

You can also create an index directly when you generate the model. In our case (an index for the attribute \texttt{name}) the command would look like this:

\begin{shaded}\begin{verbatim}
$ rails generate model product name:string:index 'price:decimal{7,2}' weight:integer in_stock:boolean expiration_date:date
      invoke  active_record
      create    db/migrate/20121120142344_create_products.rb
      create    app/models/product.rb
      invoke    test_unit
      create      test/unit/product_test.rb
      create      test/fixtures/products.yml
$ cat db/migrate/20121120142344_create_products.rb
class CreateProducts < ActiveRecord::Migration
  def change
    create_table :products do |t|
      t.string :name
      t.decimal :price, :precision => 7, :scale => 2
      t.integer :weight
      t.boolean :in_stock
      t.date :expiration_date

      t.timestamps
    end
    add_index :products, :name
  end
end
$
\end{verbatim}\end{shaded}

\subsection{Miscellaneous}\label{miscellaneous-1}

This book is aimed at beginners, so I cannot discuss the topic migrations in great depth. The main focus is on understanding the mechanics in principle. But there are a few details that are so important that I want to mention them here.

\subsection{Automatically Added Fields (id, created\_at and updated\_at)}\label{automatically-added-fields-id-createdux5fat-and-updatedux5fat}

Rails kindly adds the following fields automatically in the default migration:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{id:integer} This is the unique ID of the record. The field is automatically incremented by the database. For all SQL fans: \texttt{NOT NULL AUTO\_INCREMENT}
\item
  \texttt{created\_at:datetime} The field is filled automatically by ActiveRecord when a record is created.
\item
  \texttt{updated\_at:datetime} The field is automatically updated to the current time whenever the record is edited.
\end{itemize}

So you don't have to enter these fields yourself when generating the model.

At first you may ask yourself: “Is that really necessary? Does it make sense?”. But after a while you will learn to appreciate these automatic fields. Omitting them would usually be false economy.

\subsection{Further Documentation}\label{further-documentation-1}

The following webpages provide excellent further information on the topic migration:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \url{http://api.rubyonrails.org/classes/ActiveRecord/Migration.html}\{.uri\}
\item
  \url{http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html}\{.uri\}
\item
  \url{http://railscasts.com/episodes/107-migrations-in-rails-2-1}\{.uri\} This screencast is a bit dated (Rails version 2.1), but still good if you are trying to understand the basics.
\item
  \url{http://www.dizzy.co.uk/ruby_on_rails/cheatsheets/rails-migrations}\{.uri\}
\end{itemize}

\subsection{Miscellaneous}\label{miscellaneous-2}

In this section, I am going to show you some examples of topics and questions that are important for your everyday work, but as a whole go beyond the scope of this book aimed at beginners. They provide recipes for solving specific ActiveRecord problems.

\section{Callbacks}\label{callbacks}

Callbacks are defined programming hooks in the life of an ActiveRecord object. You can find a list of all callbacks at \url{http://api.rubyonrails.org/classes/ActiveRecord/Callbacks.html}\{.uri\}. Here are the most frequently used callbacks:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{before\_validation} Executed before the validation.
\item
  \texttt{after\_validation} Executed after the validation.
\item
  \texttt{before\_save} Executed before each save.
\item
  \texttt{before\_create} Executed before the first save.
\item
  \texttt{after\_save} Executed after every save.
\item
  \texttt{after\_create} Executed after the first save.
\end{itemize}

A callback is always executed in the model. Let's assume you always want to save an e-mail address in a \texttt{User} model in lower case, but also give the user of the web interface the option to enter upper case letters. You could use a \texttt{before\_save} callback to convert the attribute \texttt{email} to lower case via the method \texttt{downcase}.

The Rails application:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$ rails generate model user email login
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Here is what the model \texttt{app/models/user.rb} would look like. The interesting stuff is the \texttt{before\_save} part:

\begin{shaded}\begin{verbatim}
class User < ActiveRecord::Base
  validates :login,
            presence: true

  validates :email,
            presence: true,
            format: { :with => /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i }

  before_save :downcase_email

  private

  def downcase_email
    self.email = self.email.downcase
  end

end
\end{verbatim}\end{shaded}

Let's see in the console if it really works as we want it to:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> User.create(login: 'smith', email: 'SMITH@example.com')
   (0.1ms)  begin transaction
  SQL (29.9ms)  INSERT INTO "users" ("created_at", "email", "login", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Wed, 21 Nov 2012 09:14:47 UTC +00:00], ["email", "smith@example.com"], ["login", "smith"], ["updated_at", Wed, 21 Nov 2012 09:14:47 UTC +00:00]]
   (0.7ms)  commit transaction
=> #<User id: 1, email: "smith@example.com", login: "smith", created_at: "2012-11-21 09:14:47", updated_at: "2012-11-21 09:14:47">
>> exit
$
\end{verbatim}\end{shaded}

Even though the e-mail address was entered partly with a capital letters, ActiveRecord has indeed converted all letters automatically to lower case via the \texttt{before\_save} callback.

In \hyperref[actionux5fmailer]{Chapter~9, \emph{Action Mailer}} you will find an example for the same model where we use an \texttt{after\_create} callback to automatically send an e-mail to a newly created user. In \hyperref[arux5fdefaultux5fwerte]{the section called “Default Values”} you will find an example for defining a default value for a new object via an \texttt{after\_initialize} callback.

\section{Default Values}\label{default-values}

If you need specific default values for an ActiveRecord object, you can easily implement this with the \texttt{after\_initialize} callback. This method is called by ActiveRecord when a new object is created. Let's assume we have a model\texttt{Order} and the minimum order quantity is always 1, so we can enter 1 directly as default value when creating a new record.

Let's set up a quick example:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$ rails generate model order product_id:integer quantity:integer
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

We write an \texttt{after\_initialize} callback into the file \texttt{app/models/order.rb}:

\begin{shaded}\begin{verbatim}
class Order < ActiveRecord::Base
  after_initialize :set_defaults

  private
  def set_defaults
    self.quantity ||= 1
  end
end
\end{verbatim}\end{shaded}

And now we check in the console if a new order object automatically contains the quantity 1:

\begin{shaded}\begin{verbatim}
$ rails console
Loading development environment (Rails 4.0.0)
>> order = Order.new
=> #<Order id: nil, product_id: nil, quantity: 1, created_at: nil, updated_at: nil>
>> order.quantity
=> 1
>> exit
$
\end{verbatim}\end{shaded}

That's working fine.

* * * * *

\textsuperscript{{[}\hyperref[idp2940224]{9}{]}}see \url{http://en.wikipedia.org/wiki/Active_record_pattern}\{.uri\}

\textsuperscript{{[}\hyperref[idp4450352]{10}{]}}If you are interested in the theoretical background on \emph{joins}, you will find more information here: \url{http://en.wikipedia.org/wiki/SQL\#Queries}\{.uri\}, \url{http://en.wikipedia.org/wiki/Join_(SQL)}\{.uri\}, \url{http://en.wikipedia.org/wiki/Relational_algebra\#Joins_and_join-like_operators}\{.uri\}

\textsuperscript{{[}\hyperref[idp5093968]{11}{]}}Some developers believe that you should always develop with the same database that you are later going to use for production and \emph{testing}. Others feel that this is not necessary when using ORM abstraction layers. Please make your own decision on this. I often program a Rails application with SQLite and frequently use MySQL for the production.

\chap{Scaffolding and REST}\label{scaffolding-and-rest}

\section{Introduction}\label{introduction-1}

Scaffolding means purely and simply that a basic \emph{scaffold} for an application is created via a generator. This scaffold not only contains the \emph{model} but also a simple Web GUI (\emph{views}) and of course a \emph{controller}. The programming paradigm used for this is REST (Representational State Transfer).

You can find a definition of REST at \url{http://en.wikipedia.org/wiki/Representational_state_transfer}\{.uri\}. My super short version: the inventor Roy Fielding described in 2000 how you can access data with a simple set of rules within the concept of CRUD (see \texttt{http://en.wikipedia.org/wiki/Create,\_read,\_update\_and\_delete}) and the specification of the Hypertext Transfer Protocol (HTTP). CRUD is the abbreviation for Create (SQL: INSERT), Read (SQL: SELECT), Update (SQL: UPDATE) and Delete (SQL: Delete). This created URLs that are easy to read for humans and have a certain logic. In this chapter, you will see examples showing the individual paths for the different CRUD functions.

I think the greatest frustration with Rail arises regularly from the fact that many beginners use scaffolding to get quick results without having proper basic knowledge of Ruby and without knowing what ActiveRecord is. They don't know what to do next. Fortunately, you have worked your way through \hyperref[ruby-grundlagen]{Chapter~2, \emph{Ruby Basics}}, \hyperref[ersteux5fschritteux5fmitux5frails]{Chapter~3, \emph{First Steps with Rails}} and \hyperref[activerecordux5fchapter]{Chapter~4, \emph{ActiveRecord}}, so you will be able to understand and use scaffolding straight away.

\subsection{Note}\label{note-32}

This chapter is an introduction to scaffolding, not an encyclopedia that covers all variations. Our focus is on the basic idea and on getting beginners started. The same applies to REST.

\section{Generating a Scaffold}\label{generating-a-scaffold}

Let's first use scaffolding to create a list of products for an online shop. First, we need to create a new Rails application:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$
\end{verbatim}\end{shaded}

Let's look at the scaffolding options:

\begin{shaded}\begin{verbatim}
$ rails generate scaffold
Usage:
  rails generate scaffold NAME [field[:type][:index] field[:type][:index]] [options]

Options:
      [--skip-namespace]                        # Skip namespace (affects only isolated applications)
  -o, --orm=NAME                                # Orm to be invoked
                                                # Default: active_record
      [--force-plural]                          # Forces the use of a plural ModelName
      --resource-route                          # Indicates when to generate resource route
                                                # Default: true
  -y, [--stylesheets]                           # Generate Stylesheets
                                                # Default: true
  -se, [--stylesheet-engine=STYLESHEET_ENGINE]  # Engine for Stylesheets
                                                # Default: scss
  -c, --scaffold-controller=NAME                # Scaffold controller to be invoked
                                                # Default: scaffold_controller
      [--assets]                                # Indicates when to generate assets
                                                # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
      [--indexes]              # Add indexes for references and belongs_to columns
                               # Default: true
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true
      [--jbuilder]              # Indicates when to generate jbuilder
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Suppress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attributes are field arguments specifying the model's attributes. You can
    optionally pass the type and an index to each field. For instance:
    "title body:text tracking_id:integer:uniq" will generate a title field of
    string type, a body with text type and a tracking_id as an integer with an
    unique index. "index" could also be given instead of "uniq" if one desires
    a non unique index.

    Timestamps are added by default, so you don't have to specify them by hand
    as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title body:text published:boolean' gives
    you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a resources :posts declaration
    in config/routes.rb.

    If you want to remove all the generated files, run
    'rails destroy scaffold ModelName'.

Examples:
    `rails generate scaffold post`
    `rails generate scaffold post title body:text published:boolean`
    `rails generate scaffold purchase amount:decimal tracking_id:integer:uniq`
$
\end{verbatim}\end{shaded}

I'll keep it short: for our current state of knowledge, we can use \textbf{rails generate scaffold} just like \textbf{rails generate model} (see \hyperref[activerecordux5fdatenbankux5fanlegen]{the section called “Creating Database/``Model”\,''}). Let's now create the scaffold for the products:

\begin{shaded}\begin{verbatim}
$ rails generate scaffold product name 'price:decimal{7,2}'
      invoke  active_record
      create    db/migrate/20130716185952_create_products.rb
      create    app/models/product.rb
      invoke    test_unit
      create      test/models/product_test.rb
      create      test/fixtures/products.yml
      invoke  resource_route
       route    resources :products
      invoke  scaffold_controller
      create    app/controllers/products_controller.rb
      invoke    erb
      create      app/views/products
      create      app/views/products/index.html.erb
      create      app/views/products/edit.html.erb
      create      app/views/products/show.html.erb
      create      app/views/products/new.html.erb
      create      app/views/products/_form.html.erb
      invoke    test_unit
      create      test/controllers/products_controller_test.rb
      invoke    helper
      create      app/helpers/products_helper.rb
      invoke      test_unit
      create        test/helpers/products_helper_test.rb
      invoke    jbuilder
      create      app/views/products/index.json.jbuilder
      create      app/views/products/show.json.jbuilder
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/products.js.coffee
      invoke    scss
      create      app/assets/stylesheets/products.css.scss
      invoke  scss
      create    app/assets/stylesheets/scaffolds.css.scss
$
\end{verbatim}\end{shaded}

\section{Creating the Database with Sample Data}\label{creating-the-database-with-sample-data}

As you can see, \textbf{rails generate scaffold} has already created the model. So we can directly call \textbf{rake db:migrate}:

\begin{shaded}\begin{verbatim}
$ rake db:migrate
==  CreateProducts: migrating =================================================
-- create_table(:products)
   -> 0.0016s
==  CreateProducts: migrated (0.0017s) ========================================

$
\end{verbatim}\end{shaded}

Let's create the first six products in the \texttt{db/seeds.rb}. I am not quite sure about Walter Scheel, but after all, this book is all about Rails, not German post-war history.

\begin{shaded}\begin{verbatim}
Product.create(name: 'Apple', price: 1)
Product.create(name: 'Orange', price: 1)
Product.create(name: 'Pineapple', price: 2.4)
Product.create(name: 'Marble cake', price: 3)
\end{verbatim}\end{shaded}

Populate with the example data:

\begin{shaded}\begin{verbatim}
$ rake db:seed
$
\end{verbatim}\end{shaded}

\section{The Routes}\label{the-routes}

\textbf{rails generate scaffold} has created a route (more on this later in \hyperref[routes]{Chapter~6, \emph{Routes}}), a controller and several views for us (see \hyperref[dynamischeux5fwebseiten]{the section called “Creating HTML Dynamically with erb”}). We could also have done all of this manually. Scaffolding is merely an automatism that does the work for us for some basic things. This is assuming that you always want to view, create and delete records.

Without diving too deeply into the topic routes, let's just have a quick look at the available routes for our example. You need to run \textbf{rake routes}:

\begin{shaded}\begin{verbatim}
$ rake routes
      Prefix Verb   URI Pattern                  Controller#Action
    products GET    /products(.:format)          products#index
             POST   /products(.:format)          products#create
 new_product GET    /products/new(.:format)      products#new
edit_product GET    /products/:id/edit(.:format) products#edit
     product GET    /products/:id(.:format)      products#show
             PATCH  /products/:id(.:format)      products#update
             PUT    /products/:id(.:format)      products#update
             DELETE /products/:id(.:format)      products#destroy
$
\end{verbatim}\end{shaded}

These are all the routes and consequently URLs available in this Rails application. All routes invoke actions (in other words, methods) in the \texttt{ProductsController}.

\section{The Controller}\label{the-controller}

Now it's about time we had a look at the file \texttt{app/controllers/products\_controller.rb}. Scaffold automatically creates the methods \texttt{index}, \texttt{show}, \texttt{new}, \texttt{create}, \texttt{update} and \texttt{destroy}. These methods or actions are called by the routes.

Here is the content of \texttt{app/controllers/products\_controller.rb}

\begin{shaded}\begin{verbatim}
class ProductsController < ApplicationController
  before_action :set_product, only: [:show, :edit, :update, :destroy]

  ## GET /products
  # GET /products.json
  def index
    @products = Product.all
  end

  # GET /products/1
  # GET /products/1.json
  def show
  end

  # GET /products/new
  def new
    @product = Product.new
  end

  # GET /products/1/edit
  def edit
  end

  # POST /products
  # POST /products.json
  def create
    @product = Product.new(product_params)

    respond_to do |format|
      if @product.save
        format.html { redirect_to @product, notice: 'Product was successfully created.' }
        format.json { render action: 'show', status: :created, location: @product }
      else
        format.html { render action: 'new' }
        format.json { render json: @product.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /products/1
  # PATCH/PUT /products/1.json
  def update
    respond_to do |format|
      if @product.update(product_params)
        format.html { redirect_to @product, notice: 'Product was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: 'edit' }
        format.json { render json: @product.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /products/1
  # DELETE /products/1.json
  def destroy
    @product.destroy
    respond_to do |format|
      format.html { redirect_to products_url }
      format.json { head :no_content }
    end
  end

  private
    # Use callbacks to share common setup or constraints between actions.
    def set_product
      @product = Product.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def product_params
      params.require(:product).permit(:name, :price)
    end
end
\end{verbatim}\end{shaded}

Let us take a moment and go through this controller.

\section{set\_product}\label{setux5fproduct}

A \texttt{before\_action} calls a private method to set an instance variable \texttt{@product} for the actions :show, :edit, :update and :destroy. That DRYs it up nicely:

\begin{shaded}\begin{verbatim}
before_action :set_product, only: [:show, :edit, :update, :destroy]

[...]

private
  ## Use callbacks to share common setup or constraints between actions.
  def set_product
    @product = Product.find(params[:id])
  end
[...]
\end{verbatim}\end{shaded}

\section{index}\label{index}

The \texttt{index} method sets the instance variable \texttt{@products}. It contains the result of \texttt{Product.all}.

\begin{shaded}\begin{verbatim}
## GET /products
## GET /products.json
def index
  @products = Product.all
end
\end{verbatim}\end{shaded}

\section{show}\label{show}

The \texttt{show} method doesn't do anything. the \texttt{set\_product} \texttt{before\_action} already set the instance variable \texttt{@product}. So there is not more to do.

\begin{shaded}\begin{verbatim}
## GET /products/1
## GET /products/1.json
def show
end
\end{verbatim}\end{shaded}

\section{new}\label{new-1}

The \texttt{new} method creates a new instance of \texttt{Product} and saves it in the instance variable \texttt{@product}.

\begin{shaded}\begin{verbatim}
## GET /products/new
def new
  @product = Product.new
end
\end{verbatim}\end{shaded}

\section{edit}\label{edit}

The \texttt{edit} method doesn't do anything. the \texttt{set\_product} \texttt{before\_action} already set the instance variable \texttt{@product}. So there is not more to do.

\begin{shaded}\begin{verbatim}
## GET /products/1/edit
def edit
end
\end{verbatim}\end{shaded}

\section{create}\label{create-2}

The \texttt{create} method uses \texttt{Product.new} to create a new instance of \texttt{Product} and stores it in \texttt{@product}. The private method \texttt{product\_params} is used to filter the trusted parameters with a white list. When \texttt{@product} was successfully saved a \texttt{redirect} to the \texttt{show} action is initiated for html requests. If a validation error occured the \texttt{new} action will be rendered.

\begin{shaded}\begin{verbatim}
## POST /products
## POST /products.json
def create
  @product = Product.new(product_params)

  respond_to do |format|
    if @product.save
      format.html { redirect_to @product, notice: 'Product was successfully created.' }
      format.json { render action: 'show', status: :created, location: @product }
    else
      format.html { render action: 'new' }
      format.json { render json: @product.errors, status: :unprocessable_entity }
    end
  end
end

[...]

## Never trust parameters from the scary internet, only allow the white list through.
def product_params
  params.require(:product).permit(:name, :price)
end
\end{verbatim}\end{shaded}

\section{update}\label{update}

The \texttt{update} method tries to update @product with the product\_params. The private method \texttt{product\_params} is used to filter the trusted parameters with a white list. When \texttt{@product} was successfully updated a \texttt{redirect} to the \texttt{show} action is initiated for html requests. If a validation error occured the \texttt{edit} action will be rendered.

\begin{shaded}\begin{verbatim}
## PATCH/PUT /products/1
## PATCH/PUT /products/1.json
def update
  respond_to do |format|
    if @product.update(product_params)
      format.html { redirect_to @product, notice: 'Product was successfully updated.' }
      format.json { head :no_content }
    else
      format.html { render action: 'edit' }
      format.json { render json: @product.errors, status: :unprocessable_entity }
    end
  end
end

[...]

## Never trust parameters from the scary internet, only allow the white list through.
def product_params
  params.require(:product).permit(:name, :price)
end
\end{verbatim}\end{shaded}

\section{destroy}\label{destroy-1}

The \texttt{destroy} method destroys \texttt{@product} and redirects an html request to the \texttt{index} action.

\begin{shaded}\begin{verbatim}
## DELETE /products/1
## DELETE /products/1.json
def destroy
  @product.destroy
  respond_to do |format|
    format.html { redirect_to products_url }
    format.json { head :no_content }
  end
end
\end{verbatim}\end{shaded}

\section{JSON}\label{json}

The default scaffold generator creates a setup for HTML and JSON requests.

\chap{The Views}\label{the-views}

Now we start the Rails web server:

\begin{shaded}\begin{verbatim}
$ rails server
=> Booting WEBrick
=> Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=> Run `rails server -h` for more startup options
=> Ctrl-C to shutdown server
[2013-07-16 21:31:19] INFO  WEBrick 1.3.1
[2013-07-16 21:31:19] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-16 21:31:19] INFO  WEBrick::HTTPServer#start: pid=9939 port=3000
\end{verbatim}\end{shaded}

\section{Note}\label{note-33}

If you get a warning from your built-in firewall now, this shows that you have worked through \hyperref[ersteux5fschritteux5fmitux5frails]{Chapter~3, \emph{First Steps with Rails}} properly. ;-)

Now a little drum roll\ldots{} dramatic suspense\ldots{} launch the web browser and go to the URL \texttt{http://0.0.0.0:3000/products}. You can see the list of products as simple web page.

Insert products\_index.png Product index view

If you now click the link “New Product”, you will see an input form for a new record:

Insert product\_new.png Product new view

Use your browser's Back button to go back and click on the “Show” link in the first line. You will then see the following page:

Insert product\_show\_1.png Product show view of the first product

If you now click “Edit”, you will see the editing view for this record:

Insert product\_edit\_1.png Product edit view of the first product

And if you click “Destroy” on the Index page, you can delete a record after confirming the message that pops up. Isn't that cool?! Within less than 10 minutes, you have written a Web application that allows you to \textbf{c}reate, \textbf{r}ead/\textbf{r}etrieve, \textbf{u}pdate and \textbf{d}elete/\textbf{d}estroy records (CRUD). That is the scaffolding magic. You can save a lot of time.

\chap{Where Are the Views?}\label{where-are-the-views}

You can probably guess, but let's have a look at the directory \texttt{app/views/products} anyway:

\begin{shaded}\begin{verbatim}
$ tree app/views/products/
app/views/products/
├── _form.html.erb
├── edit.html.erb
├── index.html.erb
├── index.json.jbuilder
├── new.html.erb
├── show.html.erb
└── show.json.jbuilder
$
\end{verbatim}\end{shaded}

There are two different file extensions. The \texttt{html.erb} is for HTML requests and the \texttt{json.jbuilder} is for JSON requests.

For \texttt{index}, \texttt{edit}, \texttt{new} and \texttt{show} the corresponding views are located there. As \texttt{new} and \texttt{edit} both require a form for editing the data, this is stored in the partial \texttt{\_form.html.erb} (see \hyperref[partials]{the section called “Partials”}) in accordance with the principle of DRY (\textbf{D}on't \textbf{R}epeat \textbf{Y}ourself) and integrated in \texttt{new.html.erb} and \texttt{edit.html.erb} with a \texttt{\textless{}\%= render 'form'         \%\textgreater{}}.

Let's open the file \texttt{app/views/products/index.html.erb}:

\begin{shaded}\begin{verbatim}
<h1>Listing products</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Price</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>

  <tbody>
    <% @products.each do |product| %>
      <tr>
        <td><%= product.name %></td>
        <td><%= product.price %></td>
        <td><%= link_to 'Show', product %></td>
        <td><%= link_to 'Edit', edit_product_path(product) %></td>
        <td><%= link_to 'Destroy', product, method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New Product', new_product_path %>
\end{verbatim}\end{shaded}

You are now an old hand when it comes to ERB, so you'll be able to read and understand the code without any problems. If in doubt, have a quick look at \hyperref[erb-programmieren]{the section called “Programming in an erb File”}.

\chap{link\_to}\label{linkux5fto}

In the views generated by the scaffold generator, you first came across the helper \texttt{link\_to}. This creates \texttt{\textless{}a href         ...\textgreater{}} links. You can of course also enter a link manually via \texttt{\textless{}a href="..."\textgreater{}} in the erb, but for links within a Rails project, \texttt{link\_to} is more practical, because you can use the names of the routes as a target. The code becomes much easier to read. In the above example, there are the following routes:

\begin{shaded}\begin{verbatim}
$ rake routes
      Prefix Verb   URI Pattern                  Controller#Action
    products GET    /products(.:format)          products#index
             POST   /products(.:format)          products#create
 new_product GET    /products/new(.:format)      products#new
edit_product GET    /products/:id/edit(.:format) products#edit
     product GET    /products/:id(.:format)      products#show
             PATCH  /products/:id(.:format)      products#update
             PUT    /products/:id(.:format)      products#update
             DELETE /products/:id(.:format)      products#destroy
$
\end{verbatim}\end{shaded}

The first part of this route is the name of the route. With a new call, this is \texttt{new\_product}. A link to \texttt{new\_product} looks like this in the erb code (you can see it at the end of the file \texttt{app/views/products/index.html.erb}):

\begin{shaded}\begin{verbatim}
<%= link_to 'New Product', new_product_path %>
\end{verbatim}\end{shaded}

In the HTML code of the generated page (\texttt{http://0.0.0.0:3000/products}) you can see the result:

\begin{shaded}\begin{verbatim}
<a href="/products/new">New Product</a>
\end{verbatim}\end{shaded}

With \texttt{link\_to} you can also link to resources within a RESTful resource. Again, you can find examples for this in \texttt{app/views/products/index.html.erb}. In the table, a \texttt{show}, an \texttt{edit} and a \texttt{destroy} link is rendered for each \texttt{product}:

\begin{shaded}\begin{verbatim}
<tbody>
  <% @products.each do |product| %>
    <tr>
      <td><%= product.name %></td>
      <td><%= product.price %></td>
      <td><%= link_to 'Show', product %></td>
      <td><%= link_to 'Edit', edit_product_path(product) %></td>
      <td><%= link_to 'Destroy', product, method: :delete, data: { confirm: 'Are you sure?' } %></td>
    </tr>
  <% end %>
</tbody>
\end{verbatim}\end{shaded}

From the resource and the selected route, Rails automatically determines the required URL and the required HTTP verb (in other words, whether it is a POST, GET, PUT or DELETE). For index and show calls, you need to observe the difference between singular and plural. \texttt{link\_to 'Show', product} links to a single record and \texttt{link\_to 'Show', products\_path} links to the index view.

Whether the name of the route is used with or without the suffix \texttt{\_path} in \texttt{link\_to} depends on whether Rails can “derive” the route from the other specified information. If only one object is specified (in our example, the variable \texttt{product}), then Rails automatically assumes that it is a show route.

Examples:

\begin{longtable}[c]{@{}lp{10cm}@{}}
\caption{~}\\
\toprule\addlinespace
\texttt{link\_to 'Show', Product.first} & Link to the first product.
\\\addlinespace
\texttt{link\_to 'New Product',                 new\_product\_path} & Link to the Web interface where a new product can be created.
\\\addlinespace
\texttt{link\_to 'Edit',                 edit\_product\_path(Product.first)} & Link to the form where the first product can be edited.
\\\addlinespace
\texttt{link\_to 'Destroy', Product.first, method:                 :delete} & Link to deleting the first product.
\\\addlinespace
\bottomrule
\end{longtable}

\section{form\_for}\label{formux5ffor}

In the partial used by \texttt{new} and \texttt{edit}, \texttt{app/views/products/\_form.html.erb}, you will find the following code for the product form:

\begin{shaded}\begin{verbatim}
<%= form_for(@product) do |f| %>
  <% if @product.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(@product.errors.count, "error") %> prohibited this product from being saved:</h2>

      <ul>
      <% @product.errors.full_messages.each do |msg| %>
        <li><%= msg %></li>
      <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= f.label :name %><br>
    <%= f.text_field :name %>
  </div>
  <div class="field">
    <%= f.label :price %><br>
    <%= f.text_field :price %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
\end{verbatim}\end{shaded}

In a block, the helper \texttt{form\_for} takes care of creating the HTML form via which the user can enter the data for the record or edit it. If you delete a complete \texttt{\textless{}div         class="field"\textgreater{}} element here, this can no longer be used for input in the web interface. I am not going to comment on all possible form field variations at this point. The most frequently used ones will appear in examples later on and be explained then (if they are not self-explanatory).

\subsection{Note}\label{note-34}

You can find an overview of all form helpers at \url{http://guides.rubyonrails.org/form_helpers.html}\{.uri\}

When using validations in the model, any validation errors that occur are displayed in the following code at the head of the form:

\begin{shaded}\begin{verbatim}
<% if @product.errors.any? %>
  <div id="error_explanation">
    <h2><%= pluralize(@product.errors.count, "error") %> prohibited this product from being saved:</h2>

    <ul>
    <% @product.errors.full_messages.each do |msg| %>
      <li><%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
\end{verbatim}\end{shaded}

Let's add a small validation to the \texttt{app/models/product.rb} model:

\begin{shaded}\begin{verbatim}
class Product < ActiveRecord::Base
  validates :name,
            presence: true
end
\end{verbatim}\end{shaded}

When ever somebody wants to save a product which doesn't have a name Rails will show this Flash Error:

Insert product\_error\_flash.png Flash error message

\section{Access via JSON}\label{access-via-json}

By default, Rails' scaffolding generates not just access via HTML for “human” users, but also a direct interface for machines. The same methods \texttt{index}, \texttt{show}, \texttt{new}, \texttt{create}, \texttt{update} and \texttt{destroy} can be called via this interface, but in a format that is easier to read for machines. As an example, we will demonstrate the \texttt{index} action via which all data can be read in one go. With the same idea, data can be removed (\texttt{destroy}) or edited (\texttt{update}).

JSON (see \href{http://de.wikipedia.org/wiki/JavaScript_Object_Notation}{http://en.wikipedia.org/wiki/Json}) seems to be the new cool kid. So we use JSON.

If you do not require machine-readable access to data, you can skip these examples. But then you should also delete all lines with \texttt{format.json} in the \texttt{respond\_to} blocks of your controllers, to be on the safe side. Otherwise you still have an interface to the data that you may just forget and that constitutes a potential security gap.

\section{JSON as Default}\label{json-as-default}

Right at the beginning of \texttt{app/controllers/products\_controller.rb} you will find the entry for the \texttt{index} action:

\begin{shaded}\begin{verbatim}
## GET /products
## GET /products.json
def index
  @products = Product.all
end
\end{verbatim}\end{shaded}

The code is straightforward. In the instance variable \texttt{@products}, all products are saved. The view \texttt{app/views/products/index.json.jbuilder} contains the following code to render the JSON:

\begin{shaded}\begin{verbatim}
json.array!(@products) do |product|
  json.extract! product, :name, :price
  json.url product_url(product, format: :json)
end
\end{verbatim}\end{shaded}

You can use your browser to fetch the JSON output. Just open \texttt{http://0.0.0.0:3000/products.json} and view the result. I installed a JSON view extension in my Chrome browser to get a nicer format.

Insert products\_index\_json.png Product index as JSON

If you do not want the JSON output, you need to delete the \texttt{json.jbuilder} files.

\section{JSON and XML Together}\label{json-and-xml-together}

If you ever need a JSON and XML interface in a Rails application, you just need to specify both variants in the controller in the block \texttt{respond\_to}. Here is an example with the \texttt{app/controllers/products\_controller.rb} in the \texttt{index} action:

\begin{shaded}\begin{verbatim}
## GET /products
## GET /products.json
## GET /products.xml
def index
  @products = product.all

  respond_to do |format|
    format.html # index.html.erb
    format.json { render json: @products }
    format.xml { render xml: @products }
  end
end
\end{verbatim}\end{shaded}

\section{When Should You Use Scaffolding?}\label{when-should-you-use-scaffolding}

You should never use scaffolding just for the sake of it. There are Rails developers who never use scaffolding and always build everything manually. I find scaffolding quite useful for quickly getting into a new project. But it is always just the beginning.

\section{Example for a Minimal Project}\label{example-for-a-minimal-project}

Let's assume we need a web page quickly with which we can list products and represent them individually. But we do not require an editing or deleting function. In that case, a large part of the code created via scaffold would be useless and have to be deleted. Let's try it out as follows:

\begin{shaded}\begin{verbatim}
$ rails new read-only-shop
  [...]
$ cd read-only-shop
$ rails generate scaffold product name 'price:decimal{7,2}'
      invoke  active_record
      create    db/migrate/20130716202340_create_products.rb
      create    app/models/product.rb
      invoke    test_unit
      create      test/models/product_test.rb
      create      test/fixtures/products.yml
      invoke  resource_route
       route    resources :products
      invoke  scaffold_controller
      create    app/controllers/products_controller.rb
      invoke    erb
      create      app/views/products
      create      app/views/products/index.html.erb
      create      app/views/products/edit.html.erb
      create      app/views/products/show.html.erb
      create      app/views/products/new.html.erb
      create      app/views/products/_form.html.erb
      invoke    test_unit
      create      test/controllers/products_controller_test.rb
      invoke    helper
      create      app/helpers/products_helper.rb
      invoke      test_unit
      create        test/helpers/products_helper_test.rb
      invoke    jbuilder
      create      app/views/products/index.json.jbuilder
      create      app/views/products/show.json.jbuilder
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/products.js.coffee
      invoke    scss
      create      app/assets/stylesheets/products.css.scss
      invoke  scss
   identical    app/assets/stylesheets/scaffolds.css.scss
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Now create the \texttt{db/seeds.rb} with some demo products:

\begin{shaded}\begin{verbatim}
Product.create(name: 'Apple', price: 1)
Product.create(name: 'Orange', price: 1)
Product.create(name: 'Pineapple', price: 2.4)
Product.create(name: 'Marble cake', price: 3)
\end{verbatim}\end{shaded}

And populate it with this data:

\begin{shaded}\begin{verbatim}
$ rake db:seed
$
\end{verbatim}\end{shaded}

As we only need \texttt{index} and \texttt{show}, we should delete the not required views:

\begin{shaded}\begin{verbatim}
$ rm app/views/products/_form.html.erb
$ rm app/views/products/new.html.erb
$ rm app/views/products/edit.html.erb
$
\end{verbatim}\end{shaded}

The \texttt{json.jbuilder} views are not needed either:

\begin{shaded}\begin{verbatim}
$ rm app/views/products/*.json.jbuilder
$
\end{verbatim}\end{shaded}

The file \texttt{app/controllers/products\_controller.rb} can be simplified with an editor. It should look like this:

\begin{shaded}\begin{verbatim}
class ProductsController < ApplicationController
  # GET /products
  def index
    @products = Product.all
  end

  # GET /products/1
  def show
    @product = Product.find(params[:id])
  end
end
\end{verbatim}\end{shaded}

We only need the routes for \texttt{index} and \texttt{show}. Please open the file \texttt{config/routes.rb} and edit it as follows:

\begin{shaded}\begin{verbatim}
ReadOnlyShop::Application.routes.draw do
  resources :products, only: [:index, :show]
end
\end{verbatim}\end{shaded}

A \textbf{rake routes} shows us that really only \texttt{index} and \texttt{show} are routed now:

\begin{shaded}\begin{verbatim}
$ rake routes
  Prefix Verb URI Pattern             Controller#Action
products GET /products(.:format)     products#index
 product GET /products/:id(.:format) products#show
$
\end{verbatim}\end{shaded}

If we now start the server \textbf{rails server} and go to the URL \texttt{http://0.0.0.0:3000/products}, we get an error message.

Insert products\_routes\_error.png Routing error

The same message will be displayed in the log:

\begin{shaded}\begin{verbatim}
$ rails server
=> Booting WEBrick
=> Rails 4.0.0 application starting in development on http://0.0.0.0:3000
=> Run `rails server -h` for more startup options
=> Ctrl-C to shutdown server
[2013-07-16 22:29:42] INFO  WEBrick 1.3.1
[2013-07-16 22:29:42] INFO  ruby 2.0.0 (2013-06-27) [x86_64-darwin12.4.0]
[2013-07-16 22:29:42] INFO  WEBrick::HTTPServer#start: pid=10182 port=3000


Started GET "/products" for 127.0.0.1 at 2013-07-16 22:29:47 +0200
  ActiveRecord::SchemaMigration Load (0.1ms)  SELECT "schema_migrations".* FROM "schema_migrations"
Processing by ProductsController#index as HTML
  Product Load (0.1ms)  SELECT "products".* FROM "products"
  Rendered products/index.html.erb within layouts/application (21.7ms)
Completed 500 Internal Server Error in 61ms

ActionView::Template::Error (undefined method `edit_product_path' for #<#<Class:0x007f94e6baab08>:0x007f94e6ba9ed8>):
    17:         <td><%= product.name %></td>
    18:         <td><%= product.price %></td>
    19:         <td><%= link_to 'Show', product %></td>
    20:         <td><%= link_to 'Edit', edit_product_path(product) %></td>
    21:         <td><%= link_to 'Destroy', product, method: :delete, data: { confirm: 'Are you sure?' } %></td>
    22:       </tr>
    23:     <% end %>
  app/views/products/index.html.erb:20:in `block in _app_views_products_index_html_erb__535216393559089744_70138729102480'
  app/views/products/index.html.erb:15:in `_app_views_products_index_html_erb__535216393559089744_70138729102480'

[...]
\end{verbatim}\end{shaded}

The error message states that we call an undefined method \texttt{edit\_product\_path} in the view \texttt{app/views/products/index.html.erb}. As we only route \texttt{index} and \texttt{show} now, there are no more \texttt{edit}, \texttt{destroy} or \texttt{new} methods any more. So we need to adapt the file \texttt{app/views/products/index.html.erb} in the editor as follows:

\begin{shaded}\begin{verbatim}
<h1>Listing products</h1>

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Price</th>
      <th></th>
    </tr>
  </thead>

  <tbody>
    <% @products.each do |product| %>
      <tr>
        <td><%= product.name %></td>
        <td><%= product.price %></td>
        <td><%= link_to 'Show', product %></td>
      </tr>
    <% end %>
  </tbody>
</table>
\end{verbatim}\end{shaded}

And while we are at it, we also edit the \texttt{app/views/products/show.html.erb} accordingly:

\begin{shaded}\begin{verbatim}
<p>
  <strong>Name:</strong>
  <%= @product.name %>
</p>

<p>
  <strong>Price:</strong>
  <%= @product.price %>
</p>

<%= link_to 'Back', products_path %>
\end{verbatim}\end{shaded}

Now our application is finished. Start the Rails server with \textbf{rails server} and open the URL \texttt{http://0.0.0.0:3000/products} in the browser.

Insert read-only-products-index.png Read Only Index view

\subsection{Note}\label{note-35}

In this example, I am not commenting on the required changes in the tests, as this is not an exercise for test driven development but meant to demonstrate a way of working with scaffolding. TDD developers will quickly be able to adapt the tests.

\section{Conclusion}\label{conclusion}

Have a go and try it out. Try working with scaffolds one time and without them the next. Then you will soon get a feel for whether it fits into your working method or not. I find that scaffolding makes my work much easier for standard applications.

\hyperdef{}{routes}{\chap{Routes}\label{routes}}

\section{Introduction}\label{introduction-2}

In \hyperref[dynamischeux5fwebseiten]{the section called “Creating HTML Dynamically with erb”} and \hyperref[scaffolding]{Chapter~5, \emph{Scaffolding and REST}} we have already come across \emph{routes}. The routes contained in \texttt{config/routes.rb} define what happens in the Rails application when a user of a Rails application fetches a URL. A route can be static and dynamic and pass any dynamic values with variables to the controller. If several routes apply to a URL, the one that is listed at the top of \texttt{config/routes.rb} wins.

\subsection{Tip}\label{tip-14}

If you do not have much time, you can skip this chapter for now and get back to it later if you have any specific questions.

Let's first build a test Rails application so we can experiment:

\begin{shaded}\begin{verbatim}
$ rails new shop
  [...]
$ cd shop
$
\end{verbatim}\end{shaded}

With \textbf{rake routes} we can display the routes of a project. Let's try it straight away in the freshly created project:

\begin{shaded}\begin{verbatim}
$ rake routes
You don't have any routes defined!

Please add some routes in config/routes.rb.

For more information about routes, see the Rails guide: http://guides.rubyonrails.org/routing.html.
$
\end{verbatim}\end{shaded}

That's what I call a good error message. It's a new Rails project, there are no routes yet.

In case of a new Rails project, the file \texttt{config/routes.rb} has many commented out examples. For the rest of this chapter we pretend that these examples are not there and only display the newly entered routes.

\subsection{HTTP GET Requests for Singular Resources}\label{http-get-requests-for-singular-resources}

As you might know the HTTP protocol uses different so called verbs to access content on the webserver (e.g.~GET to request a page or POST to send a form to the server). First we'll have a look at GET requests.

Create a controller with three pages:

\begin{shaded}\begin{verbatim}
$ rails generate controller Home index ping pong
      create  app/controllers/home_controller.rb
       route  get "home/pong"
       route  get "home/ping"
       route  get "home/index"
       [...]
$
\end{verbatim}\end{shaded}

Now \textbf{rake routes} lists a route for these three pages:

\begin{shaded}\begin{verbatim}
$ rake routes
    Prefix Verb URI Pattern           Controller#Action
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
$
\end{verbatim}\end{shaded}

The pages can be accessed at the following URLs after starting the Rails server with \textbf{rails server}:

\begin{itemize}
\itemsep1pt\parskip0pt\parsep0pt
\item
  \texttt{http://0.0.0.0:300/home/index} for \texttt{home\_index GET /home/index(.:format)           home\#index}
\item
  \texttt{http://0.0.0.0:300/home/ping} for \texttt{home\_ping GET /home/ping(.:format)           home\#ping}
\item
  \texttt{http://0.0.0.0:300/home/pong} for \texttt{home\_pong GET /home/pong(.:format)           home\#pong}
\end{itemize}

Insert home\_ping.png Home ping view

With the output \texttt{home\#index}, Rails tells us that the route \texttt{/home/index} goes into the controller \texttt{home} and there to the action/method \texttt{index}. These routes are defined in the file \texttt{config/routes.rb}. \textbf{rails generate controller Home index ping pong} has automatically inserted the following lines there:

\begin{shaded}\begin{verbatim}
  get "home/index"

  get "home/ping"

  get "home/pong"
\end{verbatim}\end{shaded}

\section{Naming a Route}\label{naming-a-route}

A route should also always have an internal name which doesn't change. In \hyperref[routesux5fget]{the section called “HTTP GET Requests for Singular Resources”} there is the following route:

\begin{shaded}\begin{verbatim}
home_pong GET /home/pong(.:format)  home#pong
\end{verbatim}\end{shaded}

This route has the automatically created name \texttt{home\_pong}. Generally, you should always try to work with the name of the route within a Rails application. So you would point a \texttt{link\_to} to \texttt{home\_pong} and not to \texttt{/home/pong}. This has the big advantage that you can later edit (in the best case, optimize) the routing for visitors externally and do not need to make any changes internally in the application. Of course, you need to enter the old names with \texttt{:as} in that case.

\section{as}\label{as}

If you want to define the name of a route yourself, you can do so with \texttt{:as}. For example, the line

\begin{shaded}\begin{verbatim}
get "home/pong", as: 'different_name'
\end{verbatim}\end{shaded}

results in the route

\begin{shaded}\begin{verbatim}
different_name GET    /home/pong(.:format)      home#pong
\end{verbatim}\end{shaded}

\section{to}\label{to}

With to you can define an other destination for a rout. For example, the line

\begin{shaded}\begin{verbatim}
get "home/applepie", to: "home#ping"
\end{verbatim}\end{shaded}

results in the route

\begin{shaded}\begin{verbatim}
home_applepie GET /home/applepie(.:format) home#ping
\end{verbatim}\end{shaded}

\section{Parameters}\label{parameters}

The routing engine can not just assign fixed routes but also pass parameters which are part of the URL. A typical example would be date specifications (e.g. \url{http://example.com/2010/12/}\{.uri\} for all December postings).

To demonstrate this, let's create a mini blog application:

\begin{shaded}\begin{verbatim}
$ rails new blog
  [...]
$ cd blog
$ rails generate scaffold post subject content published_at:date
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

As example data in the \texttt{db/seeds.rb} we take:

\begin{shaded}\begin{verbatim}
Post.create(subject: 'A test', published_at: '01.10.2011')
Post.create(subject: 'Another test', published_at: '01.10.2011')
Post.create(subject: 'And yet one more test', published_at: '02.10.2011')
Post.create(subject: 'Last test', published_at: '01.11.2011')
Post.create(subject: 'Very final test', published_at: '01.11.2012')
\end{verbatim}\end{shaded}

With \textbf{rake db:seed} we populate the database with this data:

\begin{shaded}\begin{verbatim}
$ rake db:seed
$
\end{verbatim}\end{shaded}

If we now start the Rails server with \textbf{rails server} and go to the page \texttt{http://0.0.0.0:3000/posts} in the browser, we will see this:

Insert posts\_index.png Post index

For this kind of blog it would of course be very useful if you could render all entries for the year 2010 with the URL \texttt{http://0.0.0.0:3000/2010/} and all entries for October 1st 2010 with \texttt{http://0.0.0.0:3000/2010/10/01}. We can do this by using optional parameters. Please enter the following configuration in the \texttt{config/routes.rb}:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts

  get ':year(/:month(/:day))', to: 'posts#index'
end
\end{verbatim}\end{shaded}

The round brackets represent optional parameters. In this case, you have to specify the year, but not necessarily the month or day. \textbf{rake routes} shows the new route at the last line:

\begin{shaded}\begin{verbatim}
$ rake routes
   Prefix Verb   URI Pattern                      Controller#Action
    posts GET    /posts(.:format)                 posts#index
          POST   /posts(.:format)                 posts#create
 new_post GET    /posts/new(.:format)             posts#new
edit_post GET    /posts/:id/edit(.:format)        posts#edit
     post GET    /posts/:id(.:format)             posts#show
          PATCH  /posts/:id(.:format)             posts#update
          PUT    /posts/:id(.:format)             posts#update
          DELETE /posts/:id(.:format)             posts#destroy
          GET    /:year(/:month(/:day))(.:format) posts#index
$
\end{verbatim}\end{shaded}

If we do not change anything else, we still get the same result when calling \texttt{http://0.0.0.0:3000/2011/} and \texttt{http://0.0.0.0:3000/2011/10/01} as we did with \texttt{http://0.0.0.0:3000/posts}. But have a look at the output of rails server for the request \texttt{http://0.0.0.0:3000/2011}

\begin{shaded}\begin{verbatim}
Started GET "/2011" for 127.0.0.1 at 2013-07-17 11:08:58 +0200
  ActiveRecord::SchemaMigration Load (0.1ms)  SELECT "schema_migrations".* FROM "schema_migrations"
Processing by PostsController#index as HTML
  Parameters: {"year"=>"2011"}
  Post Load (0.1ms)  SELECT "posts".* FROM "posts"
  Rendered posts/index.html.erb within layouts/application (21.3ms)
Completed 200 OK in 96ms (Views: 76.3ms | ActiveRecord: 0.5ms)
\end{verbatim}\end{shaded}

The route has been recognised and an \texttt{"year" =\textgreater{}       "2011"} has been assigned to the hash \texttt{params} (written misleadingly as \texttt{Parameters} in the output). Going to the URL \texttt{http://0.0.0.0:3000/2010/12/24} results in the following output, as expected:

\begin{shaded}\begin{verbatim}
Started GET "/2010/12/24" for 127.0.0.1 at 2013-07-17 11:11:21 +0200
Processing by PostsController#index as HTML
  Parameters: {"year"=>"2010", "month"=>"12", "day"=>"24"}
  Post Load (0.2ms)  SELECT "posts".* FROM "posts"
  Rendered posts/index.html.erb within layouts/application (3.4ms)
Completed 200 OK in 9ms (Views: 8.1ms | ActiveRecord: 0.2ms)
\end{verbatim}\end{shaded}

In case of the URL \texttt{http://0.0.0.0:3000/2010/12/24}, the following values have been saved in the hash \texttt{params}: \texttt{"year"=\textgreater{}"2010", "month"=\textgreater{}"12",       "day"=\textgreater{}"24".}

In the controller, we can access \texttt{params{[}{]}} to access the values defined in the URL. We simply need to adapt the \texttt{index} method in \texttt{app/controllers/posts\_controller.rb} to output the \texttt{posts} entered for the corresponding date, month or year:

\begin{shaded}\begin{verbatim}
### GET /posts
### GET /posts.json
def index
  # Check if the URL requests a date.
  if Date.valid_date? params[:year].to_i, params[:month].to_i, params[:day].to_i
    start_date = Date.parse("#{params[:day]}.#{params[:month]}.#{params[:year]}")
    end_date = start_date

  # Check if the URL requests a month
  elsif Date.valid_date? params[:year].to_i, params[:month].to_i, 1
    start_date = Date.parse("1.#{params[:month]}.#{params[:year]}")
    end_date = start_date.end_of_month

  # Check if the URL requests a year
  elsif params[:year] && Date.valid_date?(params[:year].to_i, 1, 1)
    start_date = Date.parse("1.1.#{params[:year]}")
    end_date = start_date.end_of_year
  end

  if start_date && end_date
    @posts = Post.where(published_at: start_date..end_date)
  else
    @posts = Post.all
  end
end
\end{verbatim}\end{shaded}

If we now go to \texttt{http://0.0.0.0:3000/2011/10/01} , we can see all \texttt{posts} of October 1st 2011.

Insert posts\_2011\_10\_01.png Post view

\section{Constraints}\label{constraints}

In \hyperref[routesux5fmatchux5fparameter]{the section called “Parameters”} I showed you how you can read out parameters from the URL and pass them to the controller. Unfortunately, the entry defined there in the \texttt{config/routes.rb}

\begin{shaded}\begin{verbatim}
get ':year(/:month(/:day))', to: 'posts#index'
\end{verbatim}\end{shaded}

has one important disadvantage: it does not verify the individual elements. For example, the URL \texttt{http://0.0.0.0:3000/just/an/example} will be matched just the same and then of course results in an error:

Insert ein\_beispiel\_dafuer\_fehler.png Example routing error

In the log output in\texttt{log/development.log} we can see the following entry:

\begin{shaded}\begin{verbatim}
Started GET "/just/an/example" for 127.0.0.1 at 2013-07-17 12:04:01 +0200
Processing by PostsController#index as HTML
  Parameters: {"year"=>"just", "month"=>"an", "day"=>"example"}
Completed 500 Internal Server Error in 2ms

ArgumentError (invalid date):
  app/controllers/posts_controller.rb:19:in `parse'
  app/controllers/posts_controller.rb:19:in `index'
\end{verbatim}\end{shaded}

Obviously, \texttt{Date.parse( "example.an.just")} cannot work. A date is made up of numbers, not letters.

Constraints can define the content of the URL more precisely via regular expressions. In the case of our blog, the \texttt{config/routes.rb} with contraints would look like this:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts

  get ':year(/:month(/:day))', to: 'posts#index', constraints: { year: /\d{4}/, month: /\d{2}/, day: /\d{2}/ }
end
\end{verbatim}\end{shaded}

\paragraph{Warning}\label{warning-10}

Please note that you cannot use regex anchors such as “\^{}” in regular expressions in a constraint.

If we go to the URL again with this configuration, Rails gives us an error message “No route matches”:

Insert ein\_beispiel\_dafuer\_no\_route\_matches.png Routing error

\subsection{Redirects}\label{redirects-1}

Our current application answers request in the format YYYY/MM/DD (4 digits for the year, 2 digits for the month and 2 digits for the day). That is ok for machines but maybe a human would request a single digit month (like January) and a single digit day without adding the extra 0 to make it two digits. We can fix that with a couple of redirect rules which catch these URLs and redirect them to the correct ones.

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts

  get ':year/:month/:day', to: redirect("/%{year}/0%{month}/0%{day}"), constraints: { year: /\d{4}/, month: /\d{1}/, day: /\d{1}/ }
  get ':year/:month/:day', to: redirect("/%{year}/0%{month}/%{day}"), constraints: { year: /\d{4}/, month: /\d{1}/, day: /\d{2}/ }
  get ':year/:month/:day', to: redirect("/%{year}/%{month}/0%{day}"), constraints: { year: /\d{4}/, month: /\d{2}/, day: /\d{1}/ }
  get ':year/:month', to: redirect("/%{year}/0%{month}"), constraints: { year: /\d{4}/, month: /\d{1}/ }

  get ':year(/:month(/:day))', to: 'posts#index', constraints: { year: /\d{4}/, month: /\d{2}/, day: /\d{2}/ }
end
\end{verbatim}\end{shaded}

With this set of redirect rules, we can ensure that a user of the page can also enter single-digit days and months and still ends up in the right place, or is redirected to the correct format.

\paragraph{Note}\label{note-36}

Redirects in the \texttt{config/routes.rb} are by default http redirects with the code 301 (“Moved Permanently”). So even search engines will profit from this.

\subsection{root :to =\textgreater{} `welcome\#index'}\label{root-to-welcomeindex}

In the default \texttt{config/routes.rb} file you will find the following comment quite a long way down:

\begin{shaded}\begin{verbatim}
### You can have the root of your site routed with "root"
### root 'welcome#index'
\end{verbatim}\end{shaded}

If you comment out the last line there, you can define your \texttt{http://0.0.0.0:3000/} with it. Let's put it on \texttt{home\#index}:

\begin{shaded}\begin{verbatim}
Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  root 'home#index'
end
\end{verbatim}\end{shaded}

Our new routes:

\begin{shaded}\begin{verbatim}
$ rake routes
    Prefix Verb URI Pattern           Controller#Action
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
      root GET /                     home#index
$
\end{verbatim}\end{shaded}

If we go to the root URL \texttt{http://0.0.0.0:3000} we now see \texttt{home\#index}.

Insert routes\_root\_url.png Root URL

\subsection{resources}\label{resources}

\texttt{resources} provides routes for a RESTful resource. Let's try it with the mini blog application:

\begin{shaded}\begin{verbatim}
$ rails new blog
  [...]
$ cd blog
$ rails generate scaffold post subject content published_at:date
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

The scaffold generator automatically creates a \texttt{resources} route in the \texttt{config/routes.rb}:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts
end
\end{verbatim}\end{shaded}

\paragraph{Note}\label{note-37}

New routes are always added at the beginning of \texttt{config/routes.rb} by rails generate scripts.

The resulting routes:

\begin{shaded}\begin{verbatim}
$ rake routes
   Prefix Verb   URI Pattern               Controller#Action
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
$
\end{verbatim}\end{shaded}

You have already encountered these RESTful routes in \hyperref[scaffolding]{Chapter~5, \emph{Scaffolding and REST}}. They are required for displaying and editing records.

\section{Selecting Specific Routes with only: or except:}\label{selecting-specific-routes-with-only-or-except}

If you only want to use specific routes from the finished set of RESTful routes, you can limit them with \texttt{:only} or \texttt{:except}.

The following \texttt{conf/routes.rb} defines only the routes for \texttt{index} and \texttt{show}:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts, only: [:index, :show]
end
\end{verbatim}\end{shaded}

With \textbf{rake routes} we can check the result:

\begin{shaded}\begin{verbatim}
$ rake routes
Prefix Verb URI Pattern          Controller#Action
posts GET /posts(.:format)     posts#index
 post GET /posts/:id(.:format) posts#show
$
\end{verbatim}\end{shaded}

\texttt{except} works exactly the other way round:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts, except: [:index, :show]
end
\end{verbatim}\end{shaded}

Now all routes except for \texttt{index} and \texttt{show} are possible:

\begin{shaded}\begin{verbatim}
$ rake routes
   Prefix Verb   URI Pattern               Controller#Action
    posts POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post PATCH  /posts/:id(.:format)      posts#update
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
$
\end{verbatim}\end{shaded}

\paragraph{Warning}\label{warning-11}

When using \texttt{only} and \texttt{except}, please make sure you also adapt the views generated by the scaffold generator. For example, there is a link on the index page to the new view with \texttt{\textless{}\%= link\_to 'New Post', new\_post\_path \%\textgreater{}} but this view no longer exists in the above only example.

\subsection{Nested Resources}\label{nested-resources}

Nested resources refer to routes of resources that work with a association (see \hyperref[activerecordux5fhasux5fmany]{the section called “has\_many -- 1:n Association”}). These can be addressed precisely via routes. Let's create a second resource, \texttt{comment}:

\begin{shaded}\begin{verbatim}
$ rails generate scaffold comment post_id:integer content
  [...]
$ rake db:migrate
  [...]
$
\end{verbatim}\end{shaded}

Now we associate the two resources. In the file \texttt{app/models/post.rb}, we add a \texttt{has\_many}:

\begin{shaded}\begin{verbatim}
class Post < ActiveRecord::Base
  has_many :comments
end
\end{verbatim}\end{shaded}

And in the file \texttt{app/models/comment.rb}, its counterpart \texttt{belongs\_to}:

\begin{shaded}\begin{verbatim}
class Comment < ActiveRecord::Base
  belongs_to :post
end
\end{verbatim}\end{shaded}

The routes generated by the scaffold generator look like this:

\begin{shaded}\begin{verbatim}
$ rake routes
      Prefix Verb   URI Pattern                  Controller#Action
    comments GET    /comments(.:format)          comments#index
             POST   /comments(.:format)          comments#create
 new_comment GET    /comments/new(.:format)      comments#new
edit_comment GET    /comments/:id/edit(.:format) comments#edit
     comment GET    /comments/:id(.:format)      comments#show
             PATCH  /comments/:id(.:format)      comments#update
             PUT    /comments/:id(.:format)      comments#update
             DELETE /comments/:id(.:format)      comments#destroy
       posts GET    /posts(.:format)             posts#index
             POST   /posts(.:format)             posts#create
    new_post GET    /posts/new(.:format)         posts#new
   edit_post GET    /posts/:id/edit(.:format)    posts#edit
        post GET    /posts/:id(.:format)         posts#show
             PATCH  /posts/:id(.:format)         posts#update
             PUT    /posts/:id(.:format)         posts#update
             DELETE /posts/:id(.:format)         posts#destroy
$
\end{verbatim}\end{shaded}

So we can get the first post with \texttt{/posts/1} and all the comments with \texttt{/comments}. By using nesting, we can get all comments with the ID 1 via \texttt{/posts/1/}comments. We need to change the \texttt{config/routes.rb}:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts do
    resources :comments
  end
end
\end{verbatim}\end{shaded}

This gives us the desired routes:

\begin{shaded}\begin{verbatim}
$ rake routes
           Prefix Verb   URI Pattern                                 Controller#Action
    post_comments GET    /posts/:post_id/comments(.:format)          comments#index
                  POST   /posts/:post_id/comments(.:format)          comments#create
 new_post_comment GET    /posts/:post_id/comments/new(.:format)      comments#new
edit_post_comment GET    /posts/:post_id/comments/:id/edit(.:format) comments#edit
     post_comment GET    /posts/:post_id/comments/:id(.:format)      comments#show
                  PATCH  /posts/:post_id/comments/:id(.:format)      comments#update
                  PUT    /posts/:post_id/comments/:id(.:format)      comments#update
                  DELETE /posts/:post_id/comments/:id(.:format)      comments#destroy
            posts GET    /posts(.:format)                            posts#index
                  POST   /posts(.:format)                            posts#create
         new_post GET    /posts/new(.:format)                        posts#new
        edit_post GET    /posts/:id/edit(.:format)                   posts#edit
             post GET    /posts/:id(.:format)                        posts#show
                  PATCH  /posts/:id(.:format)                        posts#update
                  PUT    /posts/:id(.:format)                        posts#update
                  DELETE /posts/:id(.:format)                        posts#destroy
$
\end{verbatim}\end{shaded}

But we still need to make some changes in the file \texttt{app/controllers/comments\_controller.rb}. This ensures that only the \texttt{Comments} of the specified \texttt{Post} can be displayed or changed:

\begin{shaded}\begin{verbatim}
class CommentsController < ApplicationController
  before_action :set_post
  before_action :set_comment, only: [:show, :edit, :update, :destroy]

  # GET /comments
  # GET /comments.json
  def index
    @comments = Comment.all
  end

  # GET /comments/1
  # GET /comments/1.json
  def show
  end

  # GET /comments/new
  def new
    @comment = @post.comments.build
  end

  # GET /comments/1/edit
  def edit
  end

  # POST /comments
  # POST /comments.json
  def create
    @comment = @post.comments.build(comment_params)

    respond_to do |format|
      if @comment.save
        format.html { redirect_to @comment, notice: 'Comment was successfully created.' }
        format.json { render action: 'show', status: :created, location: @comment }
      else
        format.html { render action: 'new' }
        format.json { render json: @comment.errors, status: :unprocessable_entity }
      end
    end
  end

  # PATCH/PUT /comments/1
  # PATCH/PUT /comments/1.json
  def update
    respond_to do |format|
      if @comment.update(comment_params)
        format.html { redirect_to @comment, notice: 'Comment was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: 'edit' }
        format.json { render json: @comment.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /comments/1
  # DELETE /comments/1.json
  def destroy
    @comment.destroy
    respond_to do |format|
      format.html { redirect_to comments_url }
      format.json { head :no_content }
    end
  end

  private
    def set_post
      @post = Post.find(params[:post_id])
    end

    # Use callbacks to share common setup or constraints between actions.
    def set_comment
      @comment = @post.comments.find(params[:id])
    end

    # Never trust parameters from the scary internet, only allow the white list through.
    def comment_params
      params.require(:comment).permit(:post_id, :content)
    end
end
\end{verbatim}\end{shaded}

Unfortunately, this is only half the story, because the views still link to the old routes. So we need to adapt each view in accordance with the nested route.

\texttt{app/views/comments/\_form.html.erb}

Please note that you need to change the \texttt{form\_for} call to \texttt{form\_for({[}@post, @comment{]})}.

\begin{shaded}\begin{verbatim}
<%= form_for([@post, @comment]) do |f| %>
  <% if @comment.errors.any? %>
    <div id="error_explanation">
      <h2><%= pluralize(@comment.errors.count, "error") %> prohibited this comment from being saved:</h2>

      <ul>
      <% @comment.errors.full_messages.each do |msg| %>
        <li><%= msg %></li>
      <% end %>
      </ul>
    </div>
  <% end %>

  <div class="field">
    <%= f.label :content %><br />
    <%= f.text_field :content %>
  </div>
  <div class="actions">
    <%= f.submit %>
  </div>
<% end %>
\end{verbatim}\end{shaded}

\texttt{app/views/comments/edit.html.erb}

\begin{shaded}\begin{verbatim}
<h1>Editing comment</h1>

<%= render 'form' %>

<%= link_to 'Show', [@post, @comment] %> |
<%= link_to 'Back', post_comments_path(@post) %>
\end{verbatim}\end{shaded}

\texttt{app/views/comments/index.html.erb}

\begin{shaded}\begin{verbatim}
<h1>Listing comments</h1>

<table>
  <thead>
    <tr>
      <th>Post</th>
      <th>Content</th>
      <th></th>
      <th></th>
      <th></th>
    </tr>
  </thead>

  <tbody>
    <% @comments.each do |comment| %>
      <tr>
        <td><%= comment.post_id %></td>
        <td><%= comment.content %></td>
        <td><%= link_to 'Show', [@post, comment] %></td>
        <td><%= link_to 'Edit', edit_post_comment_path(@post, comment) %></td>
        <td><%= link_to 'Destroy', [@post, comment], method: :delete, data: { confirm: 'Are you sure?' } %></td>
      </tr>
    <% end %>
  </tbody>
</table>

<br>

<%= link_to 'New Comment', new_post_comment_path(@post) %>
\end{verbatim}\end{shaded}

\texttt{app/views/comments/new.html.erb}

\begin{shaded}\begin{verbatim}
<h1>New comment</h1>

<%= render 'form' %>

<%= link_to 'Back', post_comments_path(@post) %>
\end{verbatim}\end{shaded}

\texttt{app/views/comments/show.html.erb}

\begin{shaded}\begin{verbatim}
<p id="notice"><%= notice %></p>

<p>
  <b>Post:</b>
  <%= @comment.post_id %>
</p>

<p>
  <b>Content:</b>
  <%= @comment.content %>
</p>


<%= link_to 'Edit', edit_post_comment_path(@post, @comment) %> |
<%= link_to 'Back', post_comments_path(@post) %>
\end{verbatim}\end{shaded}

Please go ahead and have a go at experimenting with the URLs listed under rake routes. You can now generate a new post with \texttt{/posts/new} and a new comment for this post with \texttt{/posts/:post\_id/comments/new}.

If you want to see all comments of the first post you can access that with the URL \texttt{http://0.0.0.0:3000/posts/1/comments}. It would look like this:

Insert posts\_1\_comments.png Nested Route

\section{Shallow Nesting}\label{shallow-nesting}

Sometimes it is a better option to use shallow nesting. For our example the \texttt{config/routes.rb} would contain the following routes:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts do
    resources :comments, only: [:index, :new, :create]
  end

  resources :comments, except: [:index, :new, :create]
end
\end{verbatim}\end{shaded}

That would lead to a less messy \textbf{rake routes} output:

\begin{shaded}\begin{verbatim}
$ rake routes
          Prefix Verb   URI Pattern                            Controller#Action
   post_comments GET    /posts/:post_id/comments(.:format)     comments#index
                 POST   /posts/:post_id/comments(.:format)     comments#create
new_post_comment GET    /posts/:post_id/comments/new(.:format) comments#new
           posts GET    /posts(.:format)                       posts#index
                 POST   /posts(.:format)                       posts#create
        new_post GET    /posts/new(.:format)                   posts#new
       edit_post GET    /posts/:id/edit(.:format)              posts#edit
            post GET    /posts/:id(.:format)                   posts#show
                 PATCH  /posts/:id(.:format)                   posts#update
                 PUT    /posts/:id(.:format)                   posts#update
                 DELETE /posts/:id(.:format)                   posts#destroy
    edit_comment GET    /comments/:id/edit(.:format)           comments#edit
         comment GET    /comments/:id(.:format)                comments#show
                 PATCH  /comments/:id(.:format)                comments#update
                 PUT    /comments/:id(.:format)                comments#update
                 DELETE /comments/:id(.:format)                comments#destroy
$
\end{verbatim}\end{shaded}

Shallow nesting trys to combine the best of two worlds. And because it is often used there is a shortcut. You can use the following \texttt{config/routes.rb} to achieve it:

\begin{shaded}\begin{verbatim}
Blog::Application.routes.draw do
  resources :posts do
    resources :comments, shallow: true
  end
end
\end{verbatim}\end{shaded}

\subsection{Comments on Nested Resources}\label{comments-on-nested-resources}

Generally, you should never nest more deeply than one level and nested resources should feel natural. After a while, you will get a feel for it. In my opinion, the most important point about RESTful routes is that they should feel logical. If you phone a fellow Rails programmer and say “I've got a resource post and a resource comment here”, then both parties should immediately be clear on how you address these resources via REST and how you can nest them.

\subsection{Further Information on Routes}\label{further-information-on-routes}

The topic routes is far more complex than we can address here. For example, you can also involve other HTTP methods/verbs. The official routing documentation \url{http://guides.rubyonrails.org/routing.html}\{.uri\} will give you a lot of information an examples for these features and edge cases.

\end{document}
