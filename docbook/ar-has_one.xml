<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="ar-has_one"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="ar-has_one.title">has_one – 1:1-Verknüpfung</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Relationen</secondary>

    <tertiary>has_one()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Relationen</secondary>

    <tertiary>belongs_to()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Assoziationen</secondary>

    <see>ActiveRecord, Relationen</see>
  </indexterm>

  <para>Ähnlich wie bei <methodname>has_many</methodname> (siehe <xref
  linkend="activerecord_has_many" />), wird auch bei
  <methodname>has_one</methodname> ein Model mit einem anderen Model logisch
  verknüpft. Im Gegensatz zu <methodname>has_many,</methodname> gibt es aber
  bei <methodname>has_one</methodname> genau jeweils nur einen Datensatz, der
  mit genau einem anderen Datensatz verknüpft ist. In den meisten praktischen
  Anwendungsfällen bietet es sich logischerweise an, beides in das gleiche
  Model und damit in die gleiche Datenbank-Tabelle zu packen, aber der
  Vollständigkeit halber möchte ich hier auch <methodname>has_one</methodname>
  besprechen.</para>

  <para>Bei den Beispielen gehe ich davon aus, dass Sie <xref
  linkend="activerecord_has_many" /> bereits gelesen und verstanden haben. Ich
  werde Methoden wie <methodname>build</methodname> nicht neu erklären,
  sondern als Grundlage voraussetzen.</para>

  <section>
    <title>Vorbereitung</title>

    <para>Wir greifen das Beispiel von <uri
    xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
    auf und erstellen eine Applikation, in der es Angestellte und Büros gibt.
    Jeder Angestellte hat ein Büro. Erst die Applikation:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new office-space</command>
      create  
      create  README
      [...]
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd office-space</command>
stefan@swmbp 0 1.9.2-p0 office-space$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
[...]
stefan@swmbp 0 1.9.2-p0 office-space$</screen></para>

    <para>Und jetzt die beiden Modele:<screen>stefan@swmbp 0 1.9.2-p0 office-space$ <command>rails generate model employee lastname:string</command>
      invoke  active_record
      [...]
stefan@swmbp 0 1.9.2-p0 office-space$ <command>rails generate model office name:string employee_id:integer</command>
      invoke  active_record
      [...]
stefan@swmbp 0 1.9.2-p0 office-space$ <command>rake db:migrate</command>
      [...]
stefan@swmbp 0 1.9.2-p0 office-space$</screen></para>
  </section>

  <section>
    <title>Verknüpfung</title>

    <para>Die Verknüpfung in der Datei
    <filename>app/model/employee.rb:</filename><programlisting>class Employee &lt; ActiveRecord::Base
<emphasis>  has_one :office
</emphasis>end</programlisting></para>

    <para>Und das Gegenstück in der
    <filename>app/model/office.rb:</filename><programlisting>class Office &lt; ActiveRecord::Base
<emphasis>  belongs_to :employee
</emphasis>end</programlisting></para>

    <section>
      <title>Optionen</title>

      <para>Die Optionen von <methodname>has_one</methodname> ähneln denen von
      <methodname>has_many</methodname>. Aus diesem Grund verweise ich an
      dieser Stelle auf <xref linkend="activerecord_1n_optionen" /> oder auf
      <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_one">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html#method-i-has_one</uri>.
      Auf die Schnelle hier ein paar allgemeine Beispiele (zum Teil aus der
      Rails-Doku):<programlisting>has_one :office, :dependent =&gt; :destroy  # loescht den Office Eintrag
has_one :office, :dependent =&gt; :nullify  # wie :destroy, nur das der Office Datensatz nicht 
                                         # geloescht wird, sondern employee_id auf NULL gesetzt
                                         # wird
has_one :last_comment, :class_name =&gt; "Comment", :order =&gt; "posted_on"
has_one :project_manager, :class_name =&gt; "Person", :conditions =&gt; "role = 'project_manager'"
has_one :boss, :readonly =&gt; :true
has_one :club, :through =&gt; :membership
has_one :primary_address, :through =&gt; :addressables, :conditions =&gt; ["addressable.primary = ?", true], :source =&gt; :addressable</programlisting></para>
    </section>
  </section>

  <section>
    <title>Consolen-Beispiele</title>

    <para>Starten wir einmal die Console und legen zwei Angestellte
    an:<screen>stefan@swmbp 0 1.9.2-p0 office-space$ <command>rails console</command>
Loading development environment (Rails 3.0.1)
ruby-1.9.2-p0 &gt; <command>Employee</command>
 =&gt; Employee(id: integer, lastname: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Employee.create(:lastname =&gt; 'Udelhoven')</command>
 =&gt; #&lt;Employee id: 1, lastname: "Udelhoven", created_at: "2010-11-04 10:53:35", updated_at: "2010-11-04 10:53:35"&gt; 
ruby-1.9.2-p0 &gt; <command>Employee.create(:lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Employee id: 2, lastname: "Meier", created_at: "2010-11-04 10:53:47", updated_at: "2010-11-04 10:53:47"&gt; 
ruby-1.9.2-p0 &gt; </screen></para>

    <para>Jetzt bekommt ein Angestellter sein eigenes Büro:<screen>ruby-1.9.2-p0 &gt; <command>Office.create(:name =&gt; '1. Stock, 2. Tuer links', :employee_id =&gt; 1)</command>
 =&gt; #&lt;Office id: 1, name: "1. Stock, 2. Tuer links", employee_id: 1, created_at: "2010-11-04 11:09:56", updated_at: "2010-11-04 11:09:56"&gt; 
ruby-1.9.2-p0 &gt; <command>Employee.first.office</command>
 =&gt; #&lt;Office id: 1, name: "1. Stock, 2. Tuer links", employee_id: 1, created_at: "2010-11-04 11:09:56", updated_at: "2010-11-04 11:09:56"&gt; 
ruby-1.9.2-p0 &gt; <command>Office.first.employee</command>
 =&gt; #&lt;Employee id: 1, lastname: "Udelhoven", created_at: "2010-11-04 10:53:35", updated_at: "2010-11-04 10:53:35"&gt; 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Beim zweiten Angestellten benutzen wir die automatisch erzeugte
    <methodname>create_office</methodname>-Methode:<screen>ruby-1.9.2-p0 &gt; <command>Employee.last.create_office(:name =&gt; 'Erdgeschoss, 3. Tuer links')</command>
 =&gt; #&lt;Office id: 2, name: "Erdgeschoss, 3. Tuer links", employee_id: 2, created_at: "2010-11-04 12:13:28", updated_at: "2010-11-04 12:13:28"&gt; 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Löschen geht intuitiv mit <methodname>destroy</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>Employee.first.office</command>
 =&gt; #&lt;Office id: 1, name: "1. Stock, 2. Tuer links", employee_id: 1, created_at: "2010-11-04 11:09:56", updated_at: "2010-11-04 11:09:56"&gt; 
ruby-1.9.2-p0 &gt; <command>Employee.first.office.destroy</command>
 =&gt; #&lt;Office id: 1, name: "1. Stock, 2. Tuer links", employee_id: 1, created_at: "2010-11-04 11:09:56", updated_at: "2010-11-04 11:09:56"&gt; 
ruby-1.9.2-p0 &gt; <command>Employee.first.office</command>
 =&gt; nil 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Kann man eigentlich nur ein <classname>Office</classname> für jeden
    <classname>Employee</classname> in der Datenbank halten? Legen wir mal mit
    <methodname>create_office</methodname> ein weiteres
    <classname>Office</classname> für den letzten
    <classname>Employee</classname> an und schauen, was passiert:<screen>ruby-1.9.2-p0 &gt; <command>Employee.last.office</command>
 =&gt; #&lt;Office id: 2, name: "Erdgeschoss, 3. Tuer links", employee_id: 2, created_at: "2010-11-04 13:27:46", updated_at: "2010-11-04 13:27:46"&gt; 
ruby-1.9.2-p0 &gt; <command>Employee.last.create_office(:name =&gt; 'Zweitbuero')</command>
 =&gt; #&lt;Office id: 3, name: "Zweitbuero", employee_id: 2, created_at: "2010-11-04 13:29:25", updated_at: "2010-11-04 13:29:25"&gt; 
ruby-1.9.2-p0 &gt; <command>Employee.last.office</command>
 =&gt; #&lt;Office id: 3, name: "Zweitbuero", employee_id: 2, created_at: "2010-11-04 13:29:25", updated_at: "2010-11-04 13:29:25"&gt; 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Nachfolgend sehen wir uns im
    <filename>log/development.log</filename> an, was in der Datenbank
    geschah:<programlisting>  Employee Load (0.2ms)  SELECT "employees".* FROM "employees" ORDER BY employees.id DESC LIMIT 1
  Office Load (0.1ms)  SELECT "offices".* FROM "offices" WHERE ("offices".employee_id = 2) LIMIT 1
  SQL (0.3ms)  INSERT INTO "offices" ("created_at", "employee_id", "name", "updated_at") VALUES ('2010-11-04 13:29:25.549367', 2, 'Zweitbuero', '2010-11-04 13:29:25.549367')
  SQL (0.3ms)  UPDATE "offices" SET "employee_id" = NULL, "updated_at" = '2010-11-04 13:29:25.552976' WHERE ("offices"."id" = 2)


  Employee Load (0.3ms)  SELECT "employees".* FROM "employees" ORDER BY employees.id DESC LIMIT 1
  Office Load (0.1ms)  SELECT "offices".* FROM "offices" WHERE ("offices".employee_id = 2) LIMIT 1
</programlisting></para>

    <para>Der alte <classname>Office</classname>-Datensatz wurde nicht
    gelöscht, sondern das Feld <varname>employee_id</varname> mit NULL (nil)
    gefüllt. Es ist weiterhin in der Datenbank:<screen>ruby-1.9.2-p0 &gt; <command>Office.where(:employee_id =&gt; nil).all</command>
 =&gt; [#&lt;Office id: 2, name: "Erdgeschoss, 3. Tuer links", employee_id: nil, created_at: "2010-11-04 13:27:46", updated_at: "2010-11-04 13:29:25"&gt;] 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Hmmm ... was passiert, wenn wir diese <varname>employee_id</varname>
    wieder auf 2 setzen?<screen>ruby-1.9.2-p0 &gt; <command>Employee.last.office</command>
 =&gt; #&lt;Office id: 3, name: "Zweitbuero", employee_id: 2, created_at: "2010-11-04 13:29:25", updated_at: "2010-11-04 13:29:25"&gt; 
ruby-1.9.2-p0 &gt; <command>Office.where(:employee_id =&gt; nil).first.update_attributes(:employee_id =&gt; Employee.last.id)</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Employee.last.office</command>
 =&gt; #&lt;Office id: 2, name: "Erdgeschoss, 3. Tuer links", employee_id: 2, created_at: "2010-11-04 13:27:46", updated_at: "2010-11-04 13:44:44"&gt; 
ruby-1.9.2-p0 &gt; <command>Office.where(:employee_id =&gt; Employee.last.id).count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 office-space$</screen></para>

    <para>Logischerweise gibt es dann zweit passende Einträge in der
    <classname>Office</classname>-Tabelle und von der Datenbank wird der erste
    als Treffer ausgegeben (da die entsprechende SQL-Anfrage immer mit einem
    <code>LIMIT 1</code> beendet wird). Wir könnten dieses Verhalten mit der
    <methodname>:order</methodname>-Option umkehren.</para>
  </section>

  <section>
    <title>has_one vs. belongs_to</title>

    <para>Sowohl has_one wie auch belongs_to bietet die Möglichkeit, eine
    1:1-Verbindung abzubilden. Der Unterschied liegt in der Praxis in der
    persönlichen Präferenz des Programmierers und dem Ort des
    Foreign-Keys.</para>
  </section>
</section>
