<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="testing" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="testing.title">Testing</title>

  <indexterm>
    <primary>Testing</primary>

    <secondary>Test-Driven-Development</secondary>
  </indexterm>

  <section xml:id="testing_einleitung">
    <title xml:id="testing_einleitung.title">Einleitung</title>

    <para>Ich programmiere seit über 20 Jahren und die meiste Zeit bin ich
    sehr gut ohne Testing zurechtgekommen. Ich bin Ihnen also nicht böse, wenn
    Sie dieses Kapitel überspringen. Sie können Rails-Applikationen auch ohne
    Tests erstellen und werden deshalb kein schlechtes Karma bekommen
    (hoffentlich, sicher kann man bei der Karma-Sache ja nie sein).</para>

    <para>Aber sollten Sie sich auf Test-Driven-Development (TDD) einlassen,
    so kann ich Ihnen versprechen, dass es eine Erleuchtung ist. Die Grundidee
    von TDD ist, dass man für jede Programmfunktion einen Test schreibt, der
    diese Funktion überprüft. Ja, man hat initial doppelt so viel Aufwand.
    Aber danach kann man alle Tests durchlaufen lassen und sieht, dass die
    Applikation genau so funktioniert, wie man es sich vorgestellt hat. Der
    wirkliche Vorteil stellt sich aber erst nach ein paar Wochen oder Monaten
    ein, wenn man sich das Projekt wieder mal vornimmt und eine Erweiterung
    oder Veränderung schreibt. Dann kann man recht gefahrlos den Code
    verändern und danach die Funktionsweise anhand der Tests überprüfen. Es
    gibt dann kein "hmm ... das ist jetzt dumm gelaufen, aber an diese
    Besonderheit habe ich nicht gedacht" mehr.</para>

    <para>Dieses Kapitel ist ein Einstieg ins Thema Test-Driven-Development.
    Wenn Sie Blut geleckt haben, werden Sie sicher noch tiefer einsteigen
    wollen.</para>

    <note>
      <para>Testen ist wie Autofahren. Autofahren kann man auch nur beim
      Autofahren lernen.</para>
    </note>
  </section>

  <section xml:id="testing_beispiel_webshop">
    <title xml:id="testing_beispiel_webshop.title">Beispiel für einen User in
    einem Webshop</title>

    <para>Fangen wir mit einem User-Scaffold in einem imaginären Webshop
    an:<screen>MacBook:~ sw$ <command>rails new webshop</command>
[...]
MacBook:~ sw$ <command>cd webshop</command>
MacBook:webshop sw$ <command>bundle install</command>
[...]
MacBook:webshop sw$ <command>rails generate scaffold user login_name:string firstname:string lastname:string birthday:date</command>
      invoke  active_record
      create    db/migrate/20110526094713_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/unit/user_test.rb
      create      test/fixtures/users.yml
       route  resources :users
      invoke  scaffold_controller
      create    app/controllers/users_controller.rb
      invoke    erb
      create      app/views/users
      create      app/views/users/index.html.erb
      create      app/views/users/edit.html.erb
      create      app/views/users/show.html.erb
      create      app/views/users/new.html.erb
      create      app/views/users/_form.html.erb
      invoke    test_unit
      create      test/functional/users_controller_test.rb
      invoke    helper
      create      app/helpers/users_helper.rb
      invoke      test_unit
      create        test/unit/helpers/users_helper_test.rb
      create  app/assets/stylesheets/scaffold.css.scss
      invoke  assets
      create    app/assets/javascripts/users.js.coffee
      create    app/assets/stylesheets/users.css.scss
MacBook:webshop sw$ <command>rake db:migrate</command>
==  CreateUsers: migrating ====================================================
-- create_table(:users)
   -&gt; 0.0016s
==  CreateUsers: migrated (0.0017s) ===========================================
MacBook:webshop sw$ 
</screen></para>

    <para>Sie kennen sich ja mit Scaffold aus (falls nicht, bitte erst <xref
    linkend="scaffolding" /> lesen) und wissen, was die gerade erstellte
    Applikation macht. Sie haben auch gesehen, dass Scaffold einige Tests
    angelegt hat (die sind immer leicht am Wort <code>test</code> im
    Dateinamen zu erkennen).</para>

    <para>Die komplette Test-Suite eines Rails-Projektes wird mit dem Befehl
    <command>rake test</command> abgearbeitet. Probieren wir mal aus, was ein
    Test an dieser Stelle der Entwicklung ausgibt:<screen>MacBook:webshop sw$ <command>rake test</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004183 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     PASS should create user (0.10s) 
     PASS should destroy user (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     PASS should update user (0.01s) 

Finished in 0.216057 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$</screen></para>

    <para>Die Ausgabe <code>0 failures, 0 errors, 0 skips</code> sieht gut
    aus. Per Default läuft ein Test in einem Standard-Scaffold korrekt
    durch.</para>

    <para>Verändern wir jetzt die <filename>app/models/user.rb</filename> und
    fügen ein paar Validierungen (falls das nicht ganz klar ist, bitte <xref
    linkend="activerecord_validation" /> lesen) ein:<programlisting>class User &lt; ActiveRecord::Base
  # Die folgenden Felder muessen immer enthalten sein
  #
  validates_presence_of :login_name
  validates_presence_of :lastname
  validates_presence_of :birthday
  
  # Der login_name darf nur aus den Buchstaben a-z, Zahlen und den 
  # Sonderzeichen -._ bestehen
  #
  validates_format_of :login_name, :with =&gt; /[a-z0-9\-_.]+/i,
                      :message =&gt; "only characters, numbers and the special character -_. are allowed"
  
  # Der login_name muss mindestens eins der folgenden Sonderzeichen 
  # enthalten: -._
  #
  validates_format_of :login_name, :with =&gt; /^.*(?=.*[\-_.]).*$/,
                      :message =&gt; "must include at least one of the special characters -_."
  
  # User des Webshops muessen volljaehrig sein
  #
  validate :check_the_birthday
  
  private
  def check_the_birthday
    if self.birthday.nil? or Date.today &lt; self.birthday + 18.years
      errors.add(:birthday, "You have to be at least 18 years old.")
    end
  end
end
</programlisting></para>

    <para>Nachfolgend führen wir noch mal alle Tests durch:<screen>MacBook:webshop sw$ <command>rake test</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004198 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     FAIL should create user (0.21s) 
          #&lt;Proc:0x00000100c87c50@/Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:49 (lambda)&gt; didn't change by 1.
&lt;3&gt; expected but was
&lt;2&gt;.
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:58:in `block in assert_difference'

     PASS should destroy user (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     FAIL should update user (0.02s) 
          Expected response to be a &lt;:redirect&gt;, but was &lt;200&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:45:in `assert_response'


Finished in 0.283337 seconds.

7 tests, 9 assertions, 2 failures, 0 errors, 0 skips
Errors running test:functionals!
MacBook:webshop sw$</screen></para>

    <para>Dieses Mal haben wir <code>2 failures</code>. Der Fehler passiert
    beim <code>should create user</code> und beim <code>should update
    user</code>. Scaffold muss also Beispieldaten angelegt haben, die beim
    ersten Mal (ohne Validierungen) durchgelaufen sind und beim zweiten Mal
    (mit Validierungen) nicht mehr.</para>

    <para>Diese Beispieldaten werden als sogennate Fixtures im YAML-Format im
    Verzeichnis <filename>test/fixtures/</filename> angelegt. Schauen wir uns
    die Beispieldaten für <classname>User</classname> in der Datei
    <filename>test/fixtures/users.yml</filename> an:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: MyString
  firstname: MyString
  lastname: MyString
  birthday: 2011-05-26

two:
  login_name: MyString
  firstname: MyString
  lastname: MyString
  birthday: 2011-05-26
</programlisting></para>

    <para>Dort sind zwei Beispieldatensätze angelegt, die unserer Validierung
    nicht standhalten. Der <methodname>login_name</methodname> braucht
    mindestens ein Sonderzeichen und der User muss mindestens 18 Jahre alt
    sein. Ändern wir <code>login_name</code> und <code>birthday</code> in
    <filename>test/fixtures/users.yml</filename> entsprechend
    ab:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: My-String
  firstname: MyString
  lastname: MyString
  birthday: 1970-01-01

two:
  login_name: My-String
  firstname: MyString
  lastname: MyString
  birthday: 1970-01-01
</programlisting></para>

    <para>Ein <command>rake test</command> läuft jetzt wieder ohne Fehler
    durch:<screen>MacBook:webshop sw$ <command>rake test</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004292 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     PASS should create user (0.11s) 
     PASS should destroy user (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     PASS should update user (0.01s) 

Finished in 0.229877 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$ </screen></para>

    <para>Wir wissen nun, dass in der
    <filename>test/fixtures/users.yml</filename> valide Daten stehen müssen,
    damit der mit Scaffold erstellte Standard-Test durchläuft. Aber auch nicht
    mehr. Nachfolgend andern wir die
    <filename>test/fixtures/users.yml</filename> auf ein Minimum (wir brauchen
    keinen <code>firstname</code>) und mit für Menschen leichter lesbaren
    Daten ab:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
  birthday: 1970-01-01

two:
  login_name: emil.maier
  lastname: Maier
  birthday: 1950-01-01
</programlisting></para>

    <para>Sicherheitshalber nach der Veränderung noch mal ein <command>rake
    test</command> (das kann man gar nicht oft genug machen):<screen>MacBook:webshop sw$ <command>rake test</command>
[...]
7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$ </screen></para>

    <important>
      <para>Alle Fixtures werden beim Starten eines Tests in die Datenbank
      geladen. Besonders wenn man
      <methodname>validates_uniqueness_of</methodname> (siehe <xref
      linkend="validates_uniqueness_of" />) in der Validierung benutzt, muss
      man dies beim Test im Hinterkopf behalten.</para>
    </important>

    <section xml:id="testing_beispiel_webshop_functional_tests">
      <title
      xml:id="testing_beispiel_webshop_functional_tests.title">Functional
      Tests</title>

      <indexterm>
        <primary>Testing</primary>

        <secondary>Functional Tests</secondary>
      </indexterm>

      <para>Schauen wir uns mal genau an, an welcher Stelle die ursprünglichen
      Fehler aufgetreten sind:<screen>UsersControllerTest:
     FAIL should create user (0.21s) 
          #&lt;Proc:0x00000100c87c50@/Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:49 (lambda)&gt; didn't change by 1.
&lt;3&gt; expected but was
&lt;2&gt;.
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:58:in `block in assert_difference'

     PASS should destroy user (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     FAIL should update user (0.02s) 
          Expected response to be a &lt;:redirect&gt;, but was &lt;200&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:45:in `assert_response'
</screen></para>

      <para>Im <code>UsersControllerTest</code> konnte der User nicht angelegt
      und nicht verändert werden. Die Controller-Tests befinden sich im
      Verzeichnis <filename>test/functional/</filename>. Schauen wir uns jetzt
      die Datei <filename>test/functional/users_controller_test.rb</filename>
      genau an:<programlisting>require 'test_helper'

class UsersControllerTest &lt; ActionController::TestCase
  setup do
    @user = users(:one)
  end

  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:users)
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should create user" do
    assert_difference('User.count') do
      post :create, user: @user.attributes
    end

    assert_redirected_to user_path(assigns(:user))
  end

  test "should show user" do
    get :show, id: @user.to_param
    assert_response :success
  end

  test "should get edit" do
    get :edit, id: @user.to_param
    assert_response :success
  end

  test "should update user" do
    put :update, id: @user.to_param, user: @user.attributes
    assert_redirected_to user_path(assigns(:user))
  end

  test "should destroy user" do
    assert_difference('User.count', -1) do
      delete :destroy, id: @user.to_param
    end

    assert_redirected_to users_path
  end
end
</programlisting></para>

      <para>Die verschiedenen Test-Namen kennen wir von der Bildschirmausgabe
      von <command>rake test</command>. Am Anfang finden wir eine
      <code>setup</code>-Anweisung: <programlisting>  setup do
    @user = users(:one)
  end
</programlisting></para>

      <para>Diese drei Zeilen Code bedeuten, dass zum Start eines jeden
      einzelnen Tests eine Instanz <varname>@user</varname> mit den Daten des
      Eintrages <code>one</code> aus der Datei
      <filename>test/fixtures/users.yml</filename> angelegt wird.
      <methodname>setup</methodname> ist ein vordefinierter Callback, der -
      falls vorhanden - von Rails vor jedem Test gestartet wird. Das
      Gegenstück zu <methodname>setup</methodname> ist
      <methodname>teardown</methodname>. Ein <methodname>teardown</methodname>
      wird - falls vorhanden - nach jedem Test automatisch
      aufgerufen.<indexterm>
          <primary>Functional Test Callbacks</primary>

          <secondary>setup</secondary>
        </indexterm><indexterm>
          <primary>Functional Test Callbacks</primary>

          <secondary>teardown</secondary>
        </indexterm></para>

      <important>
        <para>Bei jedem Test (also bei jedem Durchlauf von <command>rake
        test</command>) wird automatisch eine frische und damit leere
        Test-Datenbank angelegt. Das ist eine andere Datenbank als die, auf
        die Sie per Default mit <command>rails console</command> zugreifen
        (das ist die Development-Datenbank). Die Datenbanken werden in der
        Konfigurationsdatei <filename>config/database.yml</filename>
        definiert. Auf die Test-Datenbank können Sie zu Debug-Zwecken mit
        <command>rails console test</command> zugreifen.</para>
      </important>

      <para>Danach werden in diesem Functional Test verschiedene
      Webseiten-Funktionen getestet. Als Erstes der Zugriff auf die
      Index-Seite:<programlisting>  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:users)
  end
</programlisting></para>

      <para>Der Befehl <code>get :index</code> ruft die Seite
      <uri>/users</uri> auf. <code>assert_response :success</code> bedeutet,
      dass die Seite ausgeliefert wurde. Die Zeile <code>assert_not_nil
      assigns(:users)</code> stellt sicher, dass die Instanz-Variable
      <varname>@users</varname> vom Controller nicht mit dem Wert
      <code>nil</code> zum View gegeben wird.<footnote>
          <para>Dabei wird hier das Symbol <varname>:users</varname> genommen,
          um sicherzustellen, dass <varname>@users</varname> in der zu
          testenden Controller-Klasse und nicht <varname>@users</varname> in
          der Test-Klasse genommen wird.</para>
        </footnote></para>

      <para>Schauen wir uns mal die beiden Probleme von vorhin genauer an. Als
      Erstes <code>should create user</code>:<programlisting>  test "should create user" do
    assert_difference('User.count') do
      post :create, user: @user.attributes
    end

    assert_redirected_to user_path(assigns(:user))
  end
</programlisting></para>

      <para>Die <code>assert_difference('User.count') do ...
      end</code>-Schleife erwartet eine Veränderung vom Anfang bis zum Ende
      der Schleife. <code>User.count</code> müsste am Anfang 1 ergeben und am
      Ende 2. Da wir aber in der ersten
      <filename>test/fixtures/users.yml</filename>-Variante einen nicht
      gültigen Datensatz hatten, ergab <code>User.count</code> am Anfang und
      am Ende 0. 0 und nicht 1 am Anfang, weil auch das <code>setup do ...
      end</code> nicht funktioniert haben kann.</para>

      <para>Die letzte Zeile <code>assert_redirected_to
      user_path(assigns(:user))</code> überprüft, ob nach einem neu angelegten
      Datensatz auch auf den entsprechenden <code>show</code> View geleitet
      wird.</para>

      <para>Den zweiten Fehler gab es bei <code>should update
      user</code>:<programlisting>  test "should update user" do
    put :update, id: @user.to_param, user: @user.attributes
    assert_redirected_to user_path(assigns(:user))
  end
</programlisting></para>

      <para>Hier sollte der Datensatz mit der <code>id</code> des
      <varname>@user</varname>-Datensatzes mit den Attributen des
      <varname>@user</varname>-Datensatzes geupdatet werden. Danach soll auch
      wieder der <code>show</code> View zu diesem Datensatz angezeigt werden.
      Logischerweise ging dieser Test auch nicht, da a) der
      <varname>@user</varname>-Datensatz gar nicht in der Datenbank existierte
      und b) er auch nicht geupdatet werden konnte, da er nicht valide
      war.</para>

      <para>Ohne jetzt auf jeden einzelnen Functional Test Zeile für Zeile
      einzugehen, wird klar, was diese Tests machen: Sie führen echte Anfragen
      an das Web-Interface aus und können somit dazu benutzt werden, die Views
      und die Controller zu testen.</para>

      <tip>
        <para>Mit <command>rake test:functionals</command> können Sie auch nur
        die Functional Tests im Verzeichnis
        <filename>test/functional/</filename> durchlaufen lassen.<screen>MacBook:webshop sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     PASS should create user (0.11s) 
     PASS should destroy user (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     PASS should update user (0.01s) 

Finished in 0.227522 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$ </screen></para>
      </tip>
    </section>

    <section xml:id="testing_beispiel_webshop_unit_tests">
      <title>Unit Tests</title>

      <indexterm>
        <primary>Testing</primary>

        <secondary>Unit Tests</secondary>
      </indexterm>

      <indexterm>
        <primary>Unit Tests</primary>

        <secondary>assert</secondary>
      </indexterm>

      <para>Zum Testen der Validierungen, die wir in
      <filename>app/models/user.rb</filename> eingetragen haben, sind Unit
      Tests besser geeignet. Diese testen nicht wie die Functional Tests die
      GUI und damit die Controller und die Views, sondern nur die
      Models.</para>

      <tip>
        <para>Mit <command>rake test</command> werden alle im Rails-Projekt
        vorhandenen Tests ausgeführt. Mit <command>rake test:units</command>
        werden nur die Unit Tests im Verzeichnis
        <filename>test/unit/</filename> ausgeführt.</para>
      </tip>

      <para>Die Unit Tests befinden sich im Verzeichnis
      <filename>test/unit/</filename>. Ein Blick in die Datei
      <filename>test/unit/user_test.rb</filename> ist aber
      ernüchternd:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end
</programlisting></para>

      <para>Per Default schreibt Scaffold nur einen mit Kommentarzeichen
      deaktivierten Dummy-Test rein. Deshalb läuft <command>rake
      test:units</command> auch so inhaltslos durch:<screen>MacBook:webshop sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004243 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$</screen></para>

      <para>Füllen wir den ersten Test in der
      <filename>test/unit/user_test.rb</filename> mit Leben:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
<emphasis>  test "an empty user is not valid" do
    assert !User.new.valid?
  end</emphasis>
end
</programlisting></para>

      <para>Dieser Test überprüft, ob ein neu angelegter
      <classname>User</classname>, der keine Daten enthält, valide ist. Da
      <code>assert</code> nur auf <code>true</code> reagiert, habe ich vor
      <code>User.new.valid?</code> ein <code>!</code> gesetzt, um aus dem
      <code>false</code> ein <code>true</code> zu machen, denn ein leerer User
      kann ja nicht valide sein.</para>

      <para>Ein <command>rake test:units</command> läuft dann auch direkt
      durch:<screen>MacBook:webshop sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS an empty user is not valid (0.07s) 

Finished in 0.075614 seconds.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$</screen></para>

      <para>Jetzt bauen wir zwei Asserts in einem Test ein, die überprüfen, ob
      die beiden Fixture-Einträge in der
      <filename>test/fixtures/users.yml</filename> auch valide
      sind:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  test "an empty user is not valid" do
    assert !User.new.valid?
  end
  
<emphasis>  test "the two fixture users are valide" do
    assert User.new(users(:one).attributes)
    assert User.new(users(:two).attributes)
  end
</emphasis>end</programlisting></para>

      <para>Danach wieder ein <command>rake test:units</command>:<screen>MacBook:webshop sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS an empty user is not valid (0.07s) 
     PASS the two fixture users are valide (0.00s) 

Finished in 0.078738 seconds.

2 tests, 3 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$</screen></para>

      <para>Jetzt erweitern wir <filename>test/unit/user_test.rb</filename> um
      einen Test, ob ein 17-jähriger User, der morgen 18 wird, nicht valide
      und ein User, der heute 18 Jahre alt geworden ist, valide
      ist:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  test "an empty user is not valid" do
    assert !User.new.valid?
  end
  
  test "the two fixture users are valide" do
    assert User.new(users(:one).attributes)
    assert User.new(users(:two).attributes)
  end
  
<emphasis>  test "a user who has tomorrow his 18th birthday is not valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years + 1.day
    assert !User.new(user.attributes).valid?
  end

  test "a user who has today his 18th birthday is valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years
    assert User.new(user.attributes).valid?
  end</emphasis>
end
</programlisting></para>

      <para>Der Test läuft sauber durch:<screen>MacBook:webshop sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS a user who has today his 18th birthday is valid (0.04s) 
     PASS a user who has tomorrow his 18th birthday is not valid (0.00s) 
     PASS an empty user is not valid (0.01s) 
     PASS the two fixture users are valide (0.00s) 

Finished in 0.087012 seconds.

4 tests, 5 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$</screen></para>

      <para>Was müssen wir noch testen? Ob bestimmte Attribute nicht nil sind.
      Dafür können wir einfach die folgende Schleife
      hinzufügen:<programlisting>  ['lastname', 'login_name', 'birthday'].each do |attribute_name|
    test "a user has to have a not nil #{attribute_name} attribute" do
      assert !User.new(users(:one).attributes.except(attribute_name)).valid?
    end
  end
</programlisting></para>

      <para>Mit zwei weiteren Tests für verschiedene valide und nicht valide
      <code>login_name</code>-Werte sieht die
      <filename>test/unit/user_test.rb</filename> dann so aus:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  test "an empty user is not valid" do
    assert !User.new.valid?
  end
  
  test "the two fixture users are valide" do
    assert User.new(users(:one).attributes)
    assert User.new(users(:two).attributes)
  end
  
  test "a user who has tomorrow his 18th birthday is not valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years + 1.day
    assert !User.new(user.attributes).valid?
  end

  test "a user who has today his 18th birthday is valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years
    assert User.new(user.attributes).valid?
  end

  ['lastname', 'login_name', 'birthday'].each do |attribute_name|
    test "a user has to have a not nil #{attribute_name} attribute" do
      assert !User.new(users(:one).attributes.except(attribute_name)).valid?
    end
  end
  
  ['hans.meier', 'hans-meier', 'h-meier', 'h_meier', 'h.meier2'].each do |valid_login_name|
    test "the login_name '#{valid_login_name}' is valid" do
      assert User.new(users(:one).attributes.except('login_name').merge({'login_name' =&gt; valid_login_name})).valid?
    end
  end

  ['hansmeier', 'hmeier', 'hmeier2'].each do |invalid_login_name|
    test "the login_name '#{invalid_login_name}' is invalid" do
      assert !User.new(users(:one).attributes.except('login_name').merge({'login_name' =&gt; invalid_login_name})).valid?
    end
  end
end</programlisting></para>

      <para>Der Durchlauf der Test-Suite zeigt die Ergebnisse:<screen>MacBook:webshop sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS a user has to have a not nil birthday attribute (0.07s) 
     PASS a user has to have a not nil lastname attribute (0.00s) 
     PASS a user has to have a not nil login name attribute (0.00s) 
     PASS a user who has today his 18th birthday is valid (0.00s) 
     PASS a user who has tomorrow his 18th birthday is not valid (0.00s) 
     PASS an empty user is not valid (0.00s) 
     PASS the login name 'h-meier' is valid (0.00s) 
     PASS the login name 'h.meier2' is valid (0.00s) 
     PASS the login name 'h meier' is valid (0.00s) 
     PASS the login name 'hans-meier' is valid (0.00s) 
     PASS the login name 'hans.meier' is valid (0.00s) 
     PASS the login name 'hansmeier' is invalid (0.00s) 
     PASS the login name 'hmeier' is invalid (0.00s) 
     PASS the login name 'hmeier2' is invalid (0.00s) 
     PASS the two fixture users are valide (0.00s) 

Finished in 0.099514 seconds.

15 tests, 16 assertions, 0 failures, 0 errors, 0 skips
MacBook:webshop sw$</screen></para>

      <para>Mit <command>rake test</command> könnten Sie jetzt alle Tests
      durchlaufen lassen.</para>
    </section>
  </section>

  <section xml:id="testing_fixtures">
    <title xml:id="testing_fixtures.title">Fixtures</title>

    <indexterm>
      <primary>Testing Fixtures</primary>

      <secondary>Fixtures</secondary>
    </indexterm>

    <para>Mit Fixtures werden Beispieldaten für Tests generiert. Das
    Default-Format dafür ist YAML. Die Dateien dafür finden sich im
    Verzeichnis <filename>test/fixtures/</filename> und werden mit
    <command>rails generate</command> automatisch mit erstellt. Sie können
    aber natürlich auch eigene Dateien definieren. Alle Fixtures werden per
    Default bei jedem Test neu in die Test-Datenbank geladen.<footnote>
        <para>Beispiele für Alternativformate (z. B. CSV) dazu finden Sie
        unter <uri
        xlink:href="http://api.rubyonrails.org/classes/Fixtures.html">http://api.rubyonrails.org/classes/Fixtures.html</uri>.</para>
      </footnote></para>

    <section xml:id="statische_fixtures">
      <title xml:id="statische_fixtures.title">Statische Fixtures</title>

      <indexterm>
        <primary>Fixtures</primary>

        <secondary>Statische Fixtures</secondary>
      </indexterm>

      <para>Die einfachste Variante für Fixtures sind statische Daten. Das in
      <xref linkend="testing_beispiel_webshop" /> benutzte Fixture für
      <varname>person</varname> sieht statisch wie folgt aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
  birthday: 1970-01-01

two:
  login_name: emil.maier
  lastname: Maier
  birthday: 1950-01-01
</programlisting></para>

      <para>Man schreibt die Daten einfach im YAML-Format in die entsprechende
      Datei.</para>
    </section>

    <section xml:id="fixtures_mit_erb">
      <title xml:id="fixtures_mit_erb.title">Fixtures mit ERB</title>

      <indexterm>
        <primary>Fixtures</primary>

        <secondary>Fixtures mit ERB</secondary>
      </indexterm>

      <para>Statische YAML Fixtures sind manchmal zu unintelligent. In diesen
      Fällen kann man mit ERB arbeiten (siehe <xref
      linkend="erb-programmieren" />). Das in <xref
      linkend="testing_beispiel_webshop" /> benutzte Fixture sah statisch so
      aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
  birthday: 1970-01-01

two:
  login_name: emil.maier
  lastname: Maier
  birthday: 1950-01-01
</programlisting></para>

      <para>Wenn wir für die Geburtstage dynamisch den heutigen Tag vor 20
      Jahren eintragen möchten, so können wir das einfach mit ERB
      realisieren:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;</emphasis>

two:
  login_name: emil.maier
  lastname: Maier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;</emphasis></programlisting></para>

      <para>Wenn wir noch zusätzliche 100 Beispiel-User bräuchten, dann könnte
      wir das auch mit ein paar Zeilen ERB erledigen:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;</emphasis>

two:
  login_name: emil.maier
  lastname: Maier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;

&lt;% for i in 1..100 %&gt;
user_&lt;%= i %&gt;:
  login_name: person_&lt;%= 1 %&gt;
  lastname: Meyer
  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;
&lt;% end %&gt;</emphasis></programlisting></para>
    </section>

    <section xml:id="has_many_und_belongs_to_fixtures">
      <title xml:id="has_many_und_belongs_to_fixtures.title">has_many und
      belongs_to Fixtures</title>

      <para>Bei <methodname>has_many</methodname>- und
      <methodname>belongs_to</methodname>-Verbindungen müssen natürlich auch
      die Fixtures entsprechend geschrieben werden, sonst passen die Daten
      nicht zueinander.</para>

      <para>Angenommen, wir haben eine Telefonbuch-Applikation mit Personen,
      die beliebig viele Telefonnummern haben (siehe <xref
      linkend="activerecord_has_many" />):<screen>MacBook:~ sw$ <command>rails new phonebook</command>
[...]
MacBook:~ sw$ <command>cd phonebook</command>
MacBook:phonebook sw$ <command>bundle install</command>
[...]
MacBook:phonebook sw$ <command>rails generate scaffold person firstname:string lastname:string</command>
[...]
MacBook:phonebook sw$ <command>rails generate scaffold phone person_id:integer name:string number:string</command>
[...]
MacBook:phonebook sw$ <command>rake db:migrate</command>
[...]
MacBook:phonebook sw$</screen></para>

      <para>In <filename>app/models/person.rb</filename>
      steht:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phones

  validates_presence_of :lastname
end</programlisting></para>

      <para>In <filename>app/models/phone.rb</filename> steht:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :person

  validates_presence_of :number
  validates_presence_of :person_id
  
  validate :person_exists

  private
  def person_exists 
    errors.add("person_id", "person is not existant") unless Person.exists?(self.person_id) 
  end   
end</programlisting></para>

      <section xml:id="has_many_und_belongs_to_fixtures_statisch">
        <title
        xml:id="has_many_und_belongs_to_fixtures_statisch.title">Statische
        Variante</title>

        <para>Wir können statische IDs von Hand vergeben. Dann sieht die
        <filename>test/fixtures/people.yml</filename> wie folgt
        aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  id: 1
  firstname: Horst
  lastname: Meier

two:
  id: 2
  firstname: Emil
  lastname: Obermeier
</programlisting></para>

        <para>Und in der <filename>test/fixtures/phones.yml</filename> werden
        die person_id-Einträge passend zum Inhalt von
        <filename>test/fixtures/people.yml</filename> gesetzt:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  person_id: 1
  name: Handy
  number: 0171 1234567

two:
  person_id: 1
  name: Zu Hause
  number: 030 1234567
  
three:
  person_id: 2
  name: Handy
  number: 0172 9876543
</programlisting></para>

        <para>Die <filename>test/unit/person_test.rb</filename> enthält die
        Tests für <classname>Person</classname>:<programlisting>require 'test_helper'

class PersonTest &lt; ActiveSupport::TestCase
  test "the fixture people data are valid" do
    assert Person.new(people(:one).attributes).valid?
    assert Person.new(people(:two).attributes).valid?
  end
end
</programlisting></para>

        <para>Und <filename>test/unit/phone_test.rb</filename> enthält die
        Tests für <classname>Phone</classname>:<programlisting>require 'test_helper'

class PhoneTest &lt; ActiveSupport::TestCase
  test "the fixture phone entry data is valid" do
    assert Phone.new(phones(:one).attributes).valid?
    assert Phone.new(phones(:two).attributes).valid?
    assert Phone.new(phones(:three).attributes).valid?
  end
  
  test "a phone without a person is not valid" do
    phone = Phone.new(phones(:one).attributes)
    phone.person.destroy
    assert !phone.valid?
  end
end
</programlisting></para>

        <para>Ein <command>rake test:units</command> sagt, dass alles okay
        ist:<screen>MacBook:phonebook sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PersonTest:
     PASS the fixture people data are valid (0.04s) 

PhoneTest:
     PASS a phone without a person is not valid (0.07s) 
     PASS the fixture phone entry data is valid (0.00s) 

Finished in 0.119441 seconds.

3 tests, 6 assertions, 0 failures, 0 errors, 0 skips
MacBook:phonebook sw$</screen></para>
      </section>

      <section xml:id="has_many_und_belongs_to_fixtures_label_referenz">
        <title
        xml:id="has_many_und_belongs_to_fixtures_label_referenz.title">Die
        Label Referenz-Variante</title>

        <indexterm>
          <primary>Fixtures</primary>

          <secondary>Label Referenz</secondary>
        </indexterm>

        <para>Eine etwas charmantere Alternative zu <xref
        linkend="has_many_und_belongs_to_fixtures_statisch" /> ist die
        Verwendung von Label Referenzen.</para>

        <para>Label sind die Namen für einzelne Fixtures. Damit sieht die
        <filename>test/fixtures/people.yml</filename> wie folgt
        aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

<emphasis>horst_meier:</emphasis>
  firstname: Horst
  lastname: Meier

<emphasis>emil_meier:</emphasis>
  firstname: Emil
  lastname: Obermeier
</programlisting></para>

        <para>In der <filename>test/fixtures/phones.yml</filename> verweisen
        wir jetzt nicht mehr auf die <varname>person_id</varname>, sondern auf
        das Label der <varname>person</varname>:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
<emphasis>  person: horst_meier</emphasis>
  name: Handy
  number: 0171 1234567

two:
<emphasis>  person: horst_meier</emphasis>
  name: Zu Hause
  number: 030 1234567
  
three:
<emphasis>  person: emil_meier</emphasis>
  name: Handy
  number: 0172 9876543</programlisting></para>

        <para>Die <filename>test/unit/person_test.rb</filename> enthält die
        Tests für Person:<programlisting>require 'test_helper'

class PersonTest &lt; ActiveSupport::TestCase
  test "the fixture people data are valid" do
    assert Person.new(people(:horst_meier).attributes).valid?
    assert Person.new(people(:emil_meier).attributes).valid?
  end
end
</programlisting></para>

        <para>Und <filename>test/unit/phone_test.rb</filename> ändert sich
        nicht:<programlisting>require 'test_helper'

class PhoneTest &lt; ActiveSupport::TestCase
  test "the fixture phone entry data is valid" do
    assert Phone.new(phones(:one).attributes).valid?
    assert Phone.new(phones(:two).attributes).valid?
    assert Phone.new(phones(:three).attributes).valid?
  end
  
  test "a phone without a person is not valid" do
    phone = Phone.new(phones(:one).attributes)
    phone.person.destroy
    assert !phone.valid?
  end
end
</programlisting></para>

        <para>Mit einem <command>rake test:units</command> können wir
        kontrollieren, ob alles korrekt ist:<screen>MacBook:phonebook sw$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PersonTest:
     PASS the fixture people data are valid (0.04s) 

PhoneTest:
     PASS a phone without a person is not valid (0.07s) 
     PASS the fixture phone entry data is valid (0.00s) 

Finished in 0.119441 seconds.

3 tests, 6 assertions, 0 failures, 0 errors, 0 skips
MacBook:phonebook sw$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="unit_tests">
    <title xml:id="unit_tests.title">Unit Tests</title>

    <indexterm>
      <primary>Testing</primary>

      <secondary>Unit Tests</secondary>
    </indexterm>

    <para>In <xref linkend="testing_beispiel_webshop" /> wurde die Grundidee
    von Unit Tests erklärt. Es geht bei Unit Tests darum, die Funktionsweise
    der Models zu testen. Also unabhängig von Controllern und Views. Alle Unit
    Tests werden im Verzeichnis <filename>test/unit/</filename> gespeichert.
    <command>rake generate</command> generiert automatisch diese Dateien. Sie
    können aber natürlich auch per Hand erstellt werden. Vor dem Ausführen der
    Tests wird die Test-Datenbank mit Test-Daten gefüllt (siehe <xref
    linkend="testing_fixtures" />).</para>

    <para>In der perfekten Welt würde man im Unit Test alles testen, was
    irgendwie schief gehen kann und zwar einmal mit einem Positiv- und einmal
    mit einem Negativ-Test. Das heißt, man würde beispielsweise für jede
    Validierung mindestens ein Beispiel durchgehen, in dem jeweils ein
    korrekter und ein inkorrekter Datensatz geprüft wird. Das Gleiche gilt für
    jede Methode des Models.</para>

    <para>Schauen wir uns noch mal die Datei
    <filename>test/unit/phone_test.rb</filename> aus <xref
    linkend="has_many_und_belongs_to_fixtures_label_referenz" />
    an:<programlisting>require 'test_helper'

class PhoneTest &lt; ActiveSupport::TestCase
  test "the fixture phone entry data is valid" do
    assert Phone.new(phones(:one).attributes).valid?
    assert Phone.new(phones(:two).attributes).valid?
    assert Phone.new(phones(:three).attributes).valid?
  end
  
  test "a phone without a person is not valid" do
    phone = Phone.new(phones(:one).attributes)
    phone.person.destroy
    assert !phone.valid?
  end
end
</programlisting></para>

    <para>Ein Test besteht also immer aus folgender Struktur:<programlisting>test "eine Behauptung" do
  assert etwas_ist_true_oder_false
end</programlisting></para>

    <para>Das Wort <code>assert</code> bedeutet in diesem Kontext behaupten
    oder feststellen. Es wird also eine Behauptung aufgestellt. Wenn diese
    Behauptung <code>true</code> ist, dann läuft der Test durch und alles ist
    okay. Wenn diese Behauptung <code>false</code> ist, schlägt der Test fehl
    und wir haben einen Fehler im Programm. Wenn Sie sich einmal auf <uri
    xlink:href="http://guides.rubyonrails.org/testing.html">http://guides.rubyonrails.org/testing.html</uri>
    umschauen, dann werden Sie sehen, dass es noch ein paar andere
    <code>assert</code>-Varianten gibt. Hier einige Beispiele:<itemizedlist>
        <listitem>
          <para><code>assert( boolean, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_equal( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_not_equal( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_same( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_not_same( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_nil( obj, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_not_nil( obj, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_match( regexp, string, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_no_match( regexp, string, [msg] )</code></para>
        </listitem>
      </itemizedlist></para>

    <para>Leider habe ich ein schlechtes Gedächtnis und kann mir diese ganzen
    Spezialfälle nicht alle merken. Ist aber auch kein Problem, denn
    eigentlich kann man auch alles mit einem <code>assert</code> abdecken.
    Wenn ich also einen Spezialfall mit dem entsprechenden Spezial-assert
    abbilden will, dann muss ich es auf <uri
    xlink:href="http://guides.rubyonrails.org/testing.html">http://guides.rubyonrails.org/testing.html</uri>
    nachschlagen. Oder ich baue mir mit einem einfachen assert die gleiche
    Behauptung als false/true-Szenario auf.</para>
  </section>

  <section xml:id="functional_tests">
    <title xml:id="functional_tests.title">Functional Tests</title>

    <indexterm>
      <primary>Testing</primary>

      <secondary>Functional Tests</secondary>
    </indexterm>

    <para>In <xref linkend="testing_beispiel_webshop" /> wurde die Grundidee
    für Functional Tests erklärt. Es geht bei Functional Tests darum, die
    Funktionsweise der Webseite zu testen. Dabei werden sowohl die Views als
    auch die Controller zu den Views getestet. Der Befehl <command>rake
    test:functionals</command> führt während des Tests echte Abfragen auf die
    Rails-Application aus, die vorher mit Test-Daten gefüllt wurden (siehe
    <xref linkend="testing_fixtures" />). Alle Functional Tests werden im
    Verzeichnis <filename>test/functional/</filename> gespeichert.
    <command>rake generate</command> generiert automatisch diese Dateien. Sie
    können aber natürlich auch per Hand erstellt werden.</para>

    <para>Das Grundgerüst für einen Functional Test sieht immer so
    aus:<programlisting>require 'test_helper'

class PeopleControllerTest &lt; ActionController::TestCase

  test "should get something" do
    get :something
    assert_response :success
  end

end</programlisting></para>

    <para>Die von <command>rails generate scaffold</command> automatisch
    erzeugten Functional Tests sind meistens eine sehr gute Ausgangsplattform.
    Diese kann man Schritt für Schritt erweitern.</para>

    <section xml:id="workflow_veraenderung_mit_functional_test">
      <title xml:id="workflow_veraenderung_mit_functional_test.title">Workflow
      für eine Veränderung im Functional Test und im Controller</title>

      <para>Nehmen wir noch einmal eine Telefonbuch-Applikation mit Personen,
      die beliebig viele Telefonnummern haben (siehe <xref
      linkend="activerecord_has_many" />) als Grundlage:<screen>MacBook:~ sw$ <command>rails new phonebook</command>
[...]
MacBook:~ sw$ <command>cd phonebook</command>
MacBook:phonebook sw$ <command>bundle install</command>
[...]
MacBook:phonebook sw$ <command>rails generate scaffold person firstname:string lastname:string</command>
[...]
MacBook:phonebook sw$ <command>rails generate scaffold phone person_id:integer name:string number:string</command>
[...]
MacBook:phonebook sw$ <command>rake db:migrate</command>
[...]
MacBook:phonebook sw$</screen></para>

      <para>In <filename>app/models/person.rb</filename>
      steht:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phones

  validates_presence_of :lastname
end</programlisting></para>

      <para>In <filename>app/models/phone.rb</filename> steht:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :person

  validates_presence_of :number
  validates_presence_of :person_id
  
  validate :person_exists

  private
  def person_exists 
    errors.add("person_id", "person is not existant") unless Person.exists?(self.person_id) 
  end   
end</programlisting></para>

      <para>Für unsere Tests brauchen wir noch sinnvolle Beispieldaten. Die
      <filename>test/fixtures/people.yml</filename> füllen wir wie
      folgt:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  id: 1
  firstname: Horst
  lastname: Meier

two:
  id: 2
  firstname: Emil
  lastname: Obermeier
</programlisting></para>

      <para>Und in der <filename>test/fixtures/phones.yml</filename> werden
      die person_id-Einträge passend zum Inhalt von
      <filename>test/fixtures/people.yml</filename> gesetzt:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  person_id: 1
  name: Handy
  number: 0171 1234567

two:
  person_id: 1
  name: Zu Hause
  number: 030 1234567
  
three:
  person_id: 2
  name: Handy
  number: 0172 9876543
</programlisting></para>

      <note>
        <para>Eigentlich sollten Sie jetzt noch die Unit Tests aus <xref
        linkend="has_many_und_belongs_to_fixtures" /> übernehmen.</para>
      </note>

      <para><command>rake generate scaffold</command> hat uns die beiden
      Functional Test-Dateien <filename>people_controller_test.rb</filename>
      und <filename>phones_controller_test.rb</filename> automatisch erstellt.
      Diese Dateien bilden eine perfekte Grundlage für uns.</para>

      <para>Als Erstes überprüfen wir, ob die Tests durchlaufen:<screen>MacBook:phonebook sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PeopleControllerTest:
     PASS should create person (0.11s) 
     PASS should destroy person (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show person (0.01s) 
     PASS should update person (0.01s) 

PhonesControllerTest:
     PASS should create phone (0.05s) 
     PASS should destroy phone (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.05s) 
     PASS should get new (0.01s) 
     PASS should show phone (0.01s) 
     PASS should update phone (0.01s) 

Finished in 0.357404 seconds.

14 tests, 20 assertions, 0 failures, 0 errors, 0 skips
MacBook:phonebook sw$ </screen></para>

      <para>Schauen wir uns nachfolgend
      <filename>test/functional/people_controller_test.rb</filename>
      an:<programlisting>require 'test_helper'

class PeopleControllerTest &lt; ActionController::TestCase
  setup do
    @person = people(:one)
  end

  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:people)
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should create person" do
    assert_difference('Person.count') do
      post :create, person: @person.attributes
    end

    assert_redirected_to person_path(assigns(:person))
  end

  test "should show person" do
    get :show, id: @person.to_param
    assert_response :success
  end

  test "should get edit" do
    get :edit, id: @person.to_param
    assert_response :success
  end

  test "should update person" do
    put :update, id: @person.to_param, person: @person.attributes
    assert_redirected_to person_path(assigns(:person))
  end

  test "should destroy person" do
    assert_difference('Person.count', -1) do
      delete :destroy, id: @person.to_param
    end

    assert_redirected_to people_path
  end
end
</programlisting></para>

      <para>Wir möchten folgende Änderung in der Applikation vornehmen:
      Nachdem eine neue <classname>person</classname> anlegt wird, soll nicht
      <code>person#show</code> (<code>person_path</code>), sondern
      <code>person#index</code> (<code>people_path</code>) angesprungen
      werden. Es soll also nicht der eben gerade angelegte Datensatz einzeln,
      sondern alle Datensätze in einer Tabelle angezeigt werden.</para>

      <para>Dazu müssen wir folgenden Test ändern:<programlisting>  test "should create person" do
    assert_difference('Person.count') do
      post :create, person: @person.attributes
    end

    assert_redirected_to person_path(assigns(:person))
  end
</programlisting></para>

      <para>Und zwar muss der <code>assert_redirect_to</code> wie folgt
      geändert werden:<programlisting>  test "should create person" do
    assert_difference('Person.count') do
      post :create, person: @person.attributes
    end

    <emphasis>assert_redirected_to people_path</emphasis>
  end</programlisting></para>

      <para>Der Test wird natürlich jetzt einen Fehler ausgeben:<screen>MacBook:phonebook sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PeopleControllerTest:
     FAIL should create person (0.11s) 
          Expected response to be a redirect to &lt;http://test.host/people&gt; but was a redirect to &lt;http://test.host/people/3&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:74:in `assert_redirected_to'

     PASS should destroy person (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show person (0.01s) 
     PASS should update person (0.01s) 

PhonesControllerTest:
     PASS should create phone (0.05s) 
     PASS should destroy phone (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.05s) 
     PASS should get new (0.01s) 
     PASS should show phone (0.01s) 
     PASS should update phone (0.01s) 

Finished in 0.357209 seconds.

14 tests, 21 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:functionals
(See full trace by running task with --trace)
MacBook:phonebook sw$</screen></para>

      <para>Die Fehlermeldung <errortext>Expected response to be a redirect to
      &lt;http://test.host/people&gt; but was a redirect to
      &lt;http://test.host/people/3&gt;</errortext> ist dabei selbsterklärend.
      Wir müssen im Controller
      <filename>app/controllers/people_controller.rb</filename> die
      <methodname>create</methodname>-Methode so verändern, dass nach dem
      Anlegen des Datensatzes ein Redirect auf die <code>people_url</code>
      erfolgt:<programlisting>  def create
    @person = Person.new(params[:person])

    respond_to do |format|
      if @person.save
        <emphasis>format.html { redirect_to people_url }</emphasis>
        format.json { render json: @person, status: :created, location: @person }
      else
        format.html { render action: "new" }
        format.json { render json: @person.errors, status: :unprocessable_entity }
      end
    end
  end
</programlisting></para>

      <para>Jetzt läuft <command>rake test:functionals</command> wieder sauber
      durch:<screen>MacBook:phonebook sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PeopleControllerTest:
     PASS should create person (0.11s) 
     PASS should destroy person (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show person (0.01s) 
     PASS should update person (0.01s) 

PhonesControllerTest:
     PASS should create phone (0.08s) 
     PASS should destroy phone (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show phone (0.01s) 
     PASS should update phone (0.01s) 

Finished in 0.349060 seconds.

14 tests, 20 assertions, 0 failures, 0 errors, 0 skips
MacBook:phonebook sw$</screen></para>
    </section>

    <section xml:id="functional_test_flash_testen">
      <title xml:id="functional_test_flash_testen.title">Flash-Nachrichten
      testen</title>

      <indexterm>
        <primary>Flash-Nachricht testen</primary>
      </indexterm>

      <para>Mit Functional Tests kann man auch die Übergabe und das Anzeigen
      von Flash-Nachrichten (siehe <xref linkend="flash" />) überprüfen. Ich
      zeige Ihnen das an einer kleinen Ping-Pong Rails-Applikation:<screen>MacBook:~ sw$ <command>rails new ping-pong</command>
[...]
MacBook:~ sw$ <command>cd ping-pong</command>
MacBook:ping-pong sw$ <command>bundle install</command>
[...]
MacBook:ping-pong sw$ <command>rails generate controller Home ping pong</command>
      create  app/controllers/home_controller.rb
       route  get "home/pong"
       route  get "home/ping"
      invoke  erb
      create    app/views/home
      create    app/views/home/ping.html.erb
      create    app/views/home/pong.html.erb
      invoke  test_unit
      create    test/functional/home_controller_test.rb
      invoke  helper
      create    app/helpers/home_helper.rb
      invoke    test_unit
      create      test/unit/helpers/home_helper_test.rb
      invoke  assets
      create    app/assets/javascripts/home.js.coffee
      create    app/assets/stylesheets/home.css.scss
MacBook:ping-pong sw$ <command>rake db:migrate</command>
MacBook:ping-pong sw$</screen></para>

      <para>Ziel der Applikation soll es sein, beim Aufruf der Seite
      <uri>/home/ping</uri> auf die Seite <uri>/home/pong</uri> umgeleitet zu
      werden und eine Flash-Nachricht "<code>Sie wurden von Ping nach Pong
      umgeleitet.</code>" zu sehen. Wenn man direkt <uri>/home/pong</uri>
      öffnet, wird keine Flash-Nachricht angezeigt.</para>

      <para>Der von <command>rails generate controller Home ping
      pong</command> generierte Standardtest in der Datei
      <filename>test/functional/home_controller_test.rb</filename> sieht so
      aus:<programlisting>require 'test_helper'

class HomeControllerTest &lt; ActionController::TestCase
  test "should get ping" do
    get :ping
    assert_response :success
  end

  test "should get pong" do
    get :pong
    assert_response :success
  end

end
</programlisting></para>

      <para>Als Erstes ändern wir den "<code>should get ping</code>"-Test so
      ab, dass ein Redirect auf <uri>/home/pong</uri> erwartet
      wird:<programlisting>require 'test_helper'

class HomeControllerTest &lt; ActionController::TestCase
<emphasis>  test "ping should be redirected to pong" do
    get :ping
    assert_redirected_to home_pong_url
  end</emphasis>

  test "should get pong" do
    get :pong
    assert_response :success
  end

end
</programlisting></para>

      <para>Ein <command>rake test:functionals</command>-Lauf zeigt das
      erwartete Ergebnis:<screen>MacBook:ping-pong sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     FAIL ping should be redirected to pong (0.09s) 
          Expected response to be a &lt;:redirect&gt;, but was &lt;200&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:45:in `assert_response'

     PASS should get pong (0.00s) 

Finished in 0.096260 seconds.

2 tests, 2 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:functionals
(See full trace by running task with --trace)
MacBook:ping-pong sw$</screen></para>

      <para>Die Rails-Applikation hat die Seite <uri>/home/ping</uri> ganz
      normal mit einem HTTP-Code 200 (erfolgreich) ausgeliefert. Da der
      erwartete Redirect nicht stattgefunden hat, wird dies als Fehler
      (<code>FAIL</code>) angezeigt.</para>

      <para>Ändern wir mal den Controller in der Datei
      <filename>app/controllers/home_controller.rb</filename> so ab, dass ein
      Redirect ausgeführt wird:<programlisting>class HomeController &lt; ApplicationController
  def ping
    redirect_to home_pong_url
  end

  def pong
  end

end
</programlisting></para>

      <para>Damit läuft der Test problemlos durch:<screen>MacBook:ping-pong sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     PASS ping should be redirected to pong (0.04s) 
     PASS should get pong (0.05s) 

Finished in 0.095929 seconds.

2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
MacBook:ping-pong sw$ </screen></para>

      <para>Es fehlt aber noch die Flash-Meldung "<code>Sie wurden von Ping
      nach Pong umgeleitet.</code>". Erweitern wir den Test
      entsprechend:<programlisting>require 'test_helper'

class HomeControllerTest &lt; ActionController::TestCase
  test "ping should be redirected to pong" do
    get :ping
    assert_redirected_to home_pong_url
    <emphasis>assert_equal 'Sie wurden von Ping nach Pong umgeleitet.', flash[:notice]</emphasis>
  end

  test "should get pong" do
    get :pong
    assert_response :success
  end

end
</programlisting></para>

      <para>Erwartungsgemäß liefert er einen Fehler:<screen>MacBook:ping-pong sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     FAIL ping should be redirected to pong (0.04s) 
          &lt;"Sie wurden von Ping nach Pong umgeleitet."&gt; expected but was
&lt;nil&gt;.
          /Users/stefan/ping-pong/test/functional/home_controller_test.rb:7:in `block in &lt;class:HomeControllerTest&gt;'

     PASS should get pong (0.05s) 

Finished in 0.097190 seconds.

2 tests, 3 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:functionals
(See full trace by running task with --trace)
MacBook:ping-pong sw$</screen></para>

      <para>Erweitern wir den Controller:<programlisting>class HomeController &lt; ApplicationController
  def ping
    <emphasis>redirect_to home_pong_url, :notice =&gt; 'Sie wurden von Ping nach Pong umgeleitet.'</emphasis>
  end

  def pong
  end

end
</programlisting></para>

      <para>Der Test läuft sauber durch:<screen>MacBook:ping-pong sw$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     PASS ping should be redirected to pong (0.04s) 
     PASS should get pong (0.05s) 

Finished in 0.094714 seconds.

2 tests, 3 assertions, 0 failures, 0 errors, 0 skips
MacBook:ping-pong sw$</screen></para>

      <para>Jetzt werden aber einige sagen "Halt! Das ist ja nur die halbe
      Miete. Ich weiß zwar jetzt, dass die Flash-Message korrekt gesetzt wird,
      aber wie kann ich testen, ob sie auch wirklich im View dargestellt
      wird?". Sehr gut aufgepasst! Dieses Verhalten lässt sich aber nicht
      innerhalb eines Functional Tests überprüfen. Ein Functional Test kann
      keinem Redirect folgen. Dies ist nur mit einem Integration Test möglich.
      In <xref linkend="integration_testing" /> werde ich Ihnen zeigen, wie
      Sie genau das testen können.</para>
    </section>
  </section>

  <section xml:id="integration_testing">
    <title xml:id="integration_testing.title">Integration Testing</title>

    <indexterm>
      <primary>Testing</primary>

      <secondary>Integration Tests</secondary>
    </indexterm>

    <para>Integration Tests sind Tests, die wie Functional Tests arbeiten,
    aber über mehrere Controller gehen können. Man kann mit ihnen deshalb
    komplexe Workflows innerhalb der Rails-Applikation nachbilden.</para>

    <para>Ich zeige Ihnen das anhand der in <xref
    linkend="functional_test_flash_testen" /> erstellten
    Ping-Pong-Applikation. Der dort entwickelte Test konnte zwar überprüfen,
    ob eine Flash-Nachricht im Controller gesetzt wurde, aber nicht, ob diese
    Flash-Nachricht auch im View angezeigt wird.</para>

    <para>Mit <command>rake generate scaffold</command> werden zwar Unit und
    Functional Tests generiert, aber keine Integration Tests. Dies können Sie
    entweder von Hand im Verzeichnis <filename>test/integration/</filename>
    oder bequemer mit <command>rails generate integration_test
    test_name</command> machen. Legen wir mal einen Integration Test
    an:<screen>MacBook:ping-pong sw$ <command>rails generate integration_test ping_pong_flash_message_flow</command>
      invoke  test_unit
      create    test/integration/ping_pong_flash_message_flow_test.rb
MacBook:ping-pong sw$</screen></para>

    <para>Diese Datei
    <filename>test/integration/ping_pong_flash_message_flow_test.rb</filename>
    füllen wir jetzt mit folgendem Test:<programlisting>require 'test_helper'

class PingPongFlashMessageFlowTest &lt; ActionDispatch::IntegrationTest
  fixtures :all

  test "browse to /home/ping and get redirected to /home/pong which displays a flash message" do
    get '/home/ping'
    assert_redirected_to home_pong_url
    assert_equal 'Sie wurden von Ping nach Pong umgeleitet.', flash[:notice]
    follow_redirect!
    assert_select 'div#flash_notice', 'Sie wurden von Ping nach Pong umgeleitet.'
  end
end</programlisting></para>

    <para>Der Zauber des Integration Tests liegt unter anderem in der Methode
    <methodname>follow_redirect!,</methodname> mit der Sie im Test dem
    Redirect folgen können. Diese Methode steht Ihnen nur innerhalb eines
    Integration Tests zur Verfügung.</para>

    <para>Alle Integration Tests lassen sich mit <command>rake
    test:integration</command> ausführen. Machen wird das mal:<screen>MacBook:ping-pong sw$ <command>rake test:integration</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PingPongFlashMessageFlowTest:
     FAIL browse to /home/ping and get redirected to /home/pong which displays a flash message (0.19s) 
          Expected at least 1 element matching "div#flash_notice", found 0.
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/selector.rb:296:in `assert_select'


Finished in 0.192592 seconds.

1 tests, 3 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:integration
(See full trace by running task with --trace)
MacBook:ping-pong sw$</screen></para>

    <para>Da wir in der View-Datei
    <filename>app/views/home/pong.html.erb</filename> noch keine Flash-Message
    anzeigen, bekommen wir diesen Fehler angezeigt. Ändern Sie bitte
    <filename>app/views/home/pong.html.erb</filename> mit folgendem
    Inhalt:<programlisting>&lt;% if flash[:notice] %&gt;
  &lt;div id="flash_notice"&gt;&lt;%= flash[:notice] %&gt;&lt;/div&gt;
&lt;% end %&gt;

&lt;h1&gt;Home#pong&lt;/h1&gt;
&lt;p&gt;Find me in app/views/home/pong.html.erb&lt;/p&gt;
</programlisting></para>

    <para>Jetzt sollte der Integration Test normal durchlaufen:<screen>MacBook:ping-pong sw$ <command>rake test:integration</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PingPongFlashMessageFlowTest:
     PASS browse to /home/ping and get redirected to /home/pong which displays a flash message (0.19s) 

Finished in 0.192106 seconds.

1 tests, 3 assertions, 0 failures, 0 errors, 0 skips
MacBook:ping-pong sw$</screen></para>

    <para>Das Beispiel zeigt deutlich, dass man vieles ohne den Einsatz eines
    Webbrowsers programmieren kann. Hat man erst einmal einen Test für den
    entsprechenden Workflow geschrieben, kann man sich in Zukunft darauf
    verlassen, dass dies auch so durchläuft und muss es nicht immer noch von
    Hand am Browser ausprobieren.</para>
  </section>

  <section xml:id="mehr_zum_thema_testing">
    <title xml:id="mehr_zum_thema_testing.title">Mehr zum Thema
    Testing</title>

    <para>Der wichtigste Link zum Thema Testing ist sicherlich die URL <uri
    xlink:href="http://guides.rubyonrails.org/testing.html">http://guides.rubyonrails.org/testing.html</uri>.
    Dort finden Sie auch einige gute Beispiele zum Thema.</para>

    <para>Bei keinem anderen Thema gibt es in der Rails-Community so viel
    Diskussion wie beim Thema Testing. Es gibt sehr viele alternative
    Test-Tools. Ein sehr populäres ist RSpec (siehe <uri
    xlink:href="http://rspec.info/">http://rspec.info/</uri>). Ich bespreche
    an dieser Stelle mit Absicht diese Alternativen nicht, da es mir in diesem
    Buch um das Verständnis von Rails geht und nicht um die abertausenden
    Extra-Tools, mit denen man sich seine persönliche
    Rails-Entwicklungsumgebung bauen kann.</para>
  </section>
</chapter>
