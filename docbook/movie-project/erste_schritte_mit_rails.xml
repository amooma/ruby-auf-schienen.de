<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="erste_schritte_mit_rails" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="erste_schritte_mit_rails.title">Erste Schritte mit
  Rails</title>

  <section>
    <title>Einleitung</title>

    <para>Nachdem Sie sich im <xref linkend="ruby-grundlagen" /> mühsam in die
    Ruby-Grundlagen eingelesen haben, können wir jetzt spannender
    weitermachen. In diesem Kapitel starten wir ein erstes Rails-Projekt und
    arbeiten uns damit Stück für Stück in die Materie ein.</para>

    <para>Auch in diesem Kapitel wird es manchmal hoppla-hopp zu gehen. Wir
    stossen auf typische Henne-Ei-Probleme wir zum Beispiel: "Wie erkläre ich
    MVC (Model-View-Controller)?". Ich habe mich für den "Wir fangen mal an
    und erklären bei der Arbeit."-Ansatz entschieden.</para>

    <para>Als erstes kleines Projekt erstellen wir eine kleine
    Filmdatenbank.</para>
  </section>

  <section xml:id="arbeits-umgebung-development">
    <title>Arbeits-Umgebung (Development)</title>

    <para>Rails kennt drei verschiedene Arbeits-Umgebungen:<itemizedlist>
        <listitem>
          <para>Development</para>
        </listitem>

        <listitem>
          <para>Testing</para>
        </listitem>

        <listitem>
          <para>Production</para>
        </listitem>
      </itemizedlist></para>

    <para>Wir arbeiten in diesem Kapitel nur mit der Development Umgebung. So
    bald Sie ein besseres Gefühl für Rails bekommen haben, starten wir mit
    Tests und benötigen dafür die entsprechende Umgebung (dort wird z.B. beim
    Start eines Tests die Test-Datenbank neu gefühlt und beim Beenden wird
    gelöscht). Später erkläre ich Ihnen dann die verschiedenen Szenarien, wie
    Sie Ihre Rails-Applikation aus der Development-Umgebung in die
    Production-Umgebung ausrollen können.</para>

    <para>Die Development-Umgebung bringt bis auf einen Editor und einen
    Webbrowser alles mit, was Sie zum Entwickeln benötigen. So müssen Sie
    nicht extra einen Webserver installieren, sondern können den eingebauten
    Rails-Webserver benutzen. Der besticht nicht durch extreme Performance,
    aber das benötigen wir bei der Entwicklung ja auch nicht. Später kann man
    dann auf grosse Systeme wie <application>Apache</application> umsteigen.
    Das gleiche gilt für die Datenbank.</para>

    <para>Um in der Development-Umgebung zu arbeiten, müssen Sie erst mal
    nichts verändern. Alle Befehle gelten per Default auf die
    Development-Umgebung.</para>

    <section xml:id="sqlite3_datenbank_default">
      <title>sqlite3 Datenbank</title>

      <para>Auch bei der Datenbank geht es in diesem Kapitel nicht um optimale
      Performance, sondern um einen einfachen Einstieg. Deshalb benutzen wir
      die sqlite3 Datenbank. Dafür haben Sie bereits alles fertig installiert
      und müssen sich keinen Kopf machen. Später erkläre ich Ihnen dann wie
      Sie andere Datenbank (z.B. MySQL) ansteuern können.</para>
    </section>
  </section>

  <section xml:id="neues_rails_projekt_starten">
    <title>Ein neues Railsprojekt starten</title>

    <para>Bevor wir hier überhaupt mit dem aller einfachsten starten,
    überprüfen Sie bitte, ob Sie eine Ruby Version 1.9.1 oder höher
    einsetzen:<screen>MacBook$ <command>ruby -v</command>
ruby 1.9.2dev (2010-04-11 trunk 27304) [x86_64-darwin10.3.0]
MacBook$</screen></para>

    <para>Und als nächstes überprüfen wir, ob auch Rails 3.0 oder höher
    installiert ist:<screen>MacBook$ <command>rails -v</command>
Rails 3.0.0.beta2
MacBook$</screen></para>

    <para>Das sieht gut aus. Falls Sie eine ältere Ruby- oder Rails-Version
    installiert haben, dann installieren Sie bitte vor dem Weiterlesen die
    aktuelle Version (siehe <xref
    linkend="installation-und-versionsauswahl" />).</para>

    <para>Jetzt erstellen wir erst mal ein neues Rails-Projekt. Da Ruby on
    Rails ein Framework ist, müssen wir erst mal die entsprechende
    Verzeichnisstruktur und die Grundkonfiguration inkl. einiger Skripte
    einrichten. Das geht aber mit dem Befehl <command>rails
    movie-app</command> ratz-fatz.<screen>MacBook:Development sw$ <command>rails movie-app</command>
      create  
      create  README
      create  .gitignore
      create  Rakefile
      create  config.ru
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/models
      create  app/views/layouts
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      create  config/initializers
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/cookie_verification_secret.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/session_store.rb
      create  config/locales
      create  config/locales/en.yml
      create  config/boot.rb
      create  config/database.yml
      create  db
      create  db/seeds.rb
      create  doc
      create  doc/README_FOR_APP
      create  lib
      create  lib/tasks
      create  lib/tasks/.gitkeep
      create  log
      create  log/server.log
      create  log/production.log
      create  log/development.log
      create  log/test.log
      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js
      create  script
      create  script/rails
      create  test
      create  test/performance/browsing_test.rb
      create  test/test_helper.rb
      create  test/fixtures
      create  test/functional
      create  test/integration
      create  test/unit
      create  tmp
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
MacBook:Development sw$ </screen></para>

    <para>Rails hat das Verzeichnis <filename>movie-app</filename> angelegt
    und in dieses Verzeichnis die Grundstruktur einer Rails-Applikation
    gespeichert.</para>

    <para>Als erstes prüfen wir mal, ob diese neue Applikation funktioniert.
    Dazu welchen wir in das neue Verzeichnis und starten mitgelieferten
    kleinen Web-Server.<footnote>
        <para>Nein, keine Angst. Das ist nicht der Webserver, mit dem wir
        später auch Produktiv gehen. Aber zum Entwickeln ist diese Variante
        sehr praktisch.</para>
      </footnote><note>
        <para>Bei verschiednen Betriebssystemen (z.B. Mac OS X) kommt beim
        ersten Starten einer Rails-Applikation, je nach Firewall Einstellung,
        ein Fenster, das Sie fragt, ob die Firewall die entsprechende
        Verbindung erlauben soll. Da wir lokal arbeiten, können Sie das mit
        ruhigen Gewissen bejahen.</para>
      </note><screen>MacBook:Development sw$ <command>cd movie-app</command> 
MacBook:movie-app sw$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-03 17:30:42] INFO  WEBrick 1.3.1
[2010-04-03 17:30:42] INFO  ruby 1.9.1 (2010-01-10) [i386-darwin10.3.0]
[2010-04-03 17:30:42] INFO  WEBrick::HTTPServer#start: pid=18770 port=3000
</screen></para>

    <para>Der Start der Rails Applikation sieht gut aus. Zum Testen rufen wir
    jetzt mit dem Webbrowser die URL <uri
    xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri> auf.<screenshot>
        <info>
          <title>Default Seite in einem frischen Rails-Projekt.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/virgin_rails_app.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn wir jetzt auf den "About your application's environment" Link
    klicken erscheint eine Aufstellung der aktuellen Umgebung.<screenshot>
        <info>
          <title>Auflistung der Start-Umgebung der Rails-Applikation.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/virgin_rails_app_env_info.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Gleichzeitig wird im Log des Webservers folgendes angezeigt:<screen>Started GET "/rails/info/properties" for 127.0.0.1 at 2010-04-03 17:38:38
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.6ms)
Completed 200 OK in 28ms (Views: 1.5ms | ActiveRecord: 0.3ms)
</screen></para>

    <para>Da beim Aufruf der ersten Startseite kein entsprechender Eintrag
    erschien, muss es sich um zwei verschiedenartige Seiten handeln. Die erste
    Seite ist tatsächlich eine statische HTML-Seite, die unter
    <filename>public/index.html</filename> abgespeichert ist und der Link, auf
    den wir geklickt haben führt ein Rails Programm aus.</para>

    <para>Mit <keycode>CTRL + C</keycode> können Sie den Webserver wieder
    stoppen.</para>

    <section xml:id="logging">
      <title xml:id="logging.title">Logging</title>

      <para>In der Datei <filename>log/development.log</filename> finden Sie
      das Log des Webservers. Bei der Entwicklung von Rails-Applikationen ist
      es oft sehr praktisch immer ein Terminal offen zu haben, das mit einem
      <command>tail -f log/development.log</command> diese Datei
      anzeigt.<screen>MacBook:movie-app sw$ <command>tail -f log/development.log</command> 

Started GET "/rails/info/properties" for 127.0.0.1 at 2010-04-03 17:38:38
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.6ms)
Completed 200 OK in 28ms (Views: 1.5ms | ActiveRecord: 0.3ms)
</screen></para>

      <section xml:id="logging-statische-oder-dynamische-seite">
        <title>Statische und dynamisch generierte Seiten</title>

        <para>Statische Seite wie die default <filename>index.html</filename>
        oder auch die 404.html Fehler-Seite liegen im Unterverzeichnis
        public<screen>MacBook:movie-app sw$ <command>ls public</command>
404.html  500.html     images      javascripts  stylesheets
422.html  favicon.ico  index.html  robots.txt
MacBook:movie-app sw$</screen></para>

        <para>Die Auslieferung einer solchen Seite oder einer Datei aus diesem
        Verzeichnis wird nicht im <filename>log/development.log</filename>
        angezeigt. Übrigens haben die Dateien im public-Verzeichnis eine
        höhere Prio, als die dynamisch gerenderten Seiten. Falls Sie also zwei
        Seiten mit dem gleichen Namen haben, dann wird Rails die statische
        Variante ausliefern. Deshalb werden Sie später die
        <filename>index.html</filename> Seite entweder umbenennen oder ganz
        löschen müssen (sonst würde Ihre Applikation immer nur mit dieser
        statischen Webseite starten).</para>
      </section>
    </section>
  </section>

  <section xml:id="die_einfachst_anzunehmende_webseite">
    <title xml:id="die_einfachst_anzunehmende_webseite.title">Die einfachst
    anzunehmende Webseite</title>

    <para>Mit Ruby on Rails werden Webseiten erstellt bzw. ausgeliefert. Also
    fangen wir als aller erstes mal mit den zwei einfachsten Varianten
    an.</para>

    <section xml:id="html_seite_im_public_verzeichnis">
      <title xml:id="html_seite_im_public_verzeichnis.title">Statische
      HTML-Seite im public-Verzeichnis</title>

      <para>Ich gehe davon aus, das Sie rudimentäre HTML-Kenntnisse haben -
      für viel mehr reicht mein HTML-Wissen auch nicht ;-). Erstellen wir also
      mal eine ganz einfache Hello-World HTML-Seite:<programlisting>&lt;html&gt;
&lt;title&gt;Hello World!&lt;/title&gt;
&lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;p&gt;Eine Beispielseite.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

      <para>Das ganze speichern wir in der Datei
      <filename>public/hello-world.html</filename> ab und starten den Rails
      Webserver:<screen>stefan@swmbp 0 head- movie-app$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-21 21:16:49] INFO  WEBrick 1.3.1
[2010-04-21 21:16:49] INFO  ruby 1.9.2 (2010-04-11) [x86_64-darwin10.3.0]
[2010-04-21 21:16:49] INFO  WEBrick::HTTPServer#start: pid=13271 port=3000
</screen></para>

      <para>Diese Webseite können wir uns mit der URI <uri
      xlink:href="http://0.0.0.0:3000/hello-world">http://0.0.0.0:3000/hello-world</uri>
      anschauen:<screenshot>
          <info>
            <title>Hello-World HTML Seite</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/hello-world-html.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Wir können natürlich auch die URI <uri
      xlink:href="http://0.0.0.0:3000/hello-world.html">http://0.0.0.0:3000/hello-world.html</uri>
      nehmen. Allerdings sieht Rails HTML und damit die Datei-Endung
      <filename>html</filename> quasi als Standard-Ausgabe-Format an und
      deshalb kann man sich das ".html" hier sparen.</para>

      <para>So, jetzt wissen Sie schon mal, wie man ganz statische Seiten in
      Rails integrieren kann. Das ist manchmal für Seiten praktisch, die sich
      nie, aber wirklich gar nie ändern. Natürlich gilt dies für jegliche Art
      von Datei. So sind Klassiker die Favicon-Datei und die robots.txt Datei.
      Beide legt man einfach in das <filename>public/</filename>
      Verzeichnis.</para>
    </section>

    <section xml:id="einfache_erb_seite">
      <title xml:id="einfache_erb_seite.title">Eine einfache
      erb-Webseite</title>

      <para>Kennen Sie PHP? Dann wird Ihnen eine erb-Datei sehr bekannt
      vorkommen. Es ist eine Mischung aus HTML und Ruby-Code. Allerdings
      können wir eine solche erb-Webseite nicht einfach in das
      <filename>public</filename> Verzeichnis legen, da dort abgelegte Seite
      1:1 ausgeliefert werden und nicht durch einen erb-Parser gehen.
      Dummerweise müssen wir dafür jetzt direkt mit dem MVC-Modell anrücken.
      Wir brauchen also einen Controler. Den können wir mit <command>rails
      generate controller</command> anlegen. Schauen wir uns mal die Hilfe
      dazu an:<screen>stefan@swmbp 0 head- movie-app$ <command>rails generate controller</command>
Usage:
  rails generate controller NAME [action action] [options]

Options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
  -t, [--test-framework=NAME]   # Test framework to be invoked
                                # Default: test_unit
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Stubs out a new controller and its views. Pass the controller name, either
    CamelCased or under_scored, and a list of views as arguments.

    To create a controller within a module, specify the controller name as a
    path like 'parent_module/controller_name'.

    This generates a controller class in app/controllers and invokes helper,
    template engine and test framework generators.

Example:
    `rails generate controller CreditCard open debit credit close`

    Credit card controller with URLs like /credit_card/debit.
        Controller:      app/controllers/credit_card_controller.rb
        Functional Test: test/functional/credit_card_controller_test.rb
        Views:           app/views/credit_card/debit.html.erb [...]
        Helper:          app/helpers/credit_card_helper.rb
stefan@swmbp 0 head- movie-app$</screen></para>

      <para>A-ha! Unten ist freundlicherweise direkt ein Beispiel angegeben
      "<code>rails generate controller CreditCard open debit credit
      close</code>". Passt aber nicht direkt für unseren Fall.</para>

      <para>Ich bin mutig und schlage vor, das wir einfach mal was
      ausprobieren:<screen>stefan@swmbp 0 head- movie-app$ <command>rails generate controller example test</command>
      create  app/controllers/example_controller.rb
       route  get "example/test"
      invoke  erb
      create    app/views/example
      create    app/views/example/test.html.erb
      invoke  test_unit
      create    test/functional/example_controller_test.rb
      invoke  helper
      create    app/helpers/example_helper.rb
      invoke    test_unit
      create      test/unit/helpers/example_helper_test.rb
stefan@swmbp 0 head- movie-app$</screen></para>

      <para>Puhhh... da wird ja direkt ne ganze Menge erstellt. Unter anderem
      eine Datei <filename>app/views/example/test.html.erb</filename>. Schauen
      wir uns die mal an:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;
</programlisting></para>

      <para>Ist also auch HTML. Sogar noch einfacher, als unsere
      hello-world.html Seite von oben (hier fehlen ja einige Tags). Zum Testen
      starten wir den Webserver<screen>stefan@swmbp 0 head- movie-app$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-21 21:54:40] INFO  WEBrick 1.3.1
[2010-04-21 21:54:40] INFO  ruby 1.9.2 (2010-04-11) [x86_64-darwin10.3.0]
[2010-04-21 21:54:40] INFO  WEBrick::HTTPServer#start: pid=14416 port=3000
</screen></para>

      <para>und schauen uns die Webseite mit der URI <uri
      xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
      mal im Browser an:<screenshot>
          <info>
            <title>test.html.erb Screenshot</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/example-test-erb.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Im Log <filename>log/development.log</filename> finden wir den
      folgenden Eintrag:<screen>Started GET "/example/test" for 127.0.0.1 at 2010-04-21 22:03:49
  Processing by ExampleController#test as HTML
Rendered example/test.html.erb (0.2ms)
Completed 200 OK in 3ms (Views: 3.0ms | ActiveRecord: 0.0ms)
</screen></para>

      <para>Das ist fast schon verständlich geschrieben. Es kam also vom
      localhost (127.0.0.1) ein HTTP GET-Request für die URI "/example/test"
      rein. Die wurde dann anscheinend vom Controller
      <code>ExampleController</code> mit der Methode
      <methodname>test</methodname> als HTML gerendert. Das ganze hat ungefähr
      3ms gedauert.</para>

      <para>Jetzt müssen wir nur noch diesen Controller finden. Aber Sie haben
      Glück ... ich weiß es nämlich. ;-) Die Controller finden sich im
      Verzeichnis <filename>app/controllers</filename> und siehe da, dort ist
      auch tatsächlich die entsprechende Datei
      <filename>app/controllers/example_controller.rb</filename>. Schauen wir
      mal rein:<programlisting>class ExampleController &lt; ApplicationController
  def test
  end

end
</programlisting></para>

      <para>Das ist jetzt sehr übersichtlich. Der Controller
      <code>ExampleController</code> stammt vom
      <code>ApplicationController</code> ab und besteht aktuell aus genau
      einer Methode mit dem Namen <methodname>test</methodname>. Und diese
      Methode macht nichts.</para>

      <para>Sie werden sich fragen, woher Rails weiß, das bei der URI
      <uri>/example/test</uri> der Controller <code>example</code> und die
      Methode <code>test</code> abzuarbeiten ist. Das wird nämlich nicht durch
      eine magische Logik, sondern durch eine einfache Routing-Konfiguration
      gesteuert. Diese finden Sie in der Datei
      <filename>config/routes.rb</filename> in der zweiten
      Zeile:<programlisting>  get "example/test"
</programlisting></para>

      <para>Diese Zeile wurde vom <command>rails generate controller</command>
      automatisch eingefügt. In der Routing-Datei können Sie auch beliebiges
      Mapping vornehmen. Aber dazu später mehr. Aktuell sehen unsere Routen
      sehr einfach aus. Mit dem Befehl <command>rake routes</command> können
      wir diese abfragen:<screen>stefan@swmbp 0 head- movie-app$ <command>rake routes</command>
(in /Users/stefan/Development/test/movie-app)
example_test GET /example/test {:controller=&gt;"example", :action=&gt;"test"}
stefan@swmbp 0 head- movie-app$</screen></para>

      <para>Wir kümmern uns später noch genauer um die Routen. Ich wollte es
      an dieser Stelle nur nicht gänzlich überspringen.</para>

      <para>MVC steht ja für Model-View-Controller (siehe auch <uri
      xlink:href="http://de.wikipedia.org/wiki/Model_View_Controller">http://de.wikipedia.org/wiki/Model_View_Controller</uri>).
      Wo ist jetzt das Model? Antwort: Wir haben kein Model in diesem Fall.
      Wir haben einen Controller mit dem Namen <code>ExampleController</code>
      und einen View mit dem Namen <code>test</code>. Das ist in diesem
      einfachsten Fall alles. Mit weniger geht es allerdings auch
      nicht.</para>

      <section xml:id="erb_mit_programmierlogik">
        <title>erb mit Programmierlogik</title>

        <para>Rein statische HTML-Seiten sind ja nicht der Grund, um sich mit
        Rails zu beschäftigen. Wie können wir also Ruby-Code in der erb-Datei
        <filename>app/views/example/test.html.erb</filename> verwenden? Ich
        zeige es mal an einem Beispiel und verändere die
        <filename>app/views/example/test.html.erb</filename> wie
        folgt:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;

&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= Time.now %&gt;
&lt;/p&gt;
</programlisting></para>

        <para>Die daraus resultierende Webseite sieht so aus:<screenshot>
            <info>
              <title>erb Seite mit Time.now Ausgabe</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/time_now_example.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log erscheint:<screen>Started GET "/example/test" for 127.0.0.1 at 2010-04-21 23:03:47
  Processing by ExampleController#test as HTML
Rendered example/test.html.erb (0.6ms)
Completed 200 OK in 5ms (Views: 4.1ms | ActiveRecord: 0.0ms)
</screen></para>

        <para>Daraus können wir jetzt folgende Informationen
        ableiten:<itemizedlist>
            <listitem>
              <para>Der Autor (ich) hat um 23:03 noch an dem Buch geschrieben.
              Selber schuld! ;-)</para>
            </listitem>

            <listitem>
              <para>Das erstellen der Webseite hat 5ms und damit etwas länger
              als bei der reinen HTML-Variante gedauert.</para>
            </listitem>

            <listitem>
              <para>Innerhalb einer erb-Datei wird Ruby-Code anscheinend mit
              <code>&lt;%=</code> und <code>%&gt;</code> eingeklammert.</para>
            </listitem>

            <listitem>
              <para>Rails hat automatisch aus <code>Time.now</code> ein
              <code>Time.now.to_s</code> gemacht. Denn <code>Time.now</code>
              gehört zur Klasse Time und kann so gar nicht angezeigt werden.
              Auf einer Webseite kann nur Text also ein String angezeigt
              werden. Wir merken uns: Immer wenn Rails mit der Klasse eines
              Ergebnisses nichts anfangen kann, dann fügt es automatisch die
              Methode <methodname>to_s</methodname> an. Deshalb sollte man bei
              selbst erstellten Klassen diese Methode immer mit
              anbieten.</para>
            </listitem>
          </itemizedlist></para>

        <para>Das mit dem Ruby-Code schauen wir uns mal genauer an. In einer
        <filename>html.erb</filename> Datei gibt zusätzlich zu den
        HTML-Elementen zwei Arten von Ruby-Code Elementen:<itemizedlist>
            <listitem>
              <para><code>&lt;% ... %&gt;</code></para>

              <para>Führt den enthaltenen Ruby-Code aus, aber gibt nichts
              aus.</para>
            </listitem>

            <listitem>
              <para><code>&lt;%= ... %&gt;</code></para>

              <para>Führt den enthaltenen Ruby-Code aus und gibt das Ergebnis
              als Text aus. Dabei werden seit Ruby 3.0 automatisch
              problematische Zeichen escaped (das musste man früher mit
              <code>h</code> manuel machen). Falls Sie einmal nicht escapeten
              Text ausgeben möchten, so müssen Sie das mit
              <code>raw(string)</code> realisieren.</para>
            </listitem>
          </itemizedlist></para>

        <para>Ich erkläre das am besten mal mit einem Beispiel. Bitte
        verändern Sie die <filename>app/views/example/test.html.erb</filename>
        Datei wie folgt:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;

&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= Time.now %&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;% (1..5).each do |i| %&gt;
&lt;li&gt;&lt;%= i %&gt;&lt;/li&gt;
&lt;% end %&gt;
&lt;/ul&gt;
</programlisting></para>

        <para>Danach schauen wir uns das Ergebnis im Browser an:<screenshot>
            <info>
              <title>Beispiel erb</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/test_erb_html_example_2.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Schauen wir uns den generierten HTML-Code an:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt; 
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt; 
 
&lt;p&gt; 
Die aktuelle Uhrzeit ist 
2010-04-22 14:08:47 +0200
&lt;/p&gt; 
 
&lt;ul&gt; 
&lt;li&gt;1&lt;/li&gt; 
&lt;li&gt;2&lt;/li&gt; 
&lt;li&gt;3&lt;/li&gt; 
&lt;li&gt;4&lt;/li&gt; 
&lt;li&gt;5&lt;/li&gt; 
&lt;/ul&gt; </programlisting></para>

        <para>Folgende Sachen fallen auf:<itemizedlist>
            <listitem>
              <para>Zwischen dem ersten und zweiten Screenshot ist einiges an
              Zeit vergangen. ;-)</para>
            </listitem>

            <listitem>
              <para>Der HTML-Code ist so nicht valide. Es fehlen noch ein paar
              "Kleinigkeiten" wie ein <code>&lt;HTML&gt;</code> oder ein
              <code>&lt;BODY&gt;</code> Tag.</para>
            </listitem>

            <listitem>
              <para>Bei der Ausgabe der Variable <varname>i</varname> fügt
              Rails wieder automatisch die <methodname>.to_s</methodname>
              Methode hinzu. Denn <varname>i</varname> gehört zur Klasse
              Integer.</para>
            </listitem>
          </itemizedlist></para>

        <para>Ich glaube das Grundprinzip von erb ist jetzt klar. Der Rest
        kommt mit der Übung. Einen Punkt möchte ich aber noch kurz anreissen:
        Das Zusammenspiel vom Controller und vom View. Die erb-Datei ist im
        View und soll damit so wenig wie möglich Eigenintelligenz besitzen. In
        der idealen Welt kann eine erb-Datei jeder HTML-Designer ohne
        Programmierkenntnisse verändern und alle Programmierer arbeiten nur im
        Controller oder im Model (wozu wir später kommen). Leider gibt es
        dabei immer eine grosse Grauzone, aber ich werde im Buch versuchen die
        Vorteile einer sauberen Abtrennung aufzuzeigen.</para>

        <para>Wir brechen jetzt einfach mal ein Beispiel vom Zaun und fügen im
        Controller eine Instance-Variable für die aktuelle Uhrzeit ein und
        fügen diese dann im View ein. Wir nehmen also Programmierintelligenz
        aus dem View in den Controller.</para>

        <para>Die Controller Datei
        <filename>app/controllers/example_controller.rb</filename> sieht dann
        so aus:<programlisting>class ExampleController &lt; ApplicationController
  def test
    <emphasis>@current_time</emphasis> = Time.now
  end

end
</programlisting></para>

        <para>In der View Datei
        <filename>app/views/example/test.html.erb</filename> können wir dann
        auf diese Instance-Variable zurückgreifen:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;

&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= <emphasis>@current_time</emphasis> %&gt;
&lt;/p&gt;

&lt;ul&gt;
&lt;% (1..5).each do |i| %&gt;
&lt;li&gt;&lt;%= i %&gt;&lt;/li&gt;
&lt;% end %&gt;
&lt;/ul&gt;
</programlisting></para>

        <para>Die angezeigte HTML-Seite verändert sich nicht. OK, die Uhrzeit
        ist natürlich immer die aktuelle. Aber wir haben eine Trennung von
        Programmierlogik und Darstellungslogik mit dem Controller und dem
        View.</para>

        <para>Mir ist klar, das jetzt keiner aufspringen und schreien wird
        "Danke für die Erleuchtung! Ich werde nur noch sauber nach MVC
        programmieren". Das obige Beispiel ist der erste kleine Schritt in die
        Richtung und zeigt wie wir einfach mit Instance Variablen (das sind
        die mit dem @-Zeichen davor) Werte aus dem Controller in den View
        bringenen können.</para>
      </section>
    </section>

    <section xml:id="partials">
      <title xml:id="partials.title">Partials</title>

      <para>Mit Partials lassen sich innerhalb von erb-Seiten andere Views die
      mit einem Unterstrich (Underscore = _) anfangen einbetten. Nehmen wir
      einmal an, das wir aus logischen (hier rein hypotetisch) Gründen den
      folgenden Teil aus unserer
      <filename>app/views/movies/test.html.erb</filename> auslagern
      wollen:<programlisting>&lt;ul&gt;
&lt;% (1..5).each do |i| %&gt;
&lt;li&gt;&lt;%= i %&gt;&lt;/li&gt;
&lt;% end %&gt;
&lt;/ul&gt;
</programlisting></para>

      <para>Dann können wir eine Datei
      <filename>app/views/movies/_simple_example.html.erb</filename> mit genau
      diesem Inhalt erstellen und die
      <filename>app/views/example/test.html.erb</filename> wie folgt
      verändern:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;

&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= @current_time %&gt;
&lt;/p&gt;

<emphasis>&lt;%= render :partial =&gt; "simple_example" %&gt;</emphasis></programlisting></para>

      <para>Die gerenderte Webseite <uri
      xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
      sieht genauso aus wie vorher, aber wir haben die Teile logisch von
      einander getrennt. Partials bieten damit die Möglichkeit gleiche Inhalte
      in verschiedenen Views zu benutzen und nur einmal zu erstellen. Da DRY
      (Don't Repeat Yourself) in der Rails Community sehr ausgeprägt gelebt
      wird, ist dies eine gute Methode, um DRY innerhalb von Views zu
      realisieren. <important>
          <para>Der Name eines Partials wird immer ohne den Unterstrich am
          Anfang und ohne die erb und HTML Endung angegeben. Aber die
          wirkliche Datei muss im Dateinamen mit einem Unterstrich anfangen
          und auch am Ende mir der erb und HTML Endung aufhören.</para>
        </important></para>

      <para>Partials können auch aus anderen Bereichen des Unterverzeichnisses
      <filename>app/views</filename> eingebunden werden. So können Sie für
      wiederkehrende und übergreifende Inhalte beispielsweise ein Verzeichnis
      <filename>app/views/shared</filename> anlegen und dort eine Datei
      <filename>_one_more_example.html.erb</filename> anlegen. Das Einbetten
      im erb Code würde dann mit folgender Zeile erfolgen:<programlisting>&lt;%= render :partial =&gt; "shared/one_more_example" %&gt;</programlisting></para>

      <section xml:id="partials_locale_variables">
        <title xml:id="partials_locale_variables.title">Lokale Variablen an
        ein Partial übergeben</title>

        <para>Partials sind im DRY Gedanken sehr gut. Aber was sie erst
        richtig praktisch macht, ist die Möglichkeit lokale Variablen zu
        übergeben. Diese können dann im Partial selbst benutzt werden.
        Beispielhaft zerpflücke ich unsere arme Beispielseite noch mehr und
        erstelle eine
        <filename>app/views/movies/_current_time.html.erb</filename> mit
        folgendem Inhalt:<programlisting>&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= current_time %&gt;
&lt;/p&gt;</programlisting></para>

        <para>Danach binde ich das Partial in der
        <filename>app/views/example/test.html.erb</filename> wie folgt
        ein:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;

<emphasis>&lt;%= render :partial =&gt; "current_time", :locals =&gt; { :current_time =&gt; @current_time } %&gt;</emphasis>

&lt;%= render :partial =&gt; "simple_example" %&gt;</programlisting></para>

        <para>Wichtig dabei ist der Unterschied zwischen der Instance-Variable
        <varname>@current_time</varname> und der lokalen Variable
        <varname>current_time</varname>. Da hat man sich schnell mal
        verhaspelt.</para>
      </section>

      <section xml:id="weitere_doku_zu_partials">
        <title xml:id="weitere_doku_zu_partials.title">Weitere Dokumentation
        zum Thema Partials</title>

        <para>Unter <uri
        xlink:href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials</uri>
        finden Sie die Ruby on Rails Doku zum Thema Partials.</para>
      </section>
    </section>
  </section>

  <section xml:id="basics_generisches_html_framework">
    <title xml:id="basics_generisches_html_framework.title">Generisches
    HTML-Framework (Layout)</title>

    <para>Bei allen bisherigen mit erb gerenderten HTML-Seiten fehlten
    wichtige HTML-Elemente, die die Seite syntakisch erst korrekt machen.
    Heute Webbrowser stellen die Seiten trotzdem dar, aber auch nur deshalb
    weil sie so fehlertollerant programmiert wurden. Bis jetzt wurde von erb
    immer nur der Inhalts-Kern der Seite gerendert und an den Browser
    ausgeliefert. Hier der Code der <uri
    xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
    Seite:<programlisting>&lt;h1&gt;Example#test&lt;/h1&gt; 
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt; 
 
&lt;p&gt; 
Die aktuelle Uhrzeit ist 
 
&lt;/p&gt; 
 
&lt;ul&gt; 
&lt;li&gt;1&lt;/li&gt; 
&lt;li&gt;2&lt;/li&gt; 
&lt;li&gt;3&lt;/li&gt; 
&lt;li&gt;4&lt;/li&gt; 
&lt;li&gt;5&lt;/li&gt; 
&lt;/ul&gt;</programlisting></para>

    <para>Für das Gerüst drum rum müssen wir die Datei
    <filename>app/views/layouts/application.html.erb</filename> mit einem
    Editor erstellen und beispielhaft wie folgt befüllen:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Unsere Filmdatenbank&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

    <para>Wenn wir danach die <uri
    xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
    Seite noch einmal aufrufen, bekommen wir folgenden HTML-Code
    ausgeliefert:<programlisting>&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;head&gt; 
  &lt;title&gt;Unsere Filmdatenbank&lt;/title&gt; 
&lt;/head&gt; 
&lt;body&gt; 
 
&lt;h1&gt;Example#test&lt;/h1&gt; 
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt; 
 
&lt;p&gt; 
Die aktuelle Uhrzeit ist 
 
&lt;/p&gt; 
 
&lt;ul&gt; 
&lt;li&gt;1&lt;/li&gt; 
&lt;li&gt;2&lt;/li&gt; 
&lt;li&gt;3&lt;/li&gt; 
&lt;li&gt;4&lt;/li&gt; 
&lt;li&gt;5&lt;/li&gt; 
&lt;/ul&gt; 
 
&lt;/body&gt; 
&lt;/html&gt; </programlisting></para>

    <para>Das sieht doch schon direkt viel besser aus. Mit dem Befehl
    <code>yield</code> bzw. mit der erb-Zeite <code>&lt;%= yield %&gt;</code>
    wird der Kern der Seite in das Aussengerüst eingebettet. Ich überlasse es
    Ihrer Fantasie und Ihren HTML-Künsten mit der Möglichkeit zu zaubern.
    Natürlich müssen Sie diese Konstrukt nicht benutzen und können jede Seite
    im View direkt vollständig programmieren.</para>
  </section>

  <section xml:id="redirects">
    <title xml:id="redirects.title">Redirects</title>

    <para>Redirects sind Befehle, mit denen Sie innerhalb des Controllers auf
    andere Methoden oder auch auf ganz andere Webseiten "springen" also
    redirecten können. Um diese Funktion zeigen zu können, benötigen wir eine
    zweite Webseite. Das machen wir diesmal nicht mit einem Generator-Skript,
    sondern von Hand.</para>

    <para>Bitte erweitern Sie die Datei
    <filename>app/controllers/example_controller.rb</filename> wie
    folgt:<programlisting>class ExampleController &lt; ApplicationController
  def test
  end
  
  def shopping_list
  end

end</programlisting></para>

    <para>Die <filename>app/views/example/shopping_list.html.erb</filename>
    Seite erstellen Sie bitte neu mit folgendem Inhalt:<programlisting>&lt;h1&gt;Einkaufsliste&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;12 Eier&lt;/li&gt;
&lt;li&gt;250 gr Butter&lt;/li&gt;
&lt;li&gt;500 gr Mehl&lt;/li&gt;
&lt;/ul&gt;</programlisting></para>

    <para>Zum Schluss müssen wir in der Datei
    <filename>config/routes.rb</filename> noch die Route für diese Seite
    einfügen:<programlisting>MovieApp::Application.routes.draw do |map|
  get "example/test"
  get "example/shopping_list"
end
</programlisting></para>

    <para>Dies daraus resultierende Seite lässt sich unter der URI
    <uri>http://0.0.0.0:3000/example/shopping_list</uri> abrufen:<screenshot>
        <info>
          <title>shopping_list Seite</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/example_shopping_list.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Im Log finden wir folgenden Eintrag:<screen>Started GET "/example/shopping_list" for 127.0.0.1 at 2010-04-23 15:25:17
  Processing by ExampleController#shopping_list as HTML
Rendered example/shopping_list.html.erb within layouts/application (0.4ms)
Completed 200 OK in 4ms (Views: 3.4ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Ohne das mir jetzt dazu ein wirklich brauchbares Beispiel einfällt,
    zeige ich Ihnen jetzt wie ein Redirect funktioniert. Ändern Sie dazu bitte
    die Datei <filename>app/controllers/example_controller.rb</filename> wie
    folgt:<programlisting>class ExampleController &lt; ApplicationController
  def test
    <emphasis>redirect_to :action =&gt; "shopping_list"</emphasis>
  end
  
  def shopping_list
  end

end</programlisting>Wenn Sie jetzt im Browser die URI <uri
    xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
    aufrufen, so bekommen Sie die shopping_list Seite angezeigt. Im Log finden
    Sie den folgenden Eintrag:<screen>Started GET "/example/test" for 127.0.0.1 at 2010-04-23 23:16:13
  Processing by ExampleController#test as HTML
Redirected to http://0.0.0.0:3000/example/shopping_list
Completed 302 Found in 1ms
</screen></para>

    <para>Wie Sie sehen, wurde zwar im ersten Schritt mit "<code>Processing by
    ExampleController#test as HTML</code>" die Methode
    <methodname>test</methodname> im Controller <code>ExampleController</code>
    aufgerufen, aber danach fand ein Redirect zur Methode
    <methodname>shopping_list</methodname> statt.</para>

    <para>Auf die Details und einzelnen Möglichkeiten des Redirects gehen wir
    später im jeweils konkreten Fall ein. Nur schon so viel vorweg: Man kann
    nicht nur auf eine andere Methode, sondern auch auf einen anderen
    Controller oder eine ganze andere Seite redirecten.</para>

    <section>
      <title>Warum Redirects?</title>

      <para>Beim obigen Beispiel fragt man sich natürlich, warum man denn im
      Controller einen Redirect einbaut und nicht direkt die Routen ändert.
      Das ist der Nachteil von der "wir benutzen nur bisheriges
      Wissen"-Methode. Schon im <xref linkend="scaffolding" /> werden Sie
      verstehen warum Redirects so praktisch sind. Sie können z.B. in einem
      Controller überprüfen, ob bestimmte Eingabedaten valide sind oder nicht
      und wenn etwas fehlt zur ursprünglichen Eingabeseite redirecten. Das
      wäre mit einer statischen Route nicht lösbar. </para>

      <para>Allerdings muss man beim Programmieren auch darauf achten, nicht
      beliebig viele Redirects einzubauen. Wenn man tatsächlich mal in der
      Versuchung kommen zwei oder mehr Redirects hinter einander zu schachteln
      (also in verschiedene Methoden), dann sollte man einen Schritt zurück
      gehen und sich Gedanken über die Gesamtidee machen. Meist geht es dann
      anders einfacher und sauberer.</para>
    </section>
  </section>

  <section xml:id="flash">
    <title xml:id="flash.title">Flash Nachrichten</title>

    <para>"Der Name "Flash Message" oder "Flash Nachricht" ist meiner Meinung
    nach denkbar ungeeignet gewählt worden. Mit dem Wort "Flash" assoziiert
    fast jeder mehr oder weniger bunte Webseiten, die mit dem
    Adobe-Flash-Plug-in realisiert wurden. Aber in Rails sind Flash
    Nachrichten etwas ganz anderes. Sie sind Nachrichten, die über ein
    Redirect auf eine andere Seite weiter geleitet werden können.</para>

    <para>Flash Nachrichten sind quasi gute Freunde von Redirects. Nicht
    selten arbeiten beide ihm Team, um dem User ein Feedback über eine gerade
    vollzogene Aktion zu geben. Als Beispiel erweitern wir die in <xref
    linkend="redirects" /> erstellten
    <filename>app/controllers/example_controller.rb</filename> wie
    folgt:<programlisting>class ExampleController &lt; ApplicationController
  def test
    <emphasis>flash[:notice] = "Ein sinnfreies Beispiel."</emphasis>
    redirect_to :action =&gt; "shopping_list"
  end
  
  def shopping_list
  end

end
</programlisting></para>

    <para>Mit "<code>flash[:notice] = "Ein sinnfreies Beispiel."</code>"
    übergeben wir eine Flash Message mit dem Status "<code>notice</code>" an
    den nächsten View (in diesem Fall an
    <methodname>shopping_list</methodname>).</para>

    <para>Merkwürdigerweise verändert sich aber nichts beim erneuten Aufruf
    von <uri
    xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>.
    Der Grund dafür ist einfach: Wir haben zwar eine Flash Message generiert,
    aber im View wird nirgends überprüft, ob es Flash Messages gibt. Der
    einfachste Weg evt. existierende Flash Nachrichten immer anzuzeigen ist
    die folgende Erweiterung der
    <filename>app/views/layouts/application.html.erb</filename>
    Datei:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Unsere Filmdatenbank&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;

<emphasis>&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class="alert"&gt;&lt;%= alert %&gt;&lt;/p&gt;</emphasis>

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

    <para>Wenn wir jetzt noch einmal die Seite <uri
    xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
    aufrufen, werden wir richtig an <methodname>shopping_list</methodname>
    redirected und bekommen am Kopf der Seite die Flash Nachricht
    angezeigt:<screenshot>
        <info>
          <title>Beispiel für eine Flash Nachricht</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/flash_example_shopping_list.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <section xml:id="verschiedene_arten_von_flash_nachrichten">
      <title
      xml:id="verschiedene_arten_von_flash_nachrichten.title">Verschiedene
      Arten von Flash Nachrichten</title>

      <para>Per default werden die Arten "error", "notice" und "warning"
      unterschieden. Allerdings kann man auch selber eine Kategorie erfinden
      und diese später im View abfragen. Beim Arbeiten mit <xref
      linkend="scaffolding" /> werden Sie Beispiele für die verschiedenen
      Arten finden.</para>
    </section>

    <section xml:id="neue_flash_redirect_schreibweise">
      <title xml:id="neue_flash_redirect_schreibweise.title">Kürzere
      Schreibweise innerhalb eines Redirects</title>

      <para>Bis Rails 2.3.5 konnte man Flash Nachrichten nicht innerhalb eines
      Redirect einbauen. Mit Rails 3.0 ist dies möglich. So können Sie unser
      Beispiel von vorhin auch wie folgt schreiben: <programlisting>class ExampleController &lt; ApplicationController
  def test
    redirect_to :action =&gt; "shopping_list"<emphasis>, :flash =&gt; { :notice =&gt; "Ein sinnfreies Beispiel." }</emphasis>
  end
  
  def shopping_list
  end

end
</programlisting></para>
    </section>
  </section>

  <section xml:id="scaffolding">
    <title xml:id="scaffolding.title">Scaffolding</title>

    <para>Die typischen "Ich zeige Euch mal Ruby on Rails in 15 Minuten"
    Videos im Internet arbeiten alle mit der Magie des Scaffolding.
    Scaffolding steht dabei für ein auf den ersten Blick sehr mächtiges
    Grundgerüst mit einer fertigen GUI zum Arbeiten mit einer
    Datenbanktabelle. Leider ist dieses Vorgehen meistens kontraproduktiv,
    weil man zwar sehr schnell dieses Grundgerüst stehen hat, aber danach erst
    mal im Regen steht. Das alte "ohne Ruby-Grundkenntnisse kommt man nicht
    weiter"-Problem schlägt zu. Aber Sie haben sich ja schon das <xref
    linkend="ruby-grundlagen" /> gekämpft. Falls nicht, sollten Sie es jetzt
    nachholen.</para>

    <section xml:id="activerecord">
      <title xml:id="activerecord.title">ActiveRecord</title>

      <para>Ein ganz wichtiges Element für Rails ist ActiveRecord. Es
      übernimmt für den Programmierer transparent die Arbeit mit der
      SQL-Datenbank und stellt Tabellen und einzelne Tabellen-Zeilen als
      Objekte zur Verfügung. Um das zu ermöglichen hat man sich auf bestimmte
      Namenskonventionen geeinigt. In früheren Rails-Versionen musste man die
      Datenbank von Hand anhand dieser Konventionen anlegen. ActiveRecord hat
      dann die Felder an bestimmten Namensmerkmalen erkannt. Heute gibt es in
      Rails dazu eigene, noch dazu äusserst praktische Tools. Denn Sie wollen
      ja nicht nur jetzt eine Datenbank für Ihre Entwicklungs-Umgebung
      einrichten, sondern benötigen später auch ein Tool, das Ihre
      Produktions-Datenbank Schritt für Schritt mitzieht.</para>

      <para>Wir wollen Filme katalogisieren. Dazu benötigen wir mindestens
      folgende Datenbankfelder:<itemizedlist>
          <listitem>
            <para><varname>title:string</varname> - Titel oder Name des
            Films</para>
          </listitem>

          <listitem>
            <para><varname>production_year:integer</varname> -
            Produktionsjahr</para>
          </listitem>

          <listitem>
            <para><varname>duration:integer</varname> - Dauer (in
            Minuten)</para>
          </listitem>

          <listitem>
            <para><varname>plot:text</varname> - Story des Films</para>
          </listitem>

          <listitem>
            <para><varname>rating:integer</varname> - Bewertung (als Ganzahl
            von 1 bis 5 Sterne)</para>
          </listitem>
        </itemizedlist></para>

      <section>
        <title>Warum alle Feldnamen, Methoden und Klassen auf
        Englisch?</title>

        <para>Ganz tief im Herzen liebt Rails die englische Sprache. Damit
        muss man sich abfinden und versuchen diese Liebe zu übernehmen. So
        verwenden sehr viele Mechanismen automagisch Plural oder Singular von
        Englischen Wörtern. Wenn man sich damit anfreundet Datenbankfelder und
        Datenbanken an sich mit englischen Wörter zu benennen, dann kann man
        die ganze Macht dieser Magie ausnutzen.</para>
      </section>

      <section xml:id="dvd-ist-das-ein-model">
        <title>Ist das jetzt ein Model (laut der MVC-Idee)?</title>

        <para>Kurze Antwort: Ja. Wir müssen dem Model nur noch einen Namen
        geben. "<varname>movie</varname>" macht wohl im Englischen am meisten
        Sinn.</para>
      </section>
    </section>

    <section xml:id="rails_generate_scaffold">
      <title xml:id="rails_generade_scaffold.title">rails generate
      scaffold</title>

      <para>Mit dem Rails-Skript-Aufruf <command>rails generate
      scaffold</command> kann man fertige Code generieren. Wer (wie ich) gerne
      mal vergisst wie das Skript aufgerufen werden muss, der gibt einfach
      <filename>rails generate</filename> ein und bekommt die folgende Hilfe
      angezeigt:<screen>MacBook:movie-app sw$ <command>rails generate</command>
Usage: rails generate GENERATOR [args] [options]

General options:
  -h, [--help]     # Print generators options and usage
  -p, [--pretend]  # Run but do not make any changes
  -f, [--force]    # Overwrite files that already exist
  -s, [--skip]     # Skip files that already exist
  -q, [--quiet]    # Supress status output

Please choose a generator below.

Rails:
  controller
  generator
  helper
  integration_test
  mailer
  metal
  migration
  model
  observer
  performance_test
  plugin
  resource
  scaffold
  scaffold_controller
  session_migration
  stylesheets

MacBook:movie-app sw$</screen></para>

      <para>Interessant ist für uns der Teil "Please choose a generator
      below.". Wenn wir <parameter>scaffold</parameter> benutzen wollen und
      dazu weitere Hilfe brauchen, dann geht dies wiederrum einfach mit der
      eingebauten Hilfe:<screen>MacBook:movie-app sw$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME                  # Orm to be invoked
                                  # Default: active_record
      [--force-plural]            # Forces the use of a plural ModelName
      [--singleton]               # Supply to create a singleton controller
  -c, --scaffold-controller=NAME  # Scaffold controller to be invoked
                                  # Default: scaffold_controller
  -y, [--stylesheets]             # Indicates when to generate stylesheets
                                  # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Erb options:
  [--layout]  # Indicates when to generate layout
              # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attribute pairs are field:type arguments specifying the
    model's attributes. Timestamps are added by default, so you don't have to
    specify them by hand as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title:string body:text published:boolean'
    gives you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a resources :posts
    declaration in config/routes.rb.

    If you want to remove all the generated files, run
    'rails destroy scaffold ModelName'.

Examples:
    `rails generate scaffold post`
    `rails generate scaffold post title:string body:text published:boolean`
    `rails generate scaffold purchase order_id:integer amount:decimal`
MacBook:movie-app sw$</screen></para>

      <para>Wir müssen also nach <command>rails generate scaffold</command>
      den Namen des Models (bei uns "movie") und danach die Datenbankfelder
      mit den entsprechenden Feldtypen angeben.</para>

      <para>Dann legen wir mal los:<screen>MacBook:movie-app sw$ <command>rails generate scaffold movie title:string production_year:integer duration:integer plot:text rating:integer</command>
      invoke  active_record
      create    db/migrate/20100404113234_create_movies.rb
      create    app/models/movie.rb
      invoke    test_unit
      create      test/unit/movie_test.rb
      create      test/fixtures/movies.yml
       route  resources :movies
      invoke  scaffold_controller
      create    app/controllers/movies_controller.rb
      invoke    erb
      create      app/views/movies
      create      app/views/movies/index.html.erb
      create      app/views/movies/edit.html.erb
      create      app/views/movies/show.html.erb
      create      app/views/movies/new.html.erb
      create      app/views/movies/_form.html.erb
      create      app/views/layouts/movies.html.erb
      invoke    test_unit
      create      test/functional/movies_controller_test.rb
      invoke    helper
      create      app/helpers/movies_helper.rb
      invoke      test_unit
      create        test/unit/helpers/movies_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
MacBook:movie-app sw$</screen>Und schon ist alles fertig. Allerdings ist in
      der Datenbank noch keine entsprechende Tabelle angelegt.</para>
    </section>

    <section xml:id="migration">
      <title xml:id="migration.title">Migrationen</title>

      <para><application>In der zweiten Ausgabezeile des Scaffoldings sehen
      wir die Ausgabe:</application><screen>      create    db/migrate/20100404113234_create_movies.rb
</screen></para>

      <para>In der Datei
      <filename>db/migrate/20100404113234_create_movies.rb</filename> finden
      sich die Anweisung, mit der die Datenbank erstellt (<code>def
      self.up</code>) und auch beim Roll-Back (<code>def self.down</code>)
      wieder gelöscht werden kann.<programlisting>class CreateMovies &lt; ActiveRecord::Migration
  def self.up
    create_table :movies do |t|
      t.string :title
      t.integer :production_year
      t.integer :duration
      t.text :plot
      t.integer :rating

      t.timestamps
    end
  end

  def self.down
    drop_table :movies
  end
end
</programlisting></para>

      <para>Die in dieser Ruby-Datei angelegte Klasse
      <classname>CreateMovies</classname> ist ein Kind der Klasse
      <classname>ActiveRecord::Migration</classname> (siehe Zeile 1) und hat
      zwei Methoden:<itemizedlist>
          <listitem>
            <para><methodname>self.up</methodname> (Zeile 2). Wird aufgerufen,
            wenn die Migration durchgeführt wird.</para>
          </listitem>

          <listitem>
            <para><methodname>self.down</methodname> (Zeile 14). Wird
            aufgerufen, wenn für eine Migration ein Rollback durchgeführt
            wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Die Migration (also das Anlegen der Datenbank) wird mit
      <command>rake db:migrate</command> durchgeführt:<screen>MacBook:movie-app sw$ <command>rake db:migrate</command>
(in /Users/sw/Development/movie-app)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0015s
==  CreateMovies: migrated (0.0017s) ==========================================

MacBook:movie-app sw$</screen></para>

      <para>Die Datenbank-Tabelle <varname>movies</varname> wird angelegt.
      Dabei sehen wir, das Tabellen-Namen automatisch den Plural der Models
      bekommen. Aber welche Datenbank wird überhaupt benutzt? Das wird in der
      Konfigurationsdatei <filename>config/database.yml</filename>
      definiert:<screen>MacBook:movie-app sw$ <command>cat -n config/database.yml</command> 
     1 # SQLite version 3.x
     2 #   gem install sqlite3-ruby (not necessary on OS X Leopard)
     3 development:
     4   adapter: sqlite3
     5   database: db/development.sqlite3
     6   pool: 5
     7   timeout: 5000
     8 
     9 # Warning: The database defined as "test" will be erased and
    10 # re-generated from your development database when you run "rake".
    11 # Do not set this db to the same as development or production.
    12 test:
    13   adapter: sqlite3
    14   database: db/test.sqlite3
    15   pool: 5
    16   timeout: 5000
    17 
    18 production:
    19   adapter: sqlite3
    20   database: db/production.sqlite3
    21   pool: 5
    22   timeout: 5000
MacBook:movie-app sw$</screen></para>

      <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe
      <uri xlink:href="http://www.yaml.org/">http://www.yaml.org/</uri> bzw.
      <uri
      xlink:href="http://de.wikipedia.org/wiki/YAML">http://de.wikipedia.org/wiki/YAML</uri>)
      definiert. Für uns wichtig ist erst mal nur die development-Datenbank
      (Zeile 3 bis 7). Per default benutzt Rails dort
      <application>Sqlite3</application>. Sqlite3 mag nicht die richtige Wahl
      für die Analyse der weltweit gesammelten Wetterdaten sein, aber für die
      schnelle und unkompliziete Entwicklung von Rails-Anwendungen lernt man
      sie schnell zu schätzen. In der Produktions-Umgebung kann man später
      immer noch auf "grosse" Datenbanken wie MySQL umsteigen.<footnote>
          <para>Es gibt unter einigen Entwicklern die Ansicht, das man auf
          jeden Fall immer mit der gleichen Datenbank entwicklen soll, die man
          später auch in der Produktion und im Testing benutzt. Das sollte
          aber jeder für sich selbst entscheiden.</para>
        </footnote></para>

      <para>Um Ihre Neugierde zu befriedigen, schauen wir uns kurz noch die
      Datenbank mit dem Command-Line-Tool <application>sqlite3</application>
      an.<screen>MacBook:movie-app sw$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
movies             schema_migrations
sqlite&gt; <command>.schema movies</command>
CREATE TABLE "movies" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; <command>.quit</command>
MacBook:movie-app sw$</screen></para>

      <para>Das Anlegen der Tabelle mit <command>rake db:migrate</command>
      wurde natürlich auch im <filename>log/development.log</filename>
      eingetragen:<screen>  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
Migrating to CreateMovies (20100404113234)
  SQL (0.1ms)  select sqlite_version(*)
  SQL (0.4ms)  CREATE TABLE "movies" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20100404113234')
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.0ms)  PRAGMA index_list("movies")
</screen></para>

      <section xml:id="active-record-auto-felder">
        <title>Automatisch zugefügte Felder (id, created_at und
        updated_at)</title>

        <para>Rails ist so freundlich uns beim Scaffolding per Default
        folgende Felder hinzuzufügen:<itemizedlist>
            <listitem>
              <para><varname>id:integer</varname></para>

              <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von
              der Datenbank automatisch hochgezählt. Für alle SQL-Fans:
              AUTOINCREMENT NOT NULL</para>
            </listitem>

            <listitem>
              <para><varname>created_at:datetime</varname></para>

              <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
              eines Datensatzes gefüllt.</para>
            </listitem>

            <listitem>
              <para><varname>updated_at:datetime</varname></para>

              <para>Das Feld wird bei jeder Veränderung des Datensatzes
              automatisch an die aktuelle Zeit angepasst.</para>
            </listitem>
          </itemizedlist></para>

        <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
        Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten
        Felder schätzen.</para>
      </section>

      <section xml:id="migration-rollback">
        <title>Migration Rollback</title>

        <para>Es soll schon vorgekommen sein, das übereilt eine Migration
        durchgeführt wurde. Natürlich passiert weder Ihnen noch mir so was.
        ;-) Aber falls mal ein Freund von Ihnen in diese Predulie gerät: Keine
        Panik! Dafür wurde in der Migrations-Class die Methode
        <methodname>self.down</methodname> angelegt. Testweise können wir ja
        mal unsere letzte Migration zurückrollen:<screen>MacBook:movie-app sw$ <command>rake db:rollback</command>
(in /Users/sw/Development/movie-app)
==  CreateMovies: reverting ===================================================
-- drop_table(:movies)
   -&gt; 0.1004s
==  CreateMovies: reverted (0.1005s) ==========================================

MacBook:movie-app sw$</screen></para>

        <para>Sie können alles auf einmal zurück-rollen oder auch nur einzelne
        Migrationen. Mit dem Schalter <parameter>-T</parameter> bekommen Sie
        eine Hilfe zu allen möglichen Wegen aufgezeigt:<screen>MacBook:movie-app sw$ <command>rake -T db</command>
(in /Users/sw/Development/movie-app)
rake db:abort_if_pending_migrations  # Raises an error if there are pending...
rake db:charset                      # Retrieves the charset for the curren...
rake db:collation                    # Retrieves the collation for the curr...
rake db:create                       # Create the database defined in confi...
rake db:create:all                   # Create all the local databases defin...
rake db:drop                         # Drops the database for the current R...
rake db:drop:all                     # Drops all the local databases define...
rake db:fixtures:identify            # Search for a fixture given a LABEL o...
rake db:fixtures:load                # Load fixtures into the current envir...
rake db:forward                      # Pushes the schema to the next version.
rake db:migrate                      # Migrate the database through scripts...
rake db:migrate:down                 # Runs the "down" for a given migratio...
rake db:migrate:redo                 # Rollbacks the database one migration...
rake db:migrate:reset                # Resets your database using your migr...
rake db:migrate:up                   # Runs the "up" for a given migration ...
rake db:reset                        # Drops and recreates the database fro...
rake db:rollback                     # Rolls the schema back to the previou...
rake db:schema:dump                  # Create a db/schema.rb file that can ...
rake db:schema:load                  # Load a schema.rb file into the database
rake db:seed                         # Load the seed data from db/seeds.rb
rake db:sessions:clear               # Clear the sessions table
rake db:sessions:create              # Creates a sessions migration for use...
rake db:setup                        # Create the database, load the schema...
rake db:structure:dump               # Dump the database structure to a SQL...
rake db:test:clone                   # Recreate the test database from the ...
rake db:test:clone_structure         # Recreate the test databases from the...
rake db:test:load                    # Recreate the test database from the ...
rake db:test:prepare                 # Check for pending migrations and loa...
rake db:test:purge                   # Empty the test database
rake db:version                      # Retrieves the current schema version...
MacBook:movie-app sw$</screen></para>

        <para>Und mit <command>rake -T db:rollback</command> die Hilfe zu
        diesem bestimmten Befehl:<screen>MacBook:movie-app sw$ <command>rake -T db:rollback</command>
(in /Users/sw/Development/movie-app)
rake db:rollback  # Rolls the schema back to the previous version.
MacBook:movie-app sw$</screen></para>

        <para>Aber spielen wir lieber unsere Migration wieder ein:<screen>MacBook:movie-app sw$ <command>rake db:migrate</command>  
(in /Users/sw/Development/movie-app)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0014s
==  CreateMovies: migrated (0.0015s) ==========================================

MacBook:movie-app sw$</screen></para>
      </section>
    </section>

    <section xml:id="restful_datenbankzugriff_per_webbrowser">
      <title xml:id="restful_datenbankzugriff_per_webbrowser.title">RESTful
      Datenbankzugriff per Webbrowser</title>

      <para>Die Datenbank ist angelegt. Und der Vorteil von Scaffolding
      besteht darin, das wir jetzt auch direkt per Webbrowser in einer
      aktzeptablen Web-GUI darauf zugreifen können.</para>

      <para>Gemäss der CRUD Idee (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/CRUD">http://de.wikipedia.org/wiki/CRUD</uri>)
      bietet Rails dafür ein RESTful Webinterface an. Was heisst das? Sie
      können auf jede Resource innerhalb einer normalen Rails-Umgeben über
      definierte URLs zugreifen und damit folgende Datenbank-Operationen
      ausführen:<itemizedlist>
          <listitem>
            <para>C für CREATE</para>

            <para>SQL: <code>INSERT INTO movies (title) VALUES ('Rain
            Man')</code></para>
          </listitem>

          <listitem>
            <para>R für READ</para>

            <para>SQL: <code>SELECT * FROM movies</code></para>
          </listitem>

          <listitem>
            <para>U für UPDATE</para>

            <para>SQL: <code>UPDATE movies SET title = 'Rain Man' WHERE id =
            1</code></para>
          </listitem>

          <listitem>
            <para>D für DELETE</para>

            <para>SQL: <code>DELETE FROM movies WHERE id = 1</code></para>
          </listitem>
        </itemizedlist>Für den Rails-Neuling ist nicht direkt ersichtlich, wo
      den hier der grosse Vorteil liegt. Nachfolgend eine Mini-FAQ:<qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Warum wird um das RESTful Interface in Ruby on Rails so
                ein Bohei gemacht?</para>
              </question>

              <answer>
                <para>Damit bekommt man ein sauberes und für alle
                Programmierer leicht verständliches Interface zu Ihrem System.
                Sie brauchen nur die URI
                <uri>http://localhost:3000/movies</uri> und das Wissen, das es
                sich um ein RESTful Webdienst handelt und Sie können direkt
                loslegen.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful nur für die automatische Abfrage zwischen
                Computern gut?</para>
              </question>

              <answer>
                <para>Nein. RESTful ist auch ein guter Denkansatz, um URLs und
                damit ganze Webseiten strukturierter zu gestalten.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful Teil der <emphasis>Convention over
                Configuration</emphasis> Idee?</para>
              </question>

              <answer>
                <para>Ja! Jeder Rails-Entwickler kann sich so in kurzer Zeit
                in ein ihm neues Rails-Projekt einarbeiten.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>

      <section>
        <title>Start des Webservers</title>

        <para>Als erstes starten wir wie immer mit rails server unseren
        Entwicklungswebserver:<screen>MacBook:movie-app sw$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-04 14:56:29] INFO  WEBrick 1.3.1
[2010-04-04 14:56:29] INFO  ruby 1.9.1 (2010-01-10) [i386-darwin10.3.0]
[2010-04-04 14:56:29] INFO  WEBrick::HTTPServer#start: pid=19993 port=3000
</screen></para>
      </section>

      <section xml:id="restful_create">
        <title xml:id="restful_create.title">Create (Erstellen)</title>

        <para>Legen wir als erstes einmal einen neuen Datensatz an. Sie können
        das entsprechende Interface über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/new">http://0.0.0.0:3000/movies/new</uri>
        abrufen. Bitte benutzen Sie dieses Interface um einen Beispiel-Film
        einzutragen:<screenshot>
            <info>
              <title>Neuen Film in die Datenbank eintragen.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_new.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Nachdem Sie auf "Create Movie" geklickt haben, können Sie im
        Log-File folgenden Eintrag verfolgen:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 15:08:43
  Processing by MoviesController#create as HTML
  Parameters: {"authenticity_token"=&gt;"36ebldTKHnK4AXM9N2WFTCdzIzVtglqrsryicLEs1vE=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie \xC3\xBCber zwei sehr ungleiche Br\xC3\xBCder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Create Movie"}
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.4ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 13:08:43.139349', 133, 'Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.', 1988, 5, 'Rain Man', '2010-04-04 13:08:43.139349')
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 43ms


Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 15:08:43
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (11.7ms)
Completed 200 OK in 55ms (Views: 33.2ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Als Ergebnis bekommen Sie im Browserfenster den entsprechenden
        Eintrag angezeigt:<figure xml:id="screenshot_show_after_create">
		<title>Nach dem Abspeichern wird der neue Eintrag angezeigt.</title><screenshot>
            <info>
              <title>Nach dem Abspeichern wird der neue Eintrag
              angezeigt.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_new_show.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></figure></para>
      </section>

      <section xml:id="restful_show">
        <title xml:id="restful_show.title">Show (Anzeigen eines einzelnen
        Datensatzes)</title>

        <para>Nach dem Erstellen (Create) eines neuen Datensatzes, können wir
        uns diesen natürlich jetzt einzeln anschauen. Da unter ActiveRecord
        automatisch eine unique ID für jeden Datensatz erstellt wird, können
        wir diese zum Aufruf benutzen. In diesem Fall ist es die 1 für den
        ersten Datensatz. Das geht über die URI
        http://0.0.0.0:3000/movies/1<figure xml:id="screenshot_show">
			<title xml:id="screenshot_show.title">Anzeigen des ersten Datensatzes</title>

			<screenshot>
            <info>
              <title>Anzeigen des ersten
              Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></figure></para>

        <para>Im Log erscheint die folgende Ausgabe:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 16:19:38
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (8.7ms)
Completed 200 OK in 29ms (Views: 11.5ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Ihnen wird bestimmt beim Vergleich der Screenshots <xref
        linkend="screenshot_show" /> und <xref
        linkend="screenshot_show_after_create" /> aufgefallens ein, das bei
        <xref linkend="screenshot_show_after_create" /> am oben eine grüne
        Nachricht angezeigt wurde. Das ist eine sogenannte Flash-Nachricht.
        Dabei ist das Wording "Flash" meiner Meinung nach äusserst ungeschickt
        gewählt, weil bei "Flash" jeder automatisch an das Adobe-Flash-Format
        und nicht an eine Flash-artig (Flash = Blitz) erscheinende Nachricht
        denkt. So ist es aber bei Rails. Flash-Nachrichten werden immer auf
        der nächsten und nur auf der nächsten generierten Seite angezeigt. Wir
        kommen später auf Flash detailierter zu sprechen.</para>
      </section>

      <section xml:id="restful_edit">
        <title xml:id="restful_edit.title">Edit (Bearbeiten eines
        Datensatzes)</title>

        <para>Zum Editieren eines Datensatzes müssen wir wiederum die ID des
        Datensatzes kennen und können dann mit dieser (hier wieder die 1 als
        Beispiel) das Formular zum Bearbeiten des Filmes mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1/edit">http://0.0.0.0:3000/movies/1/edit</uri>
        aufrufen:<screenshot>
            <info>
              <title>Formular zum Editieren eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_edit.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File gibt es folgende Ausgabe:<screen>Started GET "/movies/1/edit" for 127.0.0.1 at 2010-04-04 21:04:44
  Processing by MoviesController#edit as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/_form.html.erb (72.8ms)
Rendered movies/edit.html.erb within layouts/movies (77.1ms)
Completed 200 OK in 120ms (Views: 106.3ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Durch klicken auf "Update Movie" können wir dann den Datensatz
        updaten und bekommen ihn dann wieder im Show-View
        angezeigt:<screenshot>
            <info>
              <title>Der Show-View nach dem Update des Datensatzes.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show_after_update.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Auch hier wird wieder mit einer Flash-Message ein Feedback vom
        System zum User gegeben.</para>

        <para>Im Log-File sieht man das Update wie folgt:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-04-04 21:05:23
  Processing by MoviesController#update as HTML
  Parameters: {"authenticity_token"=&gt;"Udc8Uy1kiOW0Gj2hMW72ws5HEPrLNL9ewCLiPyhR+YM=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"", "rating"=&gt;"5"}, "commit"=&gt;"Update Movie", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.4ms)  UPDATE "movies" SET "plot" = '', "updated_at" = '2010-04-04 19:05:23.696771' WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 342ms


Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 21:05:23
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (9.0ms)
Completed 200 OK in 51ms (Views: 35.8ms | ActiveRecord: 0.2ms)
</screen></para>
      </section>

      <section xml:id="restful_index">
        <title xml:id="restful_index.title">Index (Anzeigen aller
        Datensätze)</title>

        <para>Über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
        können Sie sich eine Liste aller Filme in der Datenbank anzeigen
        lassen (logischerweise ist das bis jetzt nur ein Film):<screenshot
            xml:id="screenshot_movies_index">
            <info>
              <title xml:id="screenshot_movies_index.title">Index-Ansicht
              aller Filme</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_index.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File findet sich folgende Ausgabe:<screen>Started GET "/movies" for 127.0.0.1 at 2010-04-04 16:26:30
  Processing by MoviesController#index as HTML
  Movie Load (0.5ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (9.9ms)
Completed 200 OK in 43ms (Views: 29.5ms | ActiveRecord: 0.4ms)
</screen></para>
      </section>

      <section>
        <title>Löschen eines Datensatzes</title>

        <para>Wenn Sie auf der Index-Seite auf "Destroy" klicken, so bekommen
        Sie folgende Meldung angezeigt:<screenshot>
            <info>
              <title>Sicherheitsabfrage beim Löschen eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/destroy_r_u_sure.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Klicken wir jetzt mutig auf "OK", bekommen wir wieder die
        Index-Seite, aber diesmal ganz ohne einen Film angezeigt:<screenshot>
            <info>
              <title>Index-Ansicht nach dem Löschen des einzigen
              Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/index_after_destroy.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Zum Schluss noch der obligatorische Blick in das
        Log-File:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-04-04 16:34:46
  Processing by MoviesController#destroy as HTML
  Parameters: {"authenticity_token"=&gt;"xzdq0dePdnVUkBpqbDEXPhPdAo/NhTM3U/lVtjzPTds=", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.3ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 25ms
</screen></para>
      </section>
    </section>

    <section xml:id="default_css_im_scaffolding">
      <title xml:id="default_css_im_scaffolding.title">Default CSS- und
      HTML-Layout im Scaffolding</title>

      <para>Wer sich bei den vorherigen Beispiel mal den HTML-Code der
      Webseiten angeschaut hat, der wird bemerkt haben, das die vom Framework
      wenig mit denen von uns in <xref
      linkend="basics_generisches_html_framework" /> erstellten Seiten gemein
      haben. Die Lösung liegt in der Datei
      <filename>app/views/layouts/movies.html.erb</filename>:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Movies: &lt;%= controller.action_name %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag 'scaffold' %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class="alert"&gt;&lt;%= alert %&gt;&lt;/p&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

      <para>Auch wenn es aktuell keine grosse Bedeutung hat, möchte ich kurz
      auf ein paar uns bis jetzt unbekannten Programmteilen eingehen. Alle
      werden später noch einmal detailierter behandelt.<itemizedlist>
          <listitem>
            <para><code>&lt;%= controller.action_name %&gt;</code></para>

            <para>Gibt den Namen der aktuellen Aktion bzw. Methode aus. Für
            den Fall das Sie mal den Controllernamen benötigen: Das geht mit
            <code>controller.controller_name</code>.</para>
          </listitem>

          <listitem>
            <para><code>&lt;%= stylesheet_link_tag 'scaffold'
            %&gt;</code></para>

            <para><code>stylesheet_link_tag</code> ist ein eingebautes Helper
            Skript, das das HTML-Tag für die Einbindung eines Default
            Stylesheets für Scaffolding übernimmt. Natürlich kämen wir auch
            ohne diese CSS Stylesheets aus, aber die Seiten sehen schon einen
            Tick schöner aus und ausserdem geht es ja darum Scaffolding zu
            verstehen. Schauen Sie einmal in den HTML-Source-Code oder lesen
            Sie die Hilfeseite mit <command>ri
            ActionView::Helpers::AssetTagHelper</command></para>
          </listitem>

          <listitem>
            <para><code>&lt;%= javascript_include_tag :defaults
            %&gt;</code></para>

            <para>Auch <code>javascript_include_tag</code> ist ein eingebautes
            Helper Skript, mit dem einige Default JavaScript Bibliotheken
            geladen werden. Das brauchen wir aktuell nicht und könnten es auch
            löschen.</para>
          </listitem>

          <listitem>
            <para><code>&lt;%= csrf_meta_tag %&gt;</code></para>

            <para>Ein Helper Skript, das sich um Unobtrusive Javascript (UJS)
            kümmert. Puhh... das jetzt zu erklären, würde den Rahmen völlig
            sprengen. Kommen wir später noch mal drauf zu sprechen.</para>
          </listitem>
        </itemizedlist></para>

      <para>Im Verzeichnis <filename>app/views/layouts</filename> liegen jetzt
      zwei verschiedene HTML-Frames:<screen>stefan@swmbp 0 head- movie-app$ <command>ls app/views/layouts/</command>
application.html.erb  movies.html.erb
stefan@swmbp 0 head- movie-app$</screen></para>

      <para>Die Datei <filename>movies.html.erb</filename> wurde beim
      Scaffolding automatisch erstellt und wird von Rails per default
      genommen. Wenn man nur mit der <filename>application.html.erb</filename>
      arbeiten möchte, dann muss man die <filename>movies.html.erb</filename>
      löschen. Sie können das auch Mischen. Wenn Sie möchten können Sie für
      jedes Model einen eigenen View erstellen oder mit mehren Views ein
      Framework teilen.</para>
    </section>

    <section xml:id="routen">
      <title xml:id="routen.title">Routen</title>

      <para>Fassen wir mal kurz zusammen: Man kann also mit Scaffolding eine
      Web-GUI erstellen und auf diese Web-GUI anscheinen über eine feste
      CRUD-Stuktur zugreifen. Jetzt wäre ja mal interessant zu wissen, ob es
      noch mehr URIs gibt. Rails steuert das über sogenannte Routen. Alle
      Routen werden in der Datei <filename>config/routes.rb</filename>
      definiert. Standardmässig sind in dieser Datei recht viele Beispiele als
      Kommentare eingebaut. Schauen wir uns mal an, wie die aktuelle
      Konfiguration ohne diese Kommentare aussieht:<screen>MacBook:movie-app sw$ <command>cat config/routes.rb | grep -v "#" | grep -v "^$"</command>
MovieApp::Application.routes.draw do |map|
  resources :movies
  get "example/test"
end
MacBook:movie-app sw$</screen></para>

      <para>Interessant ist die Zeile:<programlisting>  resources :movies</programlisting></para>

      <para>Diese Zeile sagt Rails, das es die Resource movies mit allen
      Standard Routen ausstatten soll. Diese Routen können wir uns mit
      <command>rake routes</command> anzeigen lassen.<screen>MacBook:movie-app sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
example_test GET    /example/test              {:controller=&gt;"example", :action=&gt;"test"}
MacBook:movie-app sw$</screen></para>

      <para>Puh... das sind ja viel mehr, als wir oben benutzt haben. Oder
      doch nicht? Und jetzt muss ich das auch noch sinnvoll und strukturiert
      erklären! Die letzte Zeile ist dabei am einfachsten. Die kommt aus
      unserem ersten Beispiel in <xref
      linkend="die_einfachst_anzunehmende_webseite" />. Kümmern wir uns also
      um die restlichen vom Scaffolding erzeugten Einträge.</para>

      <para>CRUD besteht zwar aus den vier Teilen Create, Read, Upate und
      Delete, aber diese Einzelelemente müssen in der RESTful Umsetzung weiter
      aufgeschlüsselt werden. Ziel bei REST ist es, das man eine
      Abfrage-Methodik definiert, die von allen Entwicklern gleich verstanden
      und auch benutzt werden kann. Dazu werden bei Webzugriffen die URIs und
      die HTTP-Verben benutzt. Was HTTP-Verben sind? Ich habe die Frage
      befürchtet. Bei der Entwicklung des HTTP-Protokolles wurden verschiedene
      Abfrage-Methoden definiert. Sie haben bestimmt bei einem HTML-Formular
      schon mal vom Unterschied zwischen GET und POST gelesen. GET und POST
      sind genau solche Verben. Für uns weiterhin interessant sind PUT und
      DELETE. Gerne verweise ich an dieser Stelle auf das RFC 2616 (<uri
      xlink:href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</uri>),
      falls Sie sich mit dieser Materie näher beschäftigen wollen.</para>

      <para>Für uns ist jetzt erst mal nur interessant, das gleiche URIs die
      mit unterschiedlichen Verben angesprochen werden unterschiedliche
      Aktionen in Ihrer Rails-Applikation auslösen. So können Sie in unserer
      Filmdatenbank über die URI <uri
      xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
      sowohl mit GET eine Liste (Index) aller Filme anfordern, als auch mit
      POST einen neuen Filmeintrag abspeichern.</para>

      <para>Die Kombination aus Verb und URI wird in Rails als Route
      bezeichnet. Ist eine Route nicht definiert, passiert auch nichts. Ist
      eine Route definiert, dann wird damit auf eine "Action" und einen
      "Controller" verwiesen. Ich würde jetzt gerne erklären, was es mit
      beidem auf sich hat, aber vorher will ich noch kurz <xref
      linkend="restful_mit_xml" /> besprechen, damit wir das aktuelle Thema
      RESTful Zugriff sauber abgeschlossen haben.</para>
    </section>

    <section xml:id="restful_mit_xml">
      <title xml:id="restful_mit_xml.title">RESTful Datenbankzugriff per XML
      und curl</title>

      <para><tip>
          <para>Wenn Sie sich nicht für den Austausch von Daten per XML
          interessieren, dann können Sie diesen Abschnitt ruhig
          überspringen.</para>
        </tip>Das XML-Interface erleichtert den Austausch von Daten zwischen
      Maschinen. Dabei wird der ganze HTML-Balast abgeworfen und nur noch die
      reinen Daten per XML ausgetauscht. Beispielhaft führen wir dies mit dem
      Programm curl durch. Logischerweise geht es natürlich auch mit anderen
      Programmen oder Programmiersprachen. Wer die Art und Weise verstanden
      hat, kann von beliebigen Systemen eine Rails Applikation bedienen. Da
      dies naturgemäss auch gewisse Gefahren in sich birgt (z.B. kann eine
      Maschine per Brute-Force-Attacke schnell wie Unheil anrichten), kann man
      per Default bestimmte Aktionen nicht durchführen. Dies wird in der Datei
      <filename>app/controllers/application_controller.rb</filename> mit
      <code>protect_from_forgery</code> konfiguriert. Bitte deaktiven Sie
      diese Zeile für diese Beispiele wie folgt mit einem
      #-Zeichen:<programlisting>class ApplicationController &lt; ActionController::Base
  # protect_from_forgery
end
</programlisting></para>

      <para>Dadurch entfällt eine per default aktivierte Sicherheitsschicht,
      die einen Token austauscht, um die anonyme Interaktion von aussen zu
      underbinden. Im Log-File werden Sie den Unterschied merken (es fehlt der
      Eintrag <code>"authenticity_token"=&gt;"xyz"</code>). In späteren
      Kapiteln besprechen wir Authentifizierungsmechanismen um diese Zugriffe
      mit Passwörtern abzusichern.</para>

      <section>
        <title>new</title>

        <para>Um einen neuen Film einzutragen, benötigen Sie als erstes die
        Felder die ausgefüllt werden müssen. Dazu können Sie die URL <uri
        xlink:href="http://0.0.0.0:3000/movies/new.xml">http://0.0.0.0:3000/movies/new.xml</uri>
        abrufen:<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/new.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime" nil="true"&gt;&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer" nil="true"&gt;&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title nil="true"&gt;&lt;/title&gt;
  &lt;updated-at type="datetime" nil="true"&gt;&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/new.xml" for 127.0.0.1 at 2010-04-04 19:28:19
  Processing by MoviesController#new as XML
Completed 200 OK in 124ms (Views: 111.1ms | ActiveRecord: 0.0ms)
</screen></para>

        <para>In der XML-Ausgabe können wir erkennen wie die einzelnen Felder
        heissen und welche Typen (z.B. Integer) sie darstellen. Mit diesen
        Informationen können wir jetzt einen create Aufruf mit dem neuen
        Datensatz zusammenstellen:</para>

        <para>Danach können Sie mit einem create Aufruf die Daten für einen
        neuen Datensatz uploaden:<screen>MacBook:~ sw$ <command>curl -X POST -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Ausgabe im Log:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 20:30:10
  Processing by MoviesController#create as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1988"}}
  SQL (0.3ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 18:30:10.440028', 133, NULL, 1988, 5, 'Rain Man', '2010-04-04 18:30:10.440028')
Redirected to http://0.0.0.0:3000/movies/6
Completed 302 Found in 27ms
</screen></para>

        <para>Als Ergebnis des curl Aufrufes bekommen Sie die den folgenden
        Code zurück:<screen>&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
</screen></para>

        <para>Das ist also quasi wie beim Aufruf mit dem Webbrowser, nur das
        ein Show des neuen Datensatzes so beim XML-Aufruf wenig Sinn
        macht.</para>
      </section>

      <section>
        <title>index</title>

        <para>Um das Ergebnis des Index-Aufrufes sinnvoller zu gestalten, habe
        ich vorher zwei mal den Film Rain Man eingetragen. Jetzt müssen wir
        mit curl die URI <uri
        xlink:href="http://0.0.0.0:3000/movies.xml">http://0.0.0.0:3000/movies.xml</uri>
        abrufen.<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movies type="array"&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;1&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
  &lt;/movie&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;2&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/updated-at&gt;
  &lt;/movie&gt;
&lt;/movies&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies.xml" for 127.0.0.1 at 2010-04-04 20:39:09
  Processing by MoviesController#index as XML
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies"
Completed 200 OK in 23ms (Views: 9.6ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>show</title>

        <para>Einen einzelnen Film kann man sich mit der ID des Eintrages
        (hier die 1) und der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri>
        anschauen. <screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/1.xml" for 127.0.0.1 at 2010-04-04 20:40:06
  Processing by MoviesController#show as XML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Completed 200 OK in 37ms (Views: 8.8ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>edit - update</title>

        <para>Zum Editieren eines Eintrages downloaden wir diesen Eintrag erst
        wieder von der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri><screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T19:05:23Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Danach übermitteln wir den entsprechenden Eintrag mit PUT neu
        auf die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Dabei ist es egal, ob wir wirklich neue oder wieder die gleichen Daten
        übermitteln. Wichtig dabei ist, das wir die <parameter>id</parameter>
        des Eintrages mit übertragen:<screen>MacBook:~ sw$ <command>curl -X PUT -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1989&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies/1</command>    
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/1"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started PUT "/movies/1" for 127.0.0.1 at 2010-04-04 21:12:32
  Processing by MoviesController#update as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1989"}, "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.4ms)  UPDATE "movies" SET "production_year" = 1989, "updated_at" = '2010-04-04 19:12:32.237009' WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 70ms
</screen></para>

        <para>ActiveRecord ist dabei intelligent genug nur wirkliche
        Veränderungen einzutragen.</para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
        und einem DELETE Aufruf wieder aus der Datenbank löschen.<screen>MacBook:~ sw$ <command>curl -X DELETE -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started DELETE "/movies/1" for 127.0.0.1 at 2010-04-04 21:14:44
  Processing by MoviesController#destroy as */*
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.2ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 22ms
</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="die_console">
    <title xml:id="die_console.title">Die Console</title>

    <para>Sie haben im <xref linkend="ruby-grundlagen" /> gelernt mit irb
    umzugehen. In Rails gibt es dazu ein Pondon: <command>rails
    console</command></para>

    <para>Mit der Rails Console haben Sie nicht nur die normalen irb
    Mechanismen, sondern auch direkt alle Klassen und Methoden aus Ihrer
    Rails-Applikation. Und können somit auf die Datenbank zugreifen. Diese
    werden automagisch per ActiveRecord als Objekte zur Verfügung
    gestellt.</para>

    <para>Die Rails-Console kann parallel zum Webserver oder anstatt des
    Webservers gestartet werden. Wir führen als erstes ein <command>rake
    db:reset</command> aus, damit wir eine frische und leere Datenbank zum
    Üben vorfinden. <screen>MacBook:movie-app sw$ <command>rake db:reset</command>
(in /Users/sw/Development/movie-app)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("movies", {:force=&gt;true})
   -&gt; 0.0155s
-- initialize_schema_migrations_table()
   -&gt; 0.0049s
-- assume_migrated_upto_version(20100404113234, "db/migrate")
   -&gt; 0.0026s
MacBook:movie-app sw$ </screen></para>

    <para>Danach starten wir die Console:<screen>MacBook:movie-app sw$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta2)
ruby-1.9.1-p378 &gt;</screen></para>

    <section>
      <title>Neuen Datensatz anlegen</title>

      <para>ActiveRecord stellt uns automagisch eine Klasse aus der Datenbank
      <parameter>movies</parameter> mit dem Namen <classname>Movie</classname>
      zur Verfügung. Diese KLasse hat eine Methode
      <methodname>new</methodname> und mit der können wir ein neues Objekt
      erstellen.<screen>ruby-1.9.1-p378 &gt; <command>terminator = Movie.new</command>
 =&gt; #&lt;Movie id: nil, title: nil, production_year: nil, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Wir können uns sicherheitshalber noch mal die KLasse der Instance
      terminator ausgeben lassen.<screen>ruby-1.9.1-p378 &gt; <command>terminator.class</command>
 =&gt; Movie(id: integer, title: string, production_year: integer, duration: integer, plot: text, rating: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Das neue Objekt terminator hat automatsch Accessors (siehe <xref
      linkend="getter_und_setter_methoden" />) zu den einzelnen Datenfeldern.
      Diese benutzen wir zum Füllen mit einem Beispieldatensatz.<screen>ruby-1.9.1-p378 &gt; <command>terminator.title = 'The Terminator'</command>
 =&gt; "The Terminator" 
ruby-1.9.1-p378 &gt; <command>terminator.production_year = 1984</command>
 =&gt; 1984 
ruby-1.9.1-p378 &gt; <command>terminator</command>
 =&gt; #&lt;Movie id: nil, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Objekt ist allerdings noch nicht in der Datenbank gespeichert.
      Das erfolgt erst durch Aufruf der Methode
      <methodname>save</methodname>.<screen>ruby-1.9.1-p378 &gt; <command>terminator.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Alternative können wir einen zweiten Datensatz auch direkt mit der
      Methode <methodname>create</methodname> anlegen.<screen>ruby-1.9.1-p378 &gt; <command>Movie.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })</command>
 =&gt; #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:39:22", updated_at: "2010-04-04 19:39:22"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <section>
        <title>Hilfe zu create</title>

        <para>Die Methode <methodname>create</methodname> gehört zu
        <classname>ActiveRecord::Base</classname>. Die online Hilfe dazu kann
        mit <application>ri</application> abgerufen werden. Wenn Sie das jetzt
        ausprobieren wollen, müssen Sie natürlich erst mit
        <command>exit</command> aus der Console raus.<screen>MacBook:movie-app sw$ <command>ri ActiveRecord::Base.create</command>
--------------------------------------------- ActiveRecord::Base::create
     ActiveRecord::Base::create(attributes = nil, &amp;block) {|object| ...}

     From
     /Users/sw/.rvm/gems/ruby-1.9.1-p378/doc/activerecord-3.0.0.beta2/ri
     /ActiveRecord/Base/cdesc-Base.yaml
------------------------------------------------------------------------
     Creates an object (or multiple objects) and saves it to the
     database, if validations pass. The resulting object is returned
     whether the object was saved successfully to the database or not.

     The +attributes+ parameter can be either be a Hash or an Array of
     Hashes. These Hashes describe the attributes on the objects that
     are to be created.

     Examples

       # Create a single new object
       User.create(:first_name =&gt; 'Jamie')
     
       # Create an Array of new objects
       User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])
     
       # Create a single object and pass it into a block to set other attributes.
       User.create(:first_name =&gt; 'Jamie') do |u|
         u.is_admin = false
       end
     
       # Creating an Array of new objects using a block, where the block is executed for each object:
       User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
         u.is_admin = false
       end

MacBook:movie-app sw$ 
</screen></para>
      </section>
    </section>

    <section>
      <title>Alle Datensätze anzeigen</title>

      <para>Der einfachste Weg alle Datensätze aus der Datenbank movies
      anzuzeigen ist die Methode <methodname>all</methodname>:<screen>ruby-1.9.1-p378 &gt; <command>Movie.all</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:38:36", updated_at: "2010-04-04 19:38:36"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:39:22", updated_at: "2010-04-04 19:39:22"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Was für eine Klasse ist das Ergebnis von
      <classname>Movie.all</classname>? Schauen wir mal nach.<screen>ruby-1.9.1-p378 &gt; <command>Movie.all.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Dann können wir ja die Iterator-Methode
      <methodname>each</methodname> anwenden (siehe <xref
      linkend="array_iterator" />), um durch die einzelnen Elemente des Arrays
      zu gehen. Damit können Sie sich als Beispiel alle Titel ausgeben
      lassen.<screen>ruby-1.9.1-p378 &gt; <command>Movie.all.each { |movie| puts movie.title }</command>
The Terminator
Terminator 2
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:38:36", updated_at: "2010-04-04 19:38:36"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:39:22", updated_at: "2010-04-04 19:39:22"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section xml:id="seed_rb">
      <title xml:id="seed_rb.title">Mit seed.rb die Entwicklungsdatenbank
      betanken</title>

      <para>Gehört nicht so richtig in dieses Kapitel, aber gerade bei der
      Entwicklung kommt es immer mal wieder vor, das man den Inhalt der
      Datenbank löschen und mit neuen Werten befüllen will. In Rails gibt es
      dafür den praktischen Mechanismus der Datei
      <filename>db/seeds.rb</filename></para>

      <para>Die <filename>db/seeds.rb</filename> ist ein normales
      Ruby-Programm, das man mit <command>rake db:seed</command> ausführen
      kann. Dies geht natürlich nicht nur mit der Entwicklungsdatenbank,
      sondern kann später auch in der Produktion geschehen. Das ist z.B.
      praktisch, wenn man initial eine Länderliste in eine Länderdatenbank
      eintragen will.</para>

      <para>Für unsere Film-Datenbank habe ich folgende
      <filename>db/seeds.rb</filename> vorbereitet:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#   
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Major.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Movie.create({ :title =&gt; 'The Terminator', :production_year =&gt; 1984 })
Movie.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })
Movie.create({ :title =&gt; 'Terminator Salvation', :production_year =&gt; 2009 })
Movie.create({ :title =&gt; 'Rain Man', :production_year =&gt; 1988, :rating =&gt; 5 })
Movie.create({ :title =&gt; 'War of the Worlds', :production_year =&gt; 2005, :rating =&gt; 4 })
Movie.create({ :title =&gt; 'Collateral', :production_year =&gt; 2004, :rating =&gt; 5})
Movie.create({ :title =&gt; 'Miami Vice', :production_year =&gt; 2006, :rating =&gt; 5})
Movie.create({ :title =&gt; 'Hancock', :production_year =&gt; 2008, :rating =&gt;  4})
Movie.create({ :title =&gt; 'The Aviator', :production_year =&gt; 2004, :rating =&gt;  4})
Movie.create({ :title =&gt; 'Some Like It Hot', :production_year =&gt; 1959, :rating =&gt;  5})
Movie.create({ :title =&gt; 'W.', :production_year =&gt; 2008, :rating =&gt;  4})
Movie.create({ :title =&gt; 'Iron Man', :production_year =&gt; 2008, :rating =&gt;  5})
Movie.create({ :title =&gt; 'The Dark Knight', :production_year =&gt; 2008, :rating =&gt;  5})
</programlisting></para>

      <section>
        <title>Betankung</title>

        <para>Um keine Filme doppelt zu haben, reseten wir erst mit
        <command>rake db:reset</command> die Datenbank.<screen>MacBook:movie-app sw$ <command>rake db:reset</command>
(in /Users/sw/Development/movie-app)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("movies", {:force=&gt;true})
   -&gt; 0.0168s
-- initialize_schema_migrations_table()
   -&gt; 0.0046s
-- assume_migrated_upto_version(20100404113234, "db/migrate")
   -&gt; 0.0022s
MacBook:movie-app sw$</screen></para>

        <para>Um sie dann mit <command>rake db:seed</command> zu
        betanken.<screen>MacBook:movie-app sw$ <command>rake db:seed</command>
(in /Users/sw/Development/movie-app)
MacBook:movie-app sw$</screen></para>
      </section>
    </section>

    <section xml:id="arbeiten-mit-find">
      <title>Arbeiten mit der Methode find</title>

      <para>Es gibt in <classname>ActiveRecord::Base</classname> eine Methode
      <methodname>find</methodname> die es uns ermöglicht ganz ohne
      SQL-Kenntnisse nach Daten in der Datenbank zu suchen.</para>

      <section>
        <title>Nach ID suchen</title>

        <para>Einen Film nach der ID zu suchen ist der einfachste aller
        Fälle.<screen>ruby-1.9.1-p378 &gt; <command>Movie.find(1)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>Nach einem Feldinhalt suchen</title>

        <para>Jetzt kommt ein wenig Ruby-Magie ins Spiel. Die Methode
        <methodname>find</methodname> kann dynamisch mit
        <methodname>_by_</methodname> und dem Feldnamen erweitert werden. Am
        einfachsten zeigt sich das mit ein paar Beispielen:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('The Terminator')</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_production_year(1984)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_rating(nil)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Bei der letzten Suche zeigt sich dabei allerdings schon ein
        Problem, denn <methodname>find_by_x</methodname> gibt immer nur den
        ersten Treffer aus. Wenn man mehrere Treffer ausgeben will, muss man
        <command>find_all_by_x</command> benutzen:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_rating(nil)</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Mit der Methode count kann man sich dann übrigens auch leicht
        die Anzahl der gefundenen Filme ausrechnen lassen:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_rating(nil).count</command>
 =&gt; 6 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Jetzt mal eine kleine Quizfrage: "Zählt Rails die Anzahl der
        Objekte im Array, das von
        <command>Movie.find_all_by_rating(nil)</command> ausgegeben wird oder
        geht es intelligenter vor?". Die Antwort liegt im Logfile:<screen>  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.5ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."rating" IS NULL)
</screen></para>

        <para>Rails bekommt also wirklich alle entsprechenden Tabelleneinträge
        zurück und zählt dann die Anzahl der Objekte im Array. Bei einer solch
        kleinen Tabelle ist das kein Problem. Aber bei einer grösseren will
        man so was eher vom SQL-Server machen lassen, weil dieser einfach viel
        schneller ist. Dafür gibt es die Methode count die wir wie folgt
        aufrufen können:<screen>ruby-1.9.1-p378 &gt; <command>Movie.count(:all, :conditions =&gt; { :rating =&gt; nil } )</command>
 =&gt; 6 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Im Logfile zeigt sich dann der folgende, von uns genau so
        gewünschte Eintrag:<screen>  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM "movies" WHERE ("movies"."rating" IS NULL)
</screen></para>

        <para>Man kann die <methodname>find_all_by_x</methodname> oder
        <methodname>find_by_x</methodname> Methoden übrigens beliebig mit dem
        String <methodname>_and_</methodname> und weiteren Feldnamen
        verlängern:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_duration_and_rating(nil,nil)</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>Komplexere Suchen</title>

        <para>Die Methode find ist sehr mächtig. Bevor ich einzelne Beispiele
        gebe, möchte ich Sie schon mal auf die eingebaute Hilfe
        verweisen:<screen>MacBook:movie-app sw$ <command>ri ActiveRecord::Base.find</command>
----------------------------------------------- ActiveRecord::Base::find
     ActiveRecord::Base::find(*args)

     From gem activerecord-2.3.5
------------------------------------------------------------------------
     Find operates with four different retrieval approaches:

     *   Find by id - This can either be a specific id (1), a list of
         ids (1, 5, 6), or an array of ids ([5, 6, 10]). If no record
         can be found for all of the listed ids, then RecordNotFound
         will be raised.

     *   Find first - This will return the first record matched by the
         options used. These options can either be specific conditions
         or merely an order. If no record can be matched, +nil+ is
         returned. Use +Model.find(:first, *args)+ or its shortcut
         +Model.first(*args)+.

     *   Find last - This will return the last record matched by the
         options used. These options can either be specific conditions
         or merely an order. If no record can be matched, +nil+ is
         returned. Use +Model.find(:last, *args)+ or its shortcut
         +Model.last(*args)+.

     *   Find all - This will return all the records matched by the
         options used. If no records are found, an empty array is
         returned. Use +Model.find(:all, *args)+ or its shortcut
         +Model.all(*args)+.

     All approaches accept an options hash as their last parameter.

     Parameters

     *   +:conditions+ - An SQL fragment like "administrator = 1", +[
         "user_name = ?", username ]+, or +["user_name = :user_name", {
         :user_name =&gt; user_name }]+. See conditions in the intro.

     *   +:order+ - An SQL fragment like "created_at DESC, name".

     *   +:group+ - An attribute name by which the result should be
         grouped. Uses the +GROUP BY+ SQL-clause.

     *   +:having+ - Combined with +:group+ this can be used to filter
         the records that a +GROUP BY+ returns. Uses the +HAVING+
         SQL-clause.

     *   +:limit+ - An integer determining the limit on the number of
         rows that should be returned.

     *   +:offset+ - An integer determining the offset from where the
         rows should be fetched. So at 5, it would skip rows 0 through
         4.

     *   +:joins+ - Either an SQL fragment for additional joins like
         "LEFT JOIN comments ON comments.post_id = id" (rarely needed),
         named associations in the same form used for the +:include+
         option, which will perform an +INNER JOIN+ on the associated
         table(s), or an array containing a mixture of both strings and
         named associations. If the value is a string, then the records
         will be returned read-only since they will have attributes that
         do not correspond to the table's columns. Pass +:readonly =&gt;
         false+ to override.

     *   +:include+ - Names associations that should be loaded
         alongside. The symbols named refer to already defined
         associations. See eager loading under Associations.

     *   +:select+ - By default, this is "*" as in "SELECT * FROM", but
         can be changed if you, for example, want to do a join but not
         include the joined columns. Takes a string with the SELECT SQL
         fragment (e.g. "id, name").

     *   +:from+ - By default, this is the table name of the class, but
         can be changed to an alternate table name (or even the name of
         a database view).

     *   +:readonly+ - Mark the returned records read-only so they
         cannot be saved or updated.

     *   +:lock+ - An SQL fragment like "FOR UPDATE" or "LOCK IN SHARE
         MODE". +:lock =&gt; true+ gives connection's default exclusive
         lock, usually "FOR UPDATE".

     Examples

       # find by id
       Person.find(1)       # returns the object for ID = 1
       Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
       Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
       Person.find([1])     # returns an array for the object with ID = 1
       Person.find(1, :conditions =&gt; "administrator = 1", :order =&gt; "created_on DE
SC")

     Note that returned records may not be in the same order as the ids
     you provide since database rows are unordered. Give an explicit
     +:order+ to ensure the results are sorted.

     Examples

       # find first
       Person.find(:first) # returns the first object fetched by SELECT * FROM peo
ple
       Person.find(:first, :conditions =&gt; [ "user_name = ?", user_name])
       Person.find(:first, :conditions =&gt; [ "user_name = :u", { :u =&gt; user_name }]
)
       Person.find(:first, :order =&gt; "created_on DESC", :offset =&gt; 5)
     
       # find last
       Person.find(:last) # returns the last object fetched by SELECT * FROM peopl
e
       Person.find(:last, :conditions =&gt; [ "user_name = ?", user_name])
       Person.find(:last, :order =&gt; "created_on DESC", :offset =&gt; 5)
     
       # find all
       Person.find(:all) # returns an array of objects for all the rows fetched by
 SELECT * FROM people
       Person.find(:all, :conditions =&gt; [ "category IN (?)", categories], :limit =
&gt; 50)
       Person.find(:all, :conditions =&gt; { :friends =&gt; ["Bob", "Steve", "Fred"] }
       Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)
       Person.find(:all, :include =&gt; [ :account, :friends ])
       Person.find(:all, :group =&gt; "category")

     Example for find with a lock: Imagine two concurrent transactions:
     each will read +person.visits == 2+, add 1 to it, and save,
     resulting in two saves of +person.visits = 3+. By locking the row,
     the second transaction has to wait until the first is finished; we
     get the expected +person.visits == 4+.

       Person.transaction do
         person = Person.find(1, :lock =&gt; true)
         person.visits += 1
         person.save!
       end

MacBook:movie-app sw$ </screen></para>

        <section>
          <title>Such-Beispiele</title>

          <para>Im folgenden werde ich per Fragen und Antwort ein
          Beispielprobleme mit <methodname>find</methodname> lösen.</para>

          <para><qandaset>
              <qandadiv>
                <qandaentry>
                  <question>
                    <para>Wie kann ich alle in der Datenbank enthaltenen Filme
                    in das Objekt mit dem Namen <varname>alle_filme</varname>
                    speichern?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>alle_filme = Movie.all</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 4, title: "Rain Man", production_year: 1988, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 5, title: "War of the Worlds", production_year: 2005, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 6, title: "Collateral", production_year: 2004, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 7, title: "Miami Vice", production_year: 2006, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 9, title: "The Aviator", production_year: 2004, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 10, title: "Some Like It Hot", production_year: 1959, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 17, title: "Rain Man", production_year: 1988, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 18, title: "War of the Worlds", production_year: 2005, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 19, title: "Collateral", production_year: 2004, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 20, title: "Miami Vice", production_year: 2006, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 21, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 22, title: "The Aviator", production_year: 2004, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 23, title: "Some Like It Hot", production_year: 1959, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 24, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 25, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 26, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie finde ich den ersten Film in der
                    Datenbank?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find(:first)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt;</screen>Oder noch kürzer mit der Methode
                    <methodname>first</methodname>.<screen>ruby-1.9.1-p378 &gt; <command>Movie.first</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt; </screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie kann ich alle Filme die im Jahr 1984 produziert
                    wurden suchen?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year(1984)</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie finde ich die Anzahl der im Jahr 1984
                    produzierten Filme raus?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year(1984).count</command>
 =&gt; 2 
ruby-1.9.1-p378 &gt; <command>Movie.count(:all, :conditions =&gt; { :production_year =&gt; 1984 })</command>
 =&gt; 2 
ruby-1.9.1-p378 &gt; </screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Einer Liste aller 5 Sterne Filme aus dem Jahr 2008
                    im YAML Format.</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year_and_rating(2008,5).to_yaml</command>
 =&gt; "--- \n- !ruby/object:Movie \n  attributes: \n    id: \"12\"\n    title: Iron Man\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:41.922898\n    updated_at: 2010-04-04 19:50:41.922898\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n- !ruby/object:Movie \n  attributes: \n    id: \"13\"\n    title: The Dark Knight\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:41.925878\n    updated_at: 2010-04-04 19:50:41.925878\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n- !ruby/object:Movie \n  attributes: \n    id: \"25\"\n    title: Iron Man\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:50.084528\n    updated_at: 2010-04-04 19:50:50.084528\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n- !ruby/object:Movie \n  attributes: \n    id: \"26\"\n    title: The Dark Knight\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:50.087386\n    updated_at: 2010-04-04 19:50:50.087386\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n" 
ruby-1.9.1-p378 &gt; </screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Alle 2008er Filme, alphabetisch nach Titeln
                    sortiert.</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year(2008, :order =&gt; :title)</command>
 =&gt; [#&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 21, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 25, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 26, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 24, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Ich möchte selbst SQL einbauen. Wie kann ich nach
                    allen Filmen suchen, die im Titel das Wort 'Terminator'
                    enthalten?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find(:all, :conditions =&gt; [ "title LIKE ?", '%Terminator%' ])</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>
              </qandadiv>
            </qandaset></para>
        </section>
      </section>
    </section>

    <section xml:id="datensatz-loeschen">
      <title>Einen Datensatz löschen</title>

      <para>Es gibt die Methoden <methodname>delete</methodname> und
      <methodname>destroy</methodname>, um Datensätze zu löschen.</para>

      <section>
        <title>delete</title>

        <para>Mit delete können Sie einen Datensatz löschen. Dabei werden
        allerdings keine Abhängigkeiten zu anderen Datensätzen beachtet.
        Delete löscht also nur die eine Zeile in der Datenbank und sonst
        nichts.<note>
            <para>Für unseren jetzigen Kenntnisstand sind solche Abhänigkeiten
            noch egal, aber in späteren Kapiteln werden wir verschiedene
            Tabellen mit einander verknüpfen und dann wird es entsprechende
            Abhängigkeiten geben.</para>
          </note><important>
            <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
            (eingefroren). Sie ist also noch da, kann aber nicht verändert
            werden.</para>
          </important></para>

        <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('Hancock')</command>
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>hancock = Movie.find_by_title('Hancock')</command>
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>hancock.delete</command>      # Die Zeile in der DB wird geloescht. Siehe Log.
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('Hancock')</command>
 =&gt; nil                               # Eine Suche bringt kein Ergebnis mehr.
ruby-1.9.1-p378 &gt; <command>hancock</command>             
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>hancock.frozen?</command>     # Die Instanz ist frozen.
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>destroy</title>

        <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
        löschen und dabei werden auch evt. vorhandene Abhängigkeiten beachtet
        (solche Abhängikeiten betrachten wir später). Vereinfacht kann man
        sagen: "Lieber destroy nehmen, das ist sicherer, weil das Rails-System
        dann mehr mitdenkt."<important>
            <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
            (eingefroren). Sie ist also noch da, kann aber nicht verändert
            werden.</para>
          </important></para>

        <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('The Dark Knight')</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>dark_night = Movie.find_by_title('The Dark Knight')</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>dark_night.destroy</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('The Dark Knight')</command>
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>dark_night</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>dark_night.frozen?</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>
      </section>
    </section>

    <section xml:id="datensatz-editieren">
      <title>Einen Datensatz editieren</title>

      <para>Das Verändern eines Datensatzes erfolgt in zwei
      Schritten:<orderedlist>
          <listitem>
            <para>Suche des Datensatzes und erstellen einer entsprechenden
            Instanz.</para>
          </listitem>

          <listitem>
            <para>Verändern der Werte.</para>
          </listitem>

          <listitem>
            <para>Abspeichern des Datensatzes mit der Methode
            <methodname>save</methodname>.</para>
          </listitem>
        </orderedlist></para>

      <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>iron_man = Movie.find_by_title('Iron Man')</command>
 =&gt; #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>iron_man.duration = 126</command>
 =&gt; 126 
ruby-1.9.1-p378 &gt; <command>iron_man.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('Iron Man')</command>
 =&gt; #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: 126, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:52:27"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <section>
        <title>Locking</title>

        <para>Per Default benutzt Rails Optimistisches Locking der Datensätze.
        Dies kann aber umgeschaltet werden. Da für die meisten User
        Optimistisches Locking optimal ist und viele vor diesem Absatz nicht
        mal über das Problem nachgedacht haben, werde ich nicht weiter drauf
        eingehen, sondern auf die ri Hilfe verweisen. Wer pessimistisches
        Locking benötigt, der findet dort die notwendigen Schalter.</para>

        <para><screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveRecord::Locking::Optimistic</command>
------------------------------- Class: ActiveRecord::Locking::Optimistic

What is Optimistic Locking
--------------------------

     Optimistic locking allows multiple users to access the same record
     for edits, and assumes a minimum of conflicts with the data. It
     does this by checking whether another process has made changes to a
     record since it was opened, an ActiveRecord::StaleObjectError is
     thrown if that has occurred and the update is ignored.

     Check out ActiveRecord::Locking::Pessimistic for an alternative.


Usage
-----

     Active Records support optimistic locking if the field
     +lock_version+ is present. Each update to the record increments the
     lock_version column and the locking facilities ensure that records
     instantiated twice will let the last one saved raise a
     StaleObjectError if the first was also updated. Example:

       p1 = Person.find(1)
       p2 = Person.find(1)
     
       p1.first_name = "Michael"
       p1.save
     
       p2.first_name = "should fail"
       p2.save # Raises a ActiveRecord::StaleObjectError

     You're then responsible for dealing with the conflict by rescuing
     the exception and either rolling back, merging, or otherwise apply
     the business logic needed to resolve the conflict.

     You must ensure that your database schema defaults the lock_version
     column to 0.

     This behavior can be turned off by setting
     +ActiveRecord::Base.lock_optimistically = false+. To override the
     name of the lock_version column, invoke the +set_locking_column+
     method. This method uses the same syntax as +set_table_name+

------------------------------------------------------------------------
sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="workflow-in-rails">
    <title xml:id="mvc-workflow-in-rails.title">MVC-Workflow innerhalb
    Rails</title>

    <para>Jetzt können wir eine Tabelle anlegen und auf diese via HTTP und via
    der Console zugreifen. Jetzt schauen wir uns mal an, was bei einer
    HTTP-Anfrage passiert und welchen Weg diese Anfrage geht. Hier kommt die
    versprochene Fortführung von <xref linkend="routen" />.</para>

    <section xml:id="dvd-show-html">
      <title>Beispiel movies/1</title>

      <para>Nehmen wir an, ein User ruft die URL <uri
      xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
      auf.</para>

      <section>
        <title>Routing</title>

        <para>Kommt ein Aufruf per HTTP rein, so wird die URL durch eine
        Routing-Engine verarbeitet. Diese wird durch die Datei
        <filename>config/routes.rb</filename> konfiguriert. Schauen wir noch
        mal rein. Diesmal mit allen Kommentaren.<programlisting>MovieApp::Application.routes.draw do |map|
  resources :movies

  get "example/test"

  # The priority is based upon order of creation:
  # first created -&gt; highest priority.

  # Sample of regular route:
  #   match 'products/:id' =&gt; 'catalog#view'
  # Keep in mind you can assign values other than :controller and :action

  # Sample of named route:
  #   match 'products/:id/purchase' =&gt; 'catalog#purchase', :as =&gt; :purchase
  # This route can be invoked with purchase_url(:id =&gt; product.id)

  # Sample resource route (maps HTTP verbs to controller actions automatically):
  #   resources :products

  # Sample resource route with options:
  #   resources :products do
  #     member do
  #       get :short
  #       post :toggle
  #     end
  #
  #     collection do
  #       get :sold
  #     end
  #   end

  # Sample resource route with sub-resources:
  #   resources :products do
  #     resources :comments, :sales
  #     resource :seller
  #   end

  # Sample resource route with more complex sub-resources
  #   resources :products do
  #     resources :comments
  #     resources :sales do
  #       get :recent, :on =&gt; :collection
  #     end
  #   end

  # Sample resource route within a namespace:
  #   namespace :admin do
  #     # Directs /admin/products/* to Admin::ProductsController
  #     # (app/controllers/admin/products_controller.rb)
  #     resources :products
  #   end

  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; "welcome#index"

  # See how all your routes lay out with "rake routes"

  # This is a legacy wild controller route that's not recommended for RESTful applications.
  # Note: This route will make all actions in every controller accessible via GET requests.
  # match ':controller(/:action(/:id(.:format)))'
end</programlisting></para>

        <para>Die Priorität einer Route wird anhand ihrer Position in dieser
        Datei bestimmt. Es können also mehrere Regeln auf die gleiche Route
        matchen. Die am weitesten oben stehende gewinnt.</para>

        <para>In der Zeile 2 steht eine für unsere Applikation bis jetzt die
        wichtige Konfiguration:<programlisting>resources :movies</programlisting></para>

        <para>Sie sorgt dafür das automagisch die Anfragen mit der RESTful
        Logik an die Methoden <methodname>index</methodname>,
        <methodname>show</methodname>, <methodname>new</methodname>,
        <methodname>edit</methodname>, <methodname>create</methodname>,
        <methodname>update</methodname> und <methodname>destroy</methodname>
        der Klasse <classname>MoviesController</classname> weitergeleitet
        werden.</para>

        <para>Diese Routen können wir uns mit <command>rake routes</command>
        anzeigen lassen.<screen>MacBook:movie-app sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
example_test GET    /example/test              {:controller=&gt;"example", :action=&gt;"test"}
MacBook:movie-app sw$</screen></para>

        <para>Diese Klasse wird in der Datei
        <filename>app/controllers/movies_controller.rb</filename> definiert.
        Schauen wir mal rein, was da bei der Methode
        <methodname>show</methodname> steht:<programlisting>  # GET /movies/1
  # GET /movies/1.xml
  def show
    @movie = Movie.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml =&gt; @movie }
    end
  end
</programlisting></para>

        <para>Direkt am Anfang wird die Instance-Variable
        <varname>@movie</varname> mit dem Ergebnis der Suche nach einer ID
        gefüllt (<code>Movie.find(params[:id])</code>). Die :id finden Sie
        oben in den Routen. Der Hash params wird automatisch von Rails gefühlt
        und steht dem Programmierer im Controller zur Verfügung.</para>

        <para>hmmmm... was hat es mit diesem Hash <varname>params[]</varname>
        auf sich? Machen wir mal testweise die Abfrage <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Ich gehe mal davon aus, das Sie mittlerweile den dazu passenden
        Browser-Screenshot vor Ihrem virtuellen Auge haben. Falls nicht =&gt;
        <xref linkend="screenshot_show" /></para>

        <para>Und gleichzeitig schauen wir uns die Log-Ausgabe des Webservers
        an:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-04-05 10:49:59
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (9.6ms)
Completed 200 OK in 30ms (Views: 12.5ms | ActiveRecord: 0.7ms)
</screen></para>

        <para>Da wird in der zweiten Zeile auf den Controller
        <classname>MoviesController</classname> und dort auf die Methode
        <methodname>show</methodname> verwiesen
        (<code>MoviesController#show</code>). Gleichzeitig wird ein Hash mit
        dem Namen <varname>params[]</varname> generiert und dort
        <varname>params[:id]</varname> auf 1 gesetzt.</para>

        <para>Danach wird überprüft, ob es sich um eine
        <filename>.html</filename> oder <filename>.xml</filename> Anfrage
        gehandelt hat. Wurde vom Browser nur <filename>1</filename> und nicht
        <filename>1.html</filename> abgefragt, setzt Rails den Default auf
        <filename>.html</filename>. In der Log-Ausgabe finden Sie den Eintrag
        "<code>as HTML</code>".</para>

        <para>Was passiert als nächstes? Denken wir noch mal über das
        MCV-Model nach. Wir haben schon das Model
        (<methodname>movies</methodname>) und wir haben den Controller
        (<classname>MoviesController</classname>). Was noch fehlt ist der View
        - also die Darstellung der Webseite. Die Views für unser Model finden
        sich alle im Unterverzeichnis
        <filename>app/view/movies</filename><screen>MacBook:movie-app sw$ <command>ls app/views/movies</command>
_form.html.erb edit.html.erb index.html.erb new.html.erb show.html.erb
MacBook:movie-app</screen></para>

        <para>Schauen wir uns mal die Datei <filename>show.html.erb</filename>
        an:<programlisting>&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%= @movie.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Production year:&lt;/b&gt;
  &lt;%= @movie.production_year %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Duration:&lt;/b&gt;
  &lt;%= @movie.duration %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Plot:&lt;/b&gt;
  &lt;%= @movie.plot %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Rating:&lt;/b&gt;
  &lt;%= @movie.rating %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_movie_path(@movie) %&gt; |
&lt;%= link_to 'Back', movies_path %&gt;
</programlisting></para>

        <para>Ist Ihnen aufgefallen, das bei dieser erb-Datei ja wichtige
        HTML-Elemente fehlen? Die sind in der Datei
        <filename>app/views/layouts/movies.html.erb</filename><programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Movies: &lt;%= controller.action_name %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag 'scaffold' %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class="alert"&gt;&lt;%= alert %&gt;&lt;/p&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

        <para>Das ist der Rahmen für alle Views des Models
        <varname>movies</varname>. Da es oft keinen Sinn macht für jedes Model
        ein eigenes Grundlayout zu generieren, kann man diese Datei auch
        löschen und stattdessen eine Datei
        <filename>app/views/layouts/application.html.erb</filename> mit dem
        Grundlayout erstellen. Die gilt dann für die gesamte
        Rails-Application. Die Zeile <code>&lt;%= yield %&gt;</code> wird
        dabei immer von der aufzurufenden View-Datei ersetzt.</para>
      </section>
    </section>

    <section xml:id="dvd-index-html">
      <title>Beispiel /movies (Index aller Datensätze)</title>

      <para>Da der Grundweg im letzten Segment erklärt wurde, gehe ich jetzt
      auf die schnelle durch die Anfrage <uri
      xlink:href="http://localhost:3000/movies">http://0.0.0.0:3000/movies</uri>.
      Hier noch mal den Screenshot dazu:<screenshot>
          <info>
            <title>Index-Ansicht aller Filme</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/movies_index.jpg" format="JPG"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Im Log erscheint:<screen>Started GET "/movies" for 127.0.0.1 at 2010-04-05 11:02:42
  Processing by MoviesController#index as HTML
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.6ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (28.2ms)
Completed 200 OK in 47ms (Views: 31.2ms | ActiveRecord: 1.1ms)
</screen></para>

      <para>Es geht also zu der Methode <methodname>index</methodname> der
      Klasse <classname>MoviesController</classname>
      (<code>MoviesController#index</code>). Diese Klasse wird in der Datei
      <filename>app/controllers/movies_controller.rb</filename> definiert.
      Schauen wir mal rein, was da bei der Methode
      <methodname>index</methodname> steht:<programlisting>  # GET /movies
  # GET /movies.xml
  def index
    @movies = Movie.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @movies }
    end
  end
</programlisting></para>

      <para>In der Instance-Variable <varname>@movies</varname> wird diesmal
      ein Array aus allen Datensätze die mit <code>Movie.all</code> angezeigt
      werden gespeichert. Da es sich um eine html-Anfrage handelt wird als
      nächstes der View <filename>app/views/movies/index.html.erb</filename>
      gerendert. Ein Blick in diese erb-Datei:<programlisting>&lt;h1&gt;Listing movies&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Production year&lt;/th&gt;
    &lt;th&gt;Duration&lt;/th&gt;
    &lt;th&gt;Plot&lt;/th&gt;
    &lt;th&gt;Rating&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @movies.each do |movie| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= movie.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.production_year %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.duration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.plot %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.rating %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', movie %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_movie_path(movie) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', movie, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Movie', new_movie_path %&gt;
</programlisting></para>

      <para>In der Zeile "<code>&lt;% @movies.each do |movie| %&gt;</code>"
      wird mit der Iternator-Methode <methodname>each</methodname> das Array
      <varname>@movies</varname> Eintrag für Eintrag angezeigt. Jeder Eintrag
      wird dann für den Block in der lokalen Variable <varname>movie</varname>
      gespeichert und die wird dann im Block der mit "<code>&lt;% end
      %&gt;</code>" endet dazu benutzt den Inhalt des Eintrages
      darzustellen.</para>
    </section>
  </section>
</chapter>
