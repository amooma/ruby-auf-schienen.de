<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="erste_schritte_mit_rails" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="erste_schritte_mit_rails.title">Erste Schritte mit
  Rails</title>

  <section>
    <title>Einleitung</title>

    <para>Nachdem Sie sich im <xref linkend="ruby-grundlagen" /> Kapitel
    mühsam in die Ruby-Grundlagen eingelesen haben, können wir jetzt
    spannender weitermachen. In diesem Kapitel starten wir ein erstes
    Rails-Projekt und arbeiten uns damit Stück für Stück in die Materie
    ein.</para>

    <para>Auch in diesem Kapitel wird es manchmal hoppla-hopp zu gehen. Wir
    stossen auf typische Henne-Ei-Probleme wir zum Beispiel: "Wie erkläre ich
    MVC (Model-View-Controller)?". Ich habe mich für den "Wir fangen mal an
    und erklären bei der Arbeit."-Ansatz entschieden.</para>

    <para>Als erstes kleines Projekt erstellen wir eine kleine
    Filmdatenbank.</para>
  </section>

  <section xml:id="arbeits-umgebung-development">
    <title>Arbeits-Umgebung (Development)</title>

    <para>Rails kennt drei verschiedene Arbeits-Umgebungen:<itemizedlist>
        <listitem>
          <para>Development</para>
        </listitem>

        <listitem>
          <para>Testing</para>
        </listitem>

        <listitem>
          <para>Production</para>
        </listitem>
      </itemizedlist></para>

    <para>Wir arbeiten in diesem Kapitel nur mit der Development Umgebung. So
    bald Sie ein besseres Gefühl für Rails bekommen haben, starten wir mit
    Tests und benötigen dafür die entsprechende Umgebung (dort wird z.B. beim
    Start eines Tests die Test-Datenbank neu gefühlt und beim Beenden wird
    gelöscht). Später erkläre ich Ihnen dann die verschiedenen Szenarien, wie
    Sie Ihre Rails-Applikation aus der Development-Umgebung in die
    Production-Umgebung ausrollen können.</para>

    <para>Die Development-Umgebung bringt bis auf einen Editor und einen
    Webbrowser alles mit, was Sie zum Entwickeln benötigen. So müssen Sie
    nicht extra einen Webserver installieren, sondern können den eingebauten
    Rails-Webserver benutzen. Der besticht nicht durch extreme Performance,
    aber das benötigen wir bei der Entwicklung ja auch nicht. Später kann man
    dann auf grosse Systeme wie <application>Apache</application> umsteigen.
    Das gleiche gilt für die Datenbank.</para>

    <para>Um in der Development-Umgebung zu arbeiten, müssen Sie erst mal
    nichts verändern. Alle Befehle gelten per Default auf die
    Development-Umgebung.</para>

    <section xml:id="sqlite3_datenbank_default">
      <title>sqlite3 Datenbank</title>

      <para>Auch bei der Datenbank geht es in diesem Kapitel nicht um optimale
      Performance, sondern um einen einfachen Einstieg. Deshalb benutzen wir
      die sqlite3 Datenbank. Dafür haben Sie bereits alles fertig installiert
      und müssen sich keinen Kopf machen. Später erkläre ich Ihnen dann wie
      Sie andere Datenbank (z.B. MySQL) ansteuern können.</para>
    </section>
  </section>

  <section xml:id="neues_rails_projekt_starten">
    <title>Ein neues Railsprojekt starten</title>

    <para>Als aller erstes müssen wir mal ein neues Rails-Projekt erstellen.
    Da Ruby on Rails ein Framework ist, müssen wir erst mal die entsprechende
    Verzeichnisstruktur und die Grundkonfiguration inkl. einiger Skripte
    einrichten. Das geht aber mit dem <command>rails
    movie-application</command> ratz-fatz.<tip>
        <para>Bitte überprüfen Sie an dieser Stelle, ob Sie auch wirklich mit
        der Ruby Version 1.9.1 und Rails 3.0.x arbeiten (<command>ruby
        -v</command> und <command>rails -v</command>). An sonsten werden Sie
        irgendwann in Merkwürdigkeiten laufen. Falls Sie beides noch nicht
        installiert haben finden Sie weitere Infos im <xref
        linkend="installation-und-versionsauswahl" /> .</para>
      </tip><screen>MacBook:Development sw$ <command>rails movie-application</command>
      create  
      create  README
      create  .gitignore
      create  Rakefile
      create  config.ru
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/models
      create  app/views/layouts
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      create  config/initializers
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/cookie_verification_secret.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/session_store.rb
      create  config/locales
      create  config/locales/en.yml
      create  config/boot.rb
      create  config/database.yml
      create  db
      create  db/seeds.rb
      create  doc
      create  doc/README_FOR_APP
      create  lib
      create  lib/tasks
      create  lib/tasks/.gitkeep
      create  log
      create  log/server.log
      create  log/production.log
      create  log/development.log
      create  log/test.log
      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js
      create  script
      create  script/rails
      create  test
      create  test/performance/browsing_test.rb
      create  test/test_helper.rb
      create  test/fixtures
      create  test/functional
      create  test/integration
      create  test/unit
      create  tmp
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
MacBook:Development sw$ </screen></para>

    <para>Rails hat das Verzeichnis <filename>movie-application</filename>
    angelegt und in dieses Verzeichnis die Grundstruktur einer
    Rails-Applikation gespeichert.</para>

    <para>Als erstes prüfen wir mal, ob diese neue Applikation funktioniert.
    Dazu welchen wir in das neue Verzeichnis und starten mitgelieferten
    kleinen Web-Server.<footnote>
        <para>Nein, keine Angst. Das ist nicht der Webserver, mit dem wir
        später auch Produktiv gehen. Aber zum Entwickeln ist diese Variante
        sehr praktisch.</para>
      </footnote><note>
        <para>Bei verschiednen Betriebssystemen (z.B. Mac OS X) kommt beim
        ersten Starten einer Rails-Applikation, je nach Firewall Einstellung,
        ein Fenster, das Sie fragt, ob die Firewall die entsprechende
        Verbindung erlauben soll. Da wir lokal arbeiten, können Sie das mit
        ruhigen Gewissen bejahen.</para>
      </note><screen>MacBook:Development sw$ <command>cd movie-application</command> 
MacBook:movie-application sw$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-03 17:30:42] INFO  WEBrick 1.3.1
[2010-04-03 17:30:42] INFO  ruby 1.9.1 (2010-01-10) [i386-darwin10.3.0]
[2010-04-03 17:30:42] INFO  WEBrick::HTTPServer#start: pid=18770 port=3000
</screen></para>

    <para>Der Start der Rails Applikation sieht gut aus. Zum Testen rufen wir
    jetzt mit dem Webbrowser die URL http://0.0.0.0:3000 auf.<screenshot>
        <info>
          <title>Default Seite in einem frischen Rails-Projekt.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/virgin_rails_app.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn wir jetzt auf den "About your application's environment" link
    klicken erscheint eine Aufstellung der aktuellen Umgebung.<screenshot>
        <info>
          <title>Auflistung der Start-Umgebung der Rails-Applikation.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/virgin_rails_app_env_info.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Gleichzeitig wird im Log des Webservers folgendes angezeigt:<screen>Started GET "/rails/info/properties" for 127.0.0.1 at 2010-04-03 17:38:38
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.6ms)
Completed 200 OK in 28ms (Views: 1.5ms | ActiveRecord: 0.3ms)
</screen></para>

    <para>Da beim Aufruf der ersten Startseite kein entsprechender Eintrag
    erschien, muss es sich um zwei verschiedenartige Seiten handeln. Die erste
    Seite ist tatsächlich eine statische HTML-Seite, die unter
    <filename>public/index.html</filename> abgespeichert ist und der Link, auf
    den wir geklickt haben führt ein Rails Programm aus.</para>

    <para>Mit <keycode>CTRL + C</keycode> können Sie den Webserver wieder
    stoppen.</para>

    <section xml:id="logging">
      <title xml:id="logging.title">Logging</title>

      <para>In der Datei <filename>log/development.log</filename> finden Sie
      das Log des Webservers. Bei der Entwicklung von Rails-Applikationen ist
      es oft sehr praktisch immer ein Terminal offen zu haben, das mit einem
      <command>tail -f log/development.log</command> diese Datei
      anzeigt.<screen>MacBook:movie-application sw$ <command>tail -f log/development.log</command> 

Started GET "/rails/info/properties" for 127.0.0.1 at 2010-04-03 17:38:38
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.6ms)
Completed 200 OK in 28ms (Views: 1.5ms | ActiveRecord: 0.3ms)
</screen></para>

      <section xml:id="logging-statische-oder-dynamische-seite">
        <title>Statische und dynamisch generierte Seiten</title>

        <para>Statische Seite wie die default <filename>index.html</filename>
        oder auch die 404.html Fehler-Seite liegen im Unterverzeichnis
        public<screen>MacBook:movie-application sw$ <command>ls public</command>
404.html  500.html     images      javascripts  stylesheets
422.html  favicon.ico  index.html  robots.txt
MacBook:movie-application sw$</screen></para>

        <para>Die Auslieferung einer solchen Seite oder einer Datei aus diesem
        Verzeichnis wird nicht im <filename>log/development.log</filename>
        angezeigt. Übrigens haben die Dateien im public-Verzeichnis eine
        höhere Prio, als die dynamisch gerenderten Seiten. Falls Sie also zwei
        Seiten mit dem gleichen Namen haben, dann wird Rails die statische
        Variante ausliefern. Deshalb werden Sie später die
        <filename>index.html</filename> Seite entweder umbenennen oder ganz
        löschen müssen (sonst würde Ihre Applikation immer nur mit dieser
        statischen Webseite starten).</para>
      </section>
    </section>
  </section>

  <section xml:id="scaffolding">
    <title xml:id="scaffolding.title">Scaffolding</title>

    <para>Die typischen "Ich zeige Euch mal Ruby on Rails in 15 Minuten"
    Videos im Internet arbeiten alle mit der Magie des Scaffolding.
    Scaffolding steht dabei für ein auf den ersten Blick sehr mächtiges
    Grundgerüst mit einer fertigen GUI zum Arbeiten mit einer
    Datenbanktabelle. Leider ist dieses Vorgehen meistens kontraproduktiv,
    weil man zwar sehr schnell dieses Grundgerüst stehen hat, aber danach erst
    mal im Regen steht. Das alte "ohne Ruby-Grundkenntnisse kommt man nicht
    weiter"-Problem schlägt zu. Aber Sie haben sich ja schon das <xref
    linkend="ruby-grundlagen" /> Kapitel gekämpft. Falls nicht, sollten Sie es
    jetzt nachholen.</para>

    <section xml:id="activerecord">
      <title xml:id="activerecord.title">ActiveRecord</title>

      <para>Ein ganz wichtiges Element für Rails ist ActiveRecord. Es
      übernimmt für den Programmierer transparent die Arbeit mit der
      SQL-Datenbank und stellt Tabellen und einzelne Tabellen-Zeilen als
      Objekte zur Verfügung. Um das zu ermöglichen hat man sich auf bestimmte
      Namenskonventionen geeinigt. In früheren Rails-Versionen musste man die
      Datenbank von Hand anhand dieser Konventionen anlegen. ActiveRecord hat
      dann die Felder an bestimmten Namensmerkmalen erkannt. Heute gibt es in
      Rails dazu eigene noch dazu äusserst praktische Tools. Denn Sie wollen
      ja nicht nur jetzt eine Datebank für Ihre Entwicklungs-Umgebung
      einrichten, sondern benötigen später auch ein Tool, das Ihre
      Produktions-Datenbank Schritt für Schritt mitzieht.</para>

      <para>Wir wollen Filme katalogisieren. Dazu benötigen wir mindestens
      folgende Datenbankfelder:<itemizedlist>
          <listitem>
            <para><varname>title:string</varname> - Titel oder Name des
            Films</para>
          </listitem>

          <listitem>
            <para><varname>production_year:integer</varname> -
            Produktionsjahr</para>
          </listitem>

          <listitem>
            <para><varname>duration:integer</varname> - Dauer (in
            Minuten)</para>
          </listitem>

          <listitem>
            <para><varname>plot:text</varname> - Story des Films</para>
          </listitem>

          <listitem>
            <para><varname>rating:integer</varname> - Bewertung (als Ganzahl
            von 1 bis 5 Sterne)</para>
          </listitem>
        </itemizedlist></para>

      <section>
        <title>Warum alle Feldnamen, Methoden und Klassen auf
        Englisch?</title>

        <para>Ganz tief im Herzen liebt Rails die englische Sprache. Damit
        muss man sich abfinden und versuchen diese Liebe zu übernehmen. So
        verwenden sehr viele Mechanismen automagisch Plural oder Singular von
        Englischen Wörtern. Wenn man sich damit anfreundet Datenbankfelder und
        Datenbanken an sich mit englischen Wörter zu benennen, dann kann man
        die ganze Macht dieser Magie ausnutzen.</para>
      </section>

      <section xml:id="dvd-ist-das-ein-model">
        <title>Ist das jetzt ein Model (laut der MVC-Idee)?</title>

        <para>Kurze Antwort: Ja. Wir müssen dem Model nur noch einen Namen
        geben. "<varname>movie</varname>" macht wohl im Englischen am meisten
        Sinn.</para>
      </section>
    </section>

    <section xml:id="rails_generate_scaffold">
      <title xml:id="rails_generade_scaffold.title">rails generate
      scaffold</title>

      <para>Mit dem Rails-Skript-Aufruf <command>rails generate
      scaffold</command> kann man fertige Code generieren. Wer (wie ich) gerne
      mal vergisst wie das Skript aufgerufen werden muss, der gibt einfach
      <filename>rails generate</filename> ein und bekommt die folgende Hilfe
      angezeigt:<screen>MacBook:movie-application sw$ <command>rails generate</command>
Usage: rails generate GENERATOR [args] [options]

General options:
  -h, [--help]     # Print generators options and usage
  -p, [--pretend]  # Run but do not make any changes
  -f, [--force]    # Overwrite files that already exist
  -s, [--skip]     # Skip files that already exist
  -q, [--quiet]    # Supress status output

Please choose a generator below.

Rails:
  controller
  generator
  helper
  integration_test
  mailer
  metal
  migration
  model
  observer
  performance_test
  plugin
  resource
  scaffold
  scaffold_controller
  session_migration
  stylesheets

MacBook:movie-application sw$</screen></para>

      <para>Interessant ist für uns der Teil "Please choose a generator
      below.". Wenn wir <parameter>scaffold</parameter> benutzen wollen und
      dazu weitere Hilfe brauchen, dann geht dies wiederrum einfach mit der
      eingebauten Hilfe:<screen>MacBook:movie-application sw$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME                  # Orm to be invoked
                                  # Default: active_record
      [--force-plural]            # Forces the use of a plural ModelName
      [--singleton]               # Supply to create a singleton controller
  -c, --scaffold-controller=NAME  # Scaffold controller to be invoked
                                  # Default: scaffold_controller
  -y, [--stylesheets]             # Indicates when to generate stylesheets
                                  # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Erb options:
  [--layout]  # Indicates when to generate layout
              # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attribute pairs are field:type arguments specifying the
    model's attributes. Timestamps are added by default, so you don't have to
    specify them by hand as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title:string body:text published:boolean'
    gives you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a resources :posts
    declaration in config/routes.rb.

    If you want to remove all the generated files, run
    'rails destroy scaffold ModelName'.

Examples:
    `rails generate scaffold post`
    `rails generate scaffold post title:string body:text published:boolean`
    `rails generate scaffold purchase order_id:integer amount:decimal`
MacBook:movie-application sw$</screen></para>

      <para>Wir müssen also nach <command>rails generate scaffold</command>
      den Namen des Models (bei uns "movie") und danach die Datenbankfelder
      mit den entsprechenden Feldtypen angeben.</para>

      <para>Dann legen wir mal los:<screen>MacBook:movie-application sw$ <command>rails generate scaffold movie title:string production_year:integer duration:integer plot:text rating:integer</command>
      invoke  active_record
      create    db/migrate/20100404113234_create_movies.rb
      create    app/models/movie.rb
      invoke    test_unit
      create      test/unit/movie_test.rb
      create      test/fixtures/movies.yml
       route  resources :movies
      invoke  scaffold_controller
      create    app/controllers/movies_controller.rb
      invoke    erb
      create      app/views/movies
      create      app/views/movies/index.html.erb
      create      app/views/movies/edit.html.erb
      create      app/views/movies/show.html.erb
      create      app/views/movies/new.html.erb
      create      app/views/movies/_form.html.erb
      create      app/views/layouts/movies.html.erb
      invoke    test_unit
      create      test/functional/movies_controller_test.rb
      invoke    helper
      create      app/helpers/movies_helper.rb
      invoke      test_unit
      create        test/unit/helpers/movies_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
MacBook:movie-application sw$</screen>Und schon ist alles fertig. Allerdings
      ist in der Datenbank noch keine entsprechende Tabelle angelegt.</para>
    </section>

    <section xml:id="migration">
      <title xml:id="migration.title">Migrationen</title>

      <para><application>In der zweiten Ausgabezeile des Scaffoldings sehen
      wir die Ausgabe:</application><screen>      create    db/migrate/20100404113234_create_movies.rb
</screen></para>

      <para>In der Datei
      <filename>db/migrate/20100404113234_create_movies.rb</filename> finden
      sich die Anweisung, mit der die Datenbank erstellt (<code>def
      self.up</code>) und auch beim Roll-Back (<code>def self.down</code>)
      wieder gelöscht werden kann.<programlisting>class CreateMovies &lt; ActiveRecord::Migration
  def self.up
    create_table :movies do |t|
      t.string :title
      t.integer :production_year
      t.integer :duration
      t.text :plot
      t.integer :rating

      t.timestamps
    end
  end

  def self.down
    drop_table :movies
  end
end
</programlisting></para>

      <para>Die in dieser Ruby-Datei angelegte Klasse
      <classname>CreateMovies</classname> ist ein Kind der Klasse
      <classname>ActiveRecord::Migration</classname> (siehe Zeile 1) und hat
      zwei Methoden:<itemizedlist>
          <listitem>
            <para><methodname>self.up</methodname> (Zeile 2). Wird aufgerufen,
            wenn die Migration durchgeführt wird.</para>
          </listitem>

          <listitem>
            <para><methodname>self.down</methodname> (Zeile 14). Wird
            aufgerufen, wenn für eine Migration ein Rollback durchgeführt
            wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Die Migration (also das Anlegen der Datenbank) wird mit
      <command>rake db:migrate</command> durchgeführt:<screen>MacBook:movie-application sw$ <command>rake db:migrate</command>
(in /Users/sw/Development/movie-application)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0015s
==  CreateMovies: migrated (0.0017s) ==========================================

MacBook:movie-application sw$</screen></para>

      <para>Die Datenbank-Tabelle <varname>movies</varname> wird angelegt.
      Dabei sehen wir, das Tabellen-Namen automatisch den Plural der Models
      bekommen. Aber welche Datenbank wird überhaupt benutzt? Das wird in der
      Konfigurationsdatei <filename>config/database.yml</filename>
      definiert:<screen>MacBook:movie-application sw$ <command>cat -n config/database.yml</command> 
     1 # SQLite version 3.x
     2 #   gem install sqlite3-ruby (not necessary on OS X Leopard)
     3 development:
     4   adapter: sqlite3
     5   database: db/development.sqlite3
     6   pool: 5
     7   timeout: 5000
     8 
     9 # Warning: The database defined as "test" will be erased and
    10 # re-generated from your development database when you run "rake".
    11 # Do not set this db to the same as development or production.
    12 test:
    13   adapter: sqlite3
    14   database: db/test.sqlite3
    15   pool: 5
    16   timeout: 5000
    17 
    18 production:
    19   adapter: sqlite3
    20   database: db/production.sqlite3
    21   pool: 5
    22   timeout: 5000
MacBook:movie-application sw$</screen></para>

      <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe
      <uri xlink:href="http://www.yaml.org/">http://www.yaml.org/</uri> bzw.
      <uri
      xlink:href="http://de.wikipedia.org/wiki/YAML">http://de.wikipedia.org/wiki/YAML</uri>)
      definiert. Für uns wichtig ist erst mal nur die development-Datenbank
      (Zeile 3 bis 7). Per default benutzt Rails dort
      <application>Sqlite3</application>. Sqlite3 mag nicht die richtige Wahl
      für die Analyse der weltweit gesammelten Wetterdaten sein, aber für die
      schnelle und unkompliziete Entwicklung von Rails-Anwendungen lernt man
      sie schnell zu schätzen. In der Produktions-Umgebung kann man später
      immer noch auf "grosse" Datenbanken wie MySQL umsteigen.<footnote>
          <para>Es gibt unter einigen Entwicklern die Ansicht, das man auf
          jeden Fall immer mit der gleichen Datenbank entwicklen soll, die man
          später auch in der Produktion und im Testing benutzt. Das sollte
          aber jeder für sich selbst entscheiden.</para>
        </footnote></para>

      <para>Um Ihre Neugierde zu befriedigen, schauen wir uns kurz noch die
      Datenbank mit dem Command-Line-Tool <application>sqlite3</application>
      an.<screen>MacBook:movie-application sw$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
movies             schema_migrations
sqlite&gt; <command>.schema movies</command>
CREATE TABLE "movies" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; <command>.quit</command>
MacBook:movie-application sw$</screen></para>

      <para>Das Anlegen der Tabelle mit <command>rake db:migrate</command>
      wurde natürlich auch im <filename>log/development.log</filename>
      eingetragen:<screen>  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
Migrating to CreateMovies (20100404113234)
  SQL (0.1ms)  select sqlite_version(*)
  SQL (0.4ms)  CREATE TABLE "movies" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20100404113234')
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.0ms)  PRAGMA index_list("movies")
</screen></para>

      <section xml:id="active-record-auto-felder">
        <title>Automatisch zugefügte Felder (id, created_at und
        updated_at)</title>

        <para>Rails ist so freundlich uns beim Scaffolding per Default
        folgende Felder hinzuzufügen:<itemizedlist>
            <listitem>
              <para><varname>id:integer</varname></para>

              <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von
              der Datenbank automatisch hochgezählt. Für alle SQL-Fans:
              AUTOINCREMENT NOT NULL</para>
            </listitem>

            <listitem>
              <para><varname>created_at:datetime</varname></para>

              <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
              eines Datensatzes gefüllt.</para>
            </listitem>

            <listitem>
              <para><varname>updated_at:datetime</varname></para>

              <para>Das Feld wird bei jeder Veränderung des Datensatzes
              automatisch an die aktuelle Zeit angepasst.</para>
            </listitem>
          </itemizedlist></para>

        <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
        Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten
        Felder schätzen.</para>
      </section>

      <section xml:id="migration-rollback">
        <title>Migration Rollback</title>

        <para>Es soll schon vorgekommen sein, das übereilt eine Migration
        durchgeführt wurde. Natürlich passiert weder Ihnen noch mir so was.
        ;-) Aber falls mal ein Freund von Ihnen in diese Predulie gerät: Keine
        Panik! Dafür wurde in der Migrations-Class die Methode
        <methodname>self.down</methodname> angelegt. Testweise können wir ja
        mal unsere letzte Migration zurückrollen:<screen>MacBook:movie-application sw$ <command>rake db:rollback</command>
(in /Users/sw/Development/movie-application)
==  CreateMovies: reverting ===================================================
-- drop_table(:movies)
   -&gt; 0.1004s
==  CreateMovies: reverted (0.1005s) ==========================================

MacBook:movie-application sw$</screen></para>

        <para>Sie können alles auf einmal zurück-rollen oder auch nur einzelne
        Migrationen. Mit dem Schalter <parameter>-T</parameter> bekommen Sie
        eine Hilfe zu allen möglichen Wegen aufgezeigt:<screen>MacBook:movie-application sw$ <command>rake -T db</command>
(in /Users/sw/Development/movie-application)
rake db:abort_if_pending_migrations  # Raises an error if there are pending...
rake db:charset                      # Retrieves the charset for the curren...
rake db:collation                    # Retrieves the collation for the curr...
rake db:create                       # Create the database defined in confi...
rake db:create:all                   # Create all the local databases defin...
rake db:drop                         # Drops the database for the current R...
rake db:drop:all                     # Drops all the local databases define...
rake db:fixtures:identify            # Search for a fixture given a LABEL o...
rake db:fixtures:load                # Load fixtures into the current envir...
rake db:forward                      # Pushes the schema to the next version.
rake db:migrate                      # Migrate the database through scripts...
rake db:migrate:down                 # Runs the "down" for a given migratio...
rake db:migrate:redo                 # Rollbacks the database one migration...
rake db:migrate:reset                # Resets your database using your migr...
rake db:migrate:up                   # Runs the "up" for a given migration ...
rake db:reset                        # Drops and recreates the database fro...
rake db:rollback                     # Rolls the schema back to the previou...
rake db:schema:dump                  # Create a db/schema.rb file that can ...
rake db:schema:load                  # Load a schema.rb file into the database
rake db:seed                         # Load the seed data from db/seeds.rb
rake db:sessions:clear               # Clear the sessions table
rake db:sessions:create              # Creates a sessions migration for use...
rake db:setup                        # Create the database, load the schema...
rake db:structure:dump               # Dump the database structure to a SQL...
rake db:test:clone                   # Recreate the test database from the ...
rake db:test:clone_structure         # Recreate the test databases from the...
rake db:test:load                    # Recreate the test database from the ...
rake db:test:prepare                 # Check for pending migrations and loa...
rake db:test:purge                   # Empty the test database
rake db:version                      # Retrieves the current schema version...
MacBook:movie-application sw$</screen></para>

        <para>Und mit <command>rake -T db:rollback</command> die Hilfe zu
        diesem bestimmten Befehl:<screen>MacBook:movie-application sw$ <command>rake -T db:rollback</command>
(in /Users/sw/Development/movie-application)
rake db:rollback  # Rolls the schema back to the previous version.
MacBook:movie-application sw$</screen></para>

        <para>Aber spielen wir lieber unsere Migration wieder ein:<screen>MacBook:movie-application sw$ <command>rake db:migrate</command>  
(in /Users/sw/Development/movie-application)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0014s
==  CreateMovies: migrated (0.0015s) ==========================================

MacBook:movie-application sw$</screen></para>
      </section>
    </section>

    <section xml:id="restful_datenbankzugriff_per_webbrowser">
      <title xml:id="restful_datenbankzugriff_per_webbrowser.title">RESTful
      Datenbankzugriff per Webbrowser</title>

      <para>Die Datenbank ist angelegt. Und der Vorteil von Scaffolding
      besteht darin, das wir jetzt auch direkt per Webbrowser in einer
      aktzeptablen Web-GUI darauf zugreifen können.</para>

      <para>Gemäss der CRUD Idee (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/CRUD">http://de.wikipedia.org/wiki/CRUD</uri>)
      bietet Rails dafür ein RESTful Webinterface an. Was heisst das? Sie
      können auf jede Resource innerhalb einer normalen Rails-Umgeben über
      definierte URLs zugreifen und damit folgende Datenbank-Operationen
      ausführen:<itemizedlist>
          <listitem>
            <para>C für CREATE</para>

            <para>SQL: <code>INSERT INTO movies (title) VALUES ('Rain
            Man')</code></para>
          </listitem>

          <listitem>
            <para>R für READ</para>

            <para>SQL: <code>SELECT * FROM movies</code></para>
          </listitem>

          <listitem>
            <para>U für UPDATE</para>

            <para>SQL: <code>UPDATE movies SET title = 'Rain Man' WHERE id =
            1</code></para>
          </listitem>

          <listitem>
            <para>D für DELETE</para>

            <para>SQL: <code>DELETE FROM movies WHERE id = 1</code></para>
          </listitem>
        </itemizedlist>Für den Rails-Neuling ist nicht direkt ersichtlich, wo
      den hier der grosse Vorteil liegt. Nachfolgend eine Mini-FAQ:<qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Warum wird um das RESTful Interface in Ruby on Rails so
                ein Bohei gemacht?</para>
              </question>

              <answer>
                <para>Damit bekommt man ein sauberes und für alle
                Programmierer leicht verständliches Interface zu Ihrem System.
                Sie brauchen nur die URI
                <uri>http://localhost:3000/movies</uri> und das Wissen, das es
                sich um ein RESTful Webdienst handelt und Sie können direkt
                loslegen.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful nur für die automatische Abfrage zwischen
                Computern gut?</para>
              </question>

              <answer>
                <para>Nein. RESTful ist auch ein guter Denkansatz, um URLs und
                damit ganze Webseiten strukturierter zu gestalten.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful Teil der <emphasis>Convention over
                Configuration</emphasis> Idee?</para>
              </question>

              <answer>
                <para>Ja! Jeder Rails-Entwickler kann sich so in kurzer Zeit
                in ein ihm neues Rails-Projekt einarbeiten.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>

      <section>
        <title>Start des Webservers</title>

        <para>Als erstes starten wir wie immer mit rails server unseren
        Entwicklungswebserver:<screen>MacBook:movie-application sw$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-04 14:56:29] INFO  WEBrick 1.3.1
[2010-04-04 14:56:29] INFO  ruby 1.9.1 (2010-01-10) [i386-darwin10.3.0]
[2010-04-04 14:56:29] INFO  WEBrick::HTTPServer#start: pid=19993 port=3000
</screen></para>
      </section>

      <section xml:id="restful_create">
        <title xml:id="restful_create.title">Create (Erstellen)</title>

        <para>Legen wir als erstes einmal einen neuen Datensatz an. Sie können
        das entsprechende Interface über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/new">http://0.0.0.0:3000/movies/new</uri>
        abrufen. Bitte benutzen Sie dieses Interface um einen Beispiel-Film
        einzutragen:<screenshot>
            <info>
              <title>Neuen Film in die Datenbank eintragen.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_new.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Nachdem Sie auf "Create Movie" geklickt haben, können Sie im
        Log-File folgenden Eintrag verfolgen:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 15:08:43
  Processing by MoviesController#create as HTML
  Parameters: {"authenticity_token"=&gt;"36ebldTKHnK4AXM9N2WFTCdzIzVtglqrsryicLEs1vE=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie \xC3\xBCber zwei sehr ungleiche Br\xC3\xBCder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Create Movie"}
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.4ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 13:08:43.139349', 133, 'Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.', 1988, 5, 'Rain Man', '2010-04-04 13:08:43.139349')
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 43ms


Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 15:08:43
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (11.7ms)
Completed 200 OK in 55ms (Views: 33.2ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Als Ergebnis bekommen Sie im Browserfenster den entsprechenden
        Eintrag angezeigt:<screenshot xml:id="screenshot_show_after_create">
            <info>
              <title>Nach dem Abspeichern wird der neue Eintrag
              angezeigt.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_new_show.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>
      </section>

      <section xml:id="restful_show">
        <title xml:id="restful_show.title">Show (Anzeigen eines einzelnen
        Datensatzes)</title>

        <para>Nach dem Erstellen (Create) eines neuen Datensatzes, können wir
        uns diesen natürlich jetzt einzeln anschauen. Da unter ActiveRecord
        automatisch eine unique ID für jeden Datensatz erstellt wird, können
        wir diese zum Aufruf benutzen. In diesem Fall ist es die 1 für den
        ersten Datensatz. Das geht über die URI
        http://0.0.0.0:3000/movies/1<screenshot xml:id="screenshot_show">
            <info>
              <title>Anzeigen des ersten Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log erscheint die folgende Ausgabe:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 16:19:38
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (8.7ms)
Completed 200 OK in 29ms (Views: 11.5ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Ihnen wird bestimmt beim Vergleich der Screenshots <xref
        linkend="screenshot_show" /> und <xref
        linkend="screenshot_show_after_create" /> aufgefallens ein, das bei
        <xref linkend="screenshot_show_after_create" /> am oben eine grüne
        Nachricht angezeigt wurde. Das ist eine sogenannte Flash-Nachricht.
        Dabei ist das Wording "Flash" meiner Meinung nach äusserst ungeschickt
        gewählt, weil bei "Flash" jeder automatisch an das Adobe-Flash-Format
        und nicht an eine Flash-artig (Flash = Blitz) erscheinende Nachricht
        denkt. So ist es aber bei Rails. Flash-Nachrichten werden immer auf
        der nächsten und nur auf der nächsten generierten Seite angezeigt. Wir
        kommen später auf Flash detailierter zu sprechen.</para>
      </section>

      <section xml:id="restful_edit">
        <title xml:id="restful_edit.title">Edit (Bearbeiten eines
        Datensatzes)</title>

        <para>Zum Editieren eines Datensatzes müssen wir wiederum die ID des
        Datensatzes kennen und können dann mit dieser (hier wieder die 1 als
        Beispiel) das Formular zum Bearbeiten des Filmes mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1/edit">http://0.0.0.0:3000/movies/1/edit</uri>
        aufrufen:<screenshot>
            <info>
              <title>Formular zum Editieren eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_edit.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File gibt es folgende Ausgabe:<screen>Started GET "/movies/1/edit" for 127.0.0.1 at 2010-04-04 21:04:44
  Processing by MoviesController#edit as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/_form.html.erb (72.8ms)
Rendered movies/edit.html.erb within layouts/movies (77.1ms)
Completed 200 OK in 120ms (Views: 106.3ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Durch klicken auf "Update Movie" können wir dann den Datensatz
        updaten und bekommen ihn dann wieder im Show-View
        angezeigt:<screenshot>
            <info>
              <title>Der Show-View nach dem Update des Datensatzes.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show_after_update.jpg"
                           format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Auch hier wird wieder mit einer Flash-Message ein Feedback vom
        System zum User gegeben.</para>

        <para>Im Log-File sieht man das Update wie folgt:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-04-04 21:05:23
  Processing by MoviesController#update as HTML
  Parameters: {"authenticity_token"=&gt;"Udc8Uy1kiOW0Gj2hMW72ws5HEPrLNL9ewCLiPyhR+YM=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"", "rating"=&gt;"5"}, "commit"=&gt;"Update Movie", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.4ms)  UPDATE "movies" SET "plot" = '', "updated_at" = '2010-04-04 19:05:23.696771' WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 342ms


Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 21:05:23
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (9.0ms)
Completed 200 OK in 51ms (Views: 35.8ms | ActiveRecord: 0.2ms)
</screen></para>
      </section>

      <section xml:id="restful_index">
        <title xml:id="restful_index.title">Index (Anzeigen aller
        Datensätze)</title>

        <para>Über die URI http://0.0.0.0:3000/movies können Sie sich eine
        Liste aller Filme in der Datenbank anzeigen lassen (logischerweise ist
        das bis jetzt nur ein Film):<screenshot>
            <info>
              <title>Index-Ansicht aller Filme</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_index.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File findet sich folgende Ausgabe:<screen>Started GET "/movies" for 127.0.0.1 at 2010-04-04 16:26:30
  Processing by MoviesController#index as HTML
  Movie Load (0.5ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (9.9ms)
Completed 200 OK in 43ms (Views: 29.5ms | ActiveRecord: 0.4ms)
</screen></para>
      </section>

      <section>
        <title>Löschen eines Datensatzes</title>

        <para>Wenn Sie auf der Index-Seite auf "Destroy" klicken, so bekommen
        Sie folgende Meldung angezeigt:<screenshot>
            <info>
              <title>Sicherheitsabfrage beim Löschen eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/destroy_r_u_sure.jpg"
                           format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Klicken wir jetzt mutig auf "OK", bekommen wir wieder die
        Index-Seite, aber diesmal ganz ohne einen Film angezeigt:<screenshot>
            <info>
              <title>Index-Ansicht nach dem Löschen des einzigen
              Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/index_after_destroy.jpg"
                           format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Zum Schluss noch der obligatorische Blick in das
        Log-File:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-04-04 16:34:46
  Processing by MoviesController#destroy as HTML
  Parameters: {"authenticity_token"=&gt;"xzdq0dePdnVUkBpqbDEXPhPdAo/NhTM3U/lVtjzPTds=", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.3ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 25ms
</screen></para>
      </section>
    </section>

    <section>
      <title>Routen</title>

      <para>Fassen wir mal kurz zusammen: Man kann also mit Scaffolding eine
      Web-GUI erstellen und auf diese Web-GUI anscheinen über eine feste
      CRUD-Stuktur zugreifen. Jetzt wäre ja mal interessant zu wissen, ob es
      noch mehr URIs gibt. Rails steuert das über sogenannte Routen. Alle
      Routen werden in der Datei <filename>config/routes.rb</filename>
      definiert. Standardmässig sind in dieser Datei recht viele Beispiele als
      Kommentare eingebaut. Schauen wir uns mal an, wie die aktuelle
      Konfiguration ohne diese Kommentare aussieht:<screen>MacBook:movie-application sw$ <command>cat config/routes.rb | grep -v "#" | grep -v "^$"</command>
MovieApp::Application.routes.draw do |map|
  resources :movies
end
MacBook:movie-application sw$</screen></para>

      <para>Interessant ist die Zeile:<programlisting>  resources :movies</programlisting></para>

      <para>Diese Zeile sagt Rails, das es die Resource movies mit allen
      Standard Routen ausstatten soll. Diese Routen können wir uns mit
      <command>rake routes</command> anzeigen lassen.<screen>MacBook:movie-application sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-application)
           GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
    movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
 new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
           GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
           PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
     movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
MacBook:movie-application sw$</screen></para>

      <para>Puh... das sind ja viel mehr, als wir oben benutzt haben. Oder
      doch nicht? Und jetzt muss ich das auch noch sinnvoll und strukturiert
      erklären! ;-)</para>

      <para>CRUD besteht zwar aus den vier Teilen Create, Read, Upate und
      Delete, aber diese Einzelelemente müssen in der RESTful Umsetzung weiter
      aufgeschlüsselt werden. Ziel bei REST ist es, das man eine
      Abfrage-Methodik definiert, die von allen Entwicklern gleich verstanden
      und auch benutzt werden kann. Dazu werden bei Webzugriffen die URIs und
      die HTTP-Verben benutzt. Was HTTP-Verben sind? Ich habe die Frage
      befürchtet. Bei der Entwicklung des HTTP-Protokolles wurden verschiedene
      Abfrage-Methoden definiert. Sie haben bestimmt bei einem HTML-Formular
      schon mal vom Unterschied zwischen GET und POST gelesen. GET und POST
      sind genau solche Verben. Für uns weiterhin interessant sind PUT und
      DELETE. Gerne verweise ich an dieser Stelle auf das RFC 2616 (<uri
      xlink:href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</uri>),
      falls Sie sich mit dieser Materie näher beschäftigen wollen.</para>

      <para>Für uns ist jetzt erst mal nur interessant, das gleiche URIs die
      mit unterschiedlichen Verben angesprochen werden unterschiedliche
      Aktionen in Ihrer Rails-Applikation auslösen. So können Sie in unserer
      Filmdatenbank über die URI <uri
      xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
      sowohl mit GET eine Liste (Index) aller Filme anfordern, als auch mit
      POST einen neuen Filmeintrag abspeichern.</para>

      <para>Die Kombination aus Verb und URI wird in Rails als Route
      bezeichnet. Ist eine Route nicht definiert, passiert auch nichts. Ist
      eine Route definiert, dann wird damit auf eine "Action" und einen
      "Controller" verwiesen. Ich würde jetzt gerne erklären, was es mit
      beidem auf sich hat, aber vorher will ich noch kurz <xref
      linkend="restful_mit_xml" /> besprechen, damit wir das aktuelle Thema
      RESTful Zugriff sauber abgeschlossen haben.</para>
    </section>

    <section xml:id="restful_mit_xml">
      <title xml:id="restful_mit_xml.title">RESTful Datenbankzugriff per XML
      und curl</title>

      <para>Das XML-Interface erleichtert den Austausch von Daten zwischen
      Maschinen. Dabei wird der ganze HTML-Balast abgeworfen und nur noch die
      reinen Daten per XML ausgetauscht. Beispielhaft führen wir dies mit dem
      Programm curl durch. Logischerweise geht es natürlich auch mit anderen
      Programmen oder Programmiersprachen. Wer die Art und Weise verstanden
      hat, kann von beliebigen Systemen eine Rails Applikation bedienen. Da
      dies naturgemäss auch gewisse Gefahren in sich birgt (z.B. kann eine
      Maschine per Brute-Force-Attacke schnell wie Unheil anrichten), kann man
      per Default bestimmte Aktionen nicht durchführen. Dies wird in der Datei
      <filename>app/controllers/application_controller.rb</filename> mit
      <code>protect_from_forgery</code> konfiguriert. Bitte deaktiven Sie
      diese Zeile für diese Beispiele wie folgt mit einem
      #-Zeichen:<programlisting>class ApplicationController &lt; ActionController::Base
  # protect_from_forgery
end
</programlisting></para>

      <para>Dadurch entfällt eine per default aktivierte Sicherheitsschicht,
      die einen Token austauscht, um die anonyme Interaktion von aussen zu
      underbinden. Im Log-File werden Sie den Unterschied merken (es fehlt der
      Eintrag <code>"authenticity_token"=&gt;"xyz"</code>). In späteren
      Kapiteln besprechen wir Authentifizierungsmechanismen um diese Zugriffe
      mit Passwörtern abzusichern.</para>

      <section>
        <title>new</title>

        <para>Um einen neuen Film einzutragen, benötigen Sie als erstes die
        Felder die ausgefüllt werden müssen. Dazu können Sie die URL <uri
        xlink:href="http://0.0.0.0:3000/movies/new.xml">http://0.0.0.0:3000/movies/new.xml</uri>
        abrufen:<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/new.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime" nil="true"&gt;&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer" nil="true"&gt;&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title nil="true"&gt;&lt;/title&gt;
  &lt;updated-at type="datetime" nil="true"&gt;&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/new.xml" for 127.0.0.1 at 2010-04-04 19:28:19
  Processing by MoviesController#new as XML
Completed 200 OK in 124ms (Views: 111.1ms | ActiveRecord: 0.0ms)
</screen></para>

        <para>In der XML-Ausgabe können wir erkennen wie die einzelnen Felder
        heissen und welche Typen (z.B. Integer) sie darstellen. Mit diesen
        Informationen können wir jetzt einen create Aufruf mit dem neuen
        Datensatz zusammenstellen:</para>

        <para>Danach können Sie mit einem create Aufruf die Daten für einen
        neuen Datensatz uploaden:<screen>MacBook:~ sw$ <command>curl -X POST -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Ausgabe im Log:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 20:30:10
  Processing by MoviesController#create as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1988"}}
  SQL (0.3ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 18:30:10.440028', 133, NULL, 1988, 5, 'Rain Man', '2010-04-04 18:30:10.440028')
Redirected to http://0.0.0.0:3000/movies/6
Completed 302 Found in 27ms
</screen></para>

        <para>Als Ergebnis des curl Aufrufes bekommen Sie die den folgenden
        Code zurück:<screen>&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
</screen></para>

        <para>Das ist also quasi wie beim Aufruf mit dem Webbrowser, nur das
        ein Show des neuen Datensatzes so beim XML-Aufruf wenig Sinn
        macht.</para>
      </section>

      <section>
        <title>index</title>

        <para>Um das Ergebnis des Index-Aufrufes sinnvoller zu gestalten, habe
        ich vorher zwei mal den Film Rain Man eingetragen. Jetzt müssen wir
        mit curl die URI <uri
        xlink:href="http://0.0.0.0:3000/movies.xml">http://0.0.0.0:3000/movies.xml</uri>
        abrufen.<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movies type="array"&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;1&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
  &lt;/movie&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;2&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/updated-at&gt;
  &lt;/movie&gt;
&lt;/movies&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies.xml" for 127.0.0.1 at 2010-04-04 20:39:09
  Processing by MoviesController#index as XML
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies"
Completed 200 OK in 23ms (Views: 9.6ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>show</title>

        <para>Einen einzelnen Film kann man sich mit der ID des Eintrages
        (hier die 1) und der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri>
        anschauen. <screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/1.xml" for 127.0.0.1 at 2010-04-04 20:40:06
  Processing by MoviesController#show as XML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Completed 200 OK in 37ms (Views: 8.8ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>edit - update</title>

        <para>Zum Editieren eines Eintrages downloaden wir diesen Eintrag erst
        wieder von der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri><screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T19:05:23Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Danach übermitteln wir den entsprechenden Eintrag mit PUT neu
        auf die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Dabei ist es egal, ob wir wirklich neue oder wieder die gleichen Daten
        übermitteln. Wichtig dabei ist, das wir die <parameter>id</parameter>
        des Eintrages mit übertragen:<screen>MacBook:~ sw$ <command>curl -X PUT -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1989&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies/1</command>    
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/1"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started PUT "/movies/1" for 127.0.0.1 at 2010-04-04 21:12:32
  Processing by MoviesController#update as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1989"}, "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.4ms)  UPDATE "movies" SET "production_year" = 1989, "updated_at" = '2010-04-04 19:12:32.237009' WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 70ms
</screen></para>

        <para>ActiveRecord ist dabei intelligent genug nur wirkliche
        Veränderungen einzutragen.</para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
        und einem DELETE Aufruf wieder aus der Datenbank löschen.<screen>MacBook:~ sw$ <command>curl -X DELETE -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started DELETE "/movies/1" for 127.0.0.1 at 2010-04-04 21:14:44
  Processing by MoviesController#destroy as */*
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.2ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 22ms
</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="die_console">
    <title xml:id="die_console.title">Die Console</title>

    <para>Sie haben im <xref linkend="ruby-grundlagen" /> Kapitel gelernt mit
    irb umzugehen. In Rails gibt es dazu ein Pondon: <command>rails
    console</command></para>

    <para>Mit der Rails Console haben Sie nicht nur die normalen irb
    Mechanismen, sondern auch direkt alle Klassen und Methoden aus Ihrer
    Rails-Applikation. Und können somit auf die Datenbank zugreifen. Diese
    werden automagisch per ActiveRecord als Objekte zur Verfügung gestellt.
    </para>

    <para>Die Rails-Console kann parallel zum Webserver oder anstatt des
    Webservers gestartet werden. Wir führen als erstes ein <command>rake
    db:reset</command> aus, damit wir eine frische und leere Datenbank zum
    Üben vorfinden. <screen>MacBook:movie-application sw$ <command>rake db:reset</command>
(in /Users/sw/Development/movie-application)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("movies", {:force=&gt;true})
   -&gt; 0.0155s
-- initialize_schema_migrations_table()
   -&gt; 0.0049s
-- assume_migrated_upto_version(20100404113234, "db/migrate")
   -&gt; 0.0026s
MacBook:movie-application sw$ </screen></para>

    <para>Danach starten wir die Console:<screen>MacBook:movie-application sw$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta2)
ruby-1.9.1-p378 &gt;</screen></para>

    <section>
      <title>Neuen Datensatz anlegen</title>

      <para>ActiveRecord stellt uns automagisch eine Klasse aus der Datenbank
      <parameter>movies</parameter> mit dem Namen <classname>Movie</classname>
      zur Verfügung. Diese KLasse hat eine Methode
      <methodname>new</methodname> und mit der können wir ein neues Objekt
      erstellen.<screen>ruby-1.9.1-p378 &gt; <command>terminator = Movie.new</command>
 =&gt; #&lt;Movie id: nil, title: nil, production_year: nil, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Wir können uns sicherheitshalber noch mal die KLasse der Instance
      terminator ausgeben lassen.<screen>ruby-1.9.1-p378 &gt; <command>terminator.class</command>
 =&gt; Movie(id: integer, title: string, production_year: integer, duration: integer, plot: text, rating: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Das neue Objekt terminator hat automatsch Accessors (siehe <xref
      linkend="getter_und_setter_methoden" />) zu den einzelnen Datenfeldern.
      Diese benutzen wir zum Füllen mit einem Beispieldatensatz.<screen>ruby-1.9.1-p378 &gt; <command>terminator.title = 'The Terminator'</command>
 =&gt; "The Terminator" 
ruby-1.9.1-p378 &gt; <command>terminator.production_year = 1984</command>
 =&gt; 1984 
ruby-1.9.1-p378 &gt; <command>terminator</command>
 =&gt; #&lt;Movie id: nil, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Objekt ist allerdings noch nicht in der Datenbank gespeichert.
      Das erfolgt erst durch Aufruf der Methode
      <methodname>save</methodname>.<screen>ruby-1.9.1-p378 &gt; <command>terminator.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Alternative können wir einen zweiten Datensatz auch direkt mit der
      Methode <methodname>create</methodname> anlegen.<screen>ruby-1.9.1-p378 &gt; <command>Movie.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })</command>
 =&gt; #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:39:22", updated_at: "2010-04-04 19:39:22"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <section>
        <title>Hilfe zu create</title>

        <para>Die Methode <methodname>create</methodname> gehört zu
        <classname>ActiveRecord::Base</classname>. Die online Hilfe dazu kann
        mit <application>ri</application> abgerufen werden. Wenn Sie das jetzt
        ausprobieren wollen, müssen Sie natürlich erst mit
        <command>exit</command> aus der Console raus.<screen>Stefan-Wintermeyers-MacBook-Pro-2008-50:movie-application sw$ <command>ri ActiveRecord::Base.create</command>
--------------------------------------------- ActiveRecord::Base::create
     ActiveRecord::Base::create(attributes = nil, &amp;block) {|object| ...}

     From
     /Users/sw/.rvm/gems/ruby-1.9.1-p378/doc/activerecord-3.0.0.beta2/ri
     /ActiveRecord/Base/cdesc-Base.yaml
------------------------------------------------------------------------
     Creates an object (or multiple objects) and saves it to the
     database, if validations pass. The resulting object is returned
     whether the object was saved successfully to the database or not.

     The +attributes+ parameter can be either be a Hash or an Array of
     Hashes. These Hashes describe the attributes on the objects that
     are to be created.

     Examples

       # Create a single new object
       User.create(:first_name =&gt; 'Jamie')
     
       # Create an Array of new objects
       User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])
     
       # Create a single object and pass it into a block to set other attributes.
       User.create(:first_name =&gt; 'Jamie') do |u|
         u.is_admin = false
       end
     
       # Creating an Array of new objects using a block, where the block is executed for each object:
       User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
         u.is_admin = false
       end

Stefan-Wintermeyers-MacBook-Pro-2008-50:movie-application sw$ 
</screen></para>
      </section>
    </section>

    <section>
      <title>Alle Datensätze anzeigen</title>

      <para>Der einfachste Weg alle Datensätze aus der Datenbank movies
      anzuzeigen ist die Methode <methodname>all</methodname>:<screen>ruby-1.9.1-p378 &gt; <command>Movie.all</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:38:36", updated_at: "2010-04-04 19:38:36"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:39:22", updated_at: "2010-04-04 19:39:22"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Was für eine Klasse ist das Ergebnis von
      <classname>Movie.all</classname>? Schauen wir mal nach.<screen>ruby-1.9.1-p378 &gt; <command>Movie.all.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Dann können wir ja die Iterator-Methode
      <methodname>each</methodname> anwenden (siehe <xref
      linkend="array_iterator" />), um durch die einzelnen Elemente des Arrays
      zu gehen. Damit können Sie sich als Beispiel alle Titel ausgeben
      lassen.<screen>ruby-1.9.1-p378 &gt; <command>Movie.all.each { |movie| puts movie.title }</command>
The Terminator
Terminator 2
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:38:36", updated_at: "2010-04-04 19:38:36"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:39:22", updated_at: "2010-04-04 19:39:22"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section xml:id="seed_rb">
      <title xml:id="seed_rb.title">Mit seed.rb die Entwicklungsdatenbank
      betanken</title>

      <para>Gehört nicht so richtig in dieses Kapitel, aber gerade bei der
      Entwicklung kommt es immer mal wieder vor, das man den Inhalt der
      Datenbank löschen und mit neuen Werten befüllen will. In Rails gibt es
      dafür den praktischen Mechanismus der Datei
      <filename>db/seeds.rb</filename></para>

      <para>Die <filename>db/seeds.rb</filename> ist ein normales
      Ruby-Programm, das man mit <command>rake db:seed</command> ausführen
      kann. Dies geht natürlich nicht nur mit der Entwicklungsdatenbank,
      sondern kann später auch in der Produktion geschehen. Das ist z.B.
      praktisch, wenn man initial eine Länderliste in eine Länderdatenbank
      eintragen will.</para>

      <para>Für unsere Film-Datenbank habe ich folgende
      <filename>db/seeds.rb</filename> vorbereitet:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#   
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Major.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Movie.create({ :title =&gt; 'The Terminator', :production_year =&gt; 1984 })
Movie.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })
Movie.create({ :title =&gt; 'Terminator Salvation', :production_year =&gt; 2009 })
Movie.create({ :title =&gt; 'Rain Man', :production_year =&gt; 1988, :rating =&gt; 5 })
Movie.create({ :title =&gt; 'War of the Worlds', :production_year =&gt; 2005, :rating =&gt; 4 })
Movie.create({ :title =&gt; 'Collateral', :production_year =&gt; 2004, :rating =&gt; 5})
Movie.create({ :title =&gt; 'Miami Vice', :production_year =&gt; 2006, :rating =&gt; 5})
Movie.create({ :title =&gt; 'Hancock', :production_year =&gt; 2008, :rating =&gt;  4})
Movie.create({ :title =&gt; 'The Aviator', :production_year =&gt; 2004, :rating =&gt;  4})
Movie.create({ :title =&gt; 'Some Like It Hot', :production_year =&gt; 1959, :rating =&gt;  5})
Movie.create({ :title =&gt; 'W.', :production_year =&gt; 2008, :rating =&gt;  4})
Movie.create({ :title =&gt; 'Iron Man', :production_year =&gt; 2008, :rating =&gt;  5})
Movie.create({ :title =&gt; 'The Dark Knight', :production_year =&gt; 2008, :rating =&gt;  5})
</programlisting></para>

      <section>
        <title>Betankung</title>

        <para>Um keine Filme doppelt zu haben, reseten wir erst mit
        <command>rake db:reset</command> die Datenbank.<screen>MacBook:movie-application sw$ <command>rake db:reset</command>
(in /Users/sw/Development/movie-application)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("movies", {:force=&gt;true})
   -&gt; 0.0168s
-- initialize_schema_migrations_table()
   -&gt; 0.0046s
-- assume_migrated_upto_version(20100404113234, "db/migrate")
   -&gt; 0.0022s
MacBook:movie-application sw$</screen></para>

        <para>Um sie dann mit <command>rake db:seed</command> zu
        betanken.<screen>MacBook:movie-application sw$ <command>rake db:seed</command>
(in /Users/sw/Development/movie-application)
MacBook:movie-application sw$</screen></para>
      </section>
    </section>

    <section xml:id="arbeiten-mit-find">
      <title>Arbeiten mit der Methode find</title>

      <para>Es gibt in <classname>ActiveRecord::Base</classname> eine Methode
      <methodname>find</methodname> die es uns ermöglicht ganz ohne
      SQL-Kenntnisse nach Daten in der Datenbank zu suchen.</para>

      <section>
        <title>Nach ID suchen</title>

        <para>Einen Film nach der ID zu suchen ist der einfachste aller
        Fälle.<screen>ruby-1.9.1-p378 &gt; <command>Movie.find(1)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>Nach einem Feldinhalt suchen</title>

        <para>Jetzt kommt ein wenig Ruby-Magie ins Spiel. Die Methode
        <methodname>find</methodname> kann dynamisch mit
        <methodname>_by_</methodname> und dem Feldnamen erweitert werden. Am
        einfachsten zeigt sich das mit ein paar Beispielen:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('The Terminator')</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_production_year(1984)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_rating(nil)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Bei der letzten Suche zeigt sich dabei allerdings schon ein
        Problem, denn <methodname>find_by_x</methodname> gibt immer nur den
        ersten Treffer aus. Wenn man mehrere Treffer ausgeben will, muss man
        <command>find_all_by_x</command> benutzen:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_rating(nil)</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Mit der Methode count kann man sich dann übrigens auch leicht
        die Anzahl der gefundenen Filme ausrechnen lassen:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_rating(nil).count</command>
 =&gt; 6 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Jetzt mal eine kleine Quizfrage: "Zählt Rails die Anzahl der
        Objekte im Array, das von
        <command>Movie.find_all_by_rating(nil)</command> ausgegeben wird oder
        geht es intelligenter vor?". Die Antwort liegt im Logfile:<screen>  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.5ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."rating" IS NULL)
</screen></para>

        <para>Rails bekommt also wirklich alle entsprechenden Tabelleneinträge
        zurück und zählt dann die Anzahl der Objekte im Array. Bei einer solch
        kleinen Tabelle ist das kein Problem. Aber bei einer grösseren will
        man so was eher vom SQL-Server machen lassen, weil dieser einfach viel
        schneller ist. Dafür gibt es die Methode count die wir wie folgt
        aufrufen können:<screen>ruby-1.9.1-p378 &gt; <command>Movie.count(:all, :conditions =&gt; { :rating =&gt; nil } )</command>
 =&gt; 6 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Im Logfile zeigt sich dann der folgende, von uns genau so
        gewünschte Eintrag:<screen>  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM "movies" WHERE ("movies"."rating" IS NULL)
</screen></para>

        <para>Man kann die <methodname>find_all_by_x</methodname> oder
        <methodname>find_by_x</methodname> Methoden übrigens beliebig mit dem
        String <methodname>_and_</methodname> und weiteren Feldnamen
        verlängern:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_duration_and_rating(nil,nil)</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>Komplexere Suchen</title>

        <para>Die Methode find ist sehr mächtig. Bevor ich einzelne Beispiele
        gebe, möchte ich Sie schon mal auf die eingebaute Hilfe
        verweisen:<screen>MacBook:movie-application sw$ <command>ri ActiveRecord::Base.find</command>
----------------------------------------------- ActiveRecord::Base::find
     ActiveRecord::Base::find(*args)

     From gem activerecord-2.3.5
------------------------------------------------------------------------
     Find operates with four different retrieval approaches:

     *   Find by id - This can either be a specific id (1), a list of
         ids (1, 5, 6), or an array of ids ([5, 6, 10]). If no record
         can be found for all of the listed ids, then RecordNotFound
         will be raised.

     *   Find first - This will return the first record matched by the
         options used. These options can either be specific conditions
         or merely an order. If no record can be matched, +nil+ is
         returned. Use +Model.find(:first, *args)+ or its shortcut
         +Model.first(*args)+.

     *   Find last - This will return the last record matched by the
         options used. These options can either be specific conditions
         or merely an order. If no record can be matched, +nil+ is
         returned. Use +Model.find(:last, *args)+ or its shortcut
         +Model.last(*args)+.

     *   Find all - This will return all the records matched by the
         options used. If no records are found, an empty array is
         returned. Use +Model.find(:all, *args)+ or its shortcut
         +Model.all(*args)+.

     All approaches accept an options hash as their last parameter.

     Parameters

     *   +:conditions+ - An SQL fragment like "administrator = 1", +[
         "user_name = ?", username ]+, or +["user_name = :user_name", {
         :user_name =&gt; user_name }]+. See conditions in the intro.

     *   +:order+ - An SQL fragment like "created_at DESC, name".

     *   +:group+ - An attribute name by which the result should be
         grouped. Uses the +GROUP BY+ SQL-clause.

     *   +:having+ - Combined with +:group+ this can be used to filter
         the records that a +GROUP BY+ returns. Uses the +HAVING+
         SQL-clause.

     *   +:limit+ - An integer determining the limit on the number of
         rows that should be returned.

     *   +:offset+ - An integer determining the offset from where the
         rows should be fetched. So at 5, it would skip rows 0 through
         4.

     *   +:joins+ - Either an SQL fragment for additional joins like
         "LEFT JOIN comments ON comments.post_id = id" (rarely needed),
         named associations in the same form used for the +:include+
         option, which will perform an +INNER JOIN+ on the associated
         table(s), or an array containing a mixture of both strings and
         named associations. If the value is a string, then the records
         will be returned read-only since they will have attributes that
         do not correspond to the table's columns. Pass +:readonly =&gt;
         false+ to override.

     *   +:include+ - Names associations that should be loaded
         alongside. The symbols named refer to already defined
         associations. See eager loading under Associations.

     *   +:select+ - By default, this is "*" as in "SELECT * FROM", but
         can be changed if you, for example, want to do a join but not
         include the joined columns. Takes a string with the SELECT SQL
         fragment (e.g. "id, name").

     *   +:from+ - By default, this is the table name of the class, but
         can be changed to an alternate table name (or even the name of
         a database view).

     *   +:readonly+ - Mark the returned records read-only so they
         cannot be saved or updated.

     *   +:lock+ - An SQL fragment like "FOR UPDATE" or "LOCK IN SHARE
         MODE". +:lock =&gt; true+ gives connection's default exclusive
         lock, usually "FOR UPDATE".

     Examples

       # find by id
       Person.find(1)       # returns the object for ID = 1
       Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
       Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
       Person.find([1])     # returns an array for the object with ID = 1
       Person.find(1, :conditions =&gt; "administrator = 1", :order =&gt; "created_on DE
SC")

     Note that returned records may not be in the same order as the ids
     you provide since database rows are unordered. Give an explicit
     +:order+ to ensure the results are sorted.

     Examples

       # find first
       Person.find(:first) # returns the first object fetched by SELECT * FROM peo
ple
       Person.find(:first, :conditions =&gt; [ "user_name = ?", user_name])
       Person.find(:first, :conditions =&gt; [ "user_name = :u", { :u =&gt; user_name }]
)
       Person.find(:first, :order =&gt; "created_on DESC", :offset =&gt; 5)
     
       # find last
       Person.find(:last) # returns the last object fetched by SELECT * FROM peopl
e
       Person.find(:last, :conditions =&gt; [ "user_name = ?", user_name])
       Person.find(:last, :order =&gt; "created_on DESC", :offset =&gt; 5)
     
       # find all
       Person.find(:all) # returns an array of objects for all the rows fetched by
 SELECT * FROM people
       Person.find(:all, :conditions =&gt; [ "category IN (?)", categories], :limit =
&gt; 50)
       Person.find(:all, :conditions =&gt; { :friends =&gt; ["Bob", "Steve", "Fred"] }
       Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)
       Person.find(:all, :include =&gt; [ :account, :friends ])
       Person.find(:all, :group =&gt; "category")

     Example for find with a lock: Imagine two concurrent transactions:
     each will read +person.visits == 2+, add 1 to it, and save,
     resulting in two saves of +person.visits = 3+. By locking the row,
     the second transaction has to wait until the first is finished; we
     get the expected +person.visits == 4+.

       Person.transaction do
         person = Person.find(1, :lock =&gt; true)
         person.visits += 1
         person.save!
       end

MacBook:movie-application sw$ </screen></para>

        <section>
          <title>Such-Beispiele</title>

          <para>Im folgenden werde ich per Fragen und Antwort ein
          Beispielprobleme mit <methodname>find</methodname> lösen.</para>

          <para><qandaset>
              <qandadiv>
                <qandaentry>
                  <question>
                    <para>Wie kann ich alle in der Datenbank enthaltenen Filme
                    in das Objekt mit dem Namen <varname>alle_filme</varname>
                    speichern?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>alle_filme = Movie.all</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 4, title: "Rain Man", production_year: 1988, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 5, title: "War of the Worlds", production_year: 2005, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 6, title: "Collateral", production_year: 2004, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 7, title: "Miami Vice", production_year: 2006, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 9, title: "The Aviator", production_year: 2004, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 10, title: "Some Like It Hot", production_year: 1959, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 17, title: "Rain Man", production_year: 1988, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 18, title: "War of the Worlds", production_year: 2005, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 19, title: "Collateral", production_year: 2004, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 20, title: "Miami Vice", production_year: 2006, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 21, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 22, title: "The Aviator", production_year: 2004, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 23, title: "Some Like It Hot", production_year: 1959, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 24, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 25, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 26, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie finde ich den ersten Film in der
                    Datenbank?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find(:first)</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt;</screen>Oder noch kürzer mit der Methode
                    <methodname>first</methodname>.<screen>ruby-1.9.1-p378 &gt; <command>Movie.first</command>
 =&gt; #&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt; 
ruby-1.9.1-p378 &gt; </screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie kann ich alle Filme die im Jahr 1984 produziert
                    wurden suchen?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year(1984)</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie finde ich die Anzahl der im Jahr 1984
                    produzierten Filme raus?</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year(1984).count</command>
 =&gt; 2 
ruby-1.9.1-p378 &gt; <command>Movie.count(:all, :conditions =&gt; { :production_year =&gt; 1984 })</command>
 =&gt; 2 
ruby-1.9.1-p378 &gt; </screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Einer Liste aller 5 Sterne Filme aus dem Jahr 2008
                    im YAML Format.</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year_and_rating(2008,5).to_yaml</command>
 =&gt; "--- \n- !ruby/object:Movie \n  attributes: \n    id: \"12\"\n    title: Iron Man\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:41.922898\n    updated_at: 2010-04-04 19:50:41.922898\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n- !ruby/object:Movie \n  attributes: \n    id: \"13\"\n    title: The Dark Knight\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:41.925878\n    updated_at: 2010-04-04 19:50:41.925878\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n- !ruby/object:Movie \n  attributes: \n    id: \"25\"\n    title: Iron Man\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:50.084528\n    updated_at: 2010-04-04 19:50:50.084528\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n- !ruby/object:Movie \n  attributes: \n    id: \"26\"\n    title: The Dark Knight\n    production_year: \"2008\"\n    duration: \n    plot: \n    rating: \"5\"\n    created_at: 2010-04-04 19:50:50.087386\n    updated_at: 2010-04-04 19:50:50.087386\n  attributes_cache: {}\n\n  changed_attributes: {}\n\n  destroyed: false\n  marked_for_destruction: false\n  new_record: false\n  previously_changed: {}\n\n  readonly: false\n" 
ruby-1.9.1-p378 &gt; </screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Alle 2008er Filme, alphabetisch nach Titeln
                    sortiert.</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find_all_by_production_year(2008, :order =&gt; :title)</command>
 =&gt; [#&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 21, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 25, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 26, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 24, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Die find Methode an sich reicht mich nicht. Ich
                    möchte auch noch selbst SQL einbauen. Wie kann ich nach
                    allen Filmen suchen, die im Titel das Wort 'Terminator'
                    enthalten.</para>
                  </question>

                  <answer>
                    <para><screen>ruby-1.9.1-p378 &gt; <command>Movie.find(:all, :conditions =&gt; [ "title LIKE ?", '%Terminator%' ])</command>
 =&gt; [#&lt;Movie id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:41", updated_at: "2010-04-04 19:50:41"&gt;, #&lt;Movie id: 14, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 15, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;, #&lt;Movie id: 16, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2010-04-04 19:50:50", updated_at: "2010-04-04 19:50:50"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
                  </answer>
                </qandaentry>
              </qandadiv>
            </qandaset></para>
        </section>
      </section>
    </section>

    <section xml:id="datensatz-loeschen">
      <title>Einen Datensatz löschen</title>

      <para>Es gibt die Methoden <methodname>delete</methodname> und
      <methodname>destroy</methodname>, um Datensätze zu löschen.</para>

      <section>
        <title>delete</title>

        <para>Mit delete können Sie einen Datensatz löschen. Dabei werden
        allerdings keine Abhängigkeiten zu anderen Datensätzen beachtet.
        Delete löscht also nur die eine Zeile in der Datenbank und sonst
        nichts.<note>
            <para>Für unseren jetzigen Kenntnisstand sind solche Abhänigkeiten
            noch egal, aber in späteren Kapiteln werden wir verschiedene
            Tabellen mit einander verknüpfen und dann wird es entsprechende
            Abhängigkeiten geben.</para>
          </note><important>
            <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
            (eingefroren). Sie ist also noch da, kann aber nicht verändert
            werden.</para>
          </important></para>

        <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('Hancock')</command>
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>hancock = Movie.find_by_title('Hancock')</command>
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>hancock.delete</command>      # Die Zeile in der DB wird geloescht. Siehe Log.
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('Hancock')</command>
 =&gt; nil                               # Eine Suche bringt kein Ergebnis mehr.
ruby-1.9.1-p378 &gt; <command>hancock</command>             
 =&gt; #&lt;Movie id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>hancock.frozen?</command>     # Die Instanz ist frozen.
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>destroy</title>

        <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
        löschen und dabei werden auch evt. vorhandene Abhängigkeiten beachtet
        (solche Abhängikeiten betrachten wir später). Vereinfacht kann man
        sagen: "Lieber destroy nehmen, das ist sicherer, weil das Rails-System
        dann mehr mitdenkt."<important>
            <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
            (eingefroren). Sie ist also noch da, kann aber nicht verändert
            werden.</para>
          </important></para>

        <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('The Dark Knight')</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>dark_night = Movie.find_by_title('The Dark Knight')</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>dark_night.destroy</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('The Dark Knight')</command>
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>dark_night</command>
 =&gt; #&lt;Movie id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>dark_night.frozen?</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>
      </section>
    </section>

    <section xml:id="datensatz-editieren">
      <title>Einen Datensatz editieren</title>

      <para>Das Verändern eines Datensatzes erfolgt in zwei
      Schritten:<orderedlist>
          <listitem>
            <para>Suche des Datensatzes und erstellen einer entsprechenden
            Instanz.</para>
          </listitem>

          <listitem>
            <para>Verändern der Werte.</para>
          </listitem>

          <listitem>
            <para>Abspeichern des Datensatzes mit der Methode
            <methodname>save</methodname>.</para>
          </listitem>
        </orderedlist></para>

      <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>iron_man = Movie.find_by_title('Iron Man')</command>
 =&gt; #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:35:48"&gt; 
ruby-1.9.1-p378 &gt; <command>iron_man.duration = 126</command>
 =&gt; 126 
ruby-1.9.1-p378 &gt; <command>iron_man.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; <command>Movie.find_by_title('Iron Man')</command>
 =&gt; #&lt;Movie id: 12, title: "Iron Man", production_year: 2008, duration: 126, plot: nil, rating: 5, created_at: "2010-04-04 20:35:48", updated_at: "2010-04-04 20:52:27"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <section>
        <title>Locking</title>

        <para>Per Default benutzt Rails Optimistisches Locking der Datensätze.
        Dies kann aber umgeschaltet werden. Da für die meisten User
        Optimistisches Locking optimal ist und viele vor diesem Absatz nicht
        mal über das Problem nachgedacht haben, werde ich nicht weiter drauf
        eingehen, sondern auf die ri Hilfe verweisen. Wer pessimistisches
        Locking benötigt, der findet dort die notwendigen Schalter.</para>

        <para><screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveRecord::Locking::Optimistic</command>
------------------------------- Class: ActiveRecord::Locking::Optimistic

What is Optimistic Locking
--------------------------

     Optimistic locking allows multiple users to access the same record
     for edits, and assumes a minimum of conflicts with the data. It
     does this by checking whether another process has made changes to a
     record since it was opened, an ActiveRecord::StaleObjectError is
     thrown if that has occurred and the update is ignored.

     Check out ActiveRecord::Locking::Pessimistic for an alternative.


Usage
-----

     Active Records support optimistic locking if the field
     +lock_version+ is present. Each update to the record increments the
     lock_version column and the locking facilities ensure that records
     instantiated twice will let the last one saved raise a
     StaleObjectError if the first was also updated. Example:

       p1 = Person.find(1)
       p2 = Person.find(1)
     
       p1.first_name = "Michael"
       p1.save
     
       p2.first_name = "should fail"
       p2.save # Raises a ActiveRecord::StaleObjectError

     You're then responsible for dealing with the conflict by rescuing
     the exception and either rolling back, merging, or otherwise apply
     the business logic needed to resolve the conflict.

     You must ensure that your database schema defaults the lock_version
     column to 0.

     This behavior can be turned off by setting
     +ActiveRecord::Base.lock_optimistically = false+. To override the
     name of the lock_version column, invoke the +set_locking_column+
     method. This method uses the same syntax as +set_table_name+

------------------------------------------------------------------------
sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>
  </section>
</chapter>
