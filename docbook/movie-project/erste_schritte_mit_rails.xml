<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="erste_schritte_mit_rails" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="erste_schritte_mit_rails.title">Erste Schritte mit
  Rails</title>

  <section>
    <title>Einleitung</title>

    <para>Nachdem Sie sich im <xref linkend="ruby-grundlagen" /> Kapitel
    mühsam in die Ruby-Grundlagen eingelesen haben, können wir jetzt
    spannender weitermachen. In diesem Kapitel starten wir ein erstes
    Rails-Projekt und arbeiten uns damit Stück für Stück in die Materie
    ein.</para>

    <para>Auch in diesem Kapitel wird es manchmal hoppla-hopp zu gehen. Wir
    stossen auf typische Henne-Ei-Probleme wir zum Beispiel: "Wie erkläre ich
    MVC (Model-View-Controller)?". Ich habe mich für den "Wir fangen mal an
    und erklären bei der Arbeit."-Ansatz entschieden.</para>

    <para>Als erstes kleines Projekt erstellen wir eine kleine
    Filmdatenbank.</para>
  </section>

  <section xml:id="arbeits-umgebung-development">
    <title>Arbeits-Umgebung (Development)</title>

    <para>Rails kennt drei verschiedene Arbeits-Umgebungen:<itemizedlist>
        <listitem>
          <para>Development</para>
        </listitem>

        <listitem>
          <para>Testing</para>
        </listitem>

        <listitem>
          <para>Production</para>
        </listitem>
      </itemizedlist></para>

    <para>Wir arbeiten in diesem Kapitel nur mit der Development Umgebung. So
    bald Sie ein besseres Gefühl für Rails bekommen haben, starten wir mit
    Tests und benötigen dafür die entsprechende Umgebung (dort wird z.B. beim
    Start eines Tests die Test-Datenbank neu gefühlt und beim Beenden wird
    gelöscht). Später erkläre ich Ihnen dann die verschiedenen Szenarien, wie
    Sie Ihre Rails-Applikation aus der Development-Umgebung in die
    Production-Umgebung ausrollen können.</para>

    <para>Die Development-Umgebung bringt bis auf einen Editor und einen
    Webbrowser alles mit, was Sie zum Entwickeln benötigen. So müssen Sie
    nicht extra einen Webserver installieren, sondern können den eingebauten
    Rails-Webserver benutzen. Der besticht nicht durch extreme Performance,
    aber das benötigen wir bei der Entwicklung ja auch nicht. Später kann man
    dann auf grosse Systeme wie <application>Apache</application> umsteigen.
    Das gleiche gilt für die Datenbank.</para>

    <para>Um in der Development-Umgebung zu arbeiten, müssen Sie erst mal
    nichts verändern. Alle Befehle gelten per Default auf die
    Development-Umgebung.</para>

    <section xml:id="sqlite3_datenbank_default">
      <title>sqlite3 Datenbank</title>

      <para>Auch bei der Datenbank geht es in diesem Kapitel nicht um optimale
      Performance, sondern um einen einfachen Einstieg. Deshalb benutzen wir
      die sqlite3 Datenbank. Dafür haben Sie bereits alles fertig installiert
      und müssen sich keinen Kopf machen. Später erkläre ich Ihnen dann wie
      Sie andere Datenbank (z.B. MySQL) ansteuern können.</para>
    </section>
  </section>

  <section xml:id="neues_rails_projekt_starten">
    <title>Ein neues Railsprojekt starten</title>

    <para>Als aller erstes müssen wir mal ein neues Rails-Projekt erstellen.
    Da Ruby on Rails ein Framework ist, müssen wir erst mal die entsprechende
    Verzeichnisstruktur und die Grundkonfiguration inkl. einiger Skripte
    einrichten. Das geht aber mit dem <command>rails
    movie-application</command> ratz-fatz.<tip>
        <para>Bitte überprüfen Sie an dieser Stelle, ob Sie auch wirklich mit
        der Ruby Version 1.9.1 und Rails 3.0.x arbeiten (<command>ruby
        -v</command> und <command>rails -v</command>). An sonsten werden Sie
        irgendwann in Merkwürdigkeiten laufen. Falls Sie beides noch nicht
        installiert haben finden Sie weitere Infos im <xref
        linkend="installation-und-versionsauswahl" /> .</para>
      </tip><screen>MacBook:Development sw$ <command>rails movie-application</command>
      create  
      create  README
      create  .gitignore
      create  Rakefile
      create  config.ru
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/models
      create  app/views/layouts
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      create  config/initializers
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/cookie_verification_secret.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/session_store.rb
      create  config/locales
      create  config/locales/en.yml
      create  config/boot.rb
      create  config/database.yml
      create  db
      create  db/seeds.rb
      create  doc
      create  doc/README_FOR_APP
      create  lib
      create  lib/tasks
      create  lib/tasks/.gitkeep
      create  log
      create  log/server.log
      create  log/production.log
      create  log/development.log
      create  log/test.log
      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js
      create  script
      create  script/rails
      create  test
      create  test/performance/browsing_test.rb
      create  test/test_helper.rb
      create  test/fixtures
      create  test/functional
      create  test/integration
      create  test/unit
      create  tmp
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
MacBook:Development sw$ </screen></para>

    <para>Rails hat das Verzeichnis <filename>movie-application</filename>
    angelegt und in dieses Verzeichnis die Grundstruktur einer
    Rails-Applikation gespeichert.</para>

    <para>Als erstes prüfen wir mal, ob diese neue Applikation funktioniert.
    Dazu welchen wir in das neue Verzeichnis und starten mitgelieferten
    kleinen Web-Server.<footnote>
        <para>Nein, keine Angst. Das ist nicht der Webserver, mit dem wir
        später auch Produktiv gehen. Aber zum Entwickeln ist diese Variante
        sehr praktisch.</para>
      </footnote><note>
        <para>Bei verschiednen Betriebssystemen (z.B. Mac OS X) kommt beim
        ersten Starten einer Rails-Applikation, je nach Firewall Einstellung,
        ein Fenster, das Sie fragt, ob die Firewall die entsprechende
        Verbindung erlauben soll. Da wir lokal arbeiten, können Sie das mit
        ruhigen Gewissen bejahen.</para>
      </note><screen>MacBook:Development sw$ <command>cd movie-application</command> 
MacBook:movie-application sw$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-03 17:30:42] INFO  WEBrick 1.3.1
[2010-04-03 17:30:42] INFO  ruby 1.9.1 (2010-01-10) [i386-darwin10.3.0]
[2010-04-03 17:30:42] INFO  WEBrick::HTTPServer#start: pid=18770 port=3000
</screen></para>

    <para>Der Start der Rails Applikation sieht gut aus. Zum Testen rufen wir
    jetzt mit dem Webbrowser die URL http://0.0.0.0:3000 auf.<screenshot>
        <info>
          <title>Default Seite in einem frischen Rails-Projekt.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/virgin_rails_app.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn wir jetzt auf den "About your application's environment" link
    klicken erscheint eine Aufstellung der aktuellen Umgebung.<screenshot>
        <info>
          <title>Auflistung der Start-Umgebung der Rails-Applikation.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/virgin_rails_app_env_info.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Gleichzeitig wird im Log des Webservers folgendes angezeigt:<screen>Started GET "/rails/info/properties" for 127.0.0.1 at 2010-04-03 17:38:38
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.6ms)
Completed 200 OK in 28ms (Views: 1.5ms | ActiveRecord: 0.3ms)
</screen></para>

    <para>Da beim Aufruf der ersten Startseite kein entsprechender Eintrag
    erschien, muss es sich um zwei verschiedenartige Seiten handeln. Die erste
    Seite ist tatsächlich eine statische HTML-Seite, die unter
    <filename>public/index.html</filename> abgespeichert ist und der Link, auf
    den wir geklickt haben führt ein Rails Programm aus.</para>

    <para>Mit <keycode>CTRL + C</keycode> können Sie den Webserver wieder
    stoppen.</para>

    <section xml:id="logging">
      <title xml:id="logging.title">Logging</title>

      <para>In der Datei <filename>log/development.log</filename> finden Sie
      das Log des Webservers. Bei der Entwicklung von Rails-Applikationen ist
      es oft sehr praktisch immer ein Terminal offen zu haben, das mit einem
      <command>tail -f log/development.log</command> diese Datei
      anzeigt.<screen>MacBook:movie-application sw$ <command>tail -f log/development.log</command> 

Started GET "/rails/info/properties" for 127.0.0.1 at 2010-04-03 17:38:38
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.6ms)
Completed 200 OK in 28ms (Views: 1.5ms | ActiveRecord: 0.3ms)
</screen></para>

      <section xml:id="logging-statische-oder-dynamische-seite">
        <title>Statische und dynamisch generierte Seiten</title>

        <para>Statische Seite wie die default <filename>index.html</filename>
        oder auch die 404.html Fehler-Seite liegen im Unterverzeichnis
        public<screen>MacBook:movie-application sw$ <command>ls public</command>
404.html  500.html     images      javascripts  stylesheets
422.html  favicon.ico  index.html  robots.txt
MacBook:movie-application sw$</screen></para>

        <para>Die Auslieferung einer solchen Seite oder einer Datei aus diesem
        Verzeichnis wird nicht im <filename>log/development.log</filename>
        angezeigt. Übrigens haben die Dateien im public-Verzeichnis eine
        höhere Prio, als die dynamisch gerenderten Seiten. Falls Sie also zwei
        Seiten mit dem gleichen Namen haben, dann wird Rails die statische
        Variante ausliefern. Deshalb werden Sie später die
        <filename>index.html</filename> Seite entweder umbenennen oder ganz
        löschen müssen (sonst würde Ihre Applikation immer nur mit dieser
        statischen Webseite starten).</para>
      </section>
    </section>
  </section>

  <section xml:id="scaffolding">
    <title xml:id="scaffolding.title">Scaffolding</title>

    <para>Die typischen "Ich zeige Euch mal Ruby on Rails in 15 Minuten"
    Videos im Internet arbeiten alle mit der Magie des Scaffolding.
    Scaffolding steht dabei für ein auf den ersten Blick sehr mächtiges
    Grundgerüst mit einer fertigen GUI zum Arbeiten mit einer
    Datenbanktabelle. Leider ist dieses Vorgehen meistens kontraproduktiv,
    weil man zwar sehr schnell dieses Grundgerüst stehen hat, aber danach erst
    mal im Regen steht. Das alte "ohne Ruby-Grundkenntnisse kommt man nicht
    weiter"-Problem schlägt zu. Aber Sie haben sich ja schon das <xref
    linkend="ruby-grundlagen" /> Kapitel gekämpft. Falls nicht, sollten Sie es
    jetzt nachholen.</para>

    <section xml:id="activerecord">
      <title xml:id="activerecord.title">ActiveRecord</title>

      <para>Ein ganz wichtiges Element für Rails ist ActiveRecord. Es
      übernimmt für den Programmierer transparent die Arbeit mit der
      SQL-Datenbank und stellt Tabellen und einzelne Tabellen-Zeilen als
      Objekte zur Verfügung. Um das zu ermöglichen hat man sich auf bestimmte
      Namenskonventionen geeinigt. In früheren Rails-Versionen musste man die
      Datenbank von Hand anhand dieser Konventionen anlegen. ActiveRecord hat
      dann die Felder an bestimmten Namensmerkmalen erkannt. Heute gibt es in
      Rails dazu eigene noch dazu äusserst praktische Tools. Denn Sie wollen
      ja nicht nur jetzt eine Datebank für Ihre Entwicklungs-Umgebung
      einrichten, sondern benötigen später auch ein Tool, das Ihre
      Produktions-Datenbank Schritt für Schritt mitzieht.</para>

      <para>Wir wollen Filme katalogisieren. Dazu benötigen wir mindestens
      folgende Datenbankfelder:<itemizedlist>
          <listitem>
            <para><varname>title:string</varname> - Titel oder Name des Films
            </para>
          </listitem>

          <listitem>
            <para><varname>production_year:integer</varname> -
            Produktionsjahr</para>
          </listitem>

          <listitem>
            <para><varname>duration:integer</varname> - Dauer (in
            Minuten)</para>
          </listitem>

          <listitem>
            <para><varname>plot:text</varname> - Story des Films</para>
          </listitem>

          <listitem>
            <para><varname>rating:integer</varname> - Bewertung (als Ganzahl
            von 1 bis 5 Sterne)</para>
          </listitem>
        </itemizedlist></para>

      <section>
        <title>Warum alle Feldnamen, Methoden und Klassen auf
        Englisch?</title>

        <para>Ganz tief im Herzen liebt Rails die englische Sprache. Damit
        muss man sich abfinden und versuchen diese Liebe zu übernehmen. So
        verwenden sehr viele Mechanismen automagisch Plural oder Singular von
        Englischen Wörtern. Wenn man sich damit anfreundet Datenbankfelder und
        Datenbanken an sich mit englischen Wörter zu benennen, dann kann man
        die ganze Macht dieser Magie ausnutzen.</para>
      </section>

      <section xml:id="dvd-ist-das-ein-model">
        <title>Ist das jetzt ein Model (laut der MVC-Idee)?</title>

        <para>Kurze Antwort: Ja. Wir müssen dem Model nur noch einen Namen
        geben. "<varname>movie</varname>" macht wohl im Englischen am meisten
        Sinn.</para>
      </section>
    </section>

    <section xml:id="rails_generate_scaffold">
      <title xml:id="rails_generade_scaffold.title">rails generate
      scaffold</title>

      <para>Mit dem Rails-Skript-Aufruf <command>rails generate
      scaffold</command> kann man fertige Code generieren. Wer (wie ich) gerne
      mal vergisst wie das Skript aufgerufen werden muss, der gibt einfach
      <filename>rails generate</filename> ein und bekommt die folgende Hilfe
      angezeigt:<screen>MacBook:movie-application sw$ <command>rails generate</command>
Usage: rails generate GENERATOR [args] [options]

General options:
  -h, [--help]     # Print generators options and usage
  -p, [--pretend]  # Run but do not make any changes
  -f, [--force]    # Overwrite files that already exist
  -s, [--skip]     # Skip files that already exist
  -q, [--quiet]    # Supress status output

Please choose a generator below.

Rails:
  controller
  generator
  helper
  integration_test
  mailer
  metal
  migration
  model
  observer
  performance_test
  plugin
  resource
  scaffold
  scaffold_controller
  session_migration
  stylesheets

MacBook:movie-application sw$</screen></para>

      <para>Interessant ist für uns der Teil "Please choose a generator
      below.". Wenn wir <parameter>scaffold</parameter> benutzen wollen und
      dazu weitere Hilfe brauchen, dann geht dies wiederrum einfach mit der
      eingebauten Hilfe:<screen>MacBook:movie-application sw$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME                  # Orm to be invoked
                                  # Default: active_record
      [--force-plural]            # Forces the use of a plural ModelName
      [--singleton]               # Supply to create a singleton controller
  -c, --scaffold-controller=NAME  # Scaffold controller to be invoked
                                  # Default: scaffold_controller
  -y, [--stylesheets]             # Indicates when to generate stylesheets
                                  # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Erb options:
  [--layout]  # Indicates when to generate layout
              # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attribute pairs are field:type arguments specifying the
    model's attributes. Timestamps are added by default, so you don't have to
    specify them by hand as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title:string body:text published:boolean'
    gives you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a resources :posts
    declaration in config/routes.rb.

    If you want to remove all the generated files, run
    'rails destroy scaffold ModelName'.

Examples:
    `rails generate scaffold post`
    `rails generate scaffold post title:string body:text published:boolean`
    `rails generate scaffold purchase order_id:integer amount:decimal`
MacBook:movie-application sw$</screen></para>

      <para>Wir müssen also nach <command>rails generate scaffold</command>
      den Namen des Models (bei uns "movie") und danach die Datenbankfelder
      mit den entsprechenden Feldtypen angeben.</para>

      <para>Dann legen wir mal los:<screen>MacBook:movie-application sw$ <command>rails generate scaffold movie title:string production_year:integer duration:integer plot:text rating:integer</command>
      invoke  active_record
      create    db/migrate/20100404113234_create_movies.rb
      create    app/models/movie.rb
      invoke    test_unit
      create      test/unit/movie_test.rb
      create      test/fixtures/movies.yml
       route  resources :movies
      invoke  scaffold_controller
      create    app/controllers/movies_controller.rb
      invoke    erb
      create      app/views/movies
      create      app/views/movies/index.html.erb
      create      app/views/movies/edit.html.erb
      create      app/views/movies/show.html.erb
      create      app/views/movies/new.html.erb
      create      app/views/movies/_form.html.erb
      create      app/views/layouts/movies.html.erb
      invoke    test_unit
      create      test/functional/movies_controller_test.rb
      invoke    helper
      create      app/helpers/movies_helper.rb
      invoke      test_unit
      create        test/unit/helpers/movies_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
MacBook:movie-application sw$</screen>Und schon ist alles fertig. Allerdings
      ist in der Datenbank noch keine entsprechende Tabelle angelegt.</para>
    </section>

    <section xml:id="migration">
      <title xml:id="migration.title">Migrationen</title>

      <para><application>In der zweiten Ausgabezeile des Scaffoldings sehen
      wir die Ausgabe:</application><screen>      create    db/migrate/20100404113234_create_movies.rb
</screen></para>

      <para>In der Datei
      <filename>db/migrate/20100404113234_create_movies.rb</filename> finden
      sich die Anweisung, mit der die Datenbank erstellt (<code>def
      self.up</code>) und auch beim Roll-Back (<code>def self.down</code>)
      wieder gelöscht werden kann.<programlisting>class CreateMovies &lt; ActiveRecord::Migration
  def self.up
    create_table :movies do |t|
      t.string :title
      t.integer :production_year
      t.integer :duration
      t.text :plot
      t.integer :rating

      t.timestamps
    end
  end

  def self.down
    drop_table :movies
  end
end
</programlisting></para>

      <para>Die in dieser Ruby-Datei angelegte Klasse
      <classname>CreateMovies</classname> ist ein Kind der Klasse
      <classname>ActiveRecord::Migration</classname> (siehe Zeile 1) und hat
      zwei Methoden:<itemizedlist>
          <listitem>
            <para><methodname>self.up</methodname> (Zeile 2). Wird aufgerufen,
            wenn die Migration durchgeführt wird.</para>
          </listitem>

          <listitem>
            <para><methodname>self.down</methodname> (Zeile 14). Wird
            aufgerufen, wenn für eine Migration ein Rollback durchgeführt
            wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Die Migration (also das Anlegen der Datenbank) wird mit
      <command>rake db:migrate</command> durchgeführt:<screen>MacBook:movie-application sw$ <command>rake db:migrate</command>
(in /Users/sw/Development/movie-application)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0015s
==  CreateMovies: migrated (0.0017s) ==========================================

MacBook:movie-application sw$</screen></para>

      <para>Die Datenbank-Tabelle <varname>movies</varname> wird angelegt.
      Dabei sehen wir, das Tabellen-Namen automatisch den Plural der Models
      bekommen. Aber welche Datenbank wird überhaupt benutzt? Das wird in der
      Konfigurationsdatei <filename>config/database.yml</filename>
      definiert:<screen>MacBook:movie-application sw$ <command>cat -n config/database.yml</command> 
     1 # SQLite version 3.x
     2 #   gem install sqlite3-ruby (not necessary on OS X Leopard)
     3 development:
     4   adapter: sqlite3
     5   database: db/development.sqlite3
     6   pool: 5
     7   timeout: 5000
     8 
     9 # Warning: The database defined as "test" will be erased and
    10 # re-generated from your development database when you run "rake".
    11 # Do not set this db to the same as development or production.
    12 test:
    13   adapter: sqlite3
    14   database: db/test.sqlite3
    15   pool: 5
    16   timeout: 5000
    17 
    18 production:
    19   adapter: sqlite3
    20   database: db/production.sqlite3
    21   pool: 5
    22   timeout: 5000
MacBook:movie-application sw$</screen></para>

      <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe
      <uri xlink:href="http://www.yaml.org/">http://www.yaml.org/</uri> bzw.
      <uri
      xlink:href="http://de.wikipedia.org/wiki/YAML">http://de.wikipedia.org/wiki/YAML</uri>)
      definiert. Für uns wichtig ist erst mal nur die development-Datenbank
      (Zeile 3 bis 7). Per default benutzt Rails dort
      <application>Sqlite3</application>. Sqlite3 mag nicht die richtige Wahl
      für die Analyse der weltweit gesammelten Wetterdaten sein, aber für die
      schnelle und unkompliziete Entwicklung von Rails-Anwendungen lernt man
      sie schnell zu schätzen. In der Produktions-Umgebung kann man später
      immer noch auf "grosse" Datenbanken wie MySQL umsteigen.<footnote>
          <para>Es gibt unter einigen Entwicklern die Ansicht, das man auf
          jeden Fall immer mit der gleichen Datenbank entwicklen soll, die man
          später auch in der Produktion und im Testing benutzt. Das sollte
          aber jeder für sich selbst entscheiden.</para>
        </footnote></para>

      <para>Um Ihre Neugierde zu befriedigen, schauen wir uns kurz noch die
      Datenbank mit dem Command-Line-Tool <application>sqlite3</application>
      an.<screen>MacBook:movie-application sw$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
movies             schema_migrations
sqlite&gt; <command>.schema movies</command>
CREATE TABLE "movies" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; <command>.quit</command>
MacBook:movie-application sw$</screen></para>

      <para>Das Anlegen der Tabelle mit <command>rake db:migrate</command>
      wurde natürlich auch im <filename>log/development.log</filename>
      eingetragen:<screen>  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
Migrating to CreateMovies (20100404113234)
  SQL (0.1ms)  select sqlite_version(*)
  SQL (0.4ms)  CREATE TABLE "movies" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20100404113234')
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.0ms)  PRAGMA index_list("movies")
</screen></para>

      <section xml:id="active-record-auto-felder">
        <title>Automatisch zugefügte Felder (id, created_at und
        updated_at)</title>

        <para>Rails ist so freundlich uns beim Scaffolding per Default
        folgende Felder hinzuzufügen:<itemizedlist>
            <listitem>
              <para><varname>id:integer</varname></para>

              <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von
              der Datenbank automatisch hochgezählt. Für alle SQL-Fans:
              AUTOINCREMENT NOT NULL</para>
            </listitem>

            <listitem>
              <para><varname>created_at:datetime</varname></para>

              <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
              eines Datensatzes gefüllt.</para>
            </listitem>

            <listitem>
              <para><varname>updated_at:datetime</varname></para>

              <para>Das Feld wird bei jeder Veränderung des Datensatzes
              automatisch an die aktuelle Zeit angepasst.</para>
            </listitem>
          </itemizedlist></para>

        <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
        Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten
        Felder schätzen.</para>
      </section>

      <section xml:id="migration-rollback">
        <title>Migration Rollback</title>

        <para>Es soll schon vorgekommen sein, das übereilt eine Migration
        durchgeführt wurde. Natürlich passiert weder Ihnen noch mir so was.
        ;-) Aber falls mal ein Freund von Ihnen in diese Predulie gerät: Keine
        Panik! Dafür wurde in der Migrations-Class die Methode
        <methodname>self.down</methodname> angelegt. Testweise können wir ja
        mal unsere letzte Migration zurückrollen:<screen>MacBook:movie-application sw$ <command>rake db:rollback</command>
(in /Users/sw/Development/movie-application)
==  CreateMovies: reverting ===================================================
-- drop_table(:movies)
   -&gt; 0.1004s
==  CreateMovies: reverted (0.1005s) ==========================================

MacBook:movie-application sw$</screen></para>

        <para>Sie können alles auf einmal zurück-rollen oder auch nur einzelne
        Migrationen. Mit dem Schalter <parameter>-T</parameter> bekommen Sie
        eine Hilfe zu allen möglichen Wegen aufgezeigt:<screen>MacBook:movie-application sw$ <command>rake -T db</command>
(in /Users/sw/Development/movie-application)
rake db:abort_if_pending_migrations  # Raises an error if there are pending...
rake db:charset                      # Retrieves the charset for the curren...
rake db:collation                    # Retrieves the collation for the curr...
rake db:create                       # Create the database defined in confi...
rake db:create:all                   # Create all the local databases defin...
rake db:drop                         # Drops the database for the current R...
rake db:drop:all                     # Drops all the local databases define...
rake db:fixtures:identify            # Search for a fixture given a LABEL o...
rake db:fixtures:load                # Load fixtures into the current envir...
rake db:forward                      # Pushes the schema to the next version.
rake db:migrate                      # Migrate the database through scripts...
rake db:migrate:down                 # Runs the "down" for a given migratio...
rake db:migrate:redo                 # Rollbacks the database one migration...
rake db:migrate:reset                # Resets your database using your migr...
rake db:migrate:up                   # Runs the "up" for a given migration ...
rake db:reset                        # Drops and recreates the database fro...
rake db:rollback                     # Rolls the schema back to the previou...
rake db:schema:dump                  # Create a db/schema.rb file that can ...
rake db:schema:load                  # Load a schema.rb file into the database
rake db:seed                         # Load the seed data from db/seeds.rb
rake db:sessions:clear               # Clear the sessions table
rake db:sessions:create              # Creates a sessions migration for use...
rake db:setup                        # Create the database, load the schema...
rake db:structure:dump               # Dump the database structure to a SQL...
rake db:test:clone                   # Recreate the test database from the ...
rake db:test:clone_structure         # Recreate the test databases from the...
rake db:test:load                    # Recreate the test database from the ...
rake db:test:prepare                 # Check for pending migrations and loa...
rake db:test:purge                   # Empty the test database
rake db:version                      # Retrieves the current schema version...
MacBook:movie-application sw$</screen></para>

        <para>Und mit <command>rake -T db:rollback</command> die Hilfe zu
        diesem bestimmten Befehl:<screen>MacBook:movie-application sw$ <command>rake -T db:rollback</command>
(in /Users/sw/Development/movie-application)
rake db:rollback  # Rolls the schema back to the previous version.
MacBook:movie-application sw$</screen></para>

        <para>Aber spielen wir lieber unsere Migration wieder ein:<screen>MacBook:movie-application sw$ <command>rake db:migrate</command>  
(in /Users/sw/Development/movie-application)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0014s
==  CreateMovies: migrated (0.0015s) ==========================================

MacBook:movie-application sw$</screen></para>
      </section>
    </section>

    <section xml:id="restful_datenbankzugriff_per_webbrowser">
      <title xml:id="restful_datenbankzugriff_per_webbrowser.title">RESTful
      Datenbankzugriff per Webbrowser</title>

      <para>Die Datenbank ist angelegt. Und der Vorteil von Scaffolding
      besteht darin, das wir jetzt auch direkt per Webbrowser in einer
      aktzeptablen Web-GUI darauf zugreifen können.</para>

      <para>Gemäss der CRUD Idee (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/CRUD">http://de.wikipedia.org/wiki/CRUD</uri>)
      bietet Rails dafür ein RESTful Webinterface an. Was heisst das? Sie
      können auf jede Resource innerhalb einer normalen Rails-Umgeben über
      definierte URLs zugreifen und damit folgende Datenbank-Operationen
      ausführen:<itemizedlist>
          <listitem>
            <para>C für CREATE</para>

            <para>SQL: <code>INSERT INTO movies (title) VALUES ('Rain
            Man')</code></para>
          </listitem>

          <listitem>
            <para>R für READ</para>

            <para>SQL: <code>SELECT * FROM movies</code></para>
          </listitem>

          <listitem>
            <para>U für UPDATE</para>

            <para>SQL: <code>UPDATE movies SET title = 'Rain Man' WHERE id =
            1</code></para>
          </listitem>

          <listitem>
            <para>D für DELETE</para>

            <para>SQL: <code>DELETE FROM movies WHERE id = 1</code></para>
          </listitem>
        </itemizedlist>Für den Rails-Neuling ist nicht direkt ersichtlich, wo
      den hier der grosse Vorteil liegt. Nachfolgend eine Mini-FAQ:<qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Warum wird um das RESTful Interface in Ruby on Rails so
                ein Bohei gemacht?</para>
              </question>

              <answer>
                <para>Damit bekommt man ein sauberes und für alle
                Programmierer leicht verständliches Interface zu Ihrem System.
                Sie brauchen nur die URI
                <uri>http://localhost:3000/movies</uri> und das Wissen, das es
                sich um ein RESTful Webdienst handelt und Sie können direkt
                loslegen.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful nur für die automatische Abfrage zwischen
                Computern gut?</para>
              </question>

              <answer>
                <para>Nein. RESTful ist auch ein guter Denkansatz, um URLs und
                damit ganze Webseiten strukturierter zu gestalten.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful Teil der <emphasis>Convention over
                Configuration</emphasis> Idee?</para>
              </question>

              <answer>
                <para>Ja! Jeder Rails-Entwickler kann sich so in kurzer Zeit
                in ein ihm neues Rails-Projekt einarbeiten.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>

      <section>
        <title>Start des Webservers</title>

        <para>Als erstes starten wir wie immer mit rails server unseren
        Entwicklungswebserver:<screen>Stefan-Wintermeyers-MacBook-Pro-2008-50:movie-application sw$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-04 14:56:29] INFO  WEBrick 1.3.1
[2010-04-04 14:56:29] INFO  ruby 1.9.1 (2010-01-10) [i386-darwin10.3.0]
[2010-04-04 14:56:29] INFO  WEBrick::HTTPServer#start: pid=19993 port=3000
</screen></para>
      </section>

      <section xml:id="restful_create">
        <title xml:id="restful_create.title">Create (Erstellen)</title>

        <para>Legen wir als erstes einmal einen neuen Datensatz an. Sie können
        das entsprechende Interface über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/new">http://0.0.0.0:3000/movies/new</uri>
        abrufen. Bitte benutzen Sie dieses Interface um einen Beispiel-Film
        einzutragen:<screenshot>
            <info>
              <title>Neuen Film in die Datenbank eintragen.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_new.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Nachdem Sie auf "Create Movie" geklickt haben, können Sie im
        Log-File folgenden Eintrag verfolgen:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 15:08:43
  Processing by MoviesController#create as HTML
  Parameters: {"authenticity_token"=&gt;"36ebldTKHnK4AXM9N2WFTCdzIzVtglqrsryicLEs1vE=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie \xC3\xBCber zwei sehr ungleiche Br\xC3\xBCder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Create Movie"}
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.4ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 13:08:43.139349', 133, 'Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.', 1988, 5, 'Rain Man', '2010-04-04 13:08:43.139349')
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 43ms


Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 15:08:43
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (11.7ms)
Completed 200 OK in 55ms (Views: 33.2ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Als Ergebnis bekommen Sie im Browserfenster den entsprechenden
        Eintrag angezeigt:<screenshot xml:id="screenshot_show_after_create">
            <info>
              <title>Nach dem Abspeichern wird der neue Eintrag
              angezeigt.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_new_show.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>
      </section>

      <section xml:id="restful_show">
        <title xml:id="restful_show.title">Show (Anzeigen eines einzelnen
        Datensatzes)</title>

        <para>Nach dem Erstellen (Create) eines neuen Datensatzes, können wir
        uns diesen natürlich jetzt einzeln anschauen. Das geht über die URI
        http://0.0.0.0:3000/movies/1<screenshot xml:id="screenshot_show">
            <info>
              <title>Anzeigen des ersten Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log erscheint die folgende Ausgabe:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-04-04 16:19:38
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (8.7ms)
Completed 200 OK in 29ms (Views: 11.5ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Ihnen wird bestimmt beim Vergleich der Screenshots <xref
        linkend="screenshot_show" /> und <xref
        linkend="screenshot_show_after_create" /> aufgefallens ein, das bei
        <xref linkend="screenshot_show_after_create" /> am oben eine grüne
        Nachricht angezeigt wurde. Das ist eine sogenannte Flash-Nachricht.
        Dabei ist das Wording "Flash" meiner Meinung nach äusserst ungeschickt
        gewählt, weil bei "Flash" jeder automatisch an das Adobe-Flash-Format
        und nicht an eine Flash-artig (Flash = Blitz) erscheinende Nachricht
        denkt. So ist es aber bei Rails. Flash-Nachrichten werden immer auf
        der nächsten und nur auf der nächsten generierten Seite angezeigt. Wir
        kommen später auf Flash detailierter zu sprechen.</para>
      </section>

      <section xml:id="restful_edit">
        <title xml:id="restful_edit.title">Edit (Bearbeiten eines
        Datensatzes)</title>

        <para></para>
      </section>

      <section xml:id="restful_index">
        <title xml:id="restful_index.title">Index (Anzeigen aller
        Datensätze)</title>

        <para>Über die URI http://0.0.0.0:3000/movies können Sie sich eine
        Liste aller Filme in der Datenbank anzeigen lassen (logischerweise ist
        das bis jetzt nur ein Film):<screenshot>
            <info>
              <title>Index-Ansicht aller Filme</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_index.jpg" format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File findet sich folgende Ausgabe:<screen>Started GET "/movies" for 127.0.0.1 at 2010-04-04 16:26:30
  Processing by MoviesController#index as HTML
  Movie Load (0.5ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (9.9ms)
Completed 200 OK in 43ms (Views: 29.5ms | ActiveRecord: 0.4ms)
</screen></para>
      </section>

      <section>
        <title>Löschen eines Datensatzes</title>

        <para>Wenn Sie auf der Index-Seite auf "Destroy" klicken, so bekommen
        Sie folgende Meldung angezeigt:<screenshot>
            <info>
              <title>Sicherheitsabfrage beim Löschen eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/destroy_r_u_sure.jpg"
                           format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Klicken wir jetzt mutig auf "OK", bekommen wir wieder die
        Index-Seite, aber diesmal ganz ohne einen Film angezeigt:<screenshot>
            <info>
              <title>Index-Ansicht nach dem Löschen des einzigen
              Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/index_after_destroy.jpg"
                           format="jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Zum Schluss noch der obligatorische Blick in das
        Log-File:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-04-04 16:34:46
  Processing by MoviesController#destroy as HTML
  Parameters: {"authenticity_token"=&gt;"xzdq0dePdnVUkBpqbDEXPhPdAo/NhTM3U/lVtjzPTds=", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.3ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 25ms
</screen></para>
      </section>
    </section>

    <section>
      <title>Routen</title>

      <para>Fassen wir mal kurz zusammen: Man kann also mit Scaffolding eine
      Web-GUI erstellen und auf diese Web-GUI anscheinen über eine feste
      CRUD-Stuktur zugreifen. Jetzt wäre ja mal interessant zu wissen, ob es
      noch mehr URIs gibt. Rails steuert das über sogenannte Routen. Alle
      Routen werden in der Datei <filename>config/routes.rb</filename>
      definiert. Standardmässig sind in dieser Datei recht viele Beispiele als
      Kommentare eingebaut. Schauen wir uns mal an, wie die aktuelle
      Konfiguration ohne diese Kommentare aussieht:<screen>MacBook:movie-application sw$ <command>cat config/routes.rb | grep -v "#" | grep -v "^$"</command>
MovieApp::Application.routes.draw do |map|
  resources :movies
end
MacBook:movie-application sw$</screen></para>

      <para>Interessant ist die Zeile:<programlisting>  resources :movies</programlisting></para>

      <para>Diese Zeile sagt Rails, das es die Resource movies mit allen
      Standard Routen ausstatten soll. Diese Routen können wir uns mit
      <command>rake routes</command> anzeigen lassen.<screen>MacBook:movie-application sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-application)
           GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
    movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
 new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
           GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
           PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
     movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
MacBook:movie-application sw$</screen></para>

      <para>Puh... das sind ja viel mehr, als wir oben benutzt haben. Oder
      doch nicht? Und jetzt muss ich das auch noch sinnvoll und strukturiert
      erklären! ;-)</para>

      <para>CRUD besteht zwar aus den vier Teilen Create, Read, Upate und
      Delete, aber diese Einzelelemente müssen in der RESTful Umsetzung weiter
      aufgeschlüsselt werden. Ziel bei REST ist es, das man eine
      Abfrage-Methodik definiert, die von allen Entwicklern gleich verstanden
      und auch benutzt werden kann. Dazu werden bei Webzugriffen die URIs und
      die HTTP-Verben benutzt. Was HTTP-Verben sind? Ich habe die Frage
      befürchtet. Bei der Entwicklung des HTTP-Protokolles wurden verschiedene
      Abfrage-Methoden definiert. Sie haben bestimmt bei einem HTML-Formular
      schon mal vom Unterschied zwischen GET und POST gelesen. GET und POST
      sind genau solche Verben. Für uns weiterhin interessant sind PUT und
      DELETE. Gerne verweise ich an dieser Stelle auf das RFC 2616 (<uri
      xlink:href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</uri>),
      falls Sie sich mit dieser Materie näher beschäftigen wollen.</para>

      <para>Für uns ist jetzt erst mal nur interessant, das gleiche URIs die
      mit unterschiedlichen Verben angesprochen werden unterschiedliche
      Aktionen in Ihrer Rails-Applikation auslösen. So können Sie in unserer
      Filmdatenbank über die URI <uri
      xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
      sowohl mit GET eine Liste (Index) aller Filme anfordern, als auch mit
      POST einen neuen Filmeintrag abspeichern.</para>

      <para>Die Kombination aus Verb und URI wird in Rails als Route
      bezeichnet. Ist eine Route nicht definiert, passiert auch nichts. Ist
      eine Route definiert, dann wird damit auf eine "Action" und einen
      "Controller" verwiesen. Ich würde jetzt gerne erklären, was es mit
      beidem auf sich hat, aber vorher will ich noch kurz <xref
      linkend="restful_mit_xml" /> besprechen, damit wir das aktuelle Thema
      RESTful Zugriff sauber abgeschlossen haben.</para>
    </section>

    <section xml:id="restful_mit_xml">
      <title xml:id="restful_mit_xml.title">RESTful Datenbankzugriff per XML
      und curl</title>

      <para>Das XML-Interface erleichtert den Austausch von Daten zwischen
      Maschinen. Dabei wird der ganze HTML-Balast abgeworfen und nur noch die
      reinen Daten per XML ausgetauscht. Beispielhaft führen wir dies mit dem
      Programm curl durch. Logischerweise geht es natürlich auch mit anderen
      Programmen oder Programmiersprachen. Wer die Art und Weise verstanden
      hat, kann von beliebigen Systemen eine Rails Applikation bedienen. Da
      dies naturgemäss auch gewisse Gefahren in sich birgt (z.B. kann eine
      Maschine per Brute-Force-Attacke schnell wie Unheil anrichten), kann man
      per Default bestimmte Aktionen nicht durchführen. Dies wird in der Datei
      <filename>app/controllers/application_controller.rb</filename> mit
      <code>protect_from_forgery</code> konfiguriert. Bitte deaktiven Sie
      diese Zeile für diese Beispiele wie folgt mit einem
      #-Zeichen:<programlisting>class ApplicationController &lt; ActionController::Base
  # protect_from_forgery
end
</programlisting></para>

      <para>Dadurch entfällt eine per default aktivierte Sicherheitsschicht,
      die einen Token austauscht, um die anonyme Interaktion von aussen zu
      underbinden. Im Log-File werden Sie den Unterschied merken (es fehlt der
      Eintrag <code>"authenticity_token"=&gt;"xyz"</code>). In späteren
      Kapiteln besprechen wir Authentifizierungsmechanismen um diese Zugriffe
      mit Passwörtern abzusichern.</para>

      <section>
        <title>new</title>

        <para>Um einen neuen Film einzutragen, benötigen Sie als erstes die
        Felder die ausgefüllt werden müssen. Dazu können Sie die URL <uri
        xlink:href="http://0.0.0.0:3000/movies/new.xml">http://0.0.0.0:3000/movies/new.xml</uri>
        abrufen:<screen>Stefan-Wintermeyers-MacBook-Pro-2008-50:~ sw$ curl -X GET http://0.0.0.0:3000/movies/new.xml
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime" nil="true"&gt;&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer" nil="true"&gt;&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title nil="true"&gt;&lt;/title&gt;
  &lt;updated-at type="datetime" nil="true"&gt;&lt;/updated-at&gt;
&lt;/movie&gt;
Stefan-Wintermeyers-MacBook-Pro-2008-50:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/new.xml" for 127.0.0.1 at 2010-04-04 19:28:19
  Processing by MoviesController#new as XML
Completed 200 OK in 124ms (Views: 111.1ms | ActiveRecord: 0.0ms)
</screen></para>

        <para>In der XML-Ausgabe können wir erkennen wie die einzelnen Felder
        heissen und welche Typen (z.B. Integer) sie darstellen. Mit diesen
        Informationen können wir jetzt einen create Aufruf mit dem neuen
        Datensatz zusammenstellen:</para>

        <para>Danach können Sie mit einem create Aufruf die Daten für einen
        neuen Datensatz uploaden:<screen>sw@debian:~/dvd-sammlung$ <command>curl -X POST -d "&lt;dvd&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/dvd&gt;" http://localhost:3000/dvds</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://localhost:3000/dvds/5"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Ausgabe im Log:<screen>Processing DvdsController#create (for 127.0.0.1 at 2009-12-25 02:25:33) [POST]
  Parameters: {"&lt;dvd&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/dvd&gt;"=&gt;nil}
  Dvd Create (0.3ms)   INSERT INTO "dvds" ("title", "production_year", "duration", "plot", "rating", "created_at", "updated_at") VALUES(NULL, NULL, NULL, NULL, NULL, '2009-12-25 01:25:33', '2009-12-25 01:25:33')
Redirected to http://localhost:3000/dvds/5
Completed in 52ms (DB: 0) | 302 Found [http://localhost/dvds]
</screen></para>

        <para>Danach werden Sie auf die show-Seite dieses Eintrages
        umgeleitet.</para>
      </section>

      <section>
        <title>index</title>

        <para>Die Liste aller aktuell gespeicherten DVDs bekommen Sie unter
        der URL <uri>http://localhost:3000/dvds.xml</uri><screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://localhost:3000/dvds.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvds type="array"&gt;
  &lt;dvd&gt;
    &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
    &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
    &lt;id type="integer"&gt;1&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1984&lt;/production-year&gt;
    &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
    &lt;title&gt;The Terminator&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
  &lt;/dvd&gt;
  &lt;dvd&gt;
    &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
    &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
    &lt;id type="integer"&gt;2&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1992&lt;/production-year&gt;
    &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
    &lt;title&gt;Terminator 2&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
  &lt;/dvd&gt;
  &lt;dvd&gt;
    &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
    &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
    &lt;id type="integer"&gt;3&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;2009&lt;/production-year&gt;
    &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
    &lt;title&gt;Terminator Salvation&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
  &lt;/dvd&gt;
&lt;/dvds&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#index to xml (for 127.0.0.1 at 2009-12-25 02:11:09) [GET]
  Dvd Load (0.9ms)   SELECT * FROM "dvds" 
Completed in 494ms (View: 491, DB: 1) | 200 OK [http://0.0.0.0/dvds.xml]
</screen></para>
      </section>

      <section>
        <title>show</title>

        <para>Eine einzelne DVD kann man sich mit der ID des Eintrages (hier
        die 1) und der entsprechenden URL
        <uri>http://localhost:3000/dvds/show/1.xml</uri> anschauen. Alternativ
        geht auch die Kurzform
        <uri>http://localhost:3000/dvds/1.xml</uri><screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://localhost:3000/dvds/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvd&gt;
  &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1984&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title&gt;The Terminator&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
&lt;/dvd&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#show to xml (for 127.0.0.1 at 2009-12-25 02:31:28) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Completed in 7ms (View: 3, DB: 0) | 200 OK [http://localhost/dvds/1.xml]
</screen></para>
      </section>

      <section>
        <title>edit - update</title>

        <para>Zum Editieren eines Eintrages downloaden wir diesen Eintrag erst
        wieder von der entsprechenden URL
        <uri>http://localhost:3000/dvds/1.xml</uri><screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://localhost:3000/dvds/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvd&gt;
  &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1984&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title&gt;The Terminator&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
&lt;/dvd&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Danach posten wir den entsprechenden Eintrag neu (in diesem
        Beispiel setzen wir das Rating auf 5 Sterne). Wichtig dabei ist, das
        wir die <parameter>id</parameter> des Eintrages mit
        übertragen:<screen>sw@debian:~/dvd-sammlung$ <command>curl -X PUT -d "&lt;dvd&gt;&lt;id&gt;1&lt;/id&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;/dvd&gt;" http://localhost:3000/dvds/update/1.xml</command>
sw@debian:~/dvd-sammlung$ </screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#update to xml (for 127.0.0.1 at 2009-12-25 02:46:31) [PUT]
  Parameters: {"&lt;dvd&gt;&lt;id&gt;1&lt;/id&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;/dvd&gt;"=&gt;nil, "id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Completed in 5ms (View: 0, DB: 0) | 200 OK [http://localhost/dvds/update/1.xml]
</screen></para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URL
        <uri>http://localhost:3000/dvds/destroy/1</uri> wieder aus der
        Datenbank löschen.<screen>sw@debian:~/dvd-sammlung$ <command>curl -X DELETE http://localhost:3000/dvds/1.xml</command>
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#destroy to xml (for 127.0.0.1 at 2009-12-25 02:49:40) [DELETE]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
  Dvd Destroy (0.2ms)   DELETE FROM "dvds" WHERE "id" = 1
Completed in 128ms (View: 0, DB: 0) | 200 OK [http://localhost/dvds/1.xml]
</screen></para>
      </section>
    </section>
  </section>
</chapter>
