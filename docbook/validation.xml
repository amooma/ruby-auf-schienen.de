<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_validation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_validation.title">Validierung</title>

  <para>ActiveRecord stellt mit validates eine schnelle und einfache
  Möglichkeit zur Validierung von Datensätzen zur Verfügung. So können Sie
  sicher sein, das auch wirklich nur sinnvolle Datensätze den Weg in Ihr
  Datenbank finden.</para>

  <section xml:id="validation_vorbereitung">
    <title
    xml:id="activerecord_validation_vorbereitung.title">Vorbereitung</title>

    <para>Erstellen wir eine neue Applikation für dieses Kapitel:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new online_shop</command>
      create  
      create  README
      create  Rakefile

      [...]

      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd online_shop</command>
stefan@swmbp 0 1.9.2-p0 online_shop$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 

[...]

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 online_shop$</screen></para>

    <para>Ein User-Model:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rails generate model user login:string password_hash:string email:string firstname:string lastname:string gender:string birthday:date</command>
      invoke  active_record
      create    db/migrate/20101013104942_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/unit/user_test.rb
      create      test/fixtures/users.yml
stefan@swmbp 0 1.9.2-p0 online_shop$ </screen></para>

    <para>Ein Telefonnummern-Model:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rails generate model phone name:string country_code:string area_code:string number:string</command>
      invoke  active_record
      create    db/migrate/20101013105612_create_phones.rb
      create    app/models/phone.rb
      invoke    test_unit
      create      test/unit/phone_test.rb
      create      test/fixtures/phones.yml
stefan@swmbp 0 1.9.2-p0 online_shop$</screen></para>

    <para>Die Datenbank anlegen:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rake db:migrate</command>
(in /Users/stefan/online_shop)
==  CreateUsers: migrating ====================================================
-- create_table(:users)
   -&gt; 0.0018s
==  CreateUsers: migrated (0.0019s) ===========================================

==  CreatePhones: migrating ===================================================
-- create_table(:phones)
   -&gt; 0.0014s
==  CreatePhones: migrated (0.0015s) ==========================================

stefan@swmbp 0 1.9.2-p0 online_shop$</screen></para>

    <para>Ein <classname>User</classname> kann mehrere Telefonnummern haben
    (siehe <xref linkend="activerecord_has_many" />). Hier die entsprechende
    <filename>app/models/user.rb</filename>:<programlisting>class User &lt; ActiveRecord::Base
  has_many :phones, :dependent =&gt; :destroy
end</programlisting></para>

    <para>Und natürlich gehört ein <classname>Phone</classname> zu einem
    <classname>User</classname>. Die entsprechende
    <filename>app/models/phone.rb</filename>:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :user
end</programlisting></para>

    <para>Brauchen wir auch Beispieldaten? Nein, die können wir auf der
    Console eingeben.</para>
  </section>

  <section>
    <title>Die Grundidee</title>

    <para>Zu jedem Model gibt es im Verzeichnis
    <filename>app/models/</filename> eine passende Datei. In dieser Datei
    können wir nicht nur Datenbankabhängikeiten definieren, sondern auch
    sämtliche Validations realisieren. Der Vorteil ist: Alles an einer Stelle.
    Convention over Configuration!</para>

    <para>Ohne jegliche Validierung können wir problemlos einen leeren
    Datensatz in beiden Modellen anlegen:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>test1 = User.create</command>
 =&gt; #&lt;User id: 1, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: "2010-10-13 11:17:44", updated_at: "2010-10-13 11:17:44"&gt; 
ruby-1.9.2-p0 &gt; <command>test2 = Phone.create</command>
 =&gt; #&lt;Phone id: 1, name: nil, country_code: nil, area_code: nil, number: nil, created_at: "2010-10-13 11:17:49", updated_at: "2010-10-13 11:17:49"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 online_shop$</screen></para>

    <para>Beide Datensätze machen aber in der Realität keinen Sinn. Ein
    <classname>User</classname> braucht ein <varname>login</varname> und eine
    Telefonnummer ohne Nummer ist auch sinnfrei. In zeige <xref
    linkend="activerecord_validation" /> ich Ihnen anhand von Beispielen, wie
    Sie für Ihre Applikation die richtigen Validations erarbeiten und sich
    damit langfristig viel Arbeit sparen können.</para>

    <para>Ich greife zur Veranschauling des Mechanismus mal <xref
    linkend="validates_presence_of" /> vorweg. Bitte füllen Sie Ihre
    <filename>app/model/user.rb</filename> mit folgendem
    Inhalt:<programlisting>class User &lt; ActiveRecord::Base
  has_many :phones, :dependent =&gt; :destroy
  
  # Validations
<emphasis>  validates_presence_of :login
</emphasis>end
</programlisting></para>

    <para>Jetzt versuchen wir noch mal in der Console einen leeren Datensatz
    anzulegen:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>apfelmus = User.create</command>
 =&gt; #&lt;User id: nil, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>apfelmus</command>
 =&gt; #&lt;User id: nil, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>apfelmus.new_record?</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; </screen></para>

    <para>Obwohl wir mit der Methode <methodname>create</methodname> (siehe
    <xref linkend="activerecord_create" />) einen neuen Datensatz anlegen
    wollten, ist dies nicht geschehen. Der Validierungs-Mechanismus hat vor
    dem Abspeichern des Datensatzes eingegriffen. Es wird also erst validiert
    und dann gespeichert.</para>

    <para>Haben wir Zugriff auf die Fehler? Ja, mit der Methode
    <methodname>errors</methodname> können wir uns die aufgetretenen Fehler
    anschauen:<screen>ruby-1.9.2-p0 &gt; <command>apfelmus.errors</command>
 =&gt; {:login=&gt;["can't be blank"]} 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Diese Fehlermeldung ist für den menschlichen Benutzer definiert
    (mehr dazu und wie die Fehler ins Deutsche übersetzt werden können in
    <xref linkend="i18n" />). Wir können aber noch eine Ebene höher gehen und
    uns mit der Methode <methodname>validators</methodname> alle aktiven
    Validierungen anschauen:<screen>ruby-1.9.2-p0 &gt; <command>User.validators</command>
 =&gt; [#&lt;ActiveModel::Validations::PresenceValidator:0x00000102b6c530 @attributes=[:login], @options={}&gt;] 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>In diesem einfachen Beispiel ist die Ausgabe noch sehr
    übersichtlich. Aber wenn Sie komplexere Validierungen haben, können Sie
    sich auch mit <methodname>validators_on</methodname> nur die Regeln für
    das Attribut <varname>login</varname> anschauen:<screen>ruby-1.9.2-p0 &gt; <command>User.validators_on(:login)</command>
 =&gt; [#&lt;ActiveModel::Validations::PresenceValidator:0x00000102b6c530 @attributes=[:login], @options={}&gt;] 
ruby-1.9.2-p0 &gt; </screen></para>

    <para>Die Ausgabe <code>ActiveModel::Validations::PresenceValidator</code>
    zeigt an, das es sich hierbei um einen
    <classname>PresenceValidator</classname> handelt.</para>

    <para>Erst wenn wir dem Attribute <varname>login</varname> einen Wert
    zuweisen, können wir das Objekt abspeichern:<screen>ruby-1.9.2-p0 &gt; <command>apfelmus.login = 'apfelmus'</command>
 =&gt; "apfelmus" 
ruby-1.9.2-p0 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>apfelmus</command>
 =&gt; #&lt;User id: 2, login: "apfelmus", password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: "2010-10-13 12:23:16", updated_at: "2010-10-13 12:23:16"&gt; 
ruby-1.9.2-p0 &gt;</screen></para>

    <section xml:id="validation_valid">
      <title xml:id="validation_valid.title">valid?</title>

      <para>Die Methode <methodname>valid?</methodname> gibt als Boolean aus,
      ob ein Objekt valide ist. So kann man schon vor dem eigentlichem
      Abspeichern eine entsprechende Kontrolle machen:<screen>ruby-1.9.2-p0 &gt; <command>pflaumenmus = User.new</command>
 =&gt; #&lt;User id: nil, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>pflaumenmus.valid?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>pflaumenmus.login = 'pflaumenmus'</command>
 =&gt; "pflaumenmus" 
ruby-1.9.2-p0 &gt; <command>pflaumenmus.valid?</command>
 =&gt; true 
ruby-1.9.2-p0 &gt;</screen></para>
    </section>

    <section xml:id="validation_safe_validate_false">
      <title xml:id="validation_safe_validate_false.title">safe(:validate
      =&gt; false)</title>

      <para>Wie so oft im Leben kann man auch hier alles umgehen. Wenn man der
      <methodname>safe</methodname> Methode als Parameter <code>:validate
      =&gt; false</code> mitgibt, dann wird der Datensatz von Validation
      abgespeichert:<screen>ruby-1.9.2-p0 &gt; <command>egon = User.new</command>
 =&gt; #&lt;User id: nil, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>egon.save</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>egon.valid?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>egon.save(:validate =&gt; false)</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>egon</command>
 =&gt; #&lt;User id: 3, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: "2010-10-13 12:32:33", updated_at: "2010-10-13 12:32:33"&gt; 
ruby-1.9.2-p0 &gt; </screen></para>

      <warning>
        <para>Ich gehe davon aus, das Sie die hier auftauchende Problematik
        verstehen. Diese Möglichkeit bitte nur einsetzen, wenn es einen guten
        Grund gibt. Sonst könnte man sich die ganze Validierung ja auch direkt
        ganz sparen.</para>
      </warning>
    </section>
  </section>

  <section xml:id="validates_presence_of">
    <title xml:id="validates_presence_of.title">validates_presence_of</title>

    <para>In unseren beiden Modellen <varname>users</varname> und
    <varname>phones</varname> gibt es ein paar Felder die auf jeden Fall
    ausgefüllt werden müssen. Das erreichen wir mit
    <methodname>validates_presence_of</methodname>.</para>

    <para><filename>app/models/user.rb</filename><programlisting>class User &lt; ActiveRecord::Base
  has_many :phones, :dependent =&gt; :destroy
  
  # Validations
<emphasis>  validates_presence_of :login, :email, :lastname, :gender, :birthday
</emphasis>end
</programlisting></para>

    <para><filename>app/models/phone.rb</filename><programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :user

  # Validations
<emphasis>  validates_presence_of :country_code, :area_code, :number
</emphasis>end</programlisting></para>

    <para>Wenn wir damit einen leeren User Datensatz anlegen wollen, bekommen
    wir massig Validierungsfehler:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>egon = User.create</command>
 =&gt; #&lt;User id: nil, login: nil, password_hash: nil, email: nil, firstname: nil, lastname: nil, gender: nil, birthday: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>egon.errors</command>
 =&gt; {:login=&gt;["can't be blank"], :email=&gt;["can't be blank"], :lastname=&gt;["can't be blank"], :gender=&gt;["can't be blank"], :birthday=&gt;["can't be blank"]} 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Erst wenn wir alle Angaben gemacht haben, kann der Datensatz
    gespeichert werden:<screen>ruby-1.9.2-p0 &gt; <command>egon.login = 'egon'</command>
 =&gt; "egon" 
ruby-1.9.2-p0 &gt; <command>egon.email = 'egon@company.com'</command>
 =&gt; "egon@company.com" 
ruby-1.9.2-p0 &gt; <command>egon.lastname = 'Meier'</command>
 =&gt; "Meier" 
ruby-1.9.2-p0 &gt; <command>egon.gender = 'male'</command>
 =&gt; "male" 
ruby-1.9.2-p0 &gt; <command>egon.birthday = Date.today - 20.years</command>
 =&gt; Sat, 13 Oct 1990 
ruby-1.9.2-p0 &gt; <command>egon.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>egon</command>
 =&gt; #&lt;User id: 4, login: "egon", password_hash: nil, email: "egon@company.com", firstname: nil, lastname: "Meier", gender: "male", birthday: "1990-10-13", created_at: "2010-10-13 20:02:18", updated_at: "2010-10-13 20:02:18"&gt; 
ruby-1.9.2-p0 &gt; </screen></para>

    <section xml:id="validates_presence_of_optionen">
      <title xml:id="validates_presence_of_optionen.title">Optionen</title>

      <para><methodname>validates_presence_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "can‘t be
            blank". Beispiel:</para>

            <para><programlisting>validates_presence_of :attribute, :message =&gt; "can't be blank" </programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><methodname>:on</methodname></para>

            <para>Um zu definieren, ob diese Validierung bei einem
            <methodname>save</methodname>, einem
            <methodname>create</methodname> oder einem
            <methodname>update</methodname> durchgeführt werden soll. Der
            Default ist <methodname>save</methodname> (also bei
            <methodname>create</methodname> und bei
            <methodname>update</methodname>). Beispiel:<programlisting>validates_presence_of :attribute, :on =&gt; :create
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_presence_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_presence_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_presence_of_doku">
      <title xml:id="validates_presence_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_presence_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_length_of">
    <title xml:id="validates_length_of.title">validates_length_of</title>

    <para>Mit <methodname>validates_length_of</methodname> können Sie die
    Länge eines bestimmten Attributes eingrenzen. Erklärt sich am Beispiel am
    einfachsten.</para>

    <para><filename>app/models/user.rb</filename><programlisting>class User &lt; ActiveRecord::Base
  has_many :phones, :dependent =&gt; :destroy
  
  # Validations
  validates_presence_of :login, :email, :lastname, :gender, :birthday
  
<emphasis>  validates_length_of :login, :within =&gt; 3..20
  validates_length_of :email, :within =&gt; 6..255
  validates_length_of :lastname, :minimum =&gt; 2
</emphasis>end
</programlisting></para>

    <para><filename>app/models/phone.rb</filename><programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :user

  # Validations
  validates_presence_of :country_code, :area_code, :number
  
<emphasis>  validates_length_of :country_code, :within =&gt; 1..3
  validates_length_of :area_code, :within =&gt; 2..5
  validates_length_of :number, :minimum =&gt; 3
</emphasis>end</programlisting></para>

    <para>Wenn wir jetzt einen <classname>User</classname> mit einem
    <methodname>login</methodname> aus einem oder zwei Buchstaben abspeichern
    wollen, dann bekommen wir einen Fehler aufgezeigt:<screen>ruby-1.9.2-p0 &gt; <command>ed = User.create(:login =&gt; 'ed', :email =&gt; 'ed@company.com', :lastname =&gt; 'Steinbruch', :gender =&gt; 'male', :birthday =&gt; Date.today - 23.years)</command>
 =&gt; #&lt;User id: nil, login: "ed", password_hash: nil, email: "ed@company.com", firstname: nil, lastname: "Steinbruch", gender: "male", birthday: "1987-10-13", created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>ed.errors</command>
 =&gt; {:login=&gt;["is too short (minimum is 3 characters)"]} 
ruby-1.9.2-p0 &gt;</screen></para>

    <section xml:id="validates_length_of_optionen">
      <title xml:id="validates_length_of_optionen.title">Optionen</title>

      <para><methodname>validates_length_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:minimum</code></para>

            <para>Die minimale Länge eines Attributes. Beispiel:</para>

            <para><programlisting>validates_length_of :attribute, :minimum =&gt; 3</programlisting></para>
          </listitem>

          <listitem>
            <para><methodname>:maximum</methodname></para>

            <para>Die maximale Länge eines Attributes.
            Beispiel:<programlisting>validates_length_of :attribute, :maximum =&gt; 255
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:is</code></para>

            <para>Ist genau so viele Zeichen lang. Beispiel:<programlisting>validates_length_of :attribute, :is =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:within</code></para>

            <para>Definiert einen Längenraum. Als erstes kommt das Minimum und
            als zweites das Maximum. Beispiel:<programlisting>validates_length_of :attribute, :within =&gt; 6..255
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben.
            Beispiel:<programlisting>validates_length_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_blank</code></para>

            <para>Das Attribut darf ganz leer sein. Beispiel:<programlisting>validates_length_of :attribute, :is =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:too_long</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:maximum</methodname>. Default: "is too long (maximum
            is %d characters)". Beispiel:<programlisting>validates_length_of :attribute, :too_long =&gt; 'way too many characters'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:too_short</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:minimum</methodname>. Default: "is too short (min is
            %d characters)". Beispiel:<programlisting>validates_length_of :attribute, :too_short =&gt; 'just not enough characters'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:wrong_length</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:is</methodname>. Default: "is the wrong length
            (should be %d characters)". Beispiel:<programlisting>validates_length_of :attribute, :wrong_length =&gt; 'not the right number of characters'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><methodname>:on</methodname></para>

            <para>Um zu definieren, ob diese Validierung bei einem
            <methodname>save</methodname>, einem
            <methodname>create</methodname> oder einem
            <methodname>update</methodname> durchgeführt werden soll. Der
            Default ist <methodname>save</methodname> (also bei
            <methodname>create</methodname> und bei
            <methodname>update</methodname>). Beispiel:<programlisting>validates_length_of :attribute, :on =&gt; :create
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_length_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_length_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:tokenizer</code></para>

            <para>Damit kann definiert werden wie das Attribut zum Zählen
            gesplittet werden soll. Default: Default: <code>lambda{ |value|
            value.split(//) }</code> (damit werden einzelne Zeichen gezählt).
            Beispiel (zum Zählen von Wörtern):<programlisting>validates_length_of :attribute, :tokenizer =&gt; lambda {|str| str.scan(/\w+/)}
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_length_of_doku">
      <title xml:id="validates_length_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_length_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_numericality_of">
    <title
    xml:id="validates_numericality_of.title">validates_numericality_of</title>

    <para>Mit <methodname>validates_numericality_of</methodname> können Sie
    überprüfen, ob ein Attributes eine Zahl ist. Erklärt sich am Beispiel am
    einfachsten.</para>

    <para><filename>app/models/phone.rb</filename><programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :user

  # Validations
  validates_presence_of :country_code, :area_code, :number
  
  validates_length_of :country_code, :within =&gt; 1..3
  validates_length_of :area_code, :within =&gt; 2..5
  validates_length_of :number, :minimum =&gt; 3
  
<emphasis>  validates_numericality_of :country_code, 
                            :only_integer =&gt; true, 
                            :greater_than_or_equal_to =&gt; 1,
                            :less_than_or_equal_to =&gt; 99
  validates_numericality_of [:area_code, :number], :only_integer =&gt; true
</emphasis>end
</programlisting></para>

    <para>Wenn wir jetzt die Telefonnummer die nicht aus Zahlen, sondern auch
    aus Zeichen besteht, bekommen wir einen Fehler angezeigt:<screen>stefan@swmbp 0 1.9.2-p0 online_shop$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>home_number = Phone.create(:country_code =&gt; '+49', :area_code =&gt; '30', :number =&gt; '88888-88')</command>
 =&gt; #&lt;Phone id: nil, name: nil, country_code: "+49", area_code: "30", number: "88888-88", created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>home_number.save</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>home_number.errors</command>
 =&gt; {:number=&gt;["is not a number"]} 
ruby-1.9.2-p0 &gt; </screen></para>

    <section xml:id="validates_numericality_of_optionen">
      <title
      xml:id="validates_numericality_of_optionen.title">Optionen</title>

      <para><methodname>validates_numericality_of</methodname> kann mit
      folgenden Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "can‘t be
            blank". Beispiel:<programlisting>validates_numericality_of :attribute, :message =&gt; 'must be a number'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><methodname>:on</methodname></para>

            <para>Um zu definieren, ob diese Validierung bei einem
            <methodname>save</methodname>, einem
            <methodname>create</methodname> oder einem
            <methodname>update</methodname> durchgeführt werden soll. Der
            Default ist <methodname>save</methodname> (also bei
            <methodname>create</methodname> und bei
            <methodname>update</methodname>). Beispiel:<programlisting>validates_numericality_of :attribute, :on =&gt; :create
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:only_integer</code></para>

            <para>Das Attribut darf nur eine Integer Zahl enthalten. Default:
            false. Beispiel:<programlisting>validates_numericality_of :attribute, :only_integer =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben.
            Beispiel:<programlisting>validates_numericality_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:greater_than</code></para>

            <para>Die im Attribut gespeicherte Zahl muss grösser sein, als der
            hier angegebene Wert. Beispiel:<programlisting>validates_numericality_of :attribute, :greater_than =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:greater_than_or_equal_to</code></para>

            <para>Die im Attribut gespeicherte Zahl muss grösser oder gleich
            dem hier angegebene Wert sein. Beispiel:<programlisting>validates_numericality_of :attribute, :greater_than_or_equal_to =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:equal_to</code></para>

            <para>Definiert einen bestimmten Wert, den das Attribute haben
            muss. Beispiel:<programlisting>validates_numericality_of :attribute, :equal_to =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:less_than</code></para>

            <para>Die im Attribut gespeicherte Zahl muss kleiner sein, als der
            hier angegebene Wert. Beispiel:<programlisting>validates_numericality_of :attribute, :less_than =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:less_than_or_equal_to</code></para>

            <para>Die im Attribut gespeicherte Zahl muss kleiner oder gleich
            dem hier angegebene Wert sein. Beispiel:<programlisting>validates_numericality_of :attribute, :less_than_or_equal_to =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:odd</code></para>

            <para>Die im Attribut gespeicherte Zahl muss ungerade sein.
            Beispiel:<programlisting>validates_numericality_of :attribute, :odd
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:even</code></para>

            <para>Die im Attribut gespeicherte Zahl muss gerade sein.
            Beispiel:<programlisting>validates_numericality_of :attribute, :even
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_numericality_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_numericality_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist><note>
          <para>Die folgenden Validationen können als Wert auch ein Proc oder
          ein Symbol, das mit einer Methode korrespondiert enthalten:
          <methodname>:greater_than</methodname>,
          <methodname>:greater_than_or_equal_to</methodname>,
          <methodname>:equal_to</methodname>,
          <methodname>:less_than</methodname>,
          <methodname>:less_than_or_equal_to</methodname></para>

          <para>Beispiel dazu aus <command>ri
          validates_numericality_of</command>:<programlisting>validates_numericality_of :width, :less_than =&gt; Proc.new { |person| person.height }
</programlisting></para>
        </note></para>
    </section>

    <section xml:id="validates_numericality_of_doku">
      <title xml:id="validates_numericality_of_doku.title">Weitere
      Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_numericality_of</command> auf der Kommandozeile
      aufrufen.</para>
    </section>
  </section>
</section>
