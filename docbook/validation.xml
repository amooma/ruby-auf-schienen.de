<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_validation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_validation.title">Validierung
  (Validation)</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Validierung</secondary>
  </indexterm>

  <para>Einer der häufigsten Fehlerquellen in Programmen sind nicht valide
  Datensätze. ActiveRecord stellt mit <methodname>validates</methodname> eine
  schnelle und einfache Möglichkeit zur Validierung von Datensätzen zur
  Verfügung. So können Sie sicher sein, dass auch wirklich nur sinnvolle
  Datensätze den Weg in Ihr Datenbank finden.</para>

  <section xml:id="validation_vorbereitung">
    <title
    xml:id="activerecord_validation_vorbereitung.title">Vorbereitung</title>

    <para>Erstellen wir eine neue Applikation für dieses Kapitel:<screen>MacBook:~ xyz$ <command>rails new shop</command>
[...]
MacBook:~ xyz$ <command>cd shop</command>
MacBook:shop xyz$ <command>rails generate model product name 'price:decimal{7,2}' weight:integer in_stock:boolean expiration_date:date</command>
[...]
MacBook:shop xyz$ <command>rake db:migrate</command>
[...]
MacBook:shop xyz$</screen></para>
  </section>

  <section>
    <title>Die Grundidee</title>

    <para>Zu jedem Model gibt es im Verzeichnis
    <filename>app/models/</filename> eine passende Datei. In dieser Datei
    können wir nicht nur Datenbankabhängikeiten definieren, sondern auch
    sämtliche Validations realisieren. Der Vorteil ist: Alles an einer Stelle.
    Convention over Configuration!</para>

    <para>Ohne jegliche Validierung können wir problemlos einen leeren
    Datensatz in beiden Modellen anlegen:<screen>SW:shop stefan$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>Product.create</command>
   (0.1ms)  begin transaction
  SQL (8.9ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Mon, 10 Sep 2012 14:45:33 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", nil], ["price", nil], ["updated_at", Mon, 10 Sep 2012 14:45:33 UTC +00:00], ["weight", nil]]
   (0.9ms)  commit transaction
 =&gt; #&lt;Product id: 1, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: "2012-09-10 14:45:33", updated_at: "2012-09-10 14:45:33"&gt; 
1.9.3p194 :002 &gt; <command>exit</command>
SW:shop stefan$</screen></para>

    <para>Dieser Datensatz macht aber in der Realität keinen Sinn. Ein
    <classname>Product</classname> braucht einen <varname>name</varname> und
    einen <methodname>price</methodname>. Deshalb kann man in ActiveRecord
    Validierungen definieren. Damit können Sie als Programmierer sicher
    stellen, das nur für Sie valide Datensätze in Ihrer Datenbank
    abgespeichert werden.</para>

    <para>Ich greife zur Veranschaulichung des Mechanismus den
    <code>presence</code> Helper vorweg. Bitte füllen Sie Ihre
    <filename>app/model/product.rb</filename> mit folgendem
    Inhalt:<programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true

  validates :price,
            :presence =&gt; true
end</programlisting></para>

    <para>Jetzt versuchen wir noch mal in der Console einen leeren Datensatz
    anzulegen:<screen>SW:shop stefan$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>product = Product.create</command>
   (0.0ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.valid?</command>
 =&gt; false 
1.9.3p194 :003 &gt; </screen></para>

    <para>Obwohl wir mit der Methode <methodname>create</methodname> (siehe
    <xref linkend="activerecord_create"/>) einen neuen Datensatz anlegen
    wollten, ist dies nicht geschehen. Der Validierungs-Mechanismus hat vor
    dem Abspeichern des Datensatzes eingegriffen. Es wird also erst validiert
    und dann gespeichert.</para>

    <para>Haben wir Zugriff auf die Fehler? Ja, mit der Methode
    <methodname>errors</methodname> bzw. mit
    <methodname>errors.messages</methodname> können wir uns die aufgetretenen
    Fehler anschauen:<screen>1.9.3p194 :003 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007ff88537fae8 @base=#&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["can't be blank"], :price=&gt;["can't be blank"]}&gt; 
1.9.3p194 :004 &gt; <command>product.errors.messages</command>
 =&gt; {:name=&gt;["can't be blank"], :price=&gt;["can't be blank"]} 
1.9.3p194 :005 &gt;</screen></para>

    <para>Diese Fehlermeldung ist für einen menschlichen und
    englischsprachigen Benutzer definiert (mehr dazu und wie die Fehler ins
    Deutsche übersetzt werden können in <xref linkend="i18n"/>).</para>

    <para>Erst wenn wir den Attributen <varname>name</varname> und
    <methodname>price</methodname> einen Wert zuweisen, können wir das Objekt
    abspeichern:<screen>1.9.3p194 :005 &gt; <command>product.name = 'Milch (1 Liter)'</command>
 =&gt; "Milch (1 Liter)" 
1.9.3p194 :006 &gt; <command>product.price = 0.45</command>
 =&gt; 0.45 
1.9.3p194 :007 &gt; <command>product.save</command>
   (0.1ms)  begin transaction
  SQL (6.4ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Mon, 10 Sep 2012 14:52:44 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", "Milch (1 Liter)"], ["price", #&lt;BigDecimal:7ff8852ea5d8,'0.45E0',9(45)&gt;], ["updated_at", Mon, 10 Sep 2012 14:52:44 UTC +00:00], ["weight", nil]]
   (0.8ms)  commit transaction
 =&gt; true 
1.9.3p194 :008 &gt;</screen></para>

    <section xml:id="validation_valid">
      <title xml:id="validation_valid.title">valid?</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>valid?()</tertiary>
      </indexterm>

      <para>Die Methode <methodname>valid?</methodname> gibt als Boolean aus,
      ob ein Objekt valide ist. So kann man schon vor dem eigentlichem
      Abspeichern eine entsprechende Kontrolle machen:<screen>1.9.3p194 :008 &gt; <command>product = Product.new</command>
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :009 &gt; <command>product.valid?</command>
 =&gt; false 
1.9.3p194 :010 &gt;</screen></para>
    </section>

    <section xml:id="validation_save_validate_false">
      <title xml:id="validation_save_validate_false.title">save( :validate
      =&gt; false )</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>save()</tertiary>
      </indexterm>

      <para>Wie so oft im Leben kann man auch hier alles umgehen. Wenn man der
      Methode <methodname>save</methodname> als Parameter <code>:validate
      =&gt; false</code> mitgibt, dann wird der Datensatz von
      <code>Validation</code> abgespeichert:<screen>1.9.3p194 :010 &gt; <command>product = Product.new</command>
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :011 &gt; <command>product.save</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; false 
1.9.3p194 :012 &gt; <command>product.valid?</command>
 =&gt; false 
1.9.3p194 :013 &gt; <command>product.save(:validate =&gt; false)</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Tue, 08 May 2012 15:20:44 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", nil], ["price", nil], ["updated_at", Tue, 08 May 2012 15:20:44 UTC +00:00], ["weight", nil]]
   (3.5ms)  commit transaction
 =&gt; true 
1.9.3p194 :014 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

      <warning>
        <para>Ich gehe davon aus, dass Sie die hier auftauchende Problematik
        verstehen. Diese Möglichkeit bitte nur einsetzen, wenn es einen guten
        Grund gibt. Sonst könnte man sich die ganze Validierung ja auch direkt
        ganz sparen.</para>
      </warning>
    </section>
  </section>

  <section xml:id="validates_presence_of">
    <title xml:id="validates_presence_of.title">presence</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_presence_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>presence</tertiary>
    </indexterm>

    <para>In unserem Model <varname>product</varname> gibt es ein paar Felder
    die auf jeden Fall ausgefüllt werden müssen. Das erreichen wir mit
    <methodname>presence</methodname>.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true

  validates :price,
            :presence =&gt; true
end
</programlisting></para>

    <para>Wenn wir damit einen leeren User Datensatz anlegen wollen, bekommen
    wir massig Validierungsfehler:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>product = Product.create</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; p<command>roduct.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007ffe9189e0d0 @base=#&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["can't be blank"], :price=&gt;["can't be blank"]}&gt; 
1.9.3p194 :003 &gt;</screen></para>

    <para>Erst wenn wir alle Angaben gemacht haben, kann der Datensatz
    gespeichert werden:<screen>1.9.3p194 :003 &gt; <command>product.name = 'Milch (1 Liter)'</command>
 =&gt; "Milch (1 Liter)" 
1.9.3p194 :004 &gt; <command>product.price = 0.45</command>
 =&gt; 0.45 
1.9.3p194 :005 &gt; <command>product.save</command>
   (0.1ms)  begin transaction
  SQL (5.2ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Tue, 08 May 2012 15:25:22 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", "Milch (1 Liter)"], ["price", #&lt;BigDecimal:7ffe91a2d270,'0.45E0',9(45)&gt;], ["updated_at", Tue, 08 May 2012 15:25:22 UTC +00:00], ["weight", nil]]
   (3.9ms)  commit transaction
 =&gt; true 
1.9.3p194 :006 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>
  </section>

  <section xml:id="validates_length_of">
    <title xml:id="validates_length_of.title">length</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_length_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>length</tertiary>
    </indexterm>

    <para>Mit <methodname>length</methodname> können Sie die Länge eines
    bestimmten Attributes eingrenzen. Erklärt sich am Beispiel am
    einfachsten.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true,
            <emphasis>:length =&gt; { :in =&gt; 2..20 }</emphasis>

  validates :price,
            :presence =&gt; true
end
</programlisting></para>

    <para>Wenn wir jetzt einen <classname>Product</classname> mit einem
    <methodname>name</methodname> aus einem Buchstaben abspeichern wollen,
    dann bekommen wir einen Fehler aufgezeigt:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>product = Product.create(:name =&gt; 'M', :price =&gt; 0.45)</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "M", price: #&lt;BigDecimal:7fd6ad8cec28,'0.45E0',9(45)&gt;, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fd6ad88fe38 @base=#&lt;Product id: nil, name: "M", price: #&lt;BigDecimal:7fd6ad8d19c8,'0.45E0',9(45)&gt;, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["is too short (minimum is 2 characters)"]}&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <section xml:id="validates_length_of_optionen">
      <title xml:id="validates_length_of_optionen.title">Optionen</title>

      <para><methodname>length</methodname> kann mit folgenden Optionen
      aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:minimum</code></para>

            <para>Die minimale Länge eines Attributes. Beispiel:</para>

            <para><programlisting>validates :name,
          :presence =&gt; true,
          <emphasis>:length =&gt; { :minimum =&gt; 2 }</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><methodname>:maximum</methodname></para>

            <para>Die maximale Länge eines Attributes.
            Beispiel:<programlisting>validates :name,
          :presence =&gt; true,
          <emphasis>:length =&gt; { :maximum =&gt; 20 }</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><code>:is</code></para>

            <para>Ist genau so viele Zeichen lang. Beispiel:<programlisting>validates :name,
          :presence =&gt; true,
          <emphasis>:length =&gt; { :is =&gt; 8 }</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><code>:in oder :within</code></para>

            <para>Definiert einen Längenraum. Als erstes kommt das Minimum und
            als zweites das Maximum. Beispiel:<programlisting>validates :name,
          :presence =&gt; true,
          <emphasis>:length =&gt; { :in =&gt; 2..20 }</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><code>:tokenizer</code></para>

            <para>Damit kann definiert werden wie das Attribut zum Zählen
            gesplittet werden soll. Default: Default: <code>lambda{ |value|
            value.split(//) }</code> (damit werden einzelne Zeichen gezählt).
            Beispiel (zum Zählen von Wörtern):<programlisting>validates :content,
          :presence =&gt; true,
          :length =&gt; { :in =&gt; 2..20 },
          <emphasis>:tokenizer =&gt; lambda {|str| str.scan(/\w+/)}
</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><code>:too_long</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:maximum</methodname>. Default: "is too long (maximum
            is %d characters)". Beispiel:<programlisting>validates :name,
          :presence =&gt; true,
          :length =&gt; { :maximum =&gt; 20 },
          <emphasis>:too_long =&gt; "must have at most %{count} characters"</emphasis>
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n"/>.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:too_short</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:minimum</methodname>. Default: "is too short (min is
            %d characters)". Beispiel:<programlisting>validates :name,
          :presence =&gt; true,
          :length =&gt; { :minimum =&gt; 5 },
          <emphasis>:too_short =&gt; "must have at least %{count} characters"</emphasis>
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n"/>.</para>
              </note></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section xml:id="validates_numericality_of">
    <title xml:id="validates_numericality_of.title">numericality</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_numericality_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>numericality</tertiary>
    </indexterm>

    <para>Mit <methodname>numericality</methodname> können Sie überprüfen, ob
    ein Attributes eine Zahl ist. Erklärt sich am Beispiel am
    einfachsten.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true,
            :length =&gt; { :in =&gt; 2..20 }

  validates :price,
            :presence =&gt; true

  validates :weight,
            <emphasis>:numericality =&gt; true</emphasis>
end
</programlisting></para>

    <para>Wenn wir jetzt das Gewicht (<varname>weight</varname>) die nicht aus
    Zahlen, sondern auch aus Zeichen besteht, bekommen wir einen Fehler
    angezeigt:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>product = Product.create(:name =&gt; 'Milch (1 Liter)', :price =&gt; 0.45, :weight =&gt; 'abc')</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7f8594def848,'0.45E0',9(45)&gt;, weight: 0, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007f8594ba3878 @base=#&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7f8594df3588,'0.45E0',9(45)&gt;, weight: 0, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:weight=&gt;["is not a number"]}&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <tip>
      <para>Auch wenn ein Attribute in der Datenbank ans String abgelegt wird,
      kann man mit <methodname>numericality</methodname> den Inhalt auf eine
      Zahl festlegen.</para>
    </tip>

    <section xml:id="validates_numericality_of_optionen">
      <title
      xml:id="validates_numericality_of_optionen.title">Optionen</title>

      <para><methodname>numericality</methodname> kann mit folgenden Optionen
      aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:only_integer</code></para>

            <para>Das Attribut darf nur eine Integer Zahl enthalten. Default:
            false. Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :only_integer =&gt; true }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:greater_than</code></para>

            <para>Die im Attribut gespeicherte Zahl muss grösser sein, als der
            hier angegebene Wert. Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :greater_than =&gt; 100 }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:greater_than_or_equal_to</code></para>

            <para>Die im Attribut gespeicherte Zahl muss grösser oder gleich
            dem hier angegebene Wert sein. Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :greater_than_or_equal_to =&gt; 100 }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:equal_to</code></para>

            <para>Definiert einen bestimmten Wert, den das Attribute haben
            muss. Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :equal_to =&gt; 100 }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:less_than</code></para>

            <para>Die im Attribut gespeicherte Zahl muss kleiner sein, als der
            hier angegebene Wert. Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :less_than =&gt; 100 }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:less_than_or_equal_to</code></para>

            <para>Die im Attribut gespeicherte Zahl muss kleiner oder gleich
            dem hier angegebene Wert sein. Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :less_than_or_equal_to =&gt; 100 }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:odd</code></para>

            <para>Die im Attribut gespeicherte Zahl muss ungerade sein.
            Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :odd =&gt; true }
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:even</code></para>

            <para>Die im Attribut gespeicherte Zahl muss gerade sein.
            Beispiel:<programlisting>validates :weight, 
          :numericality =&gt; { :even =&gt; true }
</programlisting></para>
          </listitem>
        </itemizedlist><note>
          <para>Die folgenden Validationen können als Wert auch ein Proc oder
          ein Symbol, das mit einer Methode korrespondiert enthalten:
          <methodname>:greater_than</methodname>,
          <methodname>:greater_than_or_equal_to</methodname>,
          <methodname>:equal_to</methodname>,
          <methodname>:less_than</methodname>,
          <methodname>:less_than_or_equal_to</methodname></para>

          <para>Beispiel dazu aus <command>ri
          validates_numericality_of</command>:<programlisting>validates_numericality_of :width, :less_than =&gt; Proc.new { |person| person.height }
</programlisting></para>
        </note></para>
    </section>
  </section>

  <section xml:id="validates_uniqueness_of">
    <title xml:id="validates_uniqueness_of.title">uniqueness</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_uniqueness_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>uniqueness</tertiary>
    </indexterm>

    <para>Mit <methodname>uniqueness</methodname> können Sie definieren, dass
    der Wert dieses Attribut einzigartig in der Datenbank ist. Wenn ein
    Produkt in der Datenbank einen eindeutigen und nicht doppelt vorhandenen
    Namen haben soll, dann geht das mit dieser Validierung:</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true,
            <emphasis>:uniqueness =&gt; true</emphasis>
end
</programlisting></para>

    <para>Wenn wir jetzt ein neues <classname>Product</classname> mit einem
    schon existierenden <methodname>name</methodname> einrichten wollen,
    bekommen wir einen Fehler ausgegeben:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>Product.last</command>
  Product Load (0.2ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" DESC LIMIT 1
 =&gt; #&lt;Product id: 4, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7fc6e9695160,'0.45E0',9(45)&gt;, weight: nil, in_stock: nil, expiration_date: nil, created_at: "2012-05-08 15:25:22", updated_at: "2012-05-08 15:25:22"&gt; 
1.9.3p194 :002 &gt; <command>product = Product.create(:name =&gt; 'Milch (1 Liter)', :price =&gt; 0.45, :weight =&gt; 1000)</command>
   (0.1ms)  begin transaction
  Product Exists (0.2ms)  SELECT 1 FROM "products" WHERE "products"."name" = 'Milch (1 Liter)' LIMIT 1
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7fc6e9f7cb70,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :003 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fc6e9432300 @base=#&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7fc6e9b09250,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["has already been taken"]}&gt; 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <warning>
      <para>Die Validierung mit <methodname>uniqueness</methodname> ist kein
      absoluter Garant für eine echte Einzigartigkeit des Attributes in der
      Datenbank. Es kann dabei zu einer Race-Condition kommen (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/Race_Condition">http://de.wikipedia.org/wiki/Race_Condition</uri>).
      Die detaillierte Diskussion dieses Effektes übersteigt allerdings die
      Tiefe eines Einsteigerbuches (es handelt sich um ein extrem seltenes
      Phänomen).</para>
    </warning>

    <section xml:id="validates_uniqueness_of_optionen">
      <title xml:id="validates_uniqueness_of_optionen.title">Optionen</title>

      <para><methodname>uniqueness</methodname> kann mit folgenden Optionen
      aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:scope</code></para>

            <para>Definiert einen Geltungsbereich für die Einzigartigkeit.
            Wenn wir eine anderes strukturiere Telefonnummerndatenbank hätten
            (mit nur einem Feld für die Telefonnummer, dann könnten wir damit
            definieren, das eine Telefonnummer pro User nur einmal gespeichert
            werden darf. Das sähe dann so aus:</para>

            <para><programlisting>validates :name,
          :presence =&gt; true,
          <emphasis>:uniqueness =&gt; { :scope =&gt; :user_id }</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><methodname>:case_sensitive</methodname></para>

            <para>Überprüft die Einzigartikeit auch auf Gross- und
            Kleinschreibung. Default: False. Beispiel:<programlisting>validates :name,
          :presence =&gt; true,
          <emphasis>:uniqueness =&gt; { :case_sensitive =&gt; true }</emphasis>
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section xml:id="validates_inclusion_of">
    <title xml:id="validates_inclusion_of.title">inclusion</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_inclusion_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>inclusion</tertiary>
    </indexterm>

    <para>Mit <methodname>inclusion</methodname> können Sie definieren, aus
    welchen Werten der Inhalt dieses Attributes erstellt werden kann. Bei
    unserem Beispiel können wir das am Attribute
    <methodname>in_stock</methodname> veranschaulischen.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true,
            :length =&gt; { :in =&gt; 2..20 }

  validates :price,
            :presence =&gt; true

  validates :in_stock,
            <emphasis>:inclusion =&gt; { :in =&gt; [true, false] }</emphasis>
end
</programlisting></para>

    <para>In unserem Datenmodel muss ein <classname>Product</classname> als
    <methodname>in_stock</methodname> entweder <code>true</code> oder
    <code>false</code> sein (es darf also kein nil geben). Wenn wir einen
    anderen Wert als <code>true</code> oder <code>false</code> eingeben, wird
    ein Validation-Fehler gemeldet:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>product = Product.create(:name =&gt; 'Milch fettarm (1 Liter)', :price =&gt; 0.45, :weight =&gt; 1000)</command>
   (0.1ms)  begin transaction
  Product Exists (0.2ms)  SELECT 1 FROM "products" WHERE "products"."name" = 'Milch fettarm (1 Liter)' LIMIT 1
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "Milch fettarm (1 Liter)", price: #&lt;BigDecimal:7fd125470f38,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fd12513a648 @base=#&lt;Product id: nil, name: "Milch fettarm (1 Liter)", price: #&lt;BigDecimal:7fd125475bf0,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:in_stock=&gt;["is not included in the list"]}&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <tip>
      <para>Denken Sie immer an die Macht von Ruby! Sie können so z.B. das
      Enumerable Objekt für in immer live aus einer anderen Datenbank
      generieren. Das heißt die Validation ist nicht statisch
      definiert.</para>
    </tip>

    <section xml:id="validates_inclusion_of_optionen">
      <title xml:id="validates_inclusion_of_optionen.title">Optionen</title>

      <para><methodname>inclusion</methodname> kann mit folgenden Optionen
      aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "is not
            included in the list". Beispiel:<programlisting>validates :in_stock,
          :inclusion =&gt; { :in =&gt; [true, false], 
                          <emphasis>:message =&gt; 'this one is not allowed'</emphasis> }
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n"/>.</para>
              </note></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section xml:id="validates_exclusion_of">
    <title xml:id="validates_exclusion_of.title">exclusion</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_exclusion_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>exclusion</tertiary>
    </indexterm>

    <para><methodname>exclusion</methodname> ist die Umkehrung von <xref
    linkend="validates_inclusion_of"/>. Sie können definieren, aus welchen
    Werten der Inhalt dieses Attributes nicht erstellt werden darf.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true,
            :length =&gt; { :in =&gt; 2..20 }

  validates :price,
            :presence =&gt; true

  validates :in_stock,
            <emphasis>:exclusion =&gt; { :in =&gt; [nil] }</emphasis>
end
</programlisting></para>

    <tip>
      <para>Denken Sie immer an die Macht von Ruby! Sie können so z.B. das
      Enumerable Objekt für in immer live aus einer anderen Datenbank
      generieren. Das heißt die Validation muss nicht statisch definiert
      werden.</para>
    </tip>

    <section xml:id="validates_exclusion_of_optionen">
      <title xml:id="validates_exclusion_of_optionen.title">Optionen</title>

      <para><methodname>exclusion</methodname> kann mit folgenden Optionen
      aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "is not
            included in the list". Beispiel:<programlisting>validates :in_stock,
          :exclusion =&gt; { :in =&gt; [nil], 
                          <emphasis>:message =&gt; 'xyz'</emphasis> }
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n"/>.</para>
              </note></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section xml:id="validates_format_of">
    <title xml:id="validates_format_of.title">format</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_format_of()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>format</tertiary>
    </indexterm>

    <para>Mit <methodname>format</methodname> können Sie mit einer Regular
    Expression (siehe <uri
    xlink:href="http://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck">http://de.wikipedia.org/wiki/Regulärer_Ausdruck</uri>)
    definieren wie sich der Inhalt eines Attributes aufbauen darf.</para>

    <para>Mit <methodname>format</methodname> kann man z.B. eine einfache
    Validierung der Syntax einer E-Mail Adresse machen:</para>

    <para><programlisting>validates :email, 
          <emphasis>:format =&gt; { :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i }</emphasis></programlisting></para>

    <warning>
      <para>Es sollte klar sein, dass die hier gezeigte
      E-Mail-Adressen-Validierung nicht vollständig ist. Es geht hier nur um
      ein Beispiel. Damit kann man nur die syntaktische Korrektheit einer
      E-Mail-Adresse überprüfen.</para>
    </warning>

    <section xml:id="validates_format_of_optionen">
      <title xml:id="validates_format_of_optionen.title">Optionen</title>

      <para><methodname>validates_format_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "is
            invalid". Beispiel:<programlisting>validates :email, 
          :format =&gt; { :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i,
                       <emphasis>:message =&gt; 'is not a valid email address'</emphasis> }
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n"/>.</para>
              </note></para>
          </listitem>
        </itemizedlist></para>
    </section>
  </section>

  <section xml:id="validates_allgemeine_validierungs_optionen">
    <title
    xml:id="validates_allgemeine_validierungs_optionen.title">Allgemeine
    Validierungs-Optionen</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>allow_nil</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>allow_blank</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>on</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>if</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>unless</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validates</secondary>

      <tertiary>proc</tertiary>
    </indexterm>

    <para>Es gibt einige Optionen, die bei allen Validierungen verwendet
    werden können:<itemizedlist>
        <listitem>
          <para><code>:allow_nil</code></para>

          <para>Erlaubt den Wert <code>nil</code>. Beispiel:<programlisting>validates :email, 
          :format =&gt; { :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i },
          <emphasis>:allow_nil =&gt; true</emphasis></programlisting></para>
        </listitem>

        <listitem>
          <para><code>:allow_blank</code></para>

          <para>Wie <code>allow_nil</code>, aber zusätzlich noch mit einem
          leeren String. Beispiel:<programlisting>validates :email, 
          :format =&gt; { :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i },
          <emphasis>:allow_blank =&gt; true</emphasis></programlisting></para>
        </listitem>

        <listitem>
          <para><code>:on</code></para>

          <para>Eine Validierung kann mit <code>on</code> auf die Events
          <code>create</code>, <code>update</code> oder <code>safe</code>
          beschänkt werden. Im folgenden Beispiel greift die Validierung nur
          beim initialen Erstellen des Datensatzes (beim
          <code>create</code>):<programlisting>validates :email, 
          :format =&gt; { :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i },
          <emphasis>:on =&gt; :create</emphasis></programlisting></para>
        </listitem>

        <listitem>
          <para><code>:if</code> und <code>:unless</code></para>

          <para><code>:if</code> oder <code>:unless</code> rufen die
          angegebene Methode auf und führen die Validierung nur aus, wenn das
          Ergebniss der Methode true ist:<programlisting>validates :name,
          :presence =&gt; true,
          :if =&gt; :today_is_monday?

def today_is_monday?
  Date.today.monday?
end
</programlisting></para>
        </listitem>

        <listitem>
          <para><code>:proc</code></para>

          <para><code>:</code><code>proc</code> ruft ein
          <classname>Proc</classname> Objekt auf.<programlisting>validates :name,
          :presence =&gt; true,
          :if =&gt; Proc.new { |a| a.email == 'test@test.com' }
</programlisting></para>
        </listitem>
      </itemizedlist></para>
  </section>

  <section xml:id="validates_eigene_validations_definieren">
    <title xml:id="validates_eigene_validations_definieren.title">Eigene
    Validations schreiben</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Eigene Validations schreiben</secondary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>validate</secondary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>errors</secondary>

      <tertiary>add</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>errors</secondary>

      <tertiary>add_to_base</tertiary>
    </indexterm>

    <para>Hin und wieder möchte man eine Validierung durchführen, bei der man
    eigene Programmlogik benötigt. Für diesen Fall kann man eigene
    Validierungen definieren.</para>

    <section>
      <title>Validierungen mit eigenen Methoden definieren</title>

      <para>Nehmen wir einmal an, Sie haben eine Klasse HotelReservation und
      dort darf das Ende der Reservierung logischerweise nicht vor dem Start
      der Reservierung liegen. Legen wir erst mal das Model an:<screen>MacBook:shop xyz$ <command>rails generate model HotelReservation start_date:date end_date:date room_type</command>
[...]
MacBook:shop xyz$ <command>rake db:migrate</command>
[...]
MacBook:shop xyz$</screen></para>

      <para>Dann legen wir in der
      <filename>app/model/hotel_reservation.rb</filename> fest, das die
      Attribute <varname>start_date</varname> und <varname>end_date</varname>
      auf jeden Fall ausgefühlt werden müssen und zusätzlich überprüfen wir
      mit der Methode <methodname>start_has_to_be_before_end</methodname> das
      das <varname>start_date</varname> vor dem <varname>end_date</varname>
      liegt:<programlisting>class HotelReservation &lt; ActiveRecord::Base
  attr_accessible :end_date, :room_type, :start_date

  validates :start_date,
            :presence =&gt; true

  validates :end_date,
            :presence =&gt; true

<emphasis>  validate :start_has_to_be_before_end

  def start_has_to_be_before_end
    if end_date &lt; start_date
      errors.add(:start_date, 'has to be before the end date')
    end
  end</emphasis>

end</programlisting></para>

      <para>Mit <methodname>errors.add</methodname> können wir Fehlermeldungen
      zu einzelnen Attributen hinzufügen. Mit
      <methodname>errors.add_to_base</methodname> können Sie Fehlermeldungen
      zum gesamten Objekt hinzufügen.</para>

      <para>Probieren wir die Validierung in der Console aus:<screen>MacBook:shop stefan$ <command>rails console</command>
Loading development environment (Rails 3.2.8)
1.9.3p194 :001 &gt; <command>new_reservation = HotelReservation.new(:start_date =&gt; Date.today, :end_date =&gt; Date.today - 1.day)</command>
 =&gt; #&lt;HotelReservation id: nil, start_date: "2012-09-16", end_date: "2012-09-15", room_type: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>new_reservation.valid?</command>
 =&gt; false 
1.9.3p194 :003 &gt; <command>new_reservation.errors.messages</command>
 =&gt; {:start_date=&gt;["has to be before the end date"]} 
1.9.3p194 :004 &gt; <command>new_reservation.end_date = Date.today + 10.days</command>
 =&gt; Wed, 26 Sep 2012 
1.9.3p194 :005 &gt; <command>new_reservation.valid?</command>
 =&gt; true 
1.9.3p194 :006 &gt; <command>exit</command>
MacBook:shop stefan$ </screen></para>
    </section>
  </section>

  <section xml:id="validates_weitere_doku">
    <title xml:id="validates_weitere_doku.title">Weitere Doku</title>

    <para>Das Thema Validations wird in der offiziellen englischen Rails-Doku
    unter <uri
    xlink:href="http://guides.rubyonrails.org/active_record_validations_callbacks.html">http://guides.rubyonrails.org/active_record_validations_callbacks.html</uri>
    sehr gut beschrieben. Im System können Sie mit <command>ri
    validates</command> auf der Kommandozeile die System-Doku abrufen.</para>
  </section>
</section>
