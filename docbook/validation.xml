<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_validation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title
  annotations="ACHTUNG: Validierungen haben in der aktuellen Rails Version eine andere Syntax."
  xml:id="activerecord_validation.title">Validierung (Validation)</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Validierung</secondary>
  </indexterm>

  <para>Einer der häufigsten Fehlerquellen in Programmen sind nicht valide
  Datensätze. ActiveRecord stellt mit
  <methodname>validates<replaceable>…</replaceable>()</methodname> eine
  schnelle und einfache Möglichkeit zur Validierung von Datensätzen zur
  Verfügung. So können Sie sicher sein, dass auch wirklich nur sinnvolle
  Datensätze den Weg in Ihr Datenbank finden.</para>

  <section xml:id="validation_vorbereitung">
    <title
    xml:id="activerecord_validation_vorbereitung.title">Vorbereitung</title>

    <para>Erstellen wir eine neue Applikation für dieses Kapitel:<screen>MacBook:~ xyz$ <command>rails new shop</command>
[...]
MacBook:~ xyz$ <command>cd shop</command>
MacBook:shop xyz$ <command>rails generate model product name 'price:decimal{7,2}' weight:integer in_stock:boolean expiration_date:date</command>
[...]
MacBook:shop xyz$ <command>rake db:migrate</command>
[...]
MacBook:shop xyz$</screen></para>
  </section>

  <section>
    <title>Die Grundidee</title>

    <para>Zu jedem Model gibt es im Verzeichnis
    <filename>app/models/</filename> eine passende Datei. In dieser Datei
    können wir nicht nur Datenbankabhängikeiten definieren, sondern auch
    sämtliche Validations realisieren. Der Vorteil ist: Alles an einer Stelle.
    Convention over Configuration!</para>

    <para>Ohne jegliche Validierung können wir problemlos einen leeren
    Datensatz in beiden Modellen anlegen:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Product.create</command>
   (0.1ms)  begin transaction
  SQL (7.9ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Tue, 08 May 2012 14:30:51 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", nil], ["price", nil], ["updated_at", Tue, 08 May 2012 14:30:51 UTC +00:00], ["weight", nil]]
   (1.0ms)  commit transaction
 =&gt; #&lt;Product id: 1, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: "2012-05-08 14:30:51", updated_at: "2012-05-08 14:30:51"&gt; 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <para>Dieser Datensatz macht aber in der Realität keinen Sinn. Ein
    <classname>Product</classname> braucht einen <varname>name</varname> und
    einen <methodname>price</methodname>. In zeige <xref
    linkend="activerecord_validation" /> ich Ihnen anhand von Beispielen, wie
    Sie für Ihre Applikation die richtigen Validations erarbeiten und sich
    damit langfristig viel Arbeit sparen können.</para>

    <para>Ich greife zur Veranschaulichung des Mechanismus mal <xref
    linkend="validates_presence_of" /> vorweg. Bitte füllen Sie Ihre
    <filename>app/model/product.rb</filename> mit folgendem
    Inhalt:<programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price
end
</programlisting></para>

    <para>Jetzt versuchen wir noch mal in der Console einen leeren Datensatz
    anzulegen:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>product = Product.create</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.new_record?</command>
 =&gt; true 
1.9.3p194 :003 &gt;  </screen></para>

    <para>Obwohl wir mit der Methode <methodname>create</methodname> (siehe
    <xref linkend="activerecord_create" />) einen neuen Datensatz anlegen
    wollten, ist dies nicht geschehen. Der Validierungs-Mechanismus hat vor
    dem Abspeichern des Datensatzes eingegriffen. Es wird also erst validiert
    und dann gespeichert.</para>

    <para>Haben wir Zugriff auf die Fehler? Ja, mit der Methode
    <methodname>errors</methodname> können wir uns die aufgetretenen Fehler
    anschauen:<screen>1.9.3p194 :003 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fd90ceefab0 @base=#&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["can't be blank"], :price=&gt;["can't be blank"]}&gt; 
1.9.3p194 :004 &gt; <command>product.errors.messages</command>
 =&gt; {:name=&gt;["can't be blank"], :price=&gt;["can't be blank"]} 
1.9.3p194 :005 &gt;</screen></para>

    <para>Diese Fehlermeldung ist für den menschlichen Benutzer definiert
    (mehr dazu und wie die Fehler ins Deutsche übersetzt werden können in
    <xref linkend="i18n" />). </para>

    <para>Erst wenn wir den Attributen <varname>name</varname> und
    <methodname>price</methodname> einen Wert zuweisen, können wir das Objekt
    abspeichern:<screen>1.9.3p194 :005 &gt; <command>product.name = 'Milch (1 Liter)'</command>
 =&gt; "Milch (1 Liter)" 
1.9.3p194 :006 &gt; <command>product.price = 0.45</command>
 =&gt; 0.45 
1.9.3p194 :007 &gt; <command>product.save</command>
   (2.6ms)  begin transaction
  SQL (23.8ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Tue, 08 May 2012 15:18:45 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", "Milch (1 Liter)"], ["price", #&lt;BigDecimal:7fd90cc089f0,'0.45E0',9(45)&gt;], ["updated_at", Tue, 08 May 2012 15:18:45 UTC +00:00], ["weight", nil]]
   (1.1ms)  commit transaction
 =&gt; true 
1.9.3p194 :008 &gt;</screen></para>

    <section xml:id="validation_valid">
      <title xml:id="validation_valid.title">valid?</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>valid?()</tertiary>
      </indexterm>

      <para>Die Methode <methodname>valid?</methodname> gibt als Boolean aus,
      ob ein Objekt valide ist. So kann man schon vor dem eigentlichem
      Abspeichern eine entsprechende Kontrolle machen:<screen>1.9.3p194 :008 &gt; <command>product = Product.new</command>
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :009 &gt; <command>product.valid?</command>
 =&gt; false 
1.9.3p194 :010 &gt;</screen></para>
    </section>

    <section xml:id="validation_save_validate_false">
      <title xml:id="validation_save_validate_false.title">save( :validate
      =&gt; false )</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>save()</tertiary>
      </indexterm>

      <para>Wie so oft im Leben kann man auch hier alles umgehen. Wenn man der
      Methode <methodname>save</methodname> als Parameter <code>:validate
      =&gt; false</code> mitgibt, dann wird der Datensatz von
      <code>Validation</code> abgespeichert:<screen>1.9.3p194 :010 &gt; <command>product = Product.new</command>
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :011 &gt; <command>product.save</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; false 
1.9.3p194 :012 &gt; <command>product.valid?</command>
 =&gt; false 
1.9.3p194 :013 &gt; <command>product.save(:validate =&gt; false)</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Tue, 08 May 2012 15:20:44 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", nil], ["price", nil], ["updated_at", Tue, 08 May 2012 15:20:44 UTC +00:00], ["weight", nil]]
   (3.5ms)  commit transaction
 =&gt; true 
1.9.3p194 :014 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

      <warning>
        <para>Ich gehe davon aus, dass Sie die hier auftauchende Problematik
        verstehen. Diese Möglichkeit bitte nur einsetzen, wenn es einen guten
        Grund gibt. Sonst könnte man sich die ganze Validierung ja auch direkt
        ganz sparen.</para>
      </warning>
    </section>
  </section>

  <section xml:id="validates_presence_of">
    <title xml:id="validates_presence_of.title">validates_presence_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_presence_of()</tertiary>
    </indexterm>

    <para>In unserem Model <varname>product</varname> gibt es ein paar Felder
    die auf jeden Fall ausgefüllt werden müssen. Das erreichen wir mit
    <methodname>validates_presence_of</methodname>.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

<emphasis>  validates_presence_of :name
  validates_presence_of :price</emphasis>
end</programlisting></para>

    <para>Wenn wir damit einen leeren User Datensatz anlegen wollen, bekommen
    wir massig Validierungsfehler:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>product = Product.create</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; p<command>roduct.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007ffe9189e0d0 @base=#&lt;Product id: nil, name: nil, price: nil, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["can't be blank"], :price=&gt;["can't be blank"]}&gt; 
1.9.3p194 :003 &gt;</screen></para>

    <para>Erst wenn wir alle Angaben gemacht haben, kann der Datensatz
    gespeichert werden:<screen>1.9.3p194 :003 &gt; <command>product.name = 'Milch (1 Liter)'</command>
 =&gt; "Milch (1 Liter)" 
1.9.3p194 :004 &gt; <command>product.price = 0.45</command>
 =&gt; 0.45 
1.9.3p194 :005 &gt; <command>product.save</command>
   (0.1ms)  begin transaction
  SQL (5.2ms)  INSERT INTO "products" ("created_at", "expiration_date", "in_stock", "name", "price", "updated_at", "weight") VALUES (?, ?, ?, ?, ?, ?, ?)  [["created_at", Tue, 08 May 2012 15:25:22 UTC +00:00], ["expiration_date", nil], ["in_stock", nil], ["name", "Milch (1 Liter)"], ["price", #&lt;BigDecimal:7ffe91a2d270,'0.45E0',9(45)&gt;], ["updated_at", Tue, 08 May 2012 15:25:22 UTC +00:00], ["weight", nil]]
   (3.9ms)  commit transaction
 =&gt; true 
1.9.3p194 :006 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <section xml:id="validates_presence_of_optionen">
      <title xml:id="validates_presence_of_optionen.title">Optionen</title>

      <para><methodname>validates_presence_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "can‘t be
            blank". Beispiel:</para>

            <para><programlisting>validates_presence_of :attribute, :message =&gt; "can't be blank" </programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><methodname>:on</methodname></para>

            <para>Um zu definieren, ob diese Validierung bei einem
            <methodname>save</methodname>, einem
            <methodname>create</methodname> oder einem
            <methodname>update</methodname> durchgeführt werden soll. Der
            Default ist <methodname>save</methodname> (also bei
            <methodname>create</methodname> und bei
            <methodname>update</methodname>). Beispiel:<programlisting>validates_presence_of :attribute, :on =&gt; :create
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_presence_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_presence_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_presence_of_doku">
      <title xml:id="validates_presence_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_presence_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_length_of">
    <title xml:id="validates_length_of.title">validates_length_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_length_of()</tertiary>
    </indexterm>

    <para>Mit <methodname>validates_length_of</methodname> können Sie die
    Länge eines bestimmten Attributes eingrenzen. Erklärt sich am Beispiel am
    einfachsten.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price

  <emphasis>validates_length_of :name, :within =&gt; 2..255</emphasis>
end</programlisting></para>

    <para>Wenn wir jetzt einen <classname>Product</classname> mit einem
    <methodname>name</methodname> aus einem Buchstaben abspeichern wollen,
    dann bekommen wir einen Fehler aufgezeigt:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>product = Product.create(:name =&gt; 'M', :price =&gt; 0.45)</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "M", price: #&lt;BigDecimal:7fd6ad8cec28,'0.45E0',9(45)&gt;, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fd6ad88fe38 @base=#&lt;Product id: nil, name: "M", price: #&lt;BigDecimal:7fd6ad8d19c8,'0.45E0',9(45)&gt;, weight: nil, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["is too short (minimum is 2 characters)"]}&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <section xml:id="validates_length_of_optionen">
      <title xml:id="validates_length_of_optionen.title">Optionen</title>

      <para><methodname>validates_length_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:minimum</code></para>

            <para>Die minimale Länge eines Attributes. Beispiel:</para>

            <para><programlisting>validates_length_of :attribute, :minimum =&gt; 3</programlisting></para>
          </listitem>

          <listitem>
            <para><methodname>:maximum</methodname></para>

            <para>Die maximale Länge eines Attributes.
            Beispiel:<programlisting>validates_length_of :attribute, :maximum =&gt; 255
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:is</code></para>

            <para>Ist genau so viele Zeichen lang. Beispiel:<programlisting>validates_length_of :attribute, :is =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:within</code></para>

            <para>Definiert einen Längenraum. Als erstes kommt das Minimum und
            als zweites das Maximum. Beispiel:<programlisting>validates_length_of :attribute, :within =&gt; 6..255
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben. Default: false.
            Beispiel:<programlisting>validates_length_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_blank</code></para>

            <para>Das Attribut darf ganz leer sein. Default: false.
            Beispiel:<programlisting>validates_length_of :attribute, :allow_blank =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:too_long</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:maximum</methodname>. Default: "is too long (maximum
            is %d characters)". Beispiel:<programlisting>validates_length_of :attribute, :too_long =&gt; 'way too many characters'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:too_short</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:minimum</methodname>. Default: "is too short (min is
            %d characters)". Beispiel:<programlisting>validates_length_of :attribute, :too_short =&gt; 'just not enough characters'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:wrong_length</code></para>

            <para>Definiert die Fehlermeldung von
            <methodname>:is</methodname>. Default: "is the wrong length
            (should be %d characters)". Beispiel:<programlisting>validates_length_of :attribute, :wrong_length =&gt; 'not the right number of characters'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><methodname>:on</methodname></para>

            <para>Um zu definieren, ob diese Validierung bei einem
            <methodname>save</methodname>, einem
            <methodname>create</methodname> oder einem
            <methodname>update</methodname> durchgeführt werden soll. Der
            Default ist <methodname>save</methodname> (also bei
            <methodname>create</methodname> und bei
            <methodname>update</methodname>). Beispiel:<programlisting>validates_length_of :attribute, :on =&gt; :create
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_length_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_length_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:tokenizer</code></para>

            <para>Damit kann definiert werden wie das Attribut zum Zählen
            gesplittet werden soll. Default: Default: <code>lambda{ |value|
            value.split(//) }</code> (damit werden einzelne Zeichen gezählt).
            Beispiel (zum Zählen von Wörtern):<programlisting>validates_length_of :attribute, :tokenizer =&gt; lambda {|str| str.scan(/\w+/)}
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_length_of_doku">
      <title xml:id="validates_length_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_length_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_numericality_of">
    <title
    xml:id="validates_numericality_of.title">validates_numericality_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_numericality_of()</tertiary>
    </indexterm>

    <para>Mit <methodname>validates_numericality_of</methodname> können Sie
    überprüfen, ob ein Attributes eine Zahl ist. Erklärt sich am Beispiel am
    einfachsten.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price

  validates_length_of :name, :within =&gt; 2..255

<emphasis>  validates_numericality_of :weight</emphasis>
end</programlisting></para>

    <para>Wenn wir jetzt das Gewicht (<varname>weight</varname>) die nicht aus
    Zahlen, sondern auch aus Zeichen besteht, bekommen wir einen Fehler
    angezeigt:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>product = Product.create(:name =&gt; 'Milch (1 Liter)', :price =&gt; 0.45, :weight =&gt; 'abc')</command>
   (0.1ms)  begin transaction
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7f8594def848,'0.45E0',9(45)&gt;, weight: 0, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007f8594ba3878 @base=#&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7f8594df3588,'0.45E0',9(45)&gt;, weight: 0, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:weight=&gt;["is not a number"]}&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <tip>
      <para>Auch wenn ein Attribute in der Datenbank ans String abgelegt wird,
      kann man mit <methodname>validates_numericality_of</methodname> den
      Inhalt auf Integers festlegen.</para>
    </tip>

    <section xml:id="validates_numericality_of_optionen">
      <title
      xml:id="validates_numericality_of_optionen.title">Optionen</title>

      <para><methodname>validates_numericality_of</methodname> kann mit
      folgenden Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "can‘t be
            blank". Beispiel:<programlisting>validates_numericality_of :attribute, :message =&gt; 'must be a number'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><methodname>:on</methodname></para>

            <para>Um zu definieren, ob diese Validierung bei einem
            <methodname>save</methodname>, einem
            <methodname>create</methodname> oder einem
            <methodname>update</methodname> durchgeführt werden soll. Der
            Default ist <methodname>save</methodname> (also bei
            <methodname>create</methodname> und bei
            <methodname>update</methodname>). Beispiel:<programlisting>validates_numericality_of :attribute, :on =&gt; :create
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:only_integer</code></para>

            <para>Das Attribut darf nur eine Integer Zahl enthalten. Default:
            false. Beispiel:<programlisting>validates_numericality_of :attribute, :only_integer =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben.
            Beispiel:<programlisting>validates_numericality_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:greater_than</code></para>

            <para>Die im Attribut gespeicherte Zahl muss grösser sein, als der
            hier angegebene Wert. Beispiel:<programlisting>validates_numericality_of :attribute, :greater_than =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:greater_than_or_equal_to</code></para>

            <para>Die im Attribut gespeicherte Zahl muss grösser oder gleich
            dem hier angegebene Wert sein. Beispiel:<programlisting>validates_numericality_of :attribute, :greater_than_or_equal_to =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:equal_to</code></para>

            <para>Definiert einen bestimmten Wert, den das Attribute haben
            muss. Beispiel:<programlisting>validates_numericality_of :attribute, :equal_to =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:less_than</code></para>

            <para>Die im Attribut gespeicherte Zahl muss kleiner sein, als der
            hier angegebene Wert. Beispiel:<programlisting>validates_numericality_of :attribute, :less_than =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:less_than_or_equal_to</code></para>

            <para>Die im Attribut gespeicherte Zahl muss kleiner oder gleich
            dem hier angegebene Wert sein. Beispiel:<programlisting>validates_numericality_of :attribute, :less_than_or_equal_to =&gt; 23
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:odd</code></para>

            <para>Die im Attribut gespeicherte Zahl muss ungerade sein.
            Beispiel:<programlisting>validates_numericality_of :attribute, :odd
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:even</code></para>

            <para>Die im Attribut gespeicherte Zahl muss gerade sein.
            Beispiel:<programlisting>validates_numericality_of :attribute, :even
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_numericality_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_numericality_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist><note>
          <para>Die folgenden Validationen können als Wert auch ein Proc oder
          ein Symbol, das mit einer Methode korrespondiert enthalten:
          <methodname>:greater_than</methodname>,
          <methodname>:greater_than_or_equal_to</methodname>,
          <methodname>:equal_to</methodname>,
          <methodname>:less_than</methodname>,
          <methodname>:less_than_or_equal_to</methodname></para>

          <para>Beispiel dazu aus <command>ri
          validates_numericality_of</command>:<programlisting>validates_numericality_of :width, :less_than =&gt; Proc.new { |person| person.height }
</programlisting></para>
        </note></para>
    </section>

    <section xml:id="validates_numericality_of_doku">
      <title xml:id="validates_numericality_of_doku.title">Weitere
      Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_numericality_of</command> auf der Kommandozeile
      aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_uniqueness_of">
    <title
    xml:id="validates_uniqueness_of.title">validates_uniqueness_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_uniqueness_of()</tertiary>
    </indexterm>

    <para>Mit <methodname>validates_uniqueness_of</methodname> können Sie
    definieren, dass der Wert dieses Attribut einzigartig in der Datenbank
    ist. Ein Klassiker dafür sind Accounts. Da sollte man immer sicher
    stellen, das ein Account nicht doppelt vorhanden ist. Erklärt sich am
    Beispiel am einfachsten.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price

  validates_length_of :name, :within =&gt; 2..255

  validates_numericality_of :weight

  <emphasis>validates_uniqueness_of :name</emphasis>
end</programlisting></para>

    <para>Wenn wir jetzt ein neues <classname>Product</classname> mit einem
    schon existierenden <methodname>name</methodname> einrichten wollen,
    bekommen wir einen Fehler ausgegeben:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Product.last</command>
  Product Load (0.2ms)  SELECT "products".* FROM "products" ORDER BY "products"."id" DESC LIMIT 1
 =&gt; #&lt;Product id: 4, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7fc6e9695160,'0.45E0',9(45)&gt;, weight: nil, in_stock: nil, expiration_date: nil, created_at: "2012-05-08 15:25:22", updated_at: "2012-05-08 15:25:22"&gt; 
1.9.3p194 :002 &gt; <command>product = Product.create(:name =&gt; 'Milch (1 Liter)', :price =&gt; 0.45, :weight =&gt; 1000)</command>
   (0.1ms)  begin transaction
  Product Exists (0.2ms)  SELECT 1 FROM "products" WHERE "products"."name" = 'Milch (1 Liter)' LIMIT 1
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7fc6e9f7cb70,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :003 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fc6e9432300 @base=#&lt;Product id: nil, name: "Milch (1 Liter)", price: #&lt;BigDecimal:7fc6e9b09250,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:name=&gt;["has already been taken"]}&gt; 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <warning>
      <para>Die Validierung mit
      <methodname>validates_uniqueness_of</methodname> ist kein absoluter
      Garant für eine echte Einzigartigkeit des Attributes in der Datenbank.
      Es kann dabei zu einer Race-Condition kommen (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/Race_Condition">http://de.wikipedia.org/wiki/Race_Condition</uri>).
      Die detaillierte Diskussion dieses Effektes übersteigt allerdings die
      Tiefe eines Einsteigerbuches (es handelt sich um ein sehr seltenes
      Phänomen). Wenn Sie sich für diese Problematik interessieren, schauen
      Sie bitte einmal in die Doku von
      <methodname>validates_uniqueness_of</methodname> (<command>ri
      validates_uniqueness_of</command>). Dort werden Möglichkeiten
      aufgelistet, wie man dieses Problem lösen kann.</para>
    </warning>

    <section xml:id="validates_uniqueness_of_optionen">
      <title xml:id="validates_uniqueness_of_optionen.title">Optionen</title>

      <para><methodname>validates_uniqueness_of</methodname> kann mit
      folgenden Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "has
            already been taken". Beispiel:<programlisting>validates_uniqueness_of :attribute, :message =&gt; 'hmmm... not good. It has been already taken.'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:scope</code></para>

            <para>Definiert einen Geltungsbereich für die Einzigartigkeit.
            Wenn wir eine anderes strukturiere Telefonnummerndatenbank hätten
            (mit nur einem Feld für die Telefonnummer, dann könnten wir damit
            definieren, das eine Telefonnummer pro User nur einmal gespeichert
            werden darf. Das sähe dann so aus:</para>

            <para><programlisting>validates_uniqueness_of :phone_number, :scope =&gt; :user_id</programlisting></para>
          </listitem>

          <listitem>
            <para><methodname>:case_sensitive</methodname></para>

            <para>Überprüft die Einzigartikeit auch auf Gross- und
            Kleinschreibung. Default: False. Beispiel:<programlisting>validates_uniqueness_of :attribute, :case_sensitive =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben. Default: false.
            Beispiel:<programlisting>validates_uniqueness_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_blank</code></para>

            <para>Das Attribut darf ganz leer sein. Default: false.
            Beispiel:<programlisting>validates_uniqueness_of :attribute, :allow_blank =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_uniqueness_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_uniqueness_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_uniqueness_of_doku">
      <title xml:id="validates_uniqueness_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_uniqueness_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_inclusion_of">
    <title
    xml:id="validates_inclusion_of.title">validates_inclusion_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_inclusion_of()</tertiary>
    </indexterm>

    <para>Mit <methodname>validates_inclusion_of</methodname> können Sie
    definieren, aus welchen Werten der Inhalt dieses Attributes erstellt
    werden kann. Bei unserem Beispiel können wir das am Attribute
    <methodname>gender</methodname> veranschaulischen.</para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price

  validates_length_of :name, :within =&gt; 2..255

  validates_numericality_of :weight

  validates_uniqueness_of :name

  <emphasis>validates_inclusion_of :in_stock, :in =&gt; [true, false]</emphasis>
end</programlisting></para>

    <para>In unserem Datenmodel muss ein <classname>Product</classname> als
    <methodname>in_stock</methodname> entweder <code>true</code> oder
    <code>false</code> sein (es darf also kein nil geben). Wenn wir einen
    anderen Wert als <code>true</code> oder <code>false</code> eingeben, wird
    ein Validation-Fehler gemeldet:<screen>MacBook:shop xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>product = Product.create(:name =&gt; 'Milch fettarm (1 Liter)', :price =&gt; 0.45, :weight =&gt; 1000)</command>
   (0.1ms)  begin transaction
  Product Exists (0.2ms)  SELECT 1 FROM "products" WHERE "products"."name" = 'Milch fettarm (1 Liter)' LIMIT 1
   (0.1ms)  rollback transaction
 =&gt; #&lt;Product id: nil, name: "Milch fettarm (1 Liter)", price: #&lt;BigDecimal:7fd125470f38,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>product.errors</command>
 =&gt; #&lt;ActiveModel::Errors:0x007fd12513a648 @base=#&lt;Product id: nil, name: "Milch fettarm (1 Liter)", price: #&lt;BigDecimal:7fd125475bf0,'0.45E0',9(45)&gt;, weight: 1000, in_stock: nil, expiration_date: nil, created_at: nil, updated_at: nil&gt;, @messages={:in_stock=&gt;["is not included in the list"]}&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:shop xyz$</screen></para>

    <tip>
      <para>Denken Sie immer an die Macht von Ruby! Sie können so z.B. das
      Enumerable Objekt für in immer live aus einer anderen Datenbank
      generieren. Das heißt die Validation ist nicht statisch
      definiert.</para>
    </tip>

    <section xml:id="validates_inclusion_of_optionen">
      <title xml:id="validates_inclusion_of_optionen.title">Optionen</title>

      <para><methodname>validates_inclusion_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "is not
            included in the list". Beispiel:<programlisting>validates_inclusion_of :attribute, :message =&gt; 'this one is not allowed'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:in</code></para>

            <para>Definiert das Enumerable Objekt mit allen erlaubten Werten
            für dieses Attribut. Beispiele:</para>

            <para><programlisting>validates_inclusion_of :gender, :in =&gt; %w( male female )
validates_inclusion_of :age, :in =&gt; 18..105
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben. Default: false.
            Beispiel:<programlisting>validates_inclusion_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_blank</code></para>

            <para>Das Attribut darf ganz leer sein. Default:false.
            Beispiel:<programlisting>validates_inclusion_of :attribute, :allow_blank =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_inclusion_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_inclusion_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_inclusion_of_doku">
      <title xml:id="validates_inclusion_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_inclusion_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_exclusion_of">
    <title
    xml:id="validates_exclusion_of.title">validates_exclusion_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_exclusion_of()</tertiary>
    </indexterm>

    <para><methodname>validates_exclusion_of</methodname> ist die Umkehrung
    von <xref linkend="validates_inclusion_of" />. Sie können definieren, aus
    welchen Werten der Inhalt dieses Attributes nicht erstellt werden darf.
    </para>

    <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price

  validates_length_of :name, :within =&gt; 2..255

  validates_numericality_of :weight

  validates_uniqueness_of :name

  validates_inclusion_of :in_stock, :in =&gt; [true, false]
  <emphasis>validates_exclusion_of :in_stock, :in =&gt; [nil]</emphasis>
end</programlisting></para>

    <tip>
      <para>Denken Sie immer an die Macht von Ruby! Sie können so z.B. das
      Enumerable Objekt für in immer live aus einer anderen Datenbank
      generieren. Das heißt die Validation ist nicht statisch
      definiert.</para>
    </tip>

    <section xml:id="validates_exclusion_of_optionen">
      <title xml:id="validates_exclusion_of_optionen.title">Optionen</title>

      <para><methodname>validates_exclusion_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "is not
            included in the list". Beispiel:<programlisting>validates_exclusion_of :attribute, :message =&gt; 'this one is not allowed'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:in</code></para>

            <para>Definiert das Enumerable Objekt mit allen nicht erlaubten
            Werten für dieses Attribut. Beispiele:</para>

            <para><programlisting>validates_exclusion_of :login, :in =&gt; %w( admin root sysadmin )
validates_exclusion_of :age, :in =&gt; 0..17
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben. Default: false.
            Beispiel:<programlisting>validates_exclusion_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_blank</code></para>

            <para>Das Attribut darf ganz leer sein. Default: false.
            Beispiel:<programlisting>validates_exclusion_of :attribute, :allow_blank =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_exclusion_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_exclusion_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_exclusion_of_doku">
      <title xml:id="validates_exclusion_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_exclusion_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="validates_format_of">
    <title xml:id="validates_format_of.title">validates_format_of</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates_format_of()</tertiary>
    </indexterm>

    <para>Mit <methodname>validates_format_of</methodname> können Sie mit
    einer Regular Expression (siehe <uri
    xlink:href="http://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck">http://de.wikipedia.org/wiki/Regulärer_Ausdruck</uri>)
    definieren wie sich der Inhalt eines Attributes aufbauen darf.</para>

    <para>Mit <methodname>validates_format_of</methodname> kann man z.B. eine
    einfache Validierung der Syntax einer E-Mail Adresse machen:</para>

    <para><programlisting><emphasis>validates_format_of :email, :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i
</emphasis></programlisting></para>

    <para>Diese einfache Validierung einer E-Mail-Adresse auf syntaktische
    Korrektheit habe ich aus <command>ri validates_format_of</command>
    übernommen.</para>

    <warning>
      <para>Es sollte klar sein, dass die hier gezeigte
      E-Mail-Adressen-Validierung nicht vollständig ist. Es geht hier nur um
      ein Beispiel. Damit kann man nur die syntaktische Korrektheit einer
      E-Mail-Adresse überprüfen.</para>
    </warning>

    <section xml:id="validates_format_of_optionen">
      <title xml:id="validates_format_of_optionen.title">Optionen</title>

      <para><methodname>validates_format_of</methodname> kann mit folgenden
      Optionen aufgerufen werden:<itemizedlist>
          <listitem>
            <para><code>:message</code></para>

            <para>Um eine eigene Fehlermeldung auszugeben. Default: "is
            invalid". Beispiel:<programlisting>validates_format_of :attribute, :message =&gt; 'not the right format'
</programlisting><note>
                <para>Bitte beachten Sie bei allen Fehlermeldungen <xref
                linkend="i18n" />.</para>
              </note></para>
          </listitem>

          <listitem>
            <para><code>:allow_nil</code></para>

            <para>Das Attribut darf den Wert nil haben. Default: false.
            Beispiel:<programlisting>validates_format_of :attribute, :allow_nil =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:allow_blank</code></para>

            <para>Das Attribut darf ganz leer sein. Default: false.
            Beispiel:<programlisting>validates_format_of :attribute, :allow_blank =&gt; true
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:with</code></para>

            <para>Definiert die Regular Expression (siehe <uri
            xlink:href="http://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck">http://de.wikipedia.org/wiki/Regul%C3%A4rer_Ausdruck</uri>)
            zur Überprüfung des Formates. Beispiel:</para>

            <para><programlisting>validates_format_of :email, :with =&gt; /\A([^@\s]+)@((?:[-a-z0-9]+\.)+[a-z]{2,})\Z/i
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:if</code></para>

            <para>Definiert eine Methode, einen Proc oder einen String der
            definiert, ob die Validierung ausgeführt werden soll.
            Beispiel:<programlisting>validates_format_of :attribute, :if =&gt; Date.today.monday?
</programlisting></para>
          </listitem>

          <listitem>
            <para><code>:unless</code></para>

            <para>Wie <methodname>if</methodname>, nur das hier definiert
            wird, wann die Validierung nicht erfolgen soll.
            Beispiel:<programlisting>validates_format_of :attribute, :unless =&gt; Date.today.tuesday?
</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="validates_format_of_doku">
      <title xml:id="validates_format_of_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates_format_of</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>

  <section xml:id="method_validates">
    <title xml:id="method_validates.title">validates</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>validates()</tertiary>
    </indexterm>

    <para>Mit der Methode <methodname>validates</methodname> können Sie ab
    Rails 3 ebenfalls alle Validierungen vornehmen. Ich zeige Ihnen mal den
    Unterschied an der <filename>app/models/product.rb</filename><itemizedlist>
        <listitem>
          <para>Traditionell</para>

          <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates_presence_of :name
  validates_presence_of :price

  validates_length_of :name, :within =&gt; 2..255

  validates_numericality_of :weight

  validates_uniqueness_of :name

  validates_inclusion_of :in_stock, :in =&gt; [true, false]
end</programlisting></para>
        </listitem>

        <listitem>
          <para>mit <methodname>validates</methodname></para>

          <para><filename>app/models/product.rb</filename><programlisting>class Product &lt; ActiveRecord::Base
  attr_accessible :expiration_date, :in_stock, :name, :price, :weight

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true,
            :length =&gt; { :within =&gt; 2..255 }

  validates :price, :presence =&gt; true

  validates :weight, :numericality =&gt; true

  validates :in_stock,
            :presence =&gt; true,
            :inclusion =&gt; [true, false]
end</programlisting></para>
        </listitem>
      </itemizedlist></para>

    <para>Man kann sich streiten, welche Variante besser lesbar ist.</para>

    <section xml:id="method_validates_doku">
      <title xml:id="method_validates_doku.title">Weitere Doku</title>

      <para>Die beste Doku haben Sie bereits im System. Einfach <command>ri
      validates</command> auf der Kommandozeile aufrufen.</para>
    </section>
  </section>
</section>
