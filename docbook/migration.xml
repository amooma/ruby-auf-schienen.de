<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_migration"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_migration.title">Migrations</title>

  <para>SQL-Datenbanken werden mit Migrations generiert und sie können ebenso
  mit Migrations verändert werden. Wenn Sie mit <command>rails generate
  model</command> ein Model anlegen, dann wird automatisch im Verzeichnis
  <filename>db/migrate/</filename> eine entsprechende Migration-Datei
  angelegt. Ich zeige Ihnen das Prinzip an einer Adressbuch Applikation. Legen
  wir die mal an:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new address-book</command>
[...]
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd address-book</command>
stefan@swmbp 0 1.9.2-p0 address-book$ <command>bundle install</command>
[...]
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Legen wir ein <classname>Person</classname> Model an:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate model Person name:string street:string zip_code:string city:string phone:string</command>
      invoke  active_record
      create    db/migrate/20101201154722_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/unit/person_test.rb
      create      test/fixtures/people.yml
stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0018s
==  CreatePeople: migrated (0.0018s) ==========================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Es wurde automatisch die Migrations-Datei
  <filename>db/migrate/20101201154722_create_people.rb</filename> angelegt.
  Schauen wir uns die mal genauer an:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>cat db/migrate/20101201154722_create_people.rb</command>
class CreatePeople &lt; ActiveRecord::Migration
  def self.up
    create_table :people do |t|
      t.string :name
      t.string :street
      t.string :zip_code
      t.string :city
      t.string :phone

      t.timestamps
    end
  end

  def self.down
    drop_table :people
  end
end
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Die Klassenmethoden <methodname>self.up</methodname> und
  <methodname>self.down</methodname> erstellen oder löschen die Datenbank.
  Eigentlich alles recht logisch. Die Migrationsdateien haben im Dateinamen
  die aktuelle Uhrzeit eingebetet und werden bei einer Migration (also dem
  Aufruf von <command>rake db:migrate</command>) in der chronologischen
  Reihenfolge abgearbeitet. Dabei werden immer nur die Migrations
  abgearbeitet, die noch nicht ausgeführt wurden. Wenn wir jetzt noch einmal
  <command>rake db:migrate</command> aufrufen, passiert nichts, da die
  entsprechende Migration ja schon ausgeführt wurde:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

  <para>Wenn wir aber die Datenbank manuell löschen und danach wieder
  <command>rake db:migrate</command> aufrufen, wird die Migration
  wiederholt:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rm db/development.sqlite3</command> 
stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0013s
==  CreatePeople: migrated (0.0014s) ==========================================

stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

  <para>Zum weiteren Arbeiten erstellen wir folgende
  <filename>db/seeds.rb</filename> Datei:<programlisting>firstnames = ['Horst', 'Udo', 'Martin', 'Ute', 'Ursula', 'Martina']
lastnames = ['Meier', 'Udelhoven', 'Schroeder', 'Maier', 'Neuner']
streets = ['Hauptstr.', 'Bahnhofstr.', 'Molkestr.', 'Berliner Str.', 'Hamburger Str.']
cities = ['Beispielhausen', 'Hamburg', 'Berlin', 'Dresden']

anzahl_der_datensaetze = 1000
r = Random.new(42)
(0..anzahl_der_datensaetze).each do |i|
  Person.create(:name =&gt; "#{firstnames[rand(firstnames.size)]} #{lastnames[rand(lastnames.size)]}",
                :street =&gt; "#{streets[rand(streets.size)]} #{i + 1}",
                :zip_code =&gt; "#{r.rand(89999) + 10000}",
                :city =&gt; "#{cities[rand(cities.size)]}",
                :phone =&gt; "0#{r.rand(89) + 10} #{r.rand(899999) + 100000}")
end</programlisting></para>

  <para>Dann die <filename>seeds.rb</filename> Datei abarbeiten:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:seed</command>
(in /Users/stefan/address-book)
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Jetzt haben wir eine ganze Menge zufälliger Adressen in der Datenbank.
  Schauen wir ganz kurz in der Console nach:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails console</command>
jLoading development environment (Rails 3.0.3)
ruby-1.9.2-p0 &gt; <command>Person.last</command>
 =&gt; #&lt;Person id: 1000, name: "Udo Meier", street: "Bahnhofstr. 1001", zip_code: "24357", city: "Hamburg", phone: "066 430817", created_at: "2010-12-01 18:12:19", updated_at: "2010-12-01 18:12:19"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Nach einiger Zeit merken wir, das wir bei vielen Personen nicht nur
  eine normale Telefonnummer, sondern auch noch eine Handynummer abspeichern
  wollen. Wir benötigen also ein weiteres Datenbankfeld
  (<varname>mobile_phone</varname>). Dafür gibt es eine leicht zu merkende
  <command>rails generate migration add_*</command> Syntax:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate migration add_mobile_phone_to_person mobile_phone:string</command>
      invoke  active_record
      create    db/migrate/20101201181710_add_mobile_phone_to_person.rb
stefan@swmbp 0 1.9.2-p0 address-book$ <command>cat db/migrate/20101201181710_add_mobile_phone_to_person.rb</command>
class AddMobilePhoneToPerson &lt; ActiveRecord::Migration
  def self.up
    add_column :people, :mobile_phone, :string
  end

  def self.down
    remove_column :people, :mobile_phone
  end
end
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Mit <command>rake db:migrate</command> können wir die neue Migration
  einspielen:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  AddMobilePhoneToPerson: migrating =========================================
-- add_column(:people, :mobile_phone, :string)
   -&gt; 0.0006s
==  AddMobilePhoneToPerson: migrated (0.0007s) ================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>In der Console können wir uns das neue Feld anschauen. Es wurde nach
  dem Feld <varname>updated_at</varname> angefügt:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails console</command>
Loading development environment (Rails 3.0.3)
ruby-1.9.2-p0 &gt; <command>Person.last</command>
 =&gt; #&lt;Person id: 1000, name: "Udo Meier", street: "Bahnhofstr. 1001", zip_code: "24357", city: "Hamburg", phone: "066 430817", created_at: "2010-12-01 18:12:19", updated_at: "2010-12-01 18:12:19", mobile_phone: nil&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Was wäre im Fall, das noch einmal den vorherigen Stand der Dinge
  betrachten möchten? Kein Problem. Es gibt ja immer auch eine
  <methodname>self.down</methodname> Methode. Auf die vorherige Version können
  wir deshalb mit <command>rake db:rollback</command> leicht zurück
  gehen:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:rollback</command>
(in /Users/stefan/address-book)
==  AddMobilePhoneToPerson: reverting =========================================
-- remove_column(:people, :mobile_phone)
   -&gt; 0.5851s
==  AddMobilePhoneToPerson: reverted (0.5852s) ================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Jede Migration hat eine eigene Versionsnummer. Die Versionsnummer des
  aktuellen Status können Sie mit <command>rake db:version</command>
  rausfinden:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:version</command>
(in /Users/stefan/address-book)
Current version: 20101201154722
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <important>
    <para>Bitte beachten Sie, das alle Versionsnummern und Zeitstempel nur für
    das hier abgedruckte Beispiel gelten. Wenn sie das Beispiel nacharbeiten,
    bekommen Sie natürlich einen für Sie aktuellen Zeitstempel.</para>
  </important>

  <para>Sie finden die entsprechende Version im
  <filename>db/migrate</filename> Verzeichnis wieder:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>ls db/migrate</command>
20101201154722_create_people.rb
20101201181710_add_mobile_phone_to_person.rb
stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

  <para>Auf eine bestimmte Migration können Sie mit <command>rake db:migrate
  VERSION=Versionsnummer</command> gehen. Die Null steht dabei für die nullte
  Version (also den Start). Probieren wir das mal aus:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate VERSION=0</command>
(in /Users/stefan/address-book)
==  CreatePeople: reverting ===================================================
-- drop_table(:people)
   -&gt; 0.0008s
==  CreatePeople: reverted (0.0009s) ==========================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

  <para>Die Tabelle wurde mit allen Daten gelöscht. Wir sind wieder zurück auf
  Los.</para>

  <section xml:id="activerecord_welche_datenbank">
    <title>Welche Datenbank wird benutzt?</title>

    <para>Die Datenbank-Tabelle <varname>people</varname> wird durch die
    Migration angelegt. Dabei sehen wir, das Tabellen-Namen automatisch den
    Plural der Models bekommen (<classname>Person</classname> vs.
    <varname>people</varname>). Aber in welcher Datenbank werden die Tabellen
    überhaupt angelegt? Das wird in der Konfigurationsdatei
    <filename>config/database.yml</filename> definiert:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>cat config/database.yml</command> 
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe <uri
    xlink:href="http://www.yaml.org/">http://www.yaml.org/</uri> bzw. <uri
    xlink:href="http://de.wikipedia.org/wiki/YAML">http://de.wikipedia.org/wiki/YAML</uri>)
    definiert. Für uns wichtig ist erst mal nur die development-Datenbank
    (erster Eintrag). Per default benutzt Rails dort
    <application>SQLite3</application>. SQLite3 mag nicht die richtige Wahl
    für die Analyse der weltweit gesammelten Wetterdaten sein, aber für die
    schnelle und unkomplizierte Entwicklung von Rails-Anwendungen lernt man
    sie schnell zu schätzen. In der Produktions-Umgebung kann man später immer
    noch auf "grosse" Datenbanken wie MySQL oder PostgreSQL
    umsteigen.<footnote>
        <para>Einige Entwickler sind der Ansicht, das man auf jeden Fall immer
        mit der gleichen Datenbank entwicklen soll, die man später auch in der
        Produktion und im Testing benutzt. Andere sagen, das diese bei der
        Verwendung von ORM Abstraktions-Layern nicht notwendig sei. Bitte
        entscheiden Sie hier selber. Ich programmiere eine Rails Applikation
        oft mit SQLite und verwende in der Produktion oft MySQL.</para>
      </footnote></para>

    <para>Um Ihre sicherlich vorhandene Neugierde zu befriedigen, schauen wir
    uns kurz noch die Datenbank mit dem Command-Line-Tool
    <application>sqlite3</application> an:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
schema_migrations
sqlite&gt; <command>.quit</command>
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Nichts drin. Aber klar, wir haben ja auch nicht die Migration laufen
    lassen:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0016s
==  CreatePeople: migrated (0.0017s) ==========================================

==  AddMobilePhoneToPerson: migrating =========================================
-- add_column(:people, :mobile_phone, :string)
   -&gt; 0.0007s
==  AddMobilePhoneToPerson: migrated (0.0008s) ================================

stefan@swmbp 0 1.9.2-p0 address-book$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
people             schema_migrations
sqlite&gt; <command>.schema people</command>
CREATE TABLE "people" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(255), "street" varchar(255), "zip_code" varchar(255), "city" varchar(255), "phone" varchar(255), "created_at" datetime, "updated_at" datetime, "mobile_phone" varchar(255));
sqlite&gt; <command>.quit</command>
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Das Anlegen der Tabelle mit <command>rake db:migrate</command> wurde
    natürlich auch im <filename>log/development.log</filename>
    eingetragen:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>tail -n 21 log/development.log</command> 
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
Migrating to CreatePeople (20101203142738)
  SQL (0.0ms)  select sqlite_version(*)
  SQL (0.4ms)  CREATE TABLE "people" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "name" varchar(255), "street" varchar(255), "zip_code" varchar(255), "city" varchar(255), "phone" varchar(255), "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20101203142738')
Migrating to AddMobilePhoneToPerson (20101203142835)
  SQL (0.4ms)  ALTER TABLE "people" ADD "mobile_phone" varchar(255)
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20101203142835')
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.0ms)  PRAGMA index_list("people")
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Jetzt wissen Sie auch wofür die Tabelle
    <varname>schema_migrations</varname> benutzt wird. War bei dem Namen aber
    auch kein grosses Rätsel. Bei der ersten von Rails durchgeführten
    Migration wird diese Tabelle angelegt, falls sie noch nicht vorhanden ist.
    Sie dient als eine Art Buchhaltung für die Migrations-Versionen. </para>

    <para>Zum Schluss setzen wir die Datenbank wieder in den ursprünglichen
    Stand:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate VERSION=0</command>
(in /Users/stefan/address-book)
==  CreatePeople: reverting ===================================================
-- drop_table(:people)
   -&gt; 0.0008s
==  CreatePeople: reverted (0.0009s) ==========================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>
  </section>

  <section xml:id="ar_migration_db_aendern">
    <title xml:id="ar_migration_db_aendern.title">Datenbanken ändern</title>

    <para>Das wir in unserer <varname>people</varname> Datenbank zwei mal eine
    Telefonnummer haben ist nach dem was wir in <xref
    linkend="activerecord_has_many" /> gelernt haben Blödsinn. Es würde mehr
    Sinn machen die Telefonnummern in einer eigenen Datenbank zu halten. Legen
    wir die mal an:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate model phone person_id:integer phone_type:string number:string</command>
      invoke  active_record
      create    db/migrate/20101201192459_create_phones.rb
      create    app/models/phone.rb
      invoke    test_unit
      create      test/unit/phone_test.rb
      create      test/fixtures/phones.yml
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Wenn wir jetzt <command>rake db:migrate</command> ausführen, werden
    alle existierenden Migrations ausgeführt:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0014s
==  CreatePeople: migrated (0.0015s) ==========================================

==  AddMobilePhoneToPerson: migrating =========================================
-- add_column(:people, :mobile_phone, :string)
   -&gt; 0.0006s
==  AddMobilePhoneToPerson: migrated (0.0007s) ================================

==  CreatePhones: migrating ===================================================
-- create_table(:phones)
   -&gt; 0.0011s
==  CreatePhones: migrated (0.0012s) ==========================================

stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

    <para>Da es sich mit Beispieldaten besser erklären lässt:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:seed</command>
(in /Users/stefan/address-book)
stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

    <para>Jetzt haben wir zwar zwei getrennte Datenbanken, aber noch sind alle
    Telefonnummern in der <varname>people</varname> Datenbank. Mit einer
    Migration können wir dieses Problem sauber lösen. Legen wir dafür erst mal
    eine leere Migration Datei an:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate migration move_phone_numbers_to_the_phone_db</command>
      invoke  active_record
      create    db/migrate/20101201214154_move_phone_numbers_to_the_phone_db.rb
stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

    <para>Der Name der Migration ist technisch gesehen egal. Ich bemühe mich
    sie immer für menschen logisch zu benennen. Die gerade generierte Datei
    ist noch jungfräulich:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>cat db/migrate/20101201214154_move_phone_numbers_to_the_phone_db.rb</command>
class MovePhoneNumbersToThePhoneDb &lt; ActiveRecord::Migration
  def self.up
  end

  def self.down
  end
end
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Wir müssen jetzt in der <methodname>self.up</methodname> Methode ein
    kleines Programm einbauen, das durch alle Datensätze läuft und die
    Telefonnummern in die dafür vorgesehene Datenbank
    schreibt:<programlisting>class MovePhoneNumbersToThePhoneDb &lt; ActiveRecord::Migration
<emphasis>  def self.up
    # Schleife durch alle Person Datensaetze
    #
    Person.all.each do |person|
      # Wenn ein Telefoneintrag vorhanden ist, wird ein
      # neuer Datensatz in der Phone-DB angelegt.
      #
      if !person.phone.blank?
        phone = Phone.new(:person_id =&gt; person.id, 
                          :phone_type =&gt; 'Default', 
                          :number =&gt; person.phone)
        # Wenn das Abspeichern erfolgreich war, wird der 
        # alte Eintrag auf nil gesetzt.
        if phone.save
          person.phone = nil
          person.save
        end
      end
      
      # Wenn ein Handyeintrag vorhanden ist, wird ein
      # neuer Datensatz in der Phone-DB angelegt.
      #
      if !person.mobile_phone.blank?
        phone = Phone.new(:person_id =&gt; person.id, 
                          :phone_type =&gt; 'Mobile', 
                          :number =&gt; person.phone)
        # Wenn das Abspeichern erfolgreich war, wird der 
        # alte Eintrag auf nil gesetzt.
        if phone.save
          person.mobile_phone = nil
          person.save
        end
      end
      
    end
  end
</emphasis>
  def self.down
  end
end
</programlisting></para>

    <para>Starten wir die Migration:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  MovePhoneNumbersToThePhoneDb: migrating ===================================
==  MovePhoneNumbersToThePhoneDb: migrated (2.1447s) ==========================

stefan@swmbp 0 1.9.2-p0 address-book$ </screen></para>

    <para>In der Console können wir das Ergebnis überprüfen:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails console</command>
Loading development environment (Rails 3.0.3)
ruby-1.9.2-p0 &gt; <command>Person.last</command>
 =&gt; #&lt;Person id: 1000, name: "Ute Maier", street: "Berliner Str. 1001", zip_code: "24357", city: "Dresden", phone: nil, created_at: "2010-12-01 21:55:13", updated_at: "2010-12-01 21:59:11", mobile_phone: nil&gt; 
ruby-1.9.2-p0 &gt; <command>Phone.last</command>
 =&gt; #&lt;Phone id: 1000, person_id: 1000, phone_type: "Default", number: "066 430817", created_at: "2010-12-01 21:59:11", updated_at: "2010-12-01 21:59:11"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Das sieht sehr gut aus. Allerdings müssen wir jetzt auch noch die
    <methodname>self.down</methodname> Methode mit Leben füllen, damit wir das
    ganze auch sauber zurückrollen können:<programlisting>class MovePhoneNumbersToThePhoneDb &lt; ActiveRecord::Migration
  def self.up
    # Schleife durch alle Person Datensaetze
    #
    Person.all.each do |person|
      # Wenn ein Telefoneintrag vorhanden ist, wird ein
      # neuer Datensatz in der Phone-DB angelegt.
      #
      if !person.phone.blank?
        phone = Phone.new(:person_id =&gt; person.id, 
        :phone_type =&gt; 'Default', 
        :number =&gt; person.phone)
        # Wenn das Abspeichern erfolgreich war, wird der 
        # alte Eintrag auf nil gesetzt.
        if phone.save
          person.phone = nil
          person.save
        end
      end

      # Wenn ein Handyeintrag vorhanden ist, wird ein
      # neuer Datensatz in der Phone-DB angelegt.
      #
      if !person.mobile_phone.blank?
        phone = Phone.new(:person_id =&gt; person.id, 
        :phone_type =&gt; 'Mobile', 
        :number =&gt; person.phone)
        # Wenn das Abspeichern erfolgreich war, wird der 
        # alte Eintrag auf nil gesetzt.
        if phone.save
          person.mobile_phone = nil
          person.save
        end
      end

    end
  end

<emphasis>  def self.down
    # Schleife durch alle Phone Eintraege
    #
    Phone.all.each do |phone|
      person = Person.where(:id =&gt; phone.person_id).first
      if person != nil
        if phone.phone_type == 'Default'
          person.phone = phone.number
          phone.destroy if person.save
        elsif phone.phone_type == 'Mobile'
          person.mobile_phone = phone.number
          phone.destroy if person.save
        end
      end
    end
  end
</emphasis>
end
</programlisting></para>

    <para>Jetzt können wir mit <command>rake db:rollback</command> sauber
    zurückrollen:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:rollback</command>
(in /Users/stefan/address-book)
==  MovePhoneNumbersToThePhoneDb: reverting ===================================
==  MovePhoneNumbersToThePhoneDb: reverted (0.0381s) ==========================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>So weit so gut. Dummerweise habe ich aber in dieser Migration
    vergessen auch die entsprechenden Tabellenspalten zu löschen. Noch in die
    bereits fertige Migration einbauen? Nein, auf keinen Fall! Migrations
    kosten nichts und man sollte nie alte Migrations "anpassen". Das lädt nur
    zu Fehlern ein. Erstellen wir also eine neue Migration:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate migration delete_phone_fields</command>
      invoke  active_record
      create    db/migrate/20101201222624_delete_phone_fields.rb
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Diesmal füllen wir in der Datei
    <filename>db/migrate/20101201222624_delete_phone_fields.rb</filename>
    direkt <methodname>self.up</methodname> und
    <methodname>self.down</methodname> im gleichen Schritt:<programlisting>class DeletePhoneFields &lt; ActiveRecord::Migration
  def self.up
    remove_column :people, :phone
    remove_column :people, :mobile_phone
  end

  def self.down
    add_column :people, :phone, :string
    add_column :people, :mobile_phone, :string
  end
end
</programlisting></para>

    <para>Beim <methodname>self.down</methodname> werden für den Fall eines
    Rollbacks die Tabellenspalten wieder angelegt. Wenn wir jetzt ein rake
    db:migrate ausführen werden natürlich zwei Migrations ausgeführt, weil wir
    vorhin einen Rollback gemacht haben:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  MovePhoneNumbersToThePhoneDb: migrating ===================================
==  MovePhoneNumbersToThePhoneDb: migrated (0.0382s) ==========================

==  DeletePhoneFields: migrating ==============================================
-- remove_column(:people, :phone)
   -&gt; 0.0540s
-- remove_column(:people, :mobile_phone)
   -&gt; 0.0490s
==  DeletePhoneFields: migrated (0.1033s) =====================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>Die Tabellen sind nach der Migration sauber getrennt:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails console</command>
Loading development environment (Rails 3.0.3)
ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, name: "Martin Schroeder", street: "Hauptstr. 2", zip_code: "25795", city: "Beispielhausen", created_at: "2010-12-01 22:35:18", updated_at: "2010-12-01 22:35:39"&gt; 
ruby-1.9.2-p0 &gt; <command>Phone.where(:person_id =&gt; 1)</command>
 =&gt; [#&lt;Phone id: 1, person_id: 1, phone_type: "Default", number: "024 359178", created_at: "2010-12-01 22:35:39", updated_at: "2010-12-01 22:35:39"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>
  </section>

  <section xml:id="ar_migration_index">
    <title xml:id="ar_migration_index.title">Index anlegen</title>

    <para>Ich gehe davon aus, das Sie wissen was ein Index in einer Datenbank
    ist. Falls nicht finden Sie auf <uri
    xlink:href="http://de.wikipedia.org/wiki/Datenbankindex">http://de.wikipedia.org/wiki/Datenbankindex</uri>
    eine kurze Einführung. Kurzversion: Damit werden Suchen für eine bestimmte
    Tabellen-Spalte schneller.</para>

    <para>In unserem Adressbuch sollten wir das Feld <varname>name</varname>
    in der Tabelle <varname>people</varname> indexieren. Dafür erstellen wir
    eine neue Migration:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate migration create_index</command>
      invoke  active_record
      create    db/migrate/20101201224922_create_index.rb
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

    <para>In der Datei
    <filename>db/migrate/20101201224922_create_index.rb</filename> legen wir
    mit <methodname>add_index</methodname> in der
    <methodname>self.up</methodname> Methode den Index an und in der
    <methodname>self.down</methodname> Methode löschen wir ihen mit
    <methodname>remove_index</methodname> wieder:<programlisting>class CreateIndex &lt; ActiveRecord::Migration
  def self.up
    add_index :people, :name
  end

  def self.down
    remove_index :people, :name
  end
end</programlisting></para>

    <para>Mit <command>rake db:migrate</command> wird der Index
    angelegt:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rake db:migrate</command>
(in /Users/stefan/address-book)
==  CreateIndex: migrating ====================================================
-- add_index(:people, :name)
   -&gt; 0.0034s
==  CreateIndex: migrated (0.0035s) ===========================================

stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>
  </section>

  <section>
    <title>Sonstiges</title>

    <para>In diesem Anfängerbuch kann ich das Thema Migrations nicht sehr tief
    behandeln. Es geht um das prinzipielle Verständnis der Mechanik. Es gibt
    aber ein paar Details die sind so wichtig, das ich Sie hier besprechen
    möchte.</para>

    <section xml:id="active-record-auto-felder">
      <title>Automatisch zugefügte Felder (id, created_at und
      updated_at)</title>

      <para>Rails ist so freundlich uns bei der Migration automatisch folgende
      Felder hinzuzufügen:<itemizedlist>
          <listitem>
            <para><varname>id:integer</varname></para>

            <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von der
            Datenbank automatisch hochgezählt. Für alle SQL-Fans:
            AUTOINCREMENT NOT NULL</para>
          </listitem>

          <listitem>
            <para><varname>created_at:datetime</varname></para>

            <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
            eines Datensatzes gefüllt.</para>
          </listitem>

          <listitem>
            <para><varname>updated_at:datetime</varname></para>

            <para>Das Feld wird bei jeder Veränderung des Datensatzes
            automatisch an die aktuelle Zeit angepasst.</para>
          </listitem>
        </itemizedlist></para>

      <para>Man muss diese Felder also nicht beim Generieren des Models selber
      eintragen.</para>

      <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
      Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten Felder
      schätzen. Sie weg zu lassen ist meist am falschen Ende gespart.</para>
    </section>

    <section>
      <title>Dezimal-Stellen</title>

      <para>Wenn man z.B. bei einem Preis-Feld eine Dezimal-Zahl mit zwei
      Stellen hinter dem Komma benötigt, so muss man das nach dem Erstellen
      des Models manuel in der Migrationsdatei ändern. An sonsten laufen Sie
      Gefahr, das von Datenbank zu Datenbank unterschiedlich große Felder
      angelegt werden (siehe <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html">http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html</uri>).</para>

      <para>Legen wir ein Model <classname>Produkt</classname> mit Preisen
      an:<screen>stefan@swmbp 0 1.9.2-p0 address-book$ <command>rails generate model product name:string price:decimal</command>
      invoke  active_record
      create    db/migrate/20101202095315_create_products.rb
      create    app/models/product.rb
      invoke    test_unit
      create      test/unit/product_test.rb
      create      test/fixtures/products.yml
stefan@swmbp 0 1.9.2-p0 address-book$</screen></para>

      <para>Die
      <filename>db/migrate/20101202095315_create_products.rb</filename> müssen
      wir jetzt wie folgt verändern:<screen>class CreateProducts &lt; ActiveRecord::Migration
  def self.up
    create_table :products do |t|
      t.string :name
      <emphasis>t.decimal :price, :precision =&gt; 8, :scale =&gt; 2</emphasis>

      t.timestamps
    end
  end

  def self.down
    drop_table :products
  end
end
</screen></para>

      <para>Die Parameter <code>:precision =&gt; 8, :scale =&gt; 2</code>
      sagen aus, das eine Zahl mit maximal 8 Stellen (davon 2 Stellen rechts
      vom Komma) abgespeichert wird. Ein Beispiel für eine solche Zahl:
      123456,78</para>
    </section>
  </section>

  <section>
    <title>Weitere Dokumentation</title>

    <para>Folgende Webseiten geben Ihnen sehr gute weitere Informationen zum
    Thema Migration:<itemizedlist>
        <listitem>
          <para><uri
          xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Migration.html">http://api.rubyonrails.org/classes/ActiveRecord/Migration.html</uri></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html">http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/TableDefinition.html</uri></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://railscasts.com/episodes/107-migrations-in-rails-2-1">http://railscasts.com/episodes/107-migrations-in-rails-2-1</uri></para>

          <para>Dieser Screencast ist etwas veraltet (Rails-Version 2.1), aber
          immer noch gut, um die Basics zu verstehen.</para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://www.dizzy.co.uk/ruby_on_rails/cheatsheets/rails-migrations">http://www.dizzy.co.uk/ruby_on_rails/cheatsheets/rails-migrations</uri></para>
        </listitem>
      </itemizedlist></para>
  </section>
</section>
