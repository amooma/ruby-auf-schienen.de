<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="queries" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="queries.title">Suchen und Finden mit Queries</title>

  <para>Die Methoden <methodname>first</methodname> und
  <methodname>all</methodname> sind ja schon ganz nett, aber meistens will man
  ja doch nach etwas ganz Bestimmten mit einem Suchbegriff suchen
  (Query).</para>

  <para>Für die Beschreibung von Abfragen mit Queries erstellen wir ein neues
  Railsprojekt:<screen>MacBook:~ xyz$ <command>rails new jukebox</command>
[...]
MacBook:~ xyz$ <command>cd jukebox</command> 
MacBook:jukebox xyz$ <command>rails generate model album name release_year:integer</command>
[...]
MacBook:jukebox xyz$ <command>rake db:migrate</command>
[...]
MacBook:jukebox xyz$</screen></para>

  <para>Für die hier verwendeten Beispiele nehmen Sie eine
  <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting>Album.create("name"=&gt;"Sgt. Pepper's Lonely Hearts Club Band", "release_year"=&gt;1967)
Album.create("name"=&gt;"Pet Sounds", "release_year"=&gt;1966)
Album.create("name"=&gt;"Revolver", "release_year"=&gt;1966)
Album.create("name"=&gt;"Highway 61 Revisited", "release_year"=&gt;1965)
Album.create("name"=&gt;"Rubber Soul", "release_year"=&gt;1965)
Album.create("name"=&gt;"What's Going On", "release_year"=&gt;1971)
Album.create("name"=&gt;"Exile on Main St.", "release_year"=&gt;1972)
Album.create("name"=&gt;"London Calling", "release_year"=&gt;1979)
Album.create("name"=&gt;"Blonde on Blonde", "release_year"=&gt;1966)
Album.create("name"=&gt;"The Beatles", "release_year"=&gt;1968)</programlisting></para>

  <para>Danach die Datenbank mit <command>rake db:setup</command> neu
  aufsetzen:<screen>MacBook:jukebox xyz$ <command>rake db:setup</command>
db/development.sqlite3 already exists
-- create_table("albums", {:force=&gt;true})
   -&gt; 0.0308s
-- initialize_schema_migrations_table()
   -&gt; 0.0003s
-- assume_migrated_upto_version(20120426133607, ["/Users/xyz/jukebox/db/migrate"])
   -&gt; 0.0005s
MacBook:jukebox xyz$</screen></para>

  <section xml:id="find_vs_where">
    <title xml:id="find_vs_where.title">find vs. where</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>find()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>where()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Lazy Loading</secondary>
    </indexterm>

    <para>Es gibt in ActiveRecord zwei prinzipielle Suchmethoden:
    <methodname>find</methodname> und <methodname>where</methodname>.
    Logischerweise stellt sich dem Rails-Anfänger direkt die Frage "Welche
    Methode soll ich eher benutzten?". Eine Schwarz/Weiß-Antwort auf diese
    Frage fällt mir schwer. Ich selber benutze zu 80%
    <methodname>where</methodname> und bei den restlichen 20% könnte ich auch
    <methodname>where</methodname> benutzen, aber
    <methodname>find</methodname> ist dann einen Tick praktischer und der Code
    ist besser lesbar. Probieren Sie am besten beide Methoden einmal aus und
    entscheiden Sie dann aus dem Bauch raus.</para>

    <tip>
      <para>Bitte lesen Sie <xref linkend="activerecord_where"/> und <xref
      linkend="activerecord_find"/>. Besonders empfehlen möchte ich <xref
      linkend="lazy_loading"/>, um die Optimierungen und ein wichtiges Konzept
      von <methodname>where</methodname> zu verstehen.</para>
    </tip>
  </section>

  <section xml:id="activerecord_find">
    <title xml:id="activerecord_find.title">find</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>find()</tertiary>
    </indexterm>

    <para>Der einfachste Fall ist die Suche eines Datensatzes anhand eines
    Primary Key (also per Default dem id Feld in der Datenbanktabelle). Wenn
    ich die ID eines Objektes (hier: einer Datensatz-Zeile) kenne, kann ich
    das einzelne Objekt oder mehrere Objekte gleichzeitig anhand der ID
    suchen:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.find(2)</command>
  Album Load (4.0ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 2]]
 =&gt; #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>Album.find([1,3,7])</command>
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" IN (1, 3, 7)
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;] 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

    <para>Wenn man immer ein Array als Ergebnis haben will, muss man immer
    auch ein Array als Parameter übergeben:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.find(5).class</command>
  Album Load (4.0ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 5]]
 =&gt; Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
1.9.3p194 :002 &gt; <command>Album.find([5]).class</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 5]]
 =&gt; Array 
1.9.3p194 :003 &gt; <command>Album.find([1,3,7]).class</command>
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" IN (1, 3, 7)
 =&gt; Array 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

    <warning>
      <para>Die Methode find generiert eine Exception, wenn die gesuchte ID
      keinen Datensatz in der Datenbank hat. Im Zweifelsfall kann/muss man
      <methodname>where</methodname> (siehe <xref
      linkend="activerecord_where"/>) benutzen,
      <methodname>find_by_*</methodname> (siehe <xref
      linkend="activerecord_find_by"/>) oder mit der Methode <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>exists?()</tertiary>
        </indexterm><methodname>exists?</methodname> (siehe <xref
      linkend="activerecord_exists"/>) vorher prüfen, ob der Datensatz
      existiert:<footnote>
          <para>Sie können eine Exception auch mit
          <methodname>rescue</methodname> abfangen, aber darauf gehe ich in
          diesem Anfängerbuch nicht weiter ein.</para>
        </footnote><screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.last</command>
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" DESC LIMIT 1
 =&gt; #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>Album.find(50)</command>
  Album Load (33.6ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = ? LIMIT 1  [["id", 50]]
ActiveRecord::RecordNotFound: Couldn't find Album with id=50
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/activerecord-3.2.3/lib/active_record/relation/finder_methods.rb:340:in `find_one'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/activerecord-3.2.3/lib/active_record/relation/finder_methods.rb:311:in `find_with_ids'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/activerecord-3.2.3/lib/active_record/relation/finder_methods.rb:107:in `find'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/activerecord-3.2.3/lib/active_record/querying.rb:5:in `find'
 from (irb):2
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.3/lib/rails/commands/console.rb:47:in `start'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.3/lib/rails/commands/console.rb:8:in `start'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.3/lib/rails/commands.rb:41:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
1.9.3p194 :003 &gt; <command>Album.exists?(50)</command>
  Album Exists (0.2ms)  SELECT 1 FROM "albums" WHERE "albums"."id" = 50 LIMIT 1
 =&gt; false 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </warning>

    <section xml:id="activerecord_find_by">
      <title xml:id="activerecord_find_by.title">Attribut-basierendes
      find_by_*, find_last_by_* und find_all_by_* (find_by_attributes)</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_by_*()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_last_by_*()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_all_by_*()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_by_attributes</tertiary>
      </indexterm>

      <para>Das Attribut-basierende
      <methodname>find_by_<replaceable>*</replaceable></methodname> ist eine
      <quote>magische</quote> Methode, denn sie kann von Ihnen dynamisch
      erweitert werden (deshalb werden diese Methoden auch "dynamic finders"
      genannt). Die Funktionalität ist die gleiche wie die der Methode
      <methodname>where</methodname> (siehe <xref
      linkend="activerecord_where"/>), aber die Lesbarkeit des Codes wird
      besser (jedenfalls bei wenigen Parametern). Man kann treffend über den
      Sinn oder den Unsinn streiten. Probieren Sie es einmal aus, und
      entscheiden Sie selber, welchen Weg Sie gehen wollen.</para>

      <para>Ein Beispiel auf der <foreignphrase
      xml:lang="en">Console</foreignphrase> sagt mehr als tausend Worte. Ich
      verwende erst <methodname>where</methodname> und dann
      <methodname>find_by_<replaceable>*</replaceable></methodname> und
      <methodname>find_last_by_*</methodname> für gleiche Abfagen:</para>

      <para><screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; 1966).first</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966 LIMIT 1
 =&gt; #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>Album.find_by_release_year(1966)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966 LIMIT 1
 =&gt; #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :003 &gt; <command>Album.where( :release_year =&gt; 1966 ).last</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966 ORDER BY "albums"."id" DESC LIMIT 1
 =&gt; #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :004 &gt; <command>Album.find_last_by_release_year(1966)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966 ORDER BY "albums"."id" DESC LIMIT 1
 =&gt; #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

      <important>
        <para>Im Gegensatz zu <methodname>where</methodname> gibt
        <methodname>find_by_<replaceable>*</replaceable></methodname> entweder
        ein Objekt der gesuchten Klasse (hier <classname>Album</classname>)
        oder <literal>nil</literal> zurück. <methodname>where</methodname>
        gibt <emphasis>immer</emphasis> ein Array zurück! Wenn man auf diesen
        Unterschied beim Programmieren nicht achtet, bekommt man über kurz
        oder lang einen Fehler an dieser Stelle.<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.find_by_release_year(1972)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1972 LIMIT 1
 =&gt; #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>Album.find_by_release_year(1972).class</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1972 LIMIT 1
 =&gt; Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
1.9.3p194 :003 &gt; <command>Album.find_by_release_year(2010)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 2010 LIMIT 1
 =&gt; nil 
1.9.3p194 :004 &gt; <command>Album.find_by_release_year(2010).class</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 2010 LIMIT 1
 =&gt; NilClass 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
      </important>

      <para>Die Methode
      <methodname>find_all_by_<replaceable>*</replaceable></methodname> gibt
      wie <methodname>where</methodname> immer ein Array zurück:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.find_all_by_release_year(2020).class</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 2020
 =&gt; Array 
1.9.3p194 :002 &gt; <command>Album.find_all_by_release_year(1966).class</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; Array 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

      <section xml:id="activerecord_find_by_and_verkettung">
        <title xml:id="activerecord_find_by_and_verkettung.title">Verkettung
        von mehreren Attributen</title>

        <para>Mit den Methoden
        <methodname>find_by_<replaceable>*</replaceable></methodname>,
        <methodname>find_last_by_<replaceable>*</replaceable></methodname> und
        <methodname>find_all_by_<replaceable>*</replaceable></methodname>
        lassen sich auch mehrere Such-Attribute mit <literal>and</literal>
        verketten. Unsere aktuellen Datensätze lassen keine richtig guten
        Beispiele dafür zu. Deshalb ein paar wenig sinnvolle, aber die Methode
        beschreibende Abfragen, in der mit <literal>and</literal> Attribute
        verkettet werden:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.find_by_id_and_release_year(1, 1967)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = 1 AND "albums"."release_year" = 1967 LIMIT 1
 =&gt; #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>Album.find_all_by_id_and_release_year(1, 1967)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = 1 AND "albums"."release_year" = 1967
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;] 
1.9.3p194 :003 &gt; <command>Album.find_by_id_and_name(5, 'The Beatles')</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = 5 AND "albums"."name" = 'The Beatles' LIMIT 1
 =&gt; nil 
1.9.3p194 :004 &gt; <command>Album.find_all_by_id_and_name(5, 'The Beatles')</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."id" = 5 AND "albums"."name" = 'The Beatles'
 =&gt; [] 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
      </section>

      <section>
        <title>find_or_create_by_*</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>find_or_create_by_*()</tertiary>
        </indexterm>

        <para>Häufig hat man beim Programmieren die Aufgabenstellung, einen
        bestimmten Datensatz zu suchen und falls er nicht existiert, dann
        diesen anzulegen. Das lässt sich sehr schön mit
        <methodname>find_or_create_by_<replaceable>*</replaceable></methodname>
        in einem Schritt erledigen (achten Sie auf den SQL-Code):<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>beatles = Album.find_or_create_by_name('The Beatles')</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'The Beatles' LIMIT 1
 =&gt; #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>ray_charles = Album.find_or_create_by_name('Crying Time')</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'Crying Time' LIMIT 1
   (0.1ms)  begin transaction
  SQL (8.5ms)  INSERT INTO "albums" ("created_at", "name", "release_year", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 30 Apr 2012 14:17:14 UTC +00:00], ["name", "Crying Time"], ["release_year", nil], ["updated_at", Mon, 30 Apr 2012 14:17:14 UTC +00:00]]
   (1.4ms)  commit transaction
 =&gt; #&lt;Album id: 11, name: "Crying Time", release_year: nil, created_at: "2012-04-30 14:17:14", updated_at: "2012-04-30 14:17:14"&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

        <warning>
          <para>Bei der Benutzung von
          <methodname>find_or_create_by_<replaceable>*</replaceable></methodname>
          sollte man immer sicher sein, dass der eventuell neu anzulegende
          Datensatz in sich selber valide ist. Dies lässt sich einfach mit der
          Methode <indexterm>
              <primary>ActiveRecord</primary>

              <secondary>Methoden</secondary>

              <tertiary>valid?()</tertiary>
            </indexterm><methodname>valid?</methodname> realisieren (siehe
          <xref linkend="activerecord_validation"/>). Ein nicht valider
          Datensatz wird von <methodname>find_or_create_by_*</methodname>
          nicht abgespeichert!</para>
        </warning>

        <para>Wenn Sie zwar nach einem Albumnamen suchen, aber beim
        eventuellen <methodname>create</methodname> auch noch das
        <varname>release_year</varname> angeben wollen, so geht das auch mit
        <methodname>find_or_create_by_<replaceable>*</replaceable></methodname>:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>crying_time = Album.find_or_create_by_name('Genius Loves Company', :release_year =&gt; 2004)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'Genius Loves Company' LIMIT 1
   (0.1ms)  begin transaction
  SQL (5.2ms)  INSERT INTO "albums" ("created_at", "name", "release_year", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 30 Apr 2012 14:21:03 UTC +00:00], ["name", "Genius Loves Company"], ["release_year", 2004], ["updated_at", Mon, 30 Apr 2012 14:21:03 UTC +00:00]]
   (3.5ms)  commit transaction
 =&gt; #&lt;Album id: 12, name: "Genius Loves Company", release_year: 2004, created_at: "2012-04-30 14:21:03", updated_at: "2012-04-30 14:21:03"&gt; 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>
      </section>

      <section>
        <title>find_or_initialize_by_*</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>find_or_initialize_by_*()</tertiary>
        </indexterm>

        <para>Die Methode
        <methodname>find_or_initialize_by_<replaceable>*</replaceable></methodname>
        arbeitet wie
        <methodname>find_or_create_by_<replaceable>*</replaceable></methodname>.
        Allerdings gibt es einen entscheidenden Unterschied:
        <methodname>find_or_initialize_by_<replaceable>*</replaceable></methodname>
        speichert einen neuen Datensatz nicht ab. Das muss später per
        <methodname>save</methodname> erfolgen. Beispiel:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>i_got_a_woman = Album.find_or_initialize_by_name('I Got a Woman', :release_year =&gt; 1955)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."name" = 'I Got a Woman' LIMIT 1
 =&gt; #&lt;Album id: nil, name: "I Got a Woman", release_year: 1955, created_at: nil, updated_at: nil&gt; 
1.9.3p194 :002 &gt; <command>Album.last</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" DESC LIMIT 1
 =&gt; #&lt;Album id: 12, name: "Genius Loves Company", release_year: 2004, created_at: "2012-04-30 14:21:03", updated_at: "2012-04-30 14:21:03"&gt; 
1.9.3p194 :003 &gt; <command>i_got_a_woman.save</command>
   (0.1ms)  begin transaction
  SQL (6.8ms)  INSERT INTO "albums" ("created_at", "name", "release_year", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 30 Apr 2012 14:23:25 UTC +00:00], ["name", "I Got a Woman"], ["release_year", 1955], ["updated_at", Mon, 30 Apr 2012 14:23:25 UTC +00:00]]
   (3.5ms)  commit transaction
 =&gt; true 
1.9.3p194 :004 &gt; <command>Album.last</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" ORDER BY "albums"."id" DESC LIMIT 1
 =&gt; #&lt;Album id: 13, name: "I Got a Woman", release_year: 1955, created_at: "2012-04-30 14:23:25", updated_at: "2012-04-30 14:23:25"&gt; 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
      </section>

      <section xml:id="activerecord_find_by_all_performance">
        <title
        xml:id="activerecord_find_by_all_performance.title">Performance</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>where()</tertiary>
        </indexterm>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>find_all_by_*()</tertiary>
        </indexterm>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>count()</tertiary>
        </indexterm>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Lazy Loading</secondary>
        </indexterm>

        <indexterm>
          <primary>Lazy Loading</primary>

          <see>ActiveRecord, Lazy Loading</see>
        </indexterm>

        <para>Auch wenn die Methoden <methodname>where</methodname> und
        <methodname>find_all_by_<replaceable>*</replaceable></methodname> sich
        oft gleich anfühlen, so gibt es bei einigen Szenarien deutliche
        Performance-Unterschiede. Vereinfacht gesagt: Mit
        <methodname>where</methodname> machen Sie nie einen Fehler, da
        <methodname>where</methodname> <quote><foreignphrase
        xml:lang="en">Lazy Loading</foreignphrase></quote> benutzt. Auf
        <foreignphrase xml:lang="en">Lazy Loading</foreignphrase> gehen wir in
        <xref linkend="lazy_loading"/> dediziert ein. Hier aber schon mal ein
        kleiner Vorgeschmack:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1966).count</command>
   <emphasis>(0.2ms)</emphasis>  SELECT COUNT(*) FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; 3 
1.9.3p194 :002 &gt; <command>Album.find_all_by_release_year(1966).count</command>
  Album Load <emphasis>(0.3ms)</emphasis>  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; 3 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

        <para>Die Kombination der Methoden <methodname>where</methodname> und
        <methodname>count</methodname> erstellt eine SQL-Abfrage, die das
        Berechnen des Ergebnisses der SQL-Datenbank überlässt. Die Kombination
        der Methoden
        <methodname>find_all_by_<replaceable>*</replaceable></methodname> und
        <methodname>count</methodname> fragt erst alle Datensätze bei der
        Datenbank ab, speichert diese dann in einem Array und zählt
        anschließend die Einträge in diesem Array. Das macht bei unserer
        Mini-Datenbank kaum einen Unterschied (0.1ms). Wenn Sie aber mit einer
        sehr großen Datenbank arbeiten, dann wollen Sie die maximale
        Performance der SQL-Datenbank ausnutzen und nicht erst Daten hin- und
        herschieben.</para>

        <para>Wie bereits erwähnt: Diese Thematik wird in <xref
        linkend="lazy_loading"/> detailliert besprochen.</para>
      </section>
    </section>
  </section>

  <section xml:id="activerecord_where">
    <title xml:id="activerecord_where.title">where</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>where()</tertiary>
    </indexterm>

    <para>Mit der Methode <methodname>where</methodname> kann man nach
    bestimmten Werten in der Datenbank suchen. Suchen wir mal alle Alben aus
    dem Jahr 1966:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; 1966 )</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where( :release_year =&gt; 1966 ).count</command>
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; 3 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

    <para>Sie können mit <methodname>where</methodname> auch nach
    <foreignphrase xml:lang="en">Ranges</foreignphrase> (Bereichen, siehe
    <xref linkend="range_class"/>) suchen:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; 1960..1966 )</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
 =&gt; [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where( :release_year =&gt; 1960..1966 ).count</command>
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
 =&gt; 5 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

    <para>Und Sie können auch mehrere Suchfaktoren mit Komma abgetrennt
    gleichzeitig angeben:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; 1960..1966, :id =&gt; 1..5 )</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966) AND ("albums"."id" BETWEEN 1 AND 5)
 =&gt; [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where( :release_year =&gt; 1960..1966, :id =&gt; 1..5 ).count</command>
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966) AND ("albums"."id" BETWEEN 1 AND 5)
 =&gt; 4 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

    <para>Oder auch ein Array von Parametern:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; [1966, 1968] )</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968)
 =&gt; [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where( :release_year =&gt; [1966, 1968] ).count</command>
   (0.3ms)  SELECT COUNT(*) FROM "albums" WHERE "albums"."release_year" IN (1966, 1968)
 =&gt; 4 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

    <important>
      <para>Das Ergebnis von <methodname>where</methodname> ist immer ein
      Array. Auch wenn nur ein Treffer drin ist oder auch wenn gar kein
      Treffer zurückgegeben wird. Wenn Sie den ersten Treffer suchen, dann
      müssen Sie <methodname>where</methodname> mit der Methode
      <methodname>first</methodname> verketten:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; [1966, 1968] ).first</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968) LIMIT 1
 =&gt; #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt; 
1.9.3p194 :002 &gt; <command>Album.where( :release_year =&gt; [1966, 1968] ).first.class</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" IN (1966, 1968) LIMIT 1
 =&gt; Album(id: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </important>

    <section xml:id="activerecord_sql">
      <title xml:id="activerecord_sql.title">SQL-Abfragen mit where</title>

      <para>Manchmal kommt man nicht umhin und muss tatsächlich eine
      SQL-Abfrage selber definieren und durchführen. Es gibt in ActiveRecord
      zwei verschiedene Arten, dies zu machen. Die eine <quote>reinigt</quote>
      (<foreignphrase xml:lang="en">sanitize</foreignphrase>) jede Abfrage vor
      dem Ausführen und die andere gibt die Abfrage 1 zu 1 so an die
      SQL-Datenbank weiter. Im Normalfall sollte man immer die sanitize
      Variante benutzen, weil man sonst sehr schnell Opfer einer
      SQL-Einschleusungs-Attacke (<foreignphrase xml:lang="en">SQL
      injection</foreignphrase>) werden kann (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/SQL-Injection">http://de.wikipedia.org/wiki/SQL-Injection</uri>).</para>

      <para>Falls Sie sich mit SQL nicht auskennen, dann können Sie diesen
      Abschnitt ruhig überspringen. Die hier verwendeten SQL-Befehle werden
      nicht gesondert erklärt.</para>

      <section>
        <title>sanitized (gereinigte) Abfragen</title>

        <para>Bei dieser Variante werden alle dynamischen Suchanteile durch
        ein Fragezeichen als Platzhalter ersetzt und erst nach dem SQL-String
        als Parameter aufgelistet.</para>

        <para>Nachfolgend suchen wir alle Alben, in deren Namen der String
        <quote>on</quote> enthalten ist:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( 'name like ?', '%on%' )</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE (name like '%on%')
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 8, name: "London Calling", release_year: 1979, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where( 'name like ?', '%on%' ).count</command>
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%')
 =&gt; 5 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

        <para>Jetzt alle Alben, die ab 1965 veröffentlicht wurden:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( 'release_year &gt; ?', 1964 ).count</command>
   (0.1ms)  SELECT COUNT(*) FROM "albums" WHERE (release_year &gt; 1964)
 =&gt; 10 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

        <para>Alle Alben, die jünger als 1970 sind und deren Namen den String
        <quote>on</quote> enthalten:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( 'name like ? AND release_year &gt; ?', '%on%', 1970 ).count</command>
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%' AND release_year &gt; 1970)
 =&gt; 3 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

        <para>Wenn in der Variable <varname>apfelmus</varname> der gesuchte
        String enthalten ist, dann kann folgendermaßen danach gesucht
        werden:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>apfelmus = 'ing'</command>
 =&gt; "ing" 
1.9.3p194 :002 &gt; <command>Album.where( 'name like ?', "%#{apfelmus}%").count</command>
   (0.1ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%ing%')
 =&gt; 2 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
      </section>

      <section>
        <title><quote>Gefährliche</quote> SQL-Abfragen</title>

        <para>Wenn Sie wirklich wissen, was Sie tun, dann können Sie natürlich
        auch komplett die SQL-Abfrage definieren und auf das Reinigen
        (<foreignphrase xml:lang="en">sanitize</foreignphrase>) der Abfrage
        verzichten.</para>

        <para>Zählen wir einmal alle Alben, in deren Namen der String
        <quote>on</quote> enthalten ist:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( "name like '%on%'" ).count</command>
   (0.5ms)  SELECT COUNT(*) FROM "albums" WHERE (name like '%on%')
 =&gt; 5 
1.9.3p194 :002 &gt; <command>exit</command></screen></para>

        <para>Bitte benutzen Sie diese Variante nur, wenn Sie genau wissen,
        was Sie tun und nachdem Sie sich mit dem Thema SQL-Injections
        beschäftigt haben (siehe <uri
        xlink:href="http://de.wikipedia.org/wiki/SQL-Injection">http://de.wikipedia.org/wiki/SQL-Injection</uri>).</para>
      </section>
    </section>

    <section xml:id="lazy_loading">
      <title xml:id="lazy_loading.title">Lazy Loading</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Lazy Loading</secondary>
      </indexterm>

      <indexterm>
        <primary>Lazy Loading</primary>

        <see>ActiveRecord, Lazy Loading</see>
      </indexterm>

      <para>Seit Rails 3.0 wird bei ActiveRecords die Methode <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>where()</tertiary>
        </indexterm><methodname>where</methodname> und damit <foreignphrase
      xml:lang="en">Lazy Loading</foreignphrase> verwendet. Dies ist ein
      Mechanismus, der eine Datenbank-Abfrage erst dann stellt, wenn der
      weitere Programmablauf nicht ohne das Ergebnis dieser Abfrage realisiert
      werden kann. Bis dahin wird die Anfrage als
      <classname>ActiveRecord::Relation</classname> gespeichert. (Das
      Gegenteil von <foreignphrase xml:lang="en">Lazy Loading</foreignphrase>
      nennt man übrigens <foreignphrase xml:lang="en">Eager
      Loading</foreignphrase>.)</para>

      <para>Schauen wir uns die Abfrage nach allen Alben aus dem Jahr 1966
      an.</para>

      <para><screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1966)</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; [#&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
1.9.3p194 :003 &gt; <command>Album.where(:release_year =&gt; 1966).to_sql</command>
 =&gt; "SELECT \"albums\".* FROM \"albums\"  WHERE \"albums\".\"release_year\" = 1966" 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

      <para>Wenn aber <code>Album.where(:release_year =&gt; 1966)</code> eine
      <classname>ActiveRecord::Relation</classname> ist, warum bekommen wir
      dann in der <foreignphrase xml:lang="en">Console</foreignphrase> ein
      Array ausgegeben? Rails will uns das Entwicklerleben etwas einfacher
      machen und zeigt uns quasi automatisch das Ergebnis der Methode
      <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>all()</tertiary>
        </indexterm><methodname>all</methodname> an:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
1.9.3p194 :002 &gt; <command>Album.where(:release_year =&gt; 1966).all.class</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE "albums"."release_year" = 1966
 =&gt; Array 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

      <para>Prinzipiell klar, aber der Sinn noch nicht ganz? Dann bauen wir
      uns mal eine Abfrage zusammen, in der wir mehrere Methoden
      verschachteln. In dem folgenden Beispiel wird <varname>a</varname> immer
      weiter definiert und erst ganz zum Schluss (beim Aufruf der Methode
      <methodname>all</methodname>) würde bei einem Produktivsystem die
      Datenbank-Abfrage wirklich getätigt. Mit der Methode <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>to_sql()</tertiary>
        </indexterm><methodname>to_sql</methodname> kann man sich immer das
      aktuelle SQL-Query ausgeben lassen.<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>a = Album.where(:release_year =&gt; 1965..1968)</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968)
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;] 
1.9.3p194 :002 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
1.9.3p194 :003 &gt; <command>a = a.order(:release_year)</command>
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968) ORDER BY release_year
 =&gt; [#&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;] 
1.9.3p194 :004 &gt; <command>a = a.limit(3)</command>
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1965 AND 1968) ORDER BY release_year LIMIT 3
 =&gt; [#&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt;] 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:jukebox xyz$  </screen></para>

      <section xml:id="activerecord_lazyloading_automatische_optimierung">
        <title
        xml:id="activerecord_lazyloading_automatische_optimierung.title">Automatische
        Optimierung</title>

        <para>Einer der großen Vorteile von <foreignphrase xml:lang="en">Lazy
        Loading</foreignphrase> ist die automatische Optimierung der
        SQL-Abfrage durch ActiveRecord.</para>

        <para>Ziehen wir mal die Summe aller Veröffentlichungsjahre der Alben,
        die in den 70ern herausgebracht wurden. Und danach sortieren wir die
        Alben nach Namen und ziehen anschließend die Summe.<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1970..1979).sum(:release_year)</command>
   (3.1ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
 =&gt; 5922 
1.9.3p194 :002 &gt; <command>Album.where(:release_year =&gt; 1970..1979).order(:name).sum(:release_year)</command>
   (0.3ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
 =&gt; 5922 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

        <para>Das Ergebnis ist bei beiden Abfragen logischerweise identisch.
        Interessant ist aber, das ActiveRecord bei beiden Anfragen den
        gleichen SQL-Code benutzt hat. Es hat erkannt, das
        <methodname>order</methodname> bei <methodname>sum</methodname> völlig
        irrelevant ist und es deshalb direkt raus genommen.</para>

        <note>
          <para>Falls Sie sich fragen, warum die erste Abfrage 3.1ms und die
          zweite 0.3ms gedauert hat: ActiveRecord cached die Ergebnisse einer
          SQL-Abfrage innerhalb eines Webseitenaufrufes.</para>
        </note>
      </section>
    </section>
  </section>

  <section xml:id="activerecord_exists">
    <title xml:id="activerecord_exists.title">exists?</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>exists?()</tertiary>
    </indexterm>

    <para>Hin und wieder muss man wissen, ob es einen bestimmten Datensatz
    gibt, und genau dafür gibt es die Methode
    <methodname>exists?</methodname>. Sie gibt als Ergebnis
    <literal>true</literal> oder <literal>false</literal> zurück:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.first</command>
  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 1
 =&gt; #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 13:45:04", updated_at: "2012-04-30 13:45:04"&gt; 
1.9.3p194 :002 &gt; <command>Album.exists?(1)</command>
  Album Exists (0.2ms)  SELECT 1 FROM "albums" WHERE "albums"."id" = 1 LIMIT 1
 =&gt; true 
1.9.3p194 :003 &gt; <command>Album.exists?(10000)</command>
  Album Exists (0.2ms)  SELECT 1 FROM "albums" WHERE "albums"."id" = 10000 LIMIT 1
 =&gt; false 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

    <para>Die komplette Hilfe zur Methode <methodname>exists?</methodname>
    können Sie sich mit <command>ri
    ActiveRecord::FinderMethods.exists?</command> anzeigen lassen.</para>
  </section>

  <section xml:id="activerecord_order">
    <title xml:id="activerecord_order.title">order und reverse_order</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>order()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>reverse_order</tertiary>
    </indexterm>

    <para>Jede Datenbank-Anfrage kann mit der Methode
    <methodname>order</methodname> sortiert werden. Beispiel: Alle Alben aus
    den 60ern nach Namen sortiert:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; 1960..1969 ).order(:name)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY name
 =&gt; [#&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

    <para>Mit der Methode reverse_order können wir eine mit
    <methodname>order</methodname> definierte Reihenfolge umkehren:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1960..1969).order(:name).reverse_order</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY name DESC
 =&gt; [#&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
  </section>

  <section xml:id="activerecord_limit">
    <title xml:id="activerecord_limit.title">limit</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>limit()</tertiary>
    </indexterm>

    <para>Das Ergebnis jeder Suche kann mit der Methode
    <methodname>limit</methodname> auf einen bestimmten Bereich eingegrenzt
    werden.</para>

    <para>Die ersten 5 Alben aus den 60ern:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where( :release_year =&gt; 1960..1969).limit(5)</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) LIMIT 5
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

    <para>Alle Alben nach Namen sortieren und davon die ersten 5:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.order(:name).limit(5)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" ORDER BY name LIMIT 5
 =&gt; [#&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 8, name: "London Calling", release_year: 1979, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>

    <section xml:id="activerecord_offset">
      <title xml:id="activerecord_offset.title">offset</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>offset()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>offset</methodname> kann die
      Startposition der Methode <methodname>limit</methodname> definiert
      werden.</para>

      <para>Als Erstes geben wir die ersten beiden Datensätze zurück und
      danach die ersten beiden Datensätze mit einem Offset von 5:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.limit(2)</command>
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" LIMIT 2
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>Album.limit(2).offset(5)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" LIMIT 2 OFFSET 5
 =&gt; [#&lt;Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </section>
  </section>

  <section xml:id="activerecord_group">
    <title xml:id="activerecord_group.title">group</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>group()</tertiary>
    </indexterm>

    <para>Mit der Methode <methodname>group</methodname> kann das Ergebnis
    einer Abfrage gruppiert zurückgegeben werden.</para>

    <para>Geben wir erst mal alle Alben nach dem Erscheinungsjahr gruppiert
    zurück:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.group(:release_year)</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" GROUP BY release_year
 =&gt; [#&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 6, name: "What's Going On", release_year: 1971, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;, #&lt;Album id: 8, name: "London Calling", release_year: 1979, created_at: "2012-04-26 13:40:13", updated_at: "2012-04-26 13:40:13"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
  </section>

  <section xml:id="activerecord_pluck">
    <title xml:id="activerecord_pluck.title">pluck</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>pluck()</tertiary>
    </indexterm>

    <para>Normalerweise zieht ActiveRecord immer alle Tabellenspalten aus der
    Datenbank und überlässt es dem Programmierer später die für ihn
    interessanten Komponenten rauszuholen. Bei grossen Datenmengen kann es
    aber praktisch und vor allen Dingen sehr viel schneller sein, direkt bei
    der Abfrage ein bestimmtes Datenbankfeld für die Abfrage zu definieren.
    Das kann mit der Methode <methodname>pluck</methodname> gemacht werden.
    Wollen Sie alle name Einträge für alle Alben aus den 1960ern?<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1960..1969).pluck(:name)</command>
   (0.2ms)  SELECT name FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
 =&gt; ["Sgt. Pepper's Lonely Hearts Club Band", "Pet Sounds", "Revolver", "Highway 61 Revisited", "Rubber Soul", "Blonde on Blonde", "The Beatles"] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>

    <para>Als Ergebnis liefert <methodname>pluck</methodname> ein
    Array.</para>
  </section>

  <section xml:id="activerecord_berechnungen">
    <title xml:id="activerecord_berechnungen.title">Berechnungen</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Berechnungen</secondary>
    </indexterm>

    <section xml:id="activerecord_average">
      <title xml:id="activerecord_average.title">average</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>average()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>average</methodname> lässt sich der
      Durchschnitt der Werte in einer bestimmten Spalte in der Tabelle
      ausrechnen. Dafür ist unser Datenmaterial natürlich schlecht geeignet.
      Als Erstes berechnen wir das Durchschnitts-Veröffentlichungsjahr aller
      Alben und danach das Gleiche für die Alben aus den 60ern:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.average(:release_year)</command>
   (3.7ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" 
 =&gt; #&lt;BigDecimal:7fbdd1f01ef0,'0.19685E4',18(45)&gt; 
1.9.3p194 :002 &gt; <command>Album.average(:release_year).to_s</command>
   (0.3ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" 
 =&gt; "1968.5" 
1.9.3p194 :003 &gt; <command>Album.where( :release_year =&gt; 1960..1969 ).average(:release_year)</command>
   (0.3ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
 =&gt; #&lt;BigDecimal:7fbdd1b07980,'0.1966142857 142857E4',27(45)&gt; 
1.9.3p194 :004 &gt; <command>Album.where( :release_year =&gt; 1960..1969 ).average(:release_year).to_s</command>
   (0.2ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
 =&gt; "1966.142857142857" 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </section>

    <section xml:id="activerecord_count">
      <title xml:id="activerecord_count.title">count</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>count()</tertiary>
      </indexterm>

      <para>Die Methode <methodname>count</methodname> zählt die Anzahl der
      Datensätze.</para>

      <para>Als Erstes geben wir die Anzahl aller Alben in der Datenbank
      zurück und danach die Anzahl der Alben in den 60ern:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.count</command>
   (0.1ms)  SELECT COUNT(*) FROM "albums" 
 =&gt; 10 
1.9.3p194 :002 &gt; <command>Album.where( :release_year =&gt; 1960..1969 ).count</command>
   (0.2ms)  SELECT COUNT(*) FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
 =&gt; 7 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:jukebox xyz$ </screen></para>
    </section>

    <section xml:id="activerecord_maximum">
      <title xml:id="activerecord_maximum.title">maximum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>maximum()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>maximum</methodname> kann aus einer
      Abfrage der Eintrag mit dem höchsten Wert ausgegeben werden.</para>

      <para>Suchen wir das höchste Veröffentlichungsjahr:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.maximum(:release_year)</command>
   (0.2ms)  SELECT MAX("albums"."release_year") AS max_id FROM "albums" 
 =&gt; 1979 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </section>

    <section xml:id="activerecord_minimum">
      <title xml:id="activerecord_minimum.title">minimum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>minimum()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>minimum</methodname> kann aus einer
      Abfrage der Eintrag mit dem niedrigsten Wert ausgegeben werden.</para>

      <para>Suchen wir das niedrigste Veröffentlichungsjahr:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.minimum(:release_year)</command>
   (0.1ms)  SELECT MIN("albums"."release_year") AS min_id FROM "albums" 
 =&gt; 1965 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </section>

    <section xml:id="activerecord_sum">
      <title xml:id="activerecord_sum.title">sum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>sum()</tertiary>
      </indexterm>

      <para>Mit der Methode sum lässt sich die Summe aller Einträge in einer
      bestimmten Spalte der Datenbank-Abfrage berechnen.</para>

      <para>Ziehen wir die Summe aller Veröffentlichungsjahre:<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.sum(:release_year)</command>
   (3.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" 
 =&gt; 19685 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:jukebox xyz$</screen></para>
    </section>
  </section>

  <section xml:id="activerecord_explain">
    <title xml:id="activerecord_explain.title">SQL EXPLAIN</title>

    <para>Die meisten SQL-Datenbanken können mit dem Befehl EXPLAIN
    detailierte Informationen zu einer SQL-Abfrage liefert. Dies macht bei
    unserer Mini-Applikation wenig Sinn, aber wenn Sie einmal mit einer
    grossen Datenbank arbeiten, dann ist EXPLAIN eine gute Debugging-Methode,
    um z.B. rauszufinden, an welcher Stelle ein Index gesetzt werden sollte.
    SQL EXPLAIN kann mit der <methodname>explain</methodname> Methode
    abgerufen werden (mit einem <code>puts</code> kann man sich die Ausgabe
    schöner anzeigen lassen):<screen>MacBook:jukebox xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Album.where(:release_year =&gt; 1960..1969)  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)</command>
 =&gt; [#&lt;Album id: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 2, name: "Pet Sounds", release_year: 1966, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 3, name: "Revolver", release_year: 1966, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 5, name: "Rubber Soul", release_year: 1965, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;, #&lt;Album id: 10, name: "The Beatles", release_year: 1968, created_at: "2012-04-30 14:51:03", updated_at: "2012-04-30 14:51:03"&gt;] 
1.9.3p194 :002 &gt; <command>Album.where(:release_year =&gt; 1960..1969).explain</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
  EXPLAIN (0.1ms)  EXPLAIN QUERY PLAN SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
 =&gt; "EXPLAIN for: SELECT \"albums\".* FROM \"albums\"  WHERE (\"albums\".\"release_year\" BETWEEN 1960 AND 1969)\n0|0|0|SCAN TABLE albums (~500000 rows)\n" 
1.9.3p194 :003 &gt; <command>puts Album.where(:release_year =&gt; 1960..1969).explain</command>
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
  EXPLAIN (0.1ms)  EXPLAIN QUERY PLAN SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
EXPLAIN for: SELECT "albums".* FROM "albums"  WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
0|0|0|SCAN TABLE albums (~500000 rows)
 =&gt; nil 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:jukebox xyz$  </screen></para>
  </section>
</section>
