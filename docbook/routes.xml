<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="routes" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="routes.title">Routen (routes)</title>

  <indexterm>
    <primary>Routen</primary>
  </indexterm>

  <indexterm>
    <primary>routes.rb</primary>

    <see>Routen</see>
  </indexterm>

  <section xml:id="routes_einstieg">
    <title xml:id="routes_einstieg.title">Einstieg</title>

    <para>In <xref linkend="dynamische_webseiten"/> und <xref
    linkend="scaffolding"/> hatten wir schon mal kurz Kontakt mit
    <foreignphrase xml:lang="en">Routes</foreignphrase>. Mit den in
    <filename>config/routes.rb</filename> enthaltenen Routen wird definiert,
    was in Rails Application passiert, wenn eine bestimmte URL vom Besucher
    der Webseite angesteuert wird. Eine Route kann statisch und dynamisch sein
    und evt. dynamische Werte mit Variablen an den Controller übergeben.
    Sollten mehrere Routen auf eine URL zutreffen, so gewinnt die in der
    <filename>config/routes.rb</filename> am oberste eingetragene.<note>
        <para>Wenn Sie wenig Zeit haben, können Sie dieses Kapitel erst einmal
        überspringen und später bei konkreten Fragen noch mal
        nachschlagen.</para>
      </note></para>

    <para>Bauen wir uns zuerst eine Test-Rails-Applikation zum
    Experimentieren:<screen>MacBook:~ xyz$ <command>rails new shop</command>
[...]
MacBook:~ xyz$ <command>cd shop</command>
MacBook:shop xyz$</screen></para>

    <para>Mit <command>rake routes</command> können wir uns die Routen eines
    Projektes anzeigen lassen. Probieren wir das direkt im frischen Projekt
    aus:<screen>MacBook:shop xyz$ <command>rake routes</command>

MacBook:shop xyz$</screen></para>

    <para>Nichts. Es sind in einem neuen Rails-Projekt keine Routen
    eingetragen.</para>

    <important>
      <para>Auch bei einem neuen Rails-Projekt können Sie nach dem Start des
      Rails-Servers mit <command>rails server</command> auf <uri
      xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri> zugreifen.
      Wie kann dies ohne eine eingetragene Route funktionieren? Die Lösung
      liegt im Verzeichnis <filename>/public</filename>. Dort liegt die Datei
      <filename>public/index.html</filename>, und immer wenn im Verzeichnis
      <filename>/public</filename> eine Datei liegt, die zur angegebenen URL
      passt, bekommt diese eine höhere Priorität als eine Rails-Route. Falls
      keine Route definiert ist, wird automatisch in
      <filename>public</filename> nach <filename>index.html</filename>
      gesucht.</para>
    </important>

    <para>Bei einem neuen Rails-Projekt ist die Datei
    <filename>config/routes.rb</filename> mit vielen auskommentierten
    Beispielen bestückt. Für den Verlauf dieses Kapitels tun wir so, als wenn
    diese Beispiele nicht drin wären und zeigen immer nur die neu
    eingetragenen Routen an.</para>
  </section>

  <section xml:id="routes_get">
    <title xml:id="routes_get.title">get</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>get</secondary>
    </indexterm>

    <para>Erstellen wir nachfolgend einen Controller mit drei einfachen
    Seiten:<screen>MacBook:shop xyz$ <command>rails generate controller Home index ping pong</command>
      create  app/controllers/home_controller.rb
<emphasis>       route  get "home/pong"
       route  get "home/ping"
       route  get "home/index"
</emphasis>      invoke  erb
      create    app/views/home
      create    app/views/home/index.html.erb
      create    app/views/home/ping.html.erb
      create    app/views/home/pong.html.erb
      invoke  test_unit
      create    test/functional/home_controller_test.rb
      invoke  helper
      create    app/helpers/home_helper.rb
      invoke    test_unit
      create      test/unit/helpers/home_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/home.js.coffee
      invoke    scss
      create      app/assets/stylesheets/home.css.scss
MacBook:shop xyz$</screen></para>

    <para>Jetzt gibt <command>rake route</command> für diese drei Seiten eine
    Route aus:<screen>MacBook:shop xyz$ <command>rake routes</command>
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
MacBook:shop xyz$</screen></para>

    <para>Die Seiten sind nach dem Starten des Rails-Servers mit
    <command>rails server</command> unter den folgenden URLs
    erreichbar:<itemizedlist>
        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/index">http://0.0.0.0:300/home/index</uri></para>

          <para>für <code>home_index GET /home/index(.:format)
          home#index</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/ping">http://0.0.0.0:300/home/ping</uri></para>

          <para>für <code>home_ping GET /home/ping(.:format)
          home#ping</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/pong">http://0.0.0.0:300/home/pong</uri></para>

          <para>für <code>home_pong GET /home/pong(.:format)
          home#pong</code></para>
        </listitem>
      </itemizedlist></para>

    <para><screenshot>
        <info>
          <title>http://0.0.0.0:300/home/ping</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/home_ping.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Rails sagt uns mit der Ausgabe <code>home#index</code>, dass die
    Route <uri>/home/index</uri> in den Controller <classname>home</classname>
    und dort zur Action/Methode <methodname>index</methodname> geht. Definiert
    werden diese Routen in der Datei <filename>config/routes.rb</filename>.
    <command>rails generate controller Home index ping pong</command> hat dort
    automatisch folgende Zeilen eingefügt:<programlisting>  get "home/index"
  
  get "home/ping"
  
  get "home/pong"
</programlisting></para>
  </section>

  <section xml:id="namen_der_routen">
    <title xml:id="namen_der_routen.title">Namen der Routen</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>Namen</secondary>
    </indexterm>

    <para>Eine Route sollte immer auch einen internen Namen haben. In <xref
    linkend="routes_get"/> gibt es folgende Route:<programlisting>home_pong GET /home/pong(.:format)  home#pong</programlisting></para>

    <para>Diese Route hat den automatisch erzeugten Namen
    <varname>home_pong</varname>. Allgemein versucht man innerhalb einer
    Rails-Applikation immer mit dem Namen der Route zu arbeiten. Also ein
    <methodname>link_to</methodname> auf <varname>home_pong</varname> und
    nicht auf <uri>/home/pong</uri> zu setzen. Das hat den sehr grossen
    Vorteil, das man später das Routing für Besucher von Aussen verändern (im
    besten Fall optimieren) kann und intern in der Applikation nichts
    verändern muss. Natürlich muss man in diesem Fall die alten Namen mit
    <methodname>:as</methodname> eintragen.</para>

    <section xml:id="routen_as">
      <title xml:id="routen_as.title">:as</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>as</secondary>
      </indexterm>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Namen</secondary>

        <tertiary>as</tertiary>
      </indexterm>

      <para>Wenn Sie den Namen einer Route selbst definieren möchten, so
      können Sie das mit <methodname>:as</methodname> machen. So gibt die
      Zeile <programlisting>get "home/pong", :as =&gt; "alter_name"</programlisting></para>

      <para>die Route<screen>alter_name GET    /home/pong(.:format)      home#pong</screen></para>
    </section>
  </section>

  <section xml:id="routes_root">
    <title xml:id="routes_root.title">root :to =&gt; 'welcome#index'</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>root</secondary>
    </indexterm>

    <para>In der Default <filename>config/routes.rb</filename>-Datei finden
    Sie recht weit unten folgenden Kommentar:<programlisting>  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; 'welcome#index'</programlisting></para>

    <para>Wenn Sie dort die letzte Zeile auskommentieren, können Sie damit
    Ihre <uri xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri>
    definieren. Legen wir sie mal auf
    <methodname>home#index</methodname>:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  <emphasis>root :to =&gt; "home#index"</emphasis>
end</programlisting></para>

    <important>
      <para>Nach dem Setzen der <code>root</code>-Route sollten Sie nicht das
      Löschen der Datei <filename>/public/index.html</filename>
      vergessen!<screen>MacBook:shop xyz$ <command>rm public/index.html</command> 
MacBook:shop xyz$</screen></para>
    </important>

    <para>Unsere neuen Routen:<screen>MacBook:shop xyz$ <command>rake routes</command>
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
      root     /                     home#index
MacBook:shop xyz$</screen></para>

    <para>Beim Aufruf der Root-URL <uri
    xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri> bekommen wir
    jetzt <code>home#index</code> angezeigt.</para>

    <para><screenshot>
        <info>
          <title>Die Route „/“ ruft home#index auf</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/routes_root_url.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>
  </section>

  <section xml:id="routes_match">
    <title xml:id="routes_match.title">match</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>match</secondary>
    </indexterm>

    <para>Wenn wir zusätzlich zur URL <uri>/home/ping</uri> noch mit
    <uri>/home/apfelmus</uri> auf die gleiche Action im gleichen Controller
    zugreifen, so müssen wir die Datei <filename>config/routes.rb</filename>
    wie folgt verändern:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  root :to =&gt; "home#index"

  <emphasis>match "home/apfelmus" =&gt; "home#ping"</emphasis>
end</programlisting></para>

    <para>Damit stehen uns folgende Routen zur Verfügung:<screen>MacBook:shop xyz$ <command>rake routes</command>
   home_index GET /home/index(.:format)    home#index
    home_ping GET /home/ping(.:format)     home#ping
    home_pong GET /home/pong(.:format)     home#pong
         root     /                        home#index
<emphasis>home_apfelmus     /home/apfelmus(.:format) home#ping</emphasis>
MacBook:shop xyz$ </screen></para>

    <para><screenshot>
        <info>
          <title>http://0.0.0.0:3000/home/apfelmus</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/home_apfelmus.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn Sie der Route <filename>/home/apfelmus</filename> einen anderen
    Namen geben wollen, so können Sie dies mit der Einstellung <code>:as =&gt;
    "<replaceable>name</replaceable>"</code> in der
    <filename>config/routes.rb</filename> realisieren:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  root :to =&gt; "home#index"

  <emphasis>match "home/ping-ping" =&gt; "home#ping", :as =&gt; "apfelmus"</emphasis>
end</programlisting></para>

    <para>Jetzt stehen Ihnen im System folgende Routen-Namen zur
    Verfügung:<screen>MacBook:shop xyz$ <command>rake routes</command>
home_index GET /home/index(.:format)    home#index
 home_ping GET /home/ping(.:format)     home#ping
 home_pong GET /home/pong(.:format)     home#pong
      root     /                        home#index
  <emphasis>apfelmus</emphasis>     /home/ping-ping(.:format) home#ping
MacBook:shop xyz$</screen></para>

    <para>Sie sehen dabei, dass eine URL ein Minuszeichen enthalten darf, aber
    der Routen-Name nicht (ein Unterstrich geht aber).</para>

    <important>
      <para>Die Routen in der Datei <filename>config/routes.rb</filename>
      werden immer von oben nach unten abgearbeitet. Der erste Treffer von
      oben gewinnt!</para>
    </important>

    <section xml:id="routes_match_parameter">
      <title xml:id="routes_match_parameter.title">Parameter</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Parameter</secondary>
      </indexterm>

      <para>Match kann nicht nur fixe Routen zuordnen, sondern auch noch
      Parameter übergeben. Ein typisches Beispiel dafür wären Angaben zu einem
      Datum. Wir erstellen dazu nachfolgend eine
      Mini-Blog-Applikation:<screen>MacBook:~ xyz$ <command>rails new blog</command>
[...]
MacBook:~ xyz$ <command>cd blog</command> 
MacBook:blog xyz$ <command>rails generate scaffold Post subject content published_at:date</command>
[...]
MacBook:blog xyz$ <command>rake db:migrate</command>
[...]
MacBook:blog xyz$</screen></para>

      <para>Als Beispieldaten in der <filename>db/seeds.rb</filename> nehmen
      wir:<programlisting>Post.create(:subject =&gt; 'Ein Test',            :published_at =&gt; '01.10.2011')
Post.create(:subject =&gt; 'Noch ein Test',       :published_at =&gt; '01.10.2011')
Post.create(:subject =&gt; 'Und wieder ein Test', :published_at =&gt; '02.10.2011')
Post.create(:subject =&gt; 'Letzter Test',        :published_at =&gt; '01.11.2011')
Post.create(:subject =&gt; 'Allerletzter Test',   :published_at =&gt; '01.11.2012')</programlisting></para>

      <para>Mit <command>rake db:seed</command> spielen wir diese Daten in die
      Datenbank:<screen>MacBook:blog xyz$ <command>rake db:seed</command>
MacBook:blog xyz$</screen></para>

      <para>Wenn wir jetzt mit <command>rails server</command> den
      Rails-Server starten und mit dem Browser auf die Seite <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>
      surfen, bekommen wir folgende Anzeige:<screenshot>
          <info>
            <title>Index-Ansicht aller Posts</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_index.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Für ein solches Blog wäre es natürlich sehr praktisch, wenn man
      mit der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      alle Einträge für das Jahr 2010 und mit <uri
      xlink:href="http://0.0.0.0:3000/2010/10/01">http://0.0.0.0:3000/2010/10/01</uri>
      alle Einträge für den 01.10.2010 anzeigen könnte. Das erreichen wir mit
      optionalen Parametern beim <code>match</code>-Eintrag. Bitte tragen Sie
      folgende Konfiguration in die <filename>config/routes.rb</filename>
      ein:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year(/:month(/:day))" =&gt; "posts#index"
end</programlisting></para>

      <para>Die runden Klammern stehen für optionale Parameter. In diesem Fall
      muss unbedingt das Jahr, aber nicht zwingend der Monat oder der Tag
      angegeben werden.</para>

      <para>Wenn wir nichts anderes ändern, bekommen wir beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/2010">http://0.0.0.0:3000/2010/10/01</uri>
      immer noch das gleiche Ergebnis wie beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>.
      Das ist ja auch logisch. Aber schauen Sie einmal in die Ausgabe von
      rails server:<screen>Started GET "/2010/" for 127.0.0.1 at 2012-05-22 11:27:29 +0200
Processing by PostsController#index as HTML
  <emphasis>Parameters: {"year"=&gt;"2010"}</emphasis>
  Post Load (0.2ms)  SELECT "posts".* FROM "posts" 
  Rendered posts/index.html.erb within layouts/application (5.5ms)
Completed 200 OK in 13ms (Views: 11.3ms | ActiveRecord: 0.2ms)</screen></para>

      <para>Die Route wurde erkannt und dem Hash
      <code><varname>params</varname></code> (in der Ausgabe irreführend als
      <code>Parameters</code> ausgeschrieben) ein Element <code>"year" =&gt;
      "2010"</code> zugewiesen. Ein Aufruf der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/12/24">http://0.0.0.0:3000/2010/12/24</uri>
      ergibt erwartungsgemäss folgende Ausgabe:<screen>Started GET "/2010/12/24" for 127.0.0.1 at 2012-05-22 11:30:49 +0200
Processing by PostsController#index as HTML
  <emphasis>Parameters: {"year"=&gt;"2010", "month"=&gt;"12", "day"=&gt;"24"}</emphasis>
  Post Load (0.2ms)  SELECT "posts".* FROM "posts" 
  Rendered posts/index.html.erb within layouts/application (5.9ms)
Completed 200 OK in 13ms (Views: 11.5ms | ActiveRecord: 0.2ms)</screen></para>

      <para>Bei der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/12/24">http://0.0.0.0:3000/2010/12/24</uri>
      wurden folgende Werte im Hash <varname>params</varname> gespeichert:
      <code>"year"=&gt;"2010", "month"=&gt;"12", "day"=&gt;"24"</code></para>

      <para>Auf <varname>params[]</varname> haben wir im Controller Zugriff
      auf die in der URL definierten Werte. Wir müssen nur noch die
      <methodname>index</methodname> Methode in
      <filename>app/controllers/posts_controller.rb</filename> anpassen, um
      die für das entsprechende Datum, den entsprechenden Monat oder das
      entsprechende Jahr eingetragenen <varname>posts</varname>
      auszugeben:<programlisting>def index
<emphasis>  if params[:day]
    @posts = Post.where(:published_at =&gt; Date.parse("#{params[:day]}.#{params[:month]}.#{params[:year]}"))
  elsif params[:month]
    @posts = Post.where(:published_at =&gt; ( Date.parse("01.#{params[:month]}.#{params[:year]}") .. Date.parse("01.#{params[:month]}.#{params[:year]}").end_of_month ))
  elsif params[:year]
    @posts = Post.where(:published_at =&gt; ( Date.parse("01.01.#{params[:year]}") .. Date.parse("31.12.#{params[:year]}") ))
  else
    @posts = Post.all
  end</emphasis>

  respond_to do |format|
    format.html # index.html.erb
    format.json { render json: @posts }
  end
end</programlisting></para>

      <para>Damit bekommen wir beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/2011/10/01">http://0.0.0.0:3000/2011/10/01</uri>
      alle <varname>posts</varname> des 01.10.2011 angezeigt.<screenshot>
          <info>
            <title>Index-View für den 01.10.2011</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_2011_10_01.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>
    </section>

    <section xml:id="routes_match_contraints">
      <title xml:id="routes_match_contraints.title">Constraints
      (Einschränkungen)</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Constraints</secondary>
      </indexterm>

      <para>In <xref linkend="routes_match_parameter"/> habe ich Ihnen
      gezeigt, wie man Parameter aus der URL auslesen und an den Controller
      weitergeben kann. Leider hat der dort definierte Eintrag in der
      <filename>config/routes.rb</filename> <programlisting>match "/:year(/:month(/:day))" =&gt; "posts#index"</programlisting>einen
      entscheidenen Nachteil: Er überprüft die einzelnen Elemente nicht. Die
      URL <uri
      xlink:href="http://0.0.0.0:3000/ein/beispiel/dafuer">http://0.0.0.0:3000/ein/beispiel/dafuer</uri>
      wird genauso gematcht und führt dann natürlich direkt zu einem
      Fehler:<screenshot>
          <info>
            <title>Fehlermeldung</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/ein_beispiel_dafuer_fehler.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>In der Log-Ausgabe in <filename>log/development.log</filename>
      sehen wir dabei folgenden Eintrag:<programlisting>Started GET "/ein/beispiel/dafuer" for 127.0.0.1 at 2012-05-22 13:20:44 +0200
Processing by PostsController#index as HTML
  Parameters: {"year"=&gt;"ein", "month"=&gt;"beispiel", "day"=&gt;"dafuer"}</programlisting></para>

      <para>Es ist klar, dass <code>Date.parse( "dafuer.beispiel.ein")</code>
      nicht funktionieren kann. Ein Datum besteht nun mal aus Zahlen und nicht
      aus Buchstaben.</para>

      <para>Constraints können mittels Regular Expressions den Inhalt der URL
      besser definieren. In unserem Blog-Fall würde die
      <filename>config/routes.rb</filename> mit Constraints so
      aussehen:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year(/:month(/:day))" =&gt; "posts#index"<emphasis role="bold">, :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{2}/ }</emphasis>
end</programlisting></para>

      <warning>
        <para>Bitte beachten Sie, dass bei den Regular Expressions in einem
        Constraint keine Regex-Anchors wie "^" benutzt werden können.</para>
      </warning>

      <para>Wenn wir mit dieser Konfiguration noch mal die URL aufrufen,
      bekommen wir einen Fehler „No route matches“ von Rails:<screenshot>
          <info>
            <title>Routing Error</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/ein_beispiel_dafuer_no_route_matches.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <section xml:id="advanced_constraints">
        <title xml:id="advanced_constraints.title">Advanced
        Constraints</title>

        <indexterm>
          <primary>Routen</primary>

          <secondary>Advanced Constraints</secondary>
        </indexterm>

        <para>Mit der Route <code>match "/:year(/:month(/:day))" =&gt;
        "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt;
        /\d{2}/, :day =&gt; /\d{2}/ }</code> haben wir zwar die URL
        syntaktisch auf ein Datum überprüft, aber es kann natürlich ein User
        immer noch die URL <uri
        xlink:href="http://0.0.0.0:3000/2011/02/31">http://0.0.0.0:3000/2011/02/31</uri>
        aufrufen. Da es keinen 31. Februar gibt, dürfte es diese Route logisch
        nicht geben. Wir brauchen also eine Möglichkeit, die ein angegebenes
        syntaktisch komplettes Datum darauf überprüft, ob es auch ein
        korrektes Datum nach dem Kalender ist.</para>

        <para>Dazu müssen wir eine eigene Klasse definieren, mit der Objekte
        mit der Methode <methodname>matches?()</methodname> definiert.
        Innerhalb von <methodname>matches?()</methodname> können wir die
        gewünschte eigene Validierung vornehmen um dann mit <code>true</code>
        oder <code>false</code> zu antworten. Bitte erstellen Sie dazu die
        Datei <filename>lib/valid_date_contraint.rb</filename> mit folgendem
        Inhalt:<programlisting>class ValidDateConstraint
  def matches?(request)
    begin
      Date.parse("#{request.params[:day]}.#{request.params[:month]}.#{request.params[:year]}")
      true
    rescue
      false
    end
  end
end</programlisting></para>

        <para>Diese Klasse müssen wir jetzt laden. Bitte erstellen Sie dazu
        die Datei <filename>config/initializers/load_extensions.rb</filename>
        mit diesem Inhalt:<programlisting>require 'valid_date_constraint'</programlisting></para>

        <para>Jetzt spliten wir die Datums-Route in der
        <filename>config/routes.rb</filename> auf:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year/:month/:day" =&gt; "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{2}/ }, :constraints =&gt; ValidDateConstraint.new

  match "/:year(/:month)" =&gt; "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/ }
end
</programlisting></para>

        <para>Das erste <methodname>match</methodname> reagiert auf alle URLs
        mit drei Parametern die syntaktisch den gegebenen Contraints
        entsprechen. Zusätzlich wird noch das Datum überprüft. Erst wenn das
        Datum an sich valide ist, wird diese Route benutzt. Sie wird also
        nicht bei der URL <uri
        xlink:href="http://0.0.0.0:3000/2011/02/31">http://0.0.0.0:3000/2011/02/31</uri>
        aufgerufen. Hingegen würde die URL <uri
        xlink:href="http://0.0.0.0:3000/2011/10/01">http://0.0.0.0:3000/2011/10/01</uri>
        funktionieren.</para>
      </section>
    </section>

    <section xml:id="routes_match_redirects">
      <title xml:id="routes_match_redirects.title">Redirects</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Redirect (Umleitung)</secondary>
      </indexterm>

      <indexterm>
        <primary>Redirect</primary>

        <secondary>per Routen</secondary>
      </indexterm>

      <para>Ich kann mit einem <code>match</code> auch auf eine andere Seite
      umleiten (<foreignphrase xml:lang="en">redirect</foreignphrase>). Wenn
      ich die Eingabe der unsinnigen URL <uri
      xlink:href="http://0.0.0.0:3000/2010/02/31">http://0.0.0.0:3000/2010/02/31</uri>
      auf /2010/02 redirecten will, dann geht das
      folgendermaßen:<programlisting>match "/:year/02/31" =&gt; redirect("/%{year}/02")</programlisting></para>

      <para>Damit könnte man auch die Eingabe eines einstelligen Monats auf
      einen zweistelligen Monat umleiten:<programlisting>match "/:year/:month/:day" =&gt; redirect("/%{year}/0%{month}/%{day}"), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/, :day =&gt; /\d{2}/ }
</programlisting></para>

      <para>Das Gleiche ginge natürlich auch für einen einstelligen Tag. Unter
      Berücksichtigung aller Kombinationen sähe unsere
      <filename>config/routes.rb</filename> dann so aus:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year/:month/:day" =&gt; redirect("/%{year}/0%{month}/%{day}" ), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/, :day =&gt; /\d{2}/ }
  match "/:year/:month/:day" =&gt; redirect("/%{year}/0%{month}/0%{day}"), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/, :day =&gt; /\d{1}/ }
  match "/:year/:month/:day" =&gt; redirect("/%{year}/%{month}/0%{day}" ), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{1}/ }

  match "/:year/:month" =&gt; redirect("/%{year}/0%{month}"), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/ }

  match "/:year(/:month(/:day))" =&gt; "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{2}/ }
end</programlisting></para>

      <para>Mit diesem Redirect-Regelwerk wäre sichergestellt, dass ein
      Benutzer der Seite auch einstellige Monate und Tage eingeben kann und
      trotzdem an der richtigen Stelle landet bzw. zum richtigen Format
      umgeleitet wird.</para>

      <note>
        <para>Redirects in der <filename>config/routes.rb</filename> sind per
        Default Redirects mit dem Code 301 ("Moved Permanetly").</para>
      </note>
    </section>
  </section>

  <section xml:id="routes_resources">
    <title xml:id="routes_resources.title">resources</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>resources</secondary>
    </indexterm>

    <para><code>resources</code> liefert Routen für eine RESTful Resource.
    Probieren wir das anhand der Mini-Blog Applikation aus:<screen>MacBook:~ xyz$ <command>rails new blog</command>
[...]
MacBook:~ xyz$ <command>cd blog</command> 
MacBook:blog xyz$ <command>rails generate scaffold Post subject content published_at:date</command>
[...]
MacBook:blog xyz$ <command>rake db:migrate</command>
[...]
MacBook:blog xyz$</screen></para>

    <para>Der scaffold Generator legt automatisch eine <code>resources</code>
    Route in der <filename>config/routes.rb</filename> an:<programlisting>Blog::Application.routes.draw do
  resources :posts
end</programlisting></para>

    <note>
      <para>Neue Routen werden von rails generate Skripten immer am Anfang von
      <filename>config/routes.rb</filename> hinzugefügt.</para>
    </note>

    <para>Die daraus resultierenden Routen:<screen>MacBook:blog xyz$ <command>rake routes</command>
    posts GET    /posts(.:format)          posts#index
          POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post GET    /posts/:id(.:format)      posts#show
          PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
MacBook:blog xyz$</screen></para>

    <para>Diese RESTful Routen sind Ihnen bereits aus <xref
    linkend="scaffolding"/> bekannt. Sie werden benötigt, um die Datensätze
    anzuzeigen und zu verändern.</para>

    <section>
      <title>Bestimmte Routen mit :only oder :except auswählen</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>resources</secondary>

        <tertiary>only</tertiary>
      </indexterm>

      <indexterm>
        <primary>Routen</primary>

        <secondary>resources</secondary>

        <tertiary>except</tertiary>
      </indexterm>

      <para>Wenn Sie nur bestimmte Routen aus dem fertigen Satz von RESTful
      Routen benutzen wollen, so können Sie diese mit <code>:only</code> oder
      <code>:except</code> einschränken.</para>

      <para>Folgende <filename>conf/routes.rb</filename> definiert nur die
      Routen für <code>index</code> und <code>show</code>:<programlisting>Blog::Application.routes.draw do

  <emphasis>resources :posts, :only =&gt; [:index, :show]</emphasis>

end</programlisting></para>

      <para>Mit <command>rake routes</command> können wir das Ergebnis
      überprüfen:<screen>MacBook:blog xyz$ <command>rake routes</command>
posts GET /posts(.:format)     posts#index
 post GET /posts/:id(.:format) posts#show
MacBook:blog xyz$</screen></para>

      <para><code>except</code> arbeitet genau anders rum:<programlisting>Blog::Application.routes.draw do

  <emphasis>resources :posts, :except =&gt; [:index, :show]</emphasis>

end</programlisting></para>

      <para>Jetzt sind alle Routen bis auf <code>index</code> und
      <code>show</code> möglich:<screen>MacBook:blog xyz$ <command>rake routes</command>
    posts POST   /posts(.:format)          posts#create
 new_post GET    /posts/new(.:format)      posts#new
edit_post GET    /posts/:id/edit(.:format) posts#edit
     post PUT    /posts/:id(.:format)      posts#update
          DELETE /posts/:id(.:format)      posts#destroy
MacBook:blog xyz$</screen></para>

      <warning>
        <para>Achten Sie bei der Verwendung von only und except bitte daran
        auch die vom scaffold Generator generierten Views anzupassen. Dort
        wird z.B. auf der index Seite mit <code>&lt;%= link_to 'New Post',
        new_post_path %&gt;</code> auf den new View verlinkt, der im obigen
        only-Beispiel dann aber gar nicht mehr existiert.</para>
      </warning>
    </section>

    <section xml:id="routes_nested_resources">
      <title xml:id="routes_nested_resources.title">Nested Resources</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>resources</secondary>

        <tertiary>nested</tertiary>
      </indexterm>

      <indexterm>
        <primary>Nested Routes</primary>

        <see>Routen</see>
      </indexterm>

      <para>Verschachtelte Ressourcen (nested resources) bezieht sich auf
      Routen von Ressourcen, die mit einer
      <methodname>has_many</methodname>-Verknüpfung (siehe <xref
      linkend="activerecord_has_many"/>) arbeiten. Diese lassen sich eindeutig
      über Routen ansprechen. Legen wir eine zweite Ressource
      <classname>comment</classname> an:<screen>MacBook:blog xyz$ <command>rails generate scaffold comment post_id:integer content</command>
[...]
MacBook:blog xyz$ <command>rake db:migrate</command>
[...]
MacBook:blog xyz$</screen></para>

      <para>Jetzt verküpfen wir beide Ressourcen miteinander. In der Datei
      <filename>app/models/post.rb</filename> fügen wir ein
      <methodname>has_many</methodname> hinzu:<programlisting>class Post &lt; ActiveRecord::Base
  attr_accessible :content, :published_at, :subject

  has_many :comments
end
</programlisting></para>

      <para>Und in der Datei <filename>app/models/comment.rb</filename> das
      Gegenstück <methodname>belongs_to</methodname>:<programlisting>class Comment &lt; ActiveRecord::Base
  attr_accessible :content, :post_id

  belongs_to :post
end
</programlisting></para>

      <para>Die vom scaffold Generator erstellten Routen sehen so aus:<screen>MacBook:blog xyz$ <command>rake routes</command>
    comments GET    /comments(.:format)          comments#index
             POST   /comments(.:format)          comments#create
 new_comment GET    /comments/new(.:format)      comments#new
edit_comment GET    /comments/:id/edit(.:format) comments#edit
     comment GET    /comments/:id(.:format)      comments#show
             PUT    /comments/:id(.:format)      comments#update
             DELETE /comments/:id(.:format)      comments#destroy
       posts GET    /posts(.:format)             posts#index
             POST   /posts(.:format)             posts#create
    new_post GET    /posts/new(.:format)         posts#new
   edit_post GET    /posts/:id/edit(.:format)    posts#edit
        post GET    /posts/:id(.:format)         posts#show
             PUT    /posts/:id(.:format)         posts#update
             DELETE /posts/:id(.:format)         posts#destroy
MacBook:blog xyz$</screen></para>

      <para>Wir können also mit <uri>/posts/1</uri> das erste Post und mit
      <uri>/comments</uri> alle Comments abfragen. Mit Hilfe von Nesting
      können wir mit <uri>/posts/1/</uri>comments alle Comments des Posts mit
      der ID 1 abfragen. Dazu müssen wir die
      <filename>config/routes.rb</filename> abändern:<programlisting>Blog::Application.routes.draw do

<emphasis>  resources :posts do
    resources :comments
  end</emphasis>

end
</programlisting></para>

      <para>Damit bekommen wir dann die gewünschten Routen:<screen>MacBook:blog xyz$ <command>rake routes</command>
    post_comments GET    /posts/:post_id/comments(.:format)          comments#index
                  POST   /posts/:post_id/comments(.:format)          comments#create
 new_post_comment GET    /posts/:post_id/comments/new(.:format)      comments#new
edit_post_comment GET    /posts/:post_id/comments/:id/edit(.:format) comments#edit
     post_comment GET    /posts/:post_id/comments/:id(.:format)      comments#show
                  PUT    /posts/:post_id/comments/:id(.:format)      comments#update
                  DELETE /posts/:post_id/comments/:id(.:format)      comments#destroy
            posts GET    /posts(.:format)                            posts#index
                  POST   /posts(.:format)                            posts#create
         new_post GET    /posts/new(.:format)                        posts#new
        edit_post GET    /posts/:id/edit(.:format)                   posts#edit
             post GET    /posts/:id(.:format)                        posts#show
                  PUT    /posts/:id(.:format)                        posts#update
                  DELETE /posts/:id(.:format)                        posts#destroy
MacBook:blog xyz$ </screen></para>

      <para>Allerdings müssen wir in
      <filename>app/controllers/comments_controller.rb</filename> noch ein
      paar Änderungen vornehmen. Damit stellen wir sicher, das immer nur die
      <varname>Comments</varname> des angegebenen <varname>Posts</varname>
      angezeigt oder verändert werden (um die Übersicht zu verbessern, habe
      ich den JSON-Teil rausgelöscht):<programlisting>class CommentsController &lt; ApplicationController
  before_filter :find_post

  def index
    @comments = @post.comments
  end

  def show
    @comment = @post.comments.find(params[:id])
  end

  def new
    @comment = @post.comments.build
  end

  def edit
    @comment = @post.comments.find(params[:id])
  end

  def create
    @comment = @post.comments.build(params[:comment])

    if @comment.save
      redirect_to [@post, @comment], notice: 'Comment was successfully created.'
    else
      render action: "new"
    end
  end

  def update
    @comment = @post.comments.find(params[:id])

    if @comment.update_attributes(params[:comment])
      redirect_to [@post, @comment], notice: 'Comment was successfully updated.'
    else
      render action: "edit"
    end
  end

  def destroy
    @comment = @post.comments.find(params[:id])
    @comment.destroy

    redirect_to post_comments_path(@post)
  end

  private
  def find_post
    @post = Post.find(params[:post_id])
  end
end
</programlisting></para>

      <para>Leider ist das nur die halbe Miete, da in den Views noch auf die
      alten Routen verwiesen wird. Wir müssen also jeden View entsprechend der
      Nested Route anpassen.</para>

      <para><filename>app/views/comments/_form.html.erb</filename></para>

      <para>Bitte beachten Sie hier, das der <code>form_for</code> Aufruf auf
      <code>form_for([@post, @comment])</code> geändert werden muss.</para>

      <para><programlisting>&lt;%= form_for([@post, @comment]) do |f| %&gt;
  &lt;% if @comment.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@comment.errors.count, "error") %&gt; prohibited this comment from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @comment.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= f.label :content %&gt;&lt;br /&gt;
    &lt;%= f.text_field :content %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</programlisting></para>

      <para><filename>app/views/comments/edit.html.erb</filename><programlisting>&lt;h1&gt;Editing comment&lt;/h1&gt;

&lt;%= render 'form' %&gt;
</programlisting></para>

      <para><filename>app/views/comments/index.html.erb</filename><programlisting>&lt;h1&gt;Listing comments&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Post&lt;/th&gt;
    &lt;th&gt;Content&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @comments.each do |comment| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= comment.post_id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= comment.content %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', [@post, comment] %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_post_comment_path(@post, comment) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', [@post, comment], confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Comment', new_post_comment_path(@post) %&gt;
</programlisting></para>

      <para><filename>app/views/comments/new.html.erb</filename><programlisting>&lt;h1&gt;New comment&lt;/h1&gt;

&lt;%= render 'form' %&gt;</programlisting></para>

      <para><filename>app/views/comments/show.html.erb</filename><programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Post:&lt;/b&gt;
  &lt;%= @comment.post_id %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Content:&lt;/b&gt;
  &lt;%= @comment.content %&gt;
&lt;/p&gt;
</programlisting></para>

      <para>Bitte spielen Sie einmal mit den unter rake routes aufgeführten
      URLs rum. So können Sie jetzt mit <uri>/posts/new</uri> einen neuen Post
      und mit <uri>/posts/:post_id/comments/new</uri> einen neuen Comment zu
      diesem Post generieren.</para>

      <section xml:id="bemerkungen_nested_resources">
        <title xml:id="bemerkungen_nested_resources.title">Bemerkungen zu
        Nested Resources</title>

        <para>Im allgemeinen sollte man nie tiefer als eine Ebene "nesten" und
        Nested Resources sollten sich "natürlich" anfühlen. Sie werden mit der
        Zeit ein Gefühl dafür bekommen. Meiner Meinung nach ist das wichtigste
        an RESTful Routen, das sie sich logisch anfühlen müssen. Wenn Sie mit
        einem befreundeten Rails-Programmierer telefonieren und ihm sagen "Ich
        habe da eine Resource Post und eine Resource Comment.", dann sollte
        beiden Seiten direkt klar sein, wie man dieser Resourcen per REST
        anspricht und wie man sie verschachteln kann.</para>
      </section>
    </section>
  </section>

  <section xml:id="routes_weitere_informationen">
    <title xml:id="routes_weitere_informationen.title">Weitere Informationen
    zum Thema Routes</title>

    <para>Das Thema Routes ist weit komplexer als hier vorgestellt. So kann
    man z. B. auch die HTTP-Methoden mit einbeziehen. Folgende Webseiten geben
    Ihnen einen tieferen Einblick in das Thema Routes:<itemizedlist>
        <listitem>
          <para><link
          xlink:href="http://guides.rubyonrails.org/routing.html">http://guides.rubyonrails.org/routing.html</link></para>
        </listitem>

        <listitem>
          <para><link
          xlink:href="http://railscasts.com/episodes/203-routing-in-rails-3">http://railscasts.com/episodes/203-routing-in-rails-3</link></para>
        </listitem>

        <listitem>
          <para><link
          xlink:href="http://yehudakatz.com/2009/12/26/the-rails-3-router-rack-it-up/">http://yehudakatz.com/2009/12/26/the-rails-3-router-rack-it-up/</link></para>
        </listitem>

        <listitem>
          <para><link
          xlink:href="http://rizwanreza.com/2009/12/20/revamped-routes-in-rails-3">http://rizwanreza.com/2009/12/20/revamped-routes-in-rails-3</link></para>
        </listitem>
      </itemizedlist></para>
  </section>
</chapter>
