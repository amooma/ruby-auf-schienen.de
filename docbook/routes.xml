<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="routes" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="routes.title">Routes</title>

  <section xml:id="routes_einstieg">
    <title xml:id="routes_einstieg.title">Einstieg</title>

    <para>In <xref linkend="dynamische_webseiten" /> und <xref
    linkend="scaffolding" /> hatten wir schon mal kurz Kontakt mit Routes (zu
    Deutsch Routen). In diesem Kapitel werden wir einen intensiveren Blick in
    die Routing-Möglichkeit werfen. Mit Routen werden abgerufene URLs zu
    bestimmten Code in der Rails Applikation geleitet. Weiterhin können damit
    Variablen definiert werden, die aus der Applikation aufgerufen
    werden.</para>

    <para>Bauen wir uns mal eine Test-Rails-Applikation zum
    Experimentieren:<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new webshop</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd webshop</command>
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake db:migrate</command>
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Mit rake routes können wir uns die Routen eines Projektes anzeigen
    lassen. Probieren wir das mal im frischen Projekt aus:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake routes</command>
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Nichts. Es sind in einem neuen Rails-Projekt keine Routen
    eingetragen.</para>

    <important>
      <para>Auch bei einem neuen Rails-Projekt können Sie nach dem Start des
      Rails-Servers mit <command>rails server</command> auf <uri
      xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri> zugreifen.
      Wie kann dies ohne eine eingetragene Route funktionieren? Die Lösung
      liegt im Verzeichnis <filename>/public</filename>. Dort liegt die Datei
      <filename>public/index.html</filename> und immer wenn im Verzeichnis
      <filename>/public</filename> eine Datei liegt, die zur angegebenen URL
      passt, bekommt diese eine höhere Priorität als eine Rails-Route. Das
      gleiche gilt auch für den Fall, das es keine Rails-Route gibt.</para>
    </important>

    <para>Bei einem neuen Rails-Projekt ist die
    <filename>config/routes.rb</filename> Datei mit vielen auskommentieren
    Beispielen bestückt. Für den Verlauf dieses Kapitels tun wir so, als wenn
    diese Beispiele nicht drin wären und zeigen immer nur die neu
    eingetragenen Routen an (alles andere wäre eine grobe Verschwendung von
    Druckerschwärze).</para>
  </section>

  <section xml:id="routes_get">
    <title xml:id="routes_get.title">get</title>

    <para>Erstellen wir mal einen Controller mit drei einfachen
    Seiten:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rails generate controller Home index ping pong</command>
      create  app/controllers/home_controller.rb
       route  get "home/pong"
       route  get "home/ping"
       route  get "home/index"
      invoke  erb
      create    app/views/home
      create    app/views/home/index.html.erb
      create    app/views/home/ping.html.erb
      create    app/views/home/pong.html.erb
      invoke  test_unit
      create    test/functional/home_controller_test.rb
      invoke  helper
      create    app/helpers/home_helper.rb
      invoke    test_unit
      create      test/unit/helpers/home_helper_test.rb
      invoke  assets
      create    app/assets/javascripts/home.js.coffee
      create    app/assets/stylesheets/home.css.scss
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Jetzt gibt <command>rake route</command> für diese drei Seiten eine
    Route aus:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake routes</command>
home_index GET /home/index(.:format) {:controller=&gt;"home", :action=&gt;"index"}
 home_ping GET /home/ping(.:format)  {:controller=&gt;"home", :action=&gt;"ping"}
 home_pong GET /home/pong(.:format)  {:controller=&gt;"home", :action=&gt;"pong"}
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Sie sind jetzt nach dem Starten des Rails-Servers mit <command>rails
    server</command> unter<itemizedlist>
        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/index">http://0.0.0.0:300/home/index</uri></para>

          <para>für <code>home_index GET /home/index(.:format)
          {:controller=&gt;"home", :action=&gt;"index"}</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/ping">http://0.0.0.0:300/home/ping</uri></para>

          <para>für <code>home_ping GET /home/ping(.:format)
          {:controller=&gt;"home", :action=&gt;"ping"}</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/pong">http://0.0.0.0:300/home/pong</uri></para>

          <para>für <code>home_pong GET /home/pong(.:format)
          {:controller=&gt;"home", :action=&gt;"pong"}</code></para>
        </listitem>
      </itemizedlist></para>

    <para>Rails sagt uns mit der Ausgabe <code>{:controller=&gt;"home",
    :action=&gt;"index"}</code> das die Route <uri>/home/index</uri> in den
    Controller <classname>home</classname> und dort zur Action/Methode
    <methodname>index</methodname> geht. Definiert werden diese Routen in der
    Datei <filename>config/routes.rb</filename>. <command>rails generate
    controller Home index ping pong</command> hat dort automatisch folgende
    Zeilen eingefügt:<programlisting>  get "home/index"

  get "home/ping"

  get "home/pong"
</programlisting></para>
  </section>

  <section xlink:href="routes_match">
    <title xml:id="routes_match.title">match</title>

    <para>Wenn wir zusätzlich zur URL <uri>/home/ping</uri> noch mit
    <uri>/home/ping-ping</uri> auf die gleiche Action im gleichen Controller
    zugreifen, so müssen wir die Datei <filename>config/routes.rb</filename>
    wie folgt verändern:<programlisting>Webshop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"
  
  <emphasis>match 'home/ping-ping' =&gt; 'home#ping'</emphasis>
end</programlisting></para>

    <para>Damit stehen uns folgende Routen zur Verfügung:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake routes</command>
home_index GET /home/index(.:format)     {:controller=&gt;"home", :action=&gt;"index"}
 home_ping GET /home/ping(.:format)      {:controller=&gt;"home", :action=&gt;"ping"}
 home_pong GET /home/pong(.:format)      {:controller=&gt;"home", :action=&gt;"pong"}
               /home/ping-ping(.:format) {:controller=&gt;"home", :action=&gt;"ping"}
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Wenn Sie der Route <filename>/home/ping-ping</filename> einen Namen
    geben wollen, so können Sie dies mit der <code>:as =&gt; "name"</code>
    Einstellung in der <filename>config/routes.rb</filename>
    realisieren:<programlisting>Webshop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"
  
  <emphasis>match 'home/ping-ping' =&gt; 'home#ping', :as =&gt; "ping_ping"
</emphasis>end</programlisting></para>

    <para>Jetzt stehen ihnen im System folgende Routen-Namen zur
    Verfügung:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake routes</command>
home_index GET /home/index(.:format)     {:controller=&gt;"home", :action=&gt;"index"}
 home_ping GET /home/ping(.:format)      {:controller=&gt;"home", :action=&gt;"ping"}
 home_pong GET /home/pong(.:format)      {:controller=&gt;"home", :action=&gt;"pong"}
 ping_ping     /home/ping-ping(.:format) {:controller=&gt;"home", :action=&gt;"ping"}
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Sie sehen dabei, das eine URL ein Minuszeichen enthalten darf, aber
    der Routen-Name nicht (ein Unterstrich geht aber).</para>

    <section xml:id="routes_match_parameter">
      <title xml:id="routes_match_parameter.title">Parameter</title>

      <para>Match kann nicht nur fixe Routen zuordnen, sondern auch noch
      Parameter übergeben. Ein typisches Beispiel dafür wären Angaben zu einem
      Datum. Erstellen wir dazu mal eine Mini-Blog-Applikation:<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new blog</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd blog</command>
Stefan-Wintermeyers-MacBook-Air:blog stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog stefan$ <command>rails generate scaffold Post subject:string content:text posted_at:date</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog stefan$ <command>rake db:migrate</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog stefan$</screen></para>

      <para>Als Beispieldaten in der <filename>db/seeds.rb</filename> nehmen
      wir:<programlisting>Post.create(:subject =&gt; 'Ein Test', :posted_at =&gt; '01.10.2010')
Post.create(:subject =&gt; 'Noch ein Test', :posted_at =&gt; '01.10.2010')
Post.create(:subject =&gt; 'Und wieder ein Test', :posted_at =&gt; '02.10.2010')
Post.create(:subject =&gt; 'Letzter Test', :posted_at =&gt; '01.11.2010')
Post.create(:subject =&gt; 'Allerletzter Test', :posted_at =&gt; '01.11.2011')</programlisting></para>

      <para>Mit <command>rake db:seed</command> spielen wir diese Daten in die
      Datenbank:<screen>Stefan-Wintermeyers-MacBook-Air:blog stefan$ <command>rake db:seed</command>
Stefan-Wintermeyers-MacBook-Air:blog stefan$</screen></para>

      <para>Wenn wir jetzt mit <command>rails server</command> den Rails
      Server starten und mit dem Browser auf die Seite <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>
      surfen, bekommen wir folgende Anzeige:<screenshot>
          <info>
            <title>Index-Ansicht aller Posts</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_index.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Für ein solches Blog wäre es natürlich sehr praktisch, wenn man
      mit der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      alle Einträge für das Jahr 2010 und mit <uri
      xlink:href="http://0.0.0.0:3000/2010/10/01">http://0.0.0.0:3000/2010/10/01</uri>
      alle Einträge für den 01.10.2010 anzeigen könnte. Das erreichen wir mit
      optionalen Parametern beim match-Eintrag. Bitte tragen Sie folgende
      Konfiguration in die
      <filename>config/routes.rb</filename>:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year(/:month(/:day))" =&gt; "posts#index"
end</programlisting></para>

      <para>Die Klammern stehen für optionale Parameter. In diesem Fall muss
      auf jeden Fall das Jahr, aber nicht unbedingt der Monat oder der Tag
      angegeben werden.</para>

      <para>Wenn wir nichts anderes ändern, bekommen wir beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/2010">http://0.0.0.0:3000/2010</uri>
      immmer noch das gleiche Ergebnis wie vom Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>.
      Ist ja auch logisch. Erweitern wir aber mal die View-Datei
      <filename>app/views/posts/index.html.erb</filename> mit einem
      <code>&lt;%= debug params %&gt;</code> Aufruf ganz am
      Anfang:<programlisting><emphasis>&lt;%= debug params %&gt;</emphasis>

&lt;h1&gt;Listing posts&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Subject&lt;/th&gt;
    &lt;th&gt;Content&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @posts.each do |post| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= post.subject %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= post.content %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', post %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_post_path(post) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', post, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Post', new_post_path %&gt;
</programlisting></para>

      <para>Und jetzt rufen wir mit dem Browser noch mal <uri
      xlink:href="http://0.0.0.0:3000/2010">http://0.0.0.0:3000/2010</uri>
      auf:<screenshot>
          <info>
            <title>Index-View mit &lt;%= debug params %&gt;</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/2010_debug_index.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>A-ha! Es wurde von der Route der Parameter
      <varname>params[:year]</varname> mit dem Wert <code>2010</code> gesetzt.
      Sehr praktisch, den das können wir im
      <filename>app/controllers/posts_controller.rb</filename> Controller in
      der Index-Methode wie folgt einbauen:<programlisting>def index
  @posts = Post.all
  
<emphasis>  if params[:year]
    @posts = Post.where(:posted_at =&gt; (Date.parse("01.01.#{params[:year]}")..Date.parse("31.12.#{params[:year]}")))
  end</emphasis>

  respond_to do |format|
    format.html # index.html.erb
    format.json { render json: @posts }
  end
end
</programlisting></para>

      <para>Damit bekommen wir das gewünschte Ergebnis (nur die 4 Postings aus
      dem Jahr 2010):<screenshot>
          <info>
            <title>Posts aus dem Jahr 2010</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/2010_posts_index.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Die Anpassung in der Datei
      <filename>app/controllers/posts_controller.rb</filename> für das
      Anzeigen von Monaten und Tagen, ist jetzt nur noch eine
      Fleißarbeit:<programlisting>def index
  @posts = Post.all

<emphasis>  if params[:year] and params[:month] and params[:day]
    @posts = Post.where(:posted_at =&gt; Date.parse("#{params[:day]}.#{params[:month]}.#{params[:year]}"))
  elsif params[:year] and params[:month]
    @posts = Post.where(:posted_at =&gt; (Date.parse("01.#{params[:month]}.#{params[:year]}")..Date.parse("01.#{params[:month]}.#{params[:year]}").end_of_month))
  elsif params[:year]
    @posts = Post.where(:posted_at =&gt; (Date.parse("01.01.#{params[:year]}")..Date.parse("31.12.#{params[:year]}")))
  end</emphasis>

  respond_to do |format|
    format.html # index.html.erb
    format.json { render json: @posts }
  end
end</programlisting></para>

      <para>Damit können wir jetzt Jahre, Monate oder auch ganz gezielt
      einzelne Tage anzeigen:<screenshot>
          <info>
            <title>Ansicht eines Tages</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/2010-10-01_posts_index.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>more to come</para>
    </section>
  </section>

  <section xml:id="routes_root">
    <title xml:id="routes_root.title">root :to =&gt; 'welcome#index'</title>

    <para>In der Datei finden Sie folgenden Eintrag:<programlisting>  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; 'welcome#index'
</programlisting></para>

    <para>Wenn Sie dort die letzte Zeile auskommentieren, können Sie damit
    Ihre <uri xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri>
    definieren. Legen wir die mal auf
    <methodname>home#index</methodname>:<programlisting>Webshop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"
  
  match 'home/ping-ping' =&gt; 'home#ping', :as =&gt; "ping_ping"
  
  <emphasis>root :to =&gt; 'home#index'</emphasis>
end</programlisting></para>

    <para>Unsere neuen Routen:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake routes</command>
home_index GET /home/index(.:format)     {:controller=&gt;"home", :action=&gt;"index"}
 home_ping GET /home/ping(.:format)      {:controller=&gt;"home", :action=&gt;"ping"}
 home_pong GET /home/pong(.:format)      {:controller=&gt;"home", :action=&gt;"pong"}
 ping_ping     /home/ping-ping(.:format) {:controller=&gt;"home", :action=&gt;"ping"}
      root     /                         {:controller=&gt;"home", :action=&gt;"index"}
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <important>
      <para>Nach dem setzen der <code>root</code> Route nicht das Löschen der
      Datei <filename>/public/index.html</filename> vergessen!<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rm public/index.html</command> 
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>
    </important>
  </section>

  <section xml:id="routes_resources">
    <title xml:id="routes_resources.title">resources</title>

    <para>Bauen wir uns für <code>resources</code> eine neue Rails-Applikation
    zum Experimentieren:<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new phonebook</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd phonebook</command>
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ </screen></para>

    <para>Beim Verwenden von Scaffold werden automatisch Routen für die neu
    erschaffenen Resourcen erstellt. Legen wir mal eine Resource an:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails generate scaffold person firstname:string lastname:string</command>
      invoke  active_record
      create    db/migrate/20110531175742_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/unit/person_test.rb
      create      test/fixtures/people.yml
       route  resources :people
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake db:migrate</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

    <para>Die Datei <filename>config/routes.rb</filename> sieht damit so
    aus:<programlisting>Webshop::Application.routes.draw do
  <emphasis>resources :people</emphasis>
end</programlisting></para>

    <note>
      <para>Neue Routen werden von rails generate Skripten immer am Anfang von
      <filename>config/routes.rb</filename> hinzugefügt.</para>
    </note>

    <para>Die daraus resultierenden Routen:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake routes</command>
     people GET    /people(.:format)          {:action=&gt;"index", :controller=&gt;"people"}
            POST   /people(.:format)          {:action=&gt;"create", :controller=&gt;"people"}
 new_person GET    /people/new(.:format)      {:action=&gt;"new", :controller=&gt;"people"}
edit_person GET    /people/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"people"}
     person GET    /people/:id(.:format)      {:action=&gt;"show", :controller=&gt;"people"}
            PUT    /people/:id(.:format)      {:action=&gt;"update", :controller=&gt;"people"}
            DELETE /people/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"people"}
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Diese RESTful Routen sind Ihnen bereits aus <xref
    linkend="scaffolding" /> bekannt. Sie werden benötigt, um die Datensätze
    anzuzeigen und zu verändern.</para>

    <section xml:id="routes_nested_resources">
      <title xml:id="routes_nested_resources.title">Nested Resources</title>

      <para>Nested Resources bezieht sich auf Routen von Resourcen die mit
      einer <methodname>has_many</methodname> Verknüpfung (siehe <xref
      linkend="activerecord_has_many" />) arbeiten. Diese lassen sich
      eindeutig über Routen ansprechen. Legen wir eine zweite Resource
      <classname>phone</classname> an:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails generate scaffold phone person_id:integer phone_number:string</command>
      invoke  active_record
      create    db/migrate/20110531180003_create_phones.rb
      create    app/models/phone.rb
      invoke    test_unit
      create      test/unit/phone_test.rb
      create      test/fixtures/phones.yml
       route  resources :phones
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake db:migrate</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ </screen></para>

      <para>Jetzt verküpfen wir beide Resourcen miteinander. In der Datei
      <filename>app/models/person.rb</filename> fügen wir ein
      <methodname>has_many</methodname> hinzu:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phones
end</programlisting></para>

      <para>Und in der Datei <filename>app/models/phone.rb</filename> das
      <methodname>belongs_to</methodname> Gegenstück:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :person
end
</programlisting></para>

      <para>Jetzt füllen wir die <filename>db/seeds.rb</filename> Datei (siehe
      <xref linkend="seed_rb" />) noch mit ein paar
      Beispieldatensätzen:<programlisting>Person.create(:lastname =&gt; 'Meier').phones.create([{:phone_number =&gt; '030 1234567'}, {:phone_number =&gt; '0171 1234567'}])
Person.create(:lastname =&gt; 'Stein').phones.create(:phone_number =&gt; '040 1234567')
Person.create(:lastname =&gt; 'Oberhuber')</programlisting></para>

      <para>Die spielen wir mit <command>rake db:seed</command> ein:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake db:seed</command>
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

      <para>Schauen wir uns das kurz in der Console an:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails console</command>
Loading development environment (Rails 3.1.0.rc1)
ruby-1.9.2-p180 :001 &gt; <command>Person.first</command>
  Person Load (0.1ms)  SELECT "people".* FROM "people" LIMIT 1
 =&gt; #&lt;Person id: 1, firstname: nil, lastname: "Meier", created_at: "2011-05-31 18:03:07", updated_at: "2011-05-31 18:03:07"&gt; 
ruby-1.9.2-p180 :002 &gt; <command>Person.first.phones</command>
  Person Load (0.3ms)  SELECT "people".* FROM "people" LIMIT 1
  Phone Load (0.2ms)  SELECT "phones".* FROM "phones" WHERE "phones"."person_id" = 1
 =&gt; [#&lt;Phone id: 1, person_id: 1, phone_number: "030 1234567", created_at: "2011-05-31 18:03:07", updated_at: "2011-05-31 18:03:07"&gt;, #&lt;Phone id: 2, person_id: 1, phone_number: "0171 1234567", created_at: "2011-05-31 18:03:07", updated_at: "2011-05-31 18:03:07"&gt;] 
ruby-1.9.2-p180 :003 &gt; <command>exit</command>
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

      <para>Wenn wir den Datensatz von <methodname>Person.first</methodname>
      im Browser anschauen wollen, so müssen wir mit <command>rails
      server</command> den Server starten und die URL <uri
      xlink:href="http://0.0.0.0:3000/people/1">http://0.0.0.0:3000/people/1</uri>
      aufrufen:<screenshot>
          <info>
            <title>http://0.0.0.0:3000/people/1</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/people_show_1_einfach.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Wäre es nicht schön, wenn wir die Telefonnummern der
      <methodname>Person.first</methodname> mit der URL <uri
      xlink:href="http://0.0.0.0:3000/people/1/phones">http://0.0.0.0:3000/people/1/phones</uri>
      aufrufen könnten? Genau das können wir mit Nested Resources realisieren!
      Bitte ändern Sie Ihre <filename>config/routes.rb</filename> wie folgt
      ab:<programlisting>Webshop::Application.routes.draw do
<emphasis>  resources :people do
    resources :phones
  end</emphasis>

  <emphasis>resources :phones</emphasis>
end</programlisting></para>

      <para>Und jetzt noch die <methodname>index</methodname> Methode in der
      <filename>app/controllers/phones_controller.rb</filename>
      ändern:<programlisting>  def index
<emphasis>    if params[:person_id]
      @person = Person.find(params[:person_id])
      @phones = @person.phones
    else 
      @phones = Phone.all    
    end</emphasis>
    
    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @phones }
    end
  end
</programlisting></para>

      <para>Jetzt noch den Rails-Server mit <keycap>CTRL-C</keycap> stoppen
      und mit <command>rails server</command> wieder neu starten und mit dem
      Browser <uri
      xlink:href="http://0.0.0.0:3000/people/1/phones">http://0.0.0.0:3000/people/1/phones</uri>
      aufrufen:<screenshot>
          <info>
            <title>http://0.0.0.0:3000/people/1/phones</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/people_1_phones.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Durch die nested Route wurde der Parameter
      <varname>params[:person_id]</varname> an den Controller gegeben und wir
      konnten im Controller gezielt die <classname>Phones</classname> für
      diese <classname>Person</classname> raussuchen. Falls dieser Parameter
      nicht existiert, dann wurde die URL <uri
      xlink:href="http://0.0.0.0:3000/phones">http://0.0.0.0:3000/phones</uri>
      aufgerufen und es werden alle Phones angezeigt.</para>

      <para>Bis jetzt haben wir in der <filename>config/routes.rb</filename>
      zwei Einträge für <code>phones</code>. Einmal als Nested Resource
      innerhalb der <code>people</code> Resouce und einmal als eigenständige
      Resource. <command>rake routes</command> zeigt beide Varianten:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake routes</command>
    person_phones GET    /people/:person_id/phones(.:format)          {:action=&gt;"index", :controller=&gt;"phones"}
                  POST   /people/:person_id/phones(.:format)          {:action=&gt;"create", :controller=&gt;"phones"}
 new_person_phone GET    /people/:person_id/phones/new(.:format)      {:action=&gt;"new", :controller=&gt;"phones"}
edit_person_phone GET    /people/:person_id/phones/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"phones"}
     person_phone GET    /people/:person_id/phones/:id(.:format)      {:action=&gt;"show", :controller=&gt;"phones"}
                  PUT    /people/:person_id/phones/:id(.:format)      {:action=&gt;"update", :controller=&gt;"phones"}
                  DELETE /people/:person_id/phones/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"phones"}
           people GET    /people(.:format)                            {:action=&gt;"index", :controller=&gt;"people"}
                  POST   /people(.:format)                            {:action=&gt;"create", :controller=&gt;"people"}
       new_person GET    /people/new(.:format)                        {:action=&gt;"new", :controller=&gt;"people"}
      edit_person GET    /people/:id/edit(.:format)                   {:action=&gt;"edit", :controller=&gt;"people"}
           person GET    /people/:id(.:format)                        {:action=&gt;"show", :controller=&gt;"people"}
                  PUT    /people/:id(.:format)                        {:action=&gt;"update", :controller=&gt;"people"}
                  DELETE /people/:id(.:format)                        {:action=&gt;"destroy", :controller=&gt;"people"}
           phones GET    /phones(.:format)                            {:action=&gt;"index", :controller=&gt;"phones"}
                  POST   /phones(.:format)                            {:action=&gt;"create", :controller=&gt;"phones"}
        new_phone GET    /phones/new(.:format)                        {:action=&gt;"new", :controller=&gt;"phones"}
       edit_phone GET    /phones/:id/edit(.:format)                   {:action=&gt;"edit", :controller=&gt;"phones"}
            phone GET    /phones/:id(.:format)                        {:action=&gt;"show", :controller=&gt;"phones"}
                  PUT    /phones/:id(.:format)                        {:action=&gt;"update", :controller=&gt;"phones"}
                  DELETE /phones/:id(.:format)                        {:action=&gt;"destroy", :controller=&gt;"phones"}
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

      <para>Ganz oben stehen interessante neue Routen-Varianten, die wir so
      noch nicht hatten: <code>new_person_phone</code>?
      <code>edit_person_phone</code>? Gleich zwei Resourcen in einem
      Routen-Namen!</para>

      <para>Aber brauchen wir überhaupt den direkten Zugang via <uri
      xlink:href="http://0.0.0.0:3000/phones">http://0.0.0.0:3000/phones</uri>
      auf die Resource <code>phones</code>? Eigentlich nein, da man nur die
      Telefonnummern zu einer Person braucht. Also können wir in der
      <filename>config/routes.rb</filename> die entsprechende Zeile löschen
      und nur noch Zugriffe auf <classname>phones</classname> über
      <classname>people</classname> zulassen:<programlisting>Webshop::Application.routes.draw do
  resources :people do
    resources :phones
  end
end</programlisting></para>

      <para>Schauen wir uns die Routen an:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake routes</command>
    person_phones GET    /people/:person_id/phones(.:format)          {:action=&gt;"index", :controller=&gt;"phones"}
                  POST   /people/:person_id/phones(.:format)          {:action=&gt;"create", :controller=&gt;"phones"}
 new_person_phone GET    /people/:person_id/phones/new(.:format)      {:action=&gt;"new", :controller=&gt;"phones"}
edit_person_phone GET    /people/:person_id/phones/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"phones"}
     person_phone GET    /people/:person_id/phones/:id(.:format)      {:action=&gt;"show", :controller=&gt;"phones"}
                  PUT    /people/:person_id/phones/:id(.:format)      {:action=&gt;"update", :controller=&gt;"phones"}
                  DELETE /people/:person_id/phones/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"phones"}
           people GET    /people(.:format)                            {:action=&gt;"index", :controller=&gt;"people"}
                  POST   /people(.:format)                            {:action=&gt;"create", :controller=&gt;"people"}
       new_person GET    /people/new(.:format)                        {:action=&gt;"new", :controller=&gt;"people"}
      edit_person GET    /people/:id/edit(.:format)                   {:action=&gt;"edit", :controller=&gt;"people"}
           person GET    /people/:id(.:format)                        {:action=&gt;"show", :controller=&gt;"people"}
                  PUT    /people/:id(.:format)                        {:action=&gt;"update", :controller=&gt;"people"}
                  DELETE /people/:id(.:format)                        {:action=&gt;"destroy", :controller=&gt;"people"}
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ </screen></para>

      <para>Jetzt müssen wir aber noch den Controller und alle Views an die
      neue Situation anpassen.</para>

      <para>Um die Übersichtlichkeit dieser Beschreibung zu maximieren, gehen
      wir beim Controller davon aus, das nur Nested Resources und nur
      HTML-Seiten angefragt werden.</para>

      <para>Die Datei
      <filename>app/controllers/phones_controller.rb</filename> sieht dann so
      aus:<programlisting>class PhonesController &lt; ApplicationController
  before_filter :find_person
  
  # GET /phones
  def index
    @phones = @person.phones
  end

  # GET /phones/1
  def show
    @phone = @person.phones.find(params[:id])
  end

  # GET /phones/new
  def new
    @phone = @person.phones.build
  end

  # GET /phones/1/edit
  def edit
    @phone = @person.phones.find(params[:id])
  end

  # POST /phones
  def create
    @phone = @person.phones.build(params[:phone])

    if @phone.save
      redirect_to person_phone_path(@person, @phone), notice: 'Phone was successfully created.'
    else
      render action: "new"
    end
  end

  # PUT /phones/1
  def update
    @phone = @person.phones.find(params[:id])

    if @phone.update_attributes(params[:phone])
      redirect_to person_phone_path(@person, @phone), notice: 'Phone was successfully updated.'
    else
      render action: "edit"
    end
  end

  # DELETE /phones/1
  def destroy
    @phone = @person.phones.find(params[:id])
    @phone.destroy

    redirect_to person_phones_url(@person)
  end
  
  private
  def find_person
    @person = Person.find(params[:person_id])
  end
end
</programlisting></para>

      <section xml:id="routes_nested_resources_index">
        <title xml:id="routes_nested_resources_index.title">index</title>

        <para>Für den Aufruf von <uri
        xlink:href="http://0.0.0.0:3000/people/1/phones">http://0.0.0.0:3000/people/1/phones</uri>
        müssen wir die ganzen Routen in der View
        <filename>app/views/phones/index.html.erb</filename>
        ändern:<programlisting>&lt;h1&gt;Listing phones&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Person&lt;/th&gt;
    &lt;th&gt;Phone number&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @phones.each do |phone| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= phone.person_id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= phone.phone_number %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', <emphasis>person_phone_path(@person, phone)</emphasis> %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', <emphasis>edit_person_phone_path(@person,phone)</emphasis> %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', <emphasis>person_phone_path(@person, phone)</emphasis>, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Phone', <emphasis>new_person_phone_path(@person)</emphasis> %&gt;
</programlisting></para>
      </section>

      <section xml:id="routes_nested_resources_show">
        <title xml:id="routes_nested_resources_show.title">show</title>

        <para>Um mit <uri
        xlink:href="http://0.0.0.0:3000/people/1/phones/1">http://0.0.0.0:3000/people/1/phones/1</uri>
        ein <methodname>show</methodname> auf ein einzelnes Telefon zu
        bekommen, müssen wir die Routen in der Datei
        <filename>app/views/phones/view.html.erb</filename>
        ändern:<programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Phone number:&lt;/b&gt;
  &lt;%= @phone.phone_number %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', <emphasis>edit_person_phone_path(@person, @phone)</emphasis> %&gt; |
&lt;%= link_to 'Back', <emphasis>person_phones_path(@person)</emphasis> %&gt;
</programlisting></para>
      </section>

      <section xml:id="routes_nested_resources_new">
        <title xml:id="routes_nested_resources_new.title">new</title>

        <para>Um mit <uri
        xlink:href="http://0.0.0.0:3000/person/1/phones/new">http://0.0.0.0:3000/person/1/phones/new</uri>
        ein neues Telefon anlegen zu können müssen wir die Route in der Datei
        <filename>app/views/phones/new.html.erb</filename>
        ändern:<programlisting>&lt;h1&gt;New phone&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', <emphasis>person_phones_path(@person)</emphasis> %&gt;
</programlisting></para>

        <para>Und natürlich noch das Formular im
        <filename>app/views/phones/_form.html.erb</filename>
        Partial:<programlisting>&lt;%= form_for(<emphasis>[@person, @phone]</emphasis>) do |f| %&gt;
  &lt;% if @phone.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@phone.errors.count, "error") %&gt; prohibited this phone from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @phone.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= f.label :phone_number %&gt;&lt;br /&gt;
    &lt;%= f.text_field :phone_number %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</programlisting></para>
      </section>

      <section>
        <title>edit</title>

        <para>Die Änderung in der Datei
        <filename>app/views/phones/edit.html.erb</filename> für den Zugriff
        auf <uri>http://0.0.0.0:3000/people/1/phones/1/edit</uri> ähneln denen
        vom <methodname>new</methodname> View:<programlisting>&lt;h1&gt;Editing phone&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Show', <emphasis>person_phone_path(@person, @phone)</emphasis> %&gt; |
&lt;%= link_to 'Back', <emphasis>person_phones_path(@person)</emphasis> %&gt;</programlisting></para>

        <para>Das Formular im
        <filename>app/views/phones/_form.html.erb</filename> Partial brauchen
        wir natürlich nicht mehr zu ändern.</para>
      </section>
    </section>
  </section>

  <section>
    <title></title>

    <para></para>
  </section>

  <section>
    <title>Weitere Dokumentation</title>

    <para>Folgende Webseiten geben Ihnen einen tieferen Einblick in das Thema
    Routes:<itemizedlist>
        <listitem>
          <para><uri
          xlink:href="http://guides.rubyonrails.org/routing.html">http://guides.rubyonrails.org/routing.html</uri></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://railscasts.com/episodes/203-routing-in-rails-3">http://railscasts.com/episodes/203-routing-in-rails-3</uri></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://yehudakatz.com/2009/12/26/the-rails-3-router-rack-it-up/">http://yehudakatz.com/2009/12/26/the-rails-3-router-rack-it-up/</uri></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://rizwanreza.com/2009/12/20/revamped-routes-in-rails-3">http://rizwanreza.com/2009/12/20/revamped-routes-in-rails-3</uri></para>
        </listitem>
      </itemizedlist></para>
  </section>
</chapter>
