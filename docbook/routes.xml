<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="routes" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="routes.title">Routen (routes)</title>

  <indexterm>
    <primary>Routen</primary>
  </indexterm>

  <indexterm>
    <primary>routes.rb</primary>

    <see>Routen</see>
  </indexterm>

  <section xml:id="routes_einstieg">
    <title xml:id="routes_einstieg.title">Einstieg</title>

    <para>In <xref linkend="dynamische_webseiten" /> und <xref
    linkend="scaffolding" /> hatten wir schon mal kurz Kontakt mit
    <foreignphrase xml:lang="en">Routes</foreignphrase>. Mit den in
    <filename>config/routes.rb</filename> enthaltenen Routen wird definiert,
    was in Rails Application passiert, wenn eine bestimmte URL vom Besucher
    der Webseite angesteuert wird. Eine Route kann statisch und dynamisch sein
    und evt. dynamische Werte mit Variablen an den Controller übergeben.
    Sollten mehrere Routen auf eine URL zutreffen, so gewinnt die in der
    <filename>config/routes.rb</filename> am oberste eingetragene.<note>
        <para>Wenn Sie wenig Zeit haben, können Sie dieses Kapitel erst einmal
        überspringen und später bei konkreten Fragen noch mal
        nachschlagen.</para>
      </note></para>

    <para>Bauen wir uns zuerst eine Test-Rails-Applikation zum
    Experimentieren:<screen>Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>rails new shop</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>cd shop</command>
Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>

    <para>Mit <command>rake routes</command> können wir uns die Routen eines
    Projektes anzeigen lassen. Probieren wir das direkt im frischen Projekt
    aus:<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rake routes</command>

Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>

    <para>Nichts. Es sind in einem neuen Rails-Projekt keine Routen
    eingetragen.</para>

    <important>
      <para>Auch bei einem neuen Rails-Projekt können Sie nach dem Start des
      Rails-Servers mit <command>rails server</command> auf <uri
      xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri> zugreifen.
      Wie kann dies ohne eine eingetragene Route funktionieren? Die Lösung
      liegt im Verzeichnis <filename>/public</filename>. Dort liegt die Datei
      <filename>public/index.html</filename>, und immer wenn im Verzeichnis
      <filename>/public</filename> eine Datei liegt, die zur angegebenen URL
      passt, bekommt diese eine höhere Priorität als eine Rails-Route. Falls
      keine Route definiert ist, wird automatisch in
      <filename>public</filename> nach <filename>index.html</filename>
      gesucht.</para>
    </important>

    <para>Bei einem neuen Rails-Projekt ist die Datei
    <filename>config/routes.rb</filename> mit vielen auskommentierten
    Beispielen bestückt. Für den Verlauf dieses Kapitels tun wir so, als wenn
    diese Beispiele nicht drin wären und zeigen immer nur die neu
    eingetragenen Routen an.</para>
  </section>

  <section xml:id="routes_get">
    <title xml:id="routes_get.title">get</title>

    <para>Erstellen wir nachfolgend einen Controller mit drei einfachen
    Seiten:<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rails generate controller Home index ping pong</command>
      create  app/controllers/home_controller.rb
<emphasis>       route  get "home/pong"
       route  get "home/ping"
       route  get "home/index"
</emphasis>      invoke  erb
      create    app/views/home
      create    app/views/home/index.html.erb
      create    app/views/home/ping.html.erb
      create    app/views/home/pong.html.erb
      invoke  test_unit
      create    test/functional/home_controller_test.rb
      invoke  helper
      create    app/helpers/home_helper.rb
      invoke    test_unit
      create      test/unit/helpers/home_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/home.js.coffee
      invoke    scss
      create      app/assets/stylesheets/home.css.scss
Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>

    <para>Jetzt gibt <command>rake route</command> für diese drei Seiten eine
    Route aus:<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rake routes</command>
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>

    <para>Die Seiten sind nach dem Starten des Rails-Servers mit
    <command>rails server</command> unter den folgenden URLs
    erreichbar:<itemizedlist>
        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/index">http://0.0.0.0:300/home/index</uri></para>

          <para>für <code>home_index GET /home/index(.:format)
          home#index</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/ping">http://0.0.0.0:300/home/ping</uri></para>

          <para>für <code>home_ping GET /home/ping(.:format)
          home#ping</code></para>
        </listitem>

        <listitem>
          <para><uri
          xlink:href="http://0.0.0.0:300/home/pong">http://0.0.0.0:300/home/pong</uri></para>

          <para>für <code>home_pong GET /home/pong(.:format)
          home#pong</code></para>
        </listitem>
      </itemizedlist></para>

    <para><screenshot>
        <info>
          <title>http://0.0.0.0:300/home/ping</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/home_ping.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Rails sagt uns mit der Ausgabe <code>home#index</code>, dass die
    Route <uri>/home/index</uri> in den Controller <classname>home</classname>
    und dort zur Action/Methode <methodname>index</methodname> geht. Definiert
    werden diese Routen in der Datei <filename>config/routes.rb</filename>.
    <command>rails generate controller Home index ping pong</command> hat dort
    automatisch folgende Zeilen eingefügt:<programlisting>  get "home/index"
  
  get "home/ping"
  
  get "home/pong"
</programlisting></para>
  </section>

  <section xml:id="routes_root">
    <title xml:id="routes_root.title">root :to =&gt; 'welcome#index'</title>

    <para>In der Default <filename>config/routes.rb</filename>-Datei finden
    Sie recht weit unten folgenden Kommentar:<programlisting>  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; 'welcome#index'</programlisting></para>

    <para>Wenn Sie dort die letzte Zeile auskommentieren, können Sie damit
    Ihre <uri xlink:href="http://0.0.0.0:3000/">http://0.0.0.0:3000/</uri>
    definieren. Legen wir sie mal auf
    <methodname>home#index</methodname>:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  <emphasis>root :to =&gt; "home#index"</emphasis>
end</programlisting></para>

    <para>Unsere neuen Routen:<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rake routes</command>
home_index GET /home/index(.:format) home#index
 home_ping GET /home/ping(.:format)  home#ping
 home_pong GET /home/pong(.:format)  home#pong
      root     /                     home#index
Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>

    <para><screenshot>
        <info>
          <title>Die Route „/“ ruft home#index auf</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/routes_home_index.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <important>
      <para>Nach dem Setzen der <code>root</code>-Route sollten Sie nicht das
      Löschen der Datei <filename>/public/index.html</filename>
      vergessen!<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rm public/index.html</command> 
Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>
    </important>
  </section>

  <section xlink:href="routes_match">
    <title xml:id="routes_match.title">match</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>match</secondary>
    </indexterm>

    <para>Wenn wir zusätzlich zur URL <uri>/home/ping</uri> noch mit
    <uri>/home/apfelmus</uri> auf die gleiche Action im gleichen Controller
    zugreifen, so müssen wir die Datei <filename>config/routes.rb</filename>
    wie folgt verändern:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  root :to =&gt; "home#index"

  <emphasis>match "home/apfelmus" =&gt; "home#ping"</emphasis>
end</programlisting></para>

    <para>Damit stehen uns folgende Routen zur Verfügung:<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rake routes</command>
   home_index GET /home/index(.:format)    home#index
    home_ping GET /home/ping(.:format)     home#ping
    home_pong GET /home/pong(.:format)     home#pong
         root     /                        home#index
<emphasis>home_apfelmus     /home/apfelmus(.:format) home#ping</emphasis>
Stefan-Wintermeyers-MacBook-Air:shop xyz$ </screen></para>

    <para><screenshot>
        <info>
          <title>http://0.0.0.0:3000/home/apfelmus</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/home_apfelmus.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn Sie der Route <filename>/home/apfelmus</filename> einen anderen
    Namen geben wollen, so können Sie dies mit der Einstellung <code>:as =&gt;
    "<replaceable>name</replaceable>"</code> in der
    <filename>config/routes.rb</filename> realisieren:<programlisting>Shop::Application.routes.draw do
  get "home/index"

  get "home/ping"

  get "home/pong"

  root :to =&gt; "home#index"

  <emphasis>match "home/ping-ping" =&gt; "home#ping", :as =&gt; "apfelmus"</emphasis>
end</programlisting></para>

    <para>Jetzt stehen Ihnen im System folgende Routen-Namen zur
    Verfügung:<screen>Stefan-Wintermeyers-MacBook-Air:shop xyz$ <command>rake routes</command>
home_index GET /home/index(.:format)    home#index
 home_ping GET /home/ping(.:format)     home#ping
 home_pong GET /home/pong(.:format)     home#pong
      root     /                        home#index
  <emphasis>apfelmus</emphasis>     /home/apfelmus(.:format) home#ping
Stefan-Wintermeyers-MacBook-Air:shop xyz$</screen></para>

    <para>Sie sehen dabei, dass eine URL ein Minuszeichen enthalten darf, aber
    der Routen-Name nicht (ein Unterstrich geht aber).</para>

    <important>
      <para>Die Routen in der Datei <filename>config/routes.rb</filename>
      werden immer von oben nach unten abgearbeitet. Der erste Treffer von
      oben gewinnt!</para>
    </important>

    <section xml:id="routes_match_parameter">
      <title xml:id="routes_match_parameter.title">Parameter</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Parameter</secondary>
      </indexterm>

      <para>Match kann nicht nur fixe Routen zuordnen, sondern auch noch
      Parameter übergeben. Ein typisches Beispiel dafür wären Angaben zu einem
      Datum. Wir erstellen dazu nachfolgend eine
      Mini-Blog-Applikation:<screen>Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>rails new blog</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>cd blog</command> 
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails generate scaffold Post subject content published_at:date</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rake db:migrate</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

      <para>Als Beispieldaten in der <filename>db/seeds.rb</filename> nehmen
      wir:<programlisting>Post.create(:subject =&gt; 'Ein Test',            :published_at =&gt; '01.10.2011')
Post.create(:subject =&gt; 'Noch ein Test',       :published_at =&gt; '01.10.2011')
Post.create(:subject =&gt; 'Und wieder ein Test', :published_at =&gt; '02.10.2011')
Post.create(:subject =&gt; 'Letzter Test',        :published_at =&gt; '01.11.2011')
Post.create(:subject =&gt; 'Allerletzter Test',   :published_at =&gt; '01.11.2012')</programlisting></para>

      <para>Mit <command>rake db:seed</command> spielen wir diese Daten in die
      Datenbank:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rake db:seed</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

      <para>Wenn wir jetzt mit <command>rails server</command> den
      Rails-Server starten und mit dem Browser auf die Seite <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>
      surfen, bekommen wir folgende Anzeige:<screenshot>
          <info>
            <title>Index-Ansicht aller Posts</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_index.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Für ein solches Blog wäre es natürlich sehr praktisch, wenn man
      mit der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      alle Einträge für das Jahr 2010 und mit <uri
      xlink:href="http://0.0.0.0:3000/2010/10/01">http://0.0.0.0:3000/2010/10/01</uri>
      alle Einträge für den 01.10.2010 anzeigen könnte. Das erreichen wir mit
      optionalen Parametern beim <code>match</code>-Eintrag. Bitte tragen Sie
      folgende Konfiguration in die <filename>config/routes.rb</filename>
      ein:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year(/:month(/:day))" =&gt; "posts#index"
end</programlisting></para>

      <para>Die runden Klammern stehen für optionale Parameter. In diesem Fall
      muss unbedingt das Jahr, aber nicht zwingend der Monat oder der Tag
      angegeben werden.</para>

      <para>Wenn wir nichts anderes ändern, bekommen wir beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/2010/">http://0.0.0.0:3000/2010/</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/2010">http://0.0.0.0:3000/2010</uri>
      immer noch das gleiche Ergebnis wie beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/posts">http://0.0.0.0:3000/posts</uri>.
      Das ist ja auch logisch. Aber schauen Sie einmal in die Ausgabe von
      rails server:<screen>Started GET "/2010/" for 127.0.0.1 at 2012-05-22 11:27:29 +0200
Processing by PostsController#index as HTML
  <emphasis>Parameters: {"year"=&gt;"2010"}</emphasis>
  Post Load (0.2ms)  SELECT "posts".* FROM "posts" 
  Rendered posts/index.html.erb within layouts/application (5.5ms)
Completed 200 OK in 13ms (Views: 11.3ms | ActiveRecord: 0.2ms)</screen></para>

      <para>Die Route wurde erkannt und dem Hash
      <code><varname>params</varname></code> (in der Ausgabe irreführend als
      <code>Parameters</code> ausgeschrieben) ein Element <code>"year" =&gt;
      "2010"</code> zugewiesen. Ein Aufruf der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/12/24">http://0.0.0.0:3000/2010/12/24</uri>
      ergibt erwartungsgemäss folgende Ausgabe:<screen>Started GET "/2010/12/24" for 127.0.0.1 at 2012-05-22 11:30:49 +0200
Processing by PostsController#index as HTML
  <emphasis>Parameters: {"year"=&gt;"2010", "month"=&gt;"12", "day"=&gt;"24"}</emphasis>
  Post Load (0.2ms)  SELECT "posts".* FROM "posts" 
  Rendered posts/index.html.erb within layouts/application (5.9ms)
Completed 200 OK in 13ms (Views: 11.5ms | ActiveRecord: 0.2ms)</screen></para>

      <para>Bei der URL <uri
      xlink:href="http://0.0.0.0:3000/2010/12/24">http://0.0.0.0:3000/2010/12/24</uri>
      wurden folgende Werte im Hash <varname>params</varname> gespeichert:
      <code>"year"=&gt;"2010", "month"=&gt;"12", "day"=&gt;"24"</code></para>

      <para>Auf <varname>params[]</varname> haben wir im Controller Zugriff
      auf die in der URL definierten Werte. Wir müssen nur noch die
      <methodname>index</methodname> Methode in
      <filename>app/controllers/posts_controller.rb</filename> anpassen, um
      die für das entsprechende Datum, den entsprechenden Monat oder das
      entsprechende Jahr eingetragenen <varname>posts</varname>
      auszugeben:<programlisting>def index
<emphasis>  if params[:day]
    @posts = Post.where(:published_at =&gt; Date.parse("#{params[:day]}.#{params[:month]}.#{params[:year]}"))
  elsif params[:month]
    @posts = Post.where(:published_at =&gt; ( Date.parse("01.#{params[:month]}.#{params[:year]}") .. Date.parse("01.#{params[:month]}.#{params[:year]}").end_of_month ))
  elsif params[:year]
    @posts = Post.where(:published_at =&gt; ( Date.parse("01.01.#{params[:year]}") .. Date.parse("31.12.#{params[:year]}") ))
  else
    @posts = Post.all
  end</emphasis>

  respond_to do |format|
    format.html # index.html.erb
    format.json { render json: @posts }
  end
end</programlisting></para>

      <para>Damit bekommen wir beim Aufruf von <uri
      xlink:href="http://0.0.0.0:3000/2011/10/01">http://0.0.0.0:3000/2011/10/01</uri>
      alle <varname>posts</varname> des 01.10.2011 angezeigt.<screenshot>
          <info>
            <title>Index-View für den 01.11.2011</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/posts_2011_10_01.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>
    </section>

    <section xml:id="routes_match_contraints">
      <title xml:id="routes_match_contraints.title">Constraints
      (Einschränkungen)</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Constraints</secondary>
      </indexterm>

      <para>In <xref linkend="routes_match_parameter" /> habe ich Ihnen
      gezeigt, wie man Parameter aus der URL auslesen und an den Controller
      weitergeben kann. Leider hat der dort definierte Eintrag in der
      <filename>config/routes.rb</filename> <programlisting>match "/:year(/:month(/:day))" =&gt; "posts#index"</programlisting>einen
      entscheidenen Nachteil: Er überprüft die einzelnen Elemente nicht. Die
      URL <uri
      xlink:href="http://0.0.0.0:3000/ein/beispiel/dafuer">http://0.0.0.0:3000/ein/beispiel/dafuer</uri>
      wird genauso gematcht und führt dann natürlich direkt zu einem
      Fehler:<screenshot>
          <info>
            <title>Fehlermeldung</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/ein_beispiel_dafuer_fehler.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>In der Log-Ausgabe in <filename>log/development.log</filename>
      sehen wir dabei folgenden Eintrag:<programlisting>Started GET "/ein/beispiel/dafuer" for 127.0.0.1 at 2012-05-22 13:20:44 +0200
Processing by PostsController#index as HTML
  Parameters: {"year"=&gt;"ein", "month"=&gt;"beispiel", "day"=&gt;"dafuer"}</programlisting></para>

      <para>Es ist klar, dass <code>Date.parse( "dafuer.beispiel.ein")</code>
      nicht funktionieren kann. Ein Datum besteht nun mal aus Zahlen und nicht
      aus Buchstaben.</para>

      <para>Constraints können mittels Regular Expressions den Inhalt der URL
      besser definieren. In unserem Blog-Fall würde die
      <filename>config/routes.rb</filename> mit Constraints so
      aussehen:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year(/:month(/:day))" =&gt; "posts#index"<emphasis role="bold">, :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{2}/ }</emphasis>
end</programlisting></para>

      <warning>
        <para>Bitte beachten Sie, dass bei den Regular Expressions in einem
        Constraint keine Regex-Anchors wie "^" benutzt werden können.</para>
      </warning>

      <para>Wenn wir mit dieser Konfiguration noch mal die URL aufrufen,
      bekommen wir einen Fehler „No route matches“ von Rails:<screenshot>
          <info>
            <title>Routing Error</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/ein_beispiel_dafuer_no_route_matches.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <section xml:id="advanced_constraints">
        <title xml:id="advanced_constraints.title">Advanced
        Constraints</title>

        <para>Mit der Route <code>match "/:year(/:month(/:day))" =&gt;
        "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt;
        /\d{2}/, :day =&gt; /\d{2}/ }</code> haben wir zwar die URL
        syntaktisch auf ein Datum überprüft, aber es kann natürlich ein User
        immer noch die URL <uri
        xlink:href="http://0.0.0.0:3000/2011/02/31">http://0.0.0.0:3000/2011/02/31</uri>
        aufrufen. Da es keinen 31. Februar gibt, dürfte es diese Route logisch
        nicht geben. Wir brauchen also eine Möglichkeit, die ein angegebenes
        syntaktisch komplettes Datum darauf überprüft, ob es auch ein
        korrektes Datum nach dem Kalender ist.</para>

        <para>Dazu müssen wir eine eigene Klasse definieren, mit der Objekte .
        Bitte erstellen Sie dazu die Datei
        <filename>lib/valid_date_contraint.rb</filename> mit folgendem
        Inhalt:<programlisting>class ValidDateConstraint
  def matches?(request)
    begin
      Date.parse("#{request.params[:day]}.#{request.params[:month]}.#{request.params[:year]}")
      true
    rescue
      false
    end
  end
end</programlisting></para>

        <para>Diese Klasse müssen wir jetzt laden. Bitte erstellen Sie dazu
        die Datei <filename>config/initializers/load_extensions.rb</filename>
        mit diesem Inhalt:<programlisting>require 'valid_date_constraint'</programlisting></para>

        <para>Jetzt spliten wir die Datums-Route in der
        <filename>config/routes.rb</filename> auf:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year/:month/:day" =&gt; "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{2}/ }, :constraints =&gt; ValidDateConstraint.new

  match "/:year(/:month)" =&gt; "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/ }
end
</programlisting></para>

        <para>Das erste <methodname>match</methodname> reagiert auf alle URLs
        mit drei Parametern die syntaktisch den gegebenen Contraints
        entsprechen. Zusätzlich wird noch das Datum überprüft. Erst wenn das
        Datum an sich valide ist, wird diese Route benutzt. Sie wird also
        nicht bei der URL <uri
        xlink:href="http://0.0.0.0:3000/2011/02/31">http://0.0.0.0:3000/2011/02/31</uri>
        aufgerufen. Hingegen würde die URL <uri
        xlink:href="http://0.0.0.0:3000/2011/10/01">http://0.0.0.0:3000/2011/10/01</uri>
        funktionieren.</para>
      </section>
    </section>

    <section xml:id="routes_match_redirects">
      <title xml:id="routes_match_redirects.title">Redirects</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>Redirect (Umleitung)</secondary>
      </indexterm>

      <indexterm>
        <primary>Redirect</primary>

        <secondary>per Routen</secondary>
      </indexterm>

      <para>Ich kann mit einem <code>match</code> auch auf eine andere Seite
      umleiten (<foreignphrase xml:lang="en">redirect</foreignphrase>). Wenn
      ich die Eingabe der unsinnigen URL <uri
      xlink:href="http://0.0.0.0:3000/2010/02/31">http://0.0.0.0:3000/2010/02/31</uri>
      auf /2010/02 redirecten will, dann geht das
      folgendermaßen:<programlisting>match "/:year/02/31" =&gt; redirect("/%{year}/02")</programlisting></para>

      <para>Damit könnte man auch die Eingabe eines einstelligen Monats auf
      einen zweistelligen Monat umleiten:<programlisting>match "/:year/:month/:day" =&gt; redirect("/%{year}/0%{month}/%{day}"), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/, :day =&gt; /\d{2}/ }
</programlisting></para>

      <para>Das Gleiche ginge natürlich auch für einen einstelligen Tag. Unter
      Berücksichtigung aller Kombinationen sähe unsere
      <filename>config/routes.rb</filename> dann so aus:<programlisting>Blog::Application.routes.draw do
  resources :posts

  match "/:year/:month/:day" =&gt; redirect("/%{year}/0%{month}/%{day}" ), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/, :day =&gt; /\d{2}/ }
  match "/:year/:month/:day" =&gt; redirect("/%{year}/0%{month}/0%{day}"), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/, :day =&gt; /\d{1}/ }
  match "/:year/:month/:day" =&gt; redirect("/%{year}/%{month}/0%{day}" ), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{1}/ }

  match "/:year/:month" =&gt; redirect("/%{year}/0%{month}"), :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{1}/ }

  match "/:year(/:month(/:day))" =&gt; "posts#index", :constraints =&gt; { :year =&gt; /\d{4}/, :month =&gt; /\d{2}/, :day =&gt; /\d{2}/ }
end</programlisting></para>

      <para>Mit diesem Redirect-Regelwerk wäre sichergestellt, dass ein
      Benutzer der Seite auch einstellige Monate und Tage eingeben kann und
      trotzdem an der richtigen Stelle landet bzw. zum richtigen Format
      umgeleitet wird.</para>
    </section>
  </section>

  <section xml:id="routes_resources">
    <title xml:id="routes_resources.title">resources</title>

    <indexterm>
      <primary>Routen</primary>

      <secondary>resources</secondary>
    </indexterm>

    <para>Bauen wir uns für <code>resources</code> eine neue Rails-Applikation
    zum Experimentieren:<screen>MacBook:~ sw$ <command>rails new phonebook</command>
[...]
MacBook:~ sw$ <command>cd phonebook</command>
MacBook:phonebook sw$ <command>bundle install</command>
[...]
MacBook:phonebook sw$ </screen></para>

    <para>Beim Verwenden von Scaffold werden automatisch Routen für die neu
    erschaffenen Ressourcen erstellt. Legen wir mal eine Ressource an:<screen>MacBook:phonebook sw$ <command>rails generate scaffold person firstname:string lastname:string</command>
      invoke  active_record
      create    db/migrate/20110531175742_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/unit/person_test.rb
      create      test/fixtures/people.yml
       route  resources :people
[...]
MacBook:phonebook sw$ <command>rake db:migrate</command>
[...]
MacBook:phonebook sw$</screen></para>

    <para>Die Datei <filename>config/routes.rb</filename> sieht damit so
    aus:<programlisting>Webshop::Application.routes.draw do
  <emphasis role="bold">resources :people</emphasis>
end</programlisting></para>

    <note>
      <para>Neue Routen werden von rails generate Skripten immer am Anfang von
      <filename>config/routes.rb</filename> hinzugefügt.</para>
    </note>

    <para>Die daraus resultierenden Routen:<screen>MacBook:webshop sw$ <command>rake routes</command>
     people GET    /people(.:format)          {:action=&gt;"index", :controller=&gt;"people"}
            POST   /people(.:format)          {:action=&gt;"create", :controller=&gt;"people"}
 new_person GET    /people/new(.:format)      {:action=&gt;"new", :controller=&gt;"people"}
edit_person GET    /people/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"people"}
     person GET    /people/:id(.:format)      {:action=&gt;"show", :controller=&gt;"people"}
            PUT    /people/:id(.:format)      {:action=&gt;"update", :controller=&gt;"people"}
            DELETE /people/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"people"}
MacBook:webshop sw$</screen></para>

    <para>Diese RESTful Routen sind Ihnen bereits aus <xref
    linkend="scaffolding" /> bekannt. Sie werden benötigt, um die Datensätze
    anzuzeigen und zu verändern.</para>

    <section xml:id="routes_nested_resources">
      <title xml:id="routes_nested_resources.title">Nested Resources</title>

      <indexterm>
        <primary>Routen</primary>

        <secondary>resources</secondary>

        <tertiary>nested</tertiary>
      </indexterm>

      <indexterm>
        <primary>Nested Routes</primary>

        <see>Routen</see>
      </indexterm>

      <para>Verschachtelte Ressourcen (nested resources) bezieht sich auf
      Routen von Ressourcen, die mit einer
      <methodname>has_many</methodname>-Verknüpfung (siehe <xref
      linkend="activerecord_has_many" />) arbeiten. Diese lassen sich
      eindeutig über Routen ansprechen. Legen wir eine zweite Ressource
      <classname>phone</classname> an:<screen>MacBook:phonebook sw$ <command>rails generate scaffold phone person_id:integer phone_number:string</command>
      invoke  active_record
      create    db/migrate/20110531180003_create_phones.rb
      create    app/models/phone.rb
      invoke    test_unit
      create      test/unit/phone_test.rb
      create      test/fixtures/phones.yml
       route  resources :phones
[...]
MacBook:phonebook sw$ <command>rake db:migrate</command>
[...]
MacBook:phonebook sw$ </screen></para>

      <para>Jetzt verküpfen wir beide Ressourcen miteinander. In der Datei
      <filename>app/models/person.rb</filename> fügen wir ein
      <methodname>has_many</methodname> hinzu:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phones
end</programlisting></para>

      <para>Und in der Datei <filename>app/models/phone.rb</filename> das
      Gegenstück <methodname>belongs_to</methodname>:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :person
end
</programlisting></para>

      <para>Jetzt füllen wir die Datei <filename>db/seeds.rb</filename> (siehe
      <xref linkend="seed_rb" />) noch mit ein paar
      Beispieldatensätzen:<programlisting>Person.create(:lastname =&gt; 'Meier').phones.create([{:phone_number =&gt; '030 1234567'}, {:phone_number =&gt; '0171 1234567'}])
Person.create(:lastname =&gt; 'Stein').phones.create(:phone_number =&gt; '040 1234567')
Person.create(:lastname =&gt; 'Oberhuber')</programlisting></para>

      <para>Die spielen wir mit <command>rake db:seed</command> ein:<screen>MacBook:phonebook sw$ <command>rake db:seed</command>
MacBook:phonebook sw$</screen></para>

      <para>Schauen wir uns das kurz in der Console an:<screen>MacBook:phonebook sw$ <command>rails console</command>
Loading development environment (Rails 3.1.0.rc1)
ruby-1.9.2-p180 :001 &gt; <command>Person.first</command>
  Person Load (0.1ms)  SELECT "people".* FROM "people" LIMIT 1
 =&gt; #&lt;Person id: 1, firstname: nil, lastname: "Meier", created_at: "2011-05-31 18:03:07", updated_at: "2011-05-31 18:03:07"&gt; 
ruby-1.9.2-p180 :002 &gt; <command>Person.first.phones</command>
  Person Load (0.3ms)  SELECT "people".* FROM "people" LIMIT 1
  Phone Load (0.2ms)  SELECT "phones".* FROM "phones" WHERE "phones"."person_id" = 1
 =&gt; [#&lt;Phone id: 1, person_id: 1, phone_number: "030 1234567", created_at: "2011-05-31 18:03:07", updated_at: "2011-05-31 18:03:07"&gt;, #&lt;Phone id: 2, person_id: 1, phone_number: "0171 1234567", created_at: "2011-05-31 18:03:07", updated_at: "2011-05-31 18:03:07"&gt;] 
ruby-1.9.2-p180 :003 &gt; <command>exit</command>
MacBook:phonebook sw$</screen></para>

      <para>Wenn wir den Datensatz von <methodname>Person.first</methodname>
      im Browser anschauen wollen, so müssen wir mit <command>rails
      server</command> den Server starten und die URL <uri
      xlink:href="http://0.0.0.0:3000/people/1">http://0.0.0.0:3000/people/1</uri>
      aufrufen:<screenshot>
          <info>
            <title>http://0.0.0.0:3000/people/1</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/people_show_1_einfach.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Wäre es nicht schön, wenn wir die Telefonnummern der
      <methodname>Person.first</methodname> mit der URL <uri
      xlink:href="http://0.0.0.0:3000/people/1/phones">http://0.0.0.0:3000/people/1/phones</uri>
      aufrufen könnten? Genau das können wir mit Nested Resources realisieren!
      Bitte ändern Sie Ihre <filename>config/routes.rb</filename> wie folgt
      ab:<programlisting>Webshop::Application.routes.draw do
  
<emphasis role="bold">  resources :people do
    resources :phones
  end</emphasis>
  
  <emphasis role="bold">resources :phones</emphasis>
  
end</programlisting></para>

      <para>Und jetzt müssen wir noch die
      <methodname>index</methodname>-Methode in der
      <filename>app/controllers/phones_controller.rb</filename>
      ändern:<programlisting>  def index
<emphasis role="bold">    if params[:person_id]
      @person = Person.find(params[:person_id])
      @phones = @person.phones
    else 
      @phones = Phone.all    
    end</emphasis>
    
    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @phones }
    end
  end
</programlisting></para>

      <para>Jetzt noch den Rails-Server mit <keycap>Ctrl-C</keycap> stoppen
      und mit <command>rails server</command> wieder neu starten und mit dem
      Browser <uri
      xlink:href="http://0.0.0.0:3000/people/1/phones">http://0.0.0.0:3000/people/1/phones</uri>
      aufrufen:<screenshot>
          <info>
            <title>http://0.0.0.0:3000/people/1/phones</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/people_1_phones.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Durch die Nested Route wurde der Parameter
      <varname>params[:person_id]</varname> an den Controller gegeben und wir
      konnten im Controller gezielt die <classname>Phones</classname> für
      diese <classname>Person</classname> heraussuchen. Falls dieser Parameter
      nicht existiert, dann würde die URL <uri
      xlink:href="http://0.0.0.0:3000/phones">http://0.0.0.0:3000/phones</uri>
      aufgerufen und es würden alle Phones angezeigt.</para>

      <para>Bis jetzt haben wir in der <filename>config/routes.rb</filename>
      zwei Einträge für <code>phones</code>. Einmal als Nested Resource
      innerhalb der Ressource <code>people</code> und einmal als eigenständige
      Ressource. <command>rake routes</command> zeigt beide Varianten:<screen>MacBook:phonebook sw$ <command>rake routes</command>
    person_phones GET    /people/:person_id/phones(.:format)          {:action=&gt;"index", :controller=&gt;"phones"}
                  POST   /people/:person_id/phones(.:format)          {:action=&gt;"create", :controller=&gt;"phones"}
 new_person_phone GET    /people/:person_id/phones/new(.:format)      {:action=&gt;"new", :controller=&gt;"phones"}
edit_person_phone GET    /people/:person_id/phones/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"phones"}
     person_phone GET    /people/:person_id/phones/:id(.:format)      {:action=&gt;"show", :controller=&gt;"phones"}
                  PUT    /people/:person_id/phones/:id(.:format)      {:action=&gt;"update", :controller=&gt;"phones"}
                  DELETE /people/:person_id/phones/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"phones"}
           people GET    /people(.:format)                            {:action=&gt;"index", :controller=&gt;"people"}
                  POST   /people(.:format)                            {:action=&gt;"create", :controller=&gt;"people"}
       new_person GET    /people/new(.:format)                        {:action=&gt;"new", :controller=&gt;"people"}
      edit_person GET    /people/:id/edit(.:format)                   {:action=&gt;"edit", :controller=&gt;"people"}
           person GET    /people/:id(.:format)                        {:action=&gt;"show", :controller=&gt;"people"}
                  PUT    /people/:id(.:format)                        {:action=&gt;"update", :controller=&gt;"people"}
                  DELETE /people/:id(.:format)                        {:action=&gt;"destroy", :controller=&gt;"people"}
           phones GET    /phones(.:format)                            {:action=&gt;"index", :controller=&gt;"phones"}
                  POST   /phones(.:format)                            {:action=&gt;"create", :controller=&gt;"phones"}
        new_phone GET    /phones/new(.:format)                        {:action=&gt;"new", :controller=&gt;"phones"}
       edit_phone GET    /phones/:id/edit(.:format)                   {:action=&gt;"edit", :controller=&gt;"phones"}
            phone GET    /phones/:id(.:format)                        {:action=&gt;"show", :controller=&gt;"phones"}
                  PUT    /phones/:id(.:format)                        {:action=&gt;"update", :controller=&gt;"phones"}
                  DELETE /phones/:id(.:format)                        {:action=&gt;"destroy", :controller=&gt;"phones"}
MacBook:phonebook sw$</screen></para>

      <para>Ganz oben stehen interessante neue Routen-Varianten, die wir so
      noch nicht hatten: <code>new_person_phone</code>?
      <code>edit_person_phone</code>? Gleich zwei Ressourcen in einem
      Routen-Namen!</para>

      <para>Aber brauchen wir überhaupt den direkten Zugang via <uri
      xlink:href="http://0.0.0.0:3000/phones">http://0.0.0.0:3000/phones</uri>
      auf die Ressource <code>phones</code>? Eigentlich nein, da man nur die
      Telefonnummern zu einer Person braucht. Also können wir in der
      <filename>config/routes.rb</filename> die entsprechende Zeile löschen
      und Zugriffe auf <classname>phones</classname> nur noch über
      <classname>people</classname> zulassen:<programlisting>Webshop::Application.routes.draw do
  resources :people do
    resources :phones
  end
end</programlisting></para>

      <para>Schauen wir uns die Routen an:<screen>MacBook:phonebook sw$ <command>rake routes</command>
    person_phones GET    /people/:person_id/phones(.:format)          {:action=&gt;"index", :controller=&gt;"phones"}
                  POST   /people/:person_id/phones(.:format)          {:action=&gt;"create", :controller=&gt;"phones"}
 new_person_phone GET    /people/:person_id/phones/new(.:format)      {:action=&gt;"new", :controller=&gt;"phones"}
edit_person_phone GET    /people/:person_id/phones/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"phones"}
     person_phone GET    /people/:person_id/phones/:id(.:format)      {:action=&gt;"show", :controller=&gt;"phones"}
                  PUT    /people/:person_id/phones/:id(.:format)      {:action=&gt;"update", :controller=&gt;"phones"}
                  DELETE /people/:person_id/phones/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"phones"}
           people GET    /people(.:format)                            {:action=&gt;"index", :controller=&gt;"people"}
                  POST   /people(.:format)                            {:action=&gt;"create", :controller=&gt;"people"}
       new_person GET    /people/new(.:format)                        {:action=&gt;"new", :controller=&gt;"people"}
      edit_person GET    /people/:id/edit(.:format)                   {:action=&gt;"edit", :controller=&gt;"people"}
           person GET    /people/:id(.:format)                        {:action=&gt;"show", :controller=&gt;"people"}
                  PUT    /people/:id(.:format)                        {:action=&gt;"update", :controller=&gt;"people"}
                  DELETE /people/:id(.:format)                        {:action=&gt;"destroy", :controller=&gt;"people"}
MacBook:phonebook sw$ </screen></para>

      <para>Jetzt müssen wir aber noch den Controller und alle Views an die
      neue Situation anpassen.</para>

      <para>Um die Übersichtlichkeit dieser Beschreibung zu maximieren, gehen
      wir beim Controller davon aus, dass nur Nested Resources und nur
      HTML-Seiten angefragt werden.</para>

      <para>Die Datei
      <filename>app/controllers/phones_controller.rb</filename> sieht dann so
      aus:<programlisting>class PhonesController &lt; ApplicationController
  
  before_filter :find_person
  
  # GET /phones
  def index
    @phones = @person.phones
  end

  # GET /phones/1
  def show
    @phone = @person.phones.find(params[:id])
  end

  # GET /phones/new
  def new
    @phone = @person.phones.build
  end

  # GET /phones/1/edit
  def edit
    @phone = @person.phones.find(params[:id])
  end

  # POST /phones
  def create
    @phone = @person.phones.build(params[:phone])

    if @phone.save
      redirect_to person_phone_path(@person, @phone), notice: 'Phone was successfully created.'
    else
      render action: "new"
    end
  end

  # PUT /phones/1
  def update
    @phone = @person.phones.find(params[:id])

    if @phone.update_attributes(params[:phone])
      redirect_to person_phone_path(@person, @phone), notice: 'Phone was successfully updated.'
    else
      render action: "edit"
    end
  end

  # DELETE /phones/1
  def destroy
    @phone = @person.phones.find(params[:id])
    @phone.destroy

    redirect_to person_phones_url(@person)
  end
  
  private
  
  def find_person
    @person = Person.find(params[:person_id])
  end
  
end
</programlisting></para>

      <section xml:id="routes_nested_resources_index">
        <title xml:id="routes_nested_resources_index.title">index</title>

        <para>Für den Aufruf von <uri
        xlink:href="http://0.0.0.0:3000/people/1/phones">http://0.0.0.0:3000/people/1/phones</uri>
        müssen wir die ganzen Routen in der View
        <filename>app/views/phones/index.html.erb</filename>
        ändern:<programlisting>&lt;h1&gt;Listing phones&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Person&lt;/th&gt;
    &lt;th&gt;Phone number&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @phones.each do |phone| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= phone.person_id %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= phone.phone_number %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', <emphasis role="bold">person_phone_path(@person, phone)</emphasis> %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', <emphasis role="bold">edit_person_phone_path(@person,phone)</emphasis> %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', <emphasis role="bold">person_phone_path(@person, phone)</emphasis>, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Phone', <emphasis role="bold">new_person_phone_path(@person)</emphasis> %&gt;
</programlisting></para>
      </section>

      <section xml:id="routes_nested_resources_show">
        <title xml:id="routes_nested_resources_show.title">show</title>

        <para>Um mit <uri
        xlink:href="http://0.0.0.0:3000/people/1/phones/1">http://0.0.0.0:3000/people/1/phones/1</uri>
        ein <methodname>show</methodname> auf ein einzelnes Telefon zu
        bekommen, müssen wir die Routen in der Datei
        <filename>app/views/phones/view.html.erb</filename>
        ändern:<programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Phone number:&lt;/b&gt;
  &lt;%= @phone.phone_number %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', <emphasis role="bold">edit_person_phone_path(@person, @phone)</emphasis> %&gt; |
&lt;%= link_to 'Back', <emphasis role="bold">person_phones_path(@person)</emphasis> %&gt;
</programlisting></para>
      </section>

      <section xml:id="routes_nested_resources_new">
        <title xml:id="routes_nested_resources_new.title">new</title>

        <para>Um mit <uri
        xlink:href="http://0.0.0.0:3000/person/1/phones/new">http://0.0.0.0:3000/person/1/phones/new</uri>
        ein neues Telefon anlegen zu können, müssen wir die Route in der Datei
        <filename>app/views/phones/new.html.erb</filename>
        ändern:<programlisting>&lt;h1&gt;New phone&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Back', <emphasis role="bold">person_phones_path(@person)</emphasis> %&gt;
</programlisting></para>

        <para>Und natürlich noch das Formular im Partial
        <filename>app/views/phones/_form.html.erb</filename>:<programlisting>&lt;%= form_for(<emphasis
              role="bold">[@person, @phone]</emphasis>) do |f| %&gt;
  &lt;% if @phone.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@phone.errors.count, "error") %&gt; prohibited this phone from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @phone.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= f.label :phone_number %&gt;&lt;br /&gt;
    &lt;%= f.text_field :phone_number %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</programlisting></para>
      </section>

      <section>
        <title>edit</title>

        <para>Die Änderungen in der Datei
        <filename>app/views/phones/edit.html.erb</filename> für den Zugriff
        auf <uri>http://0.0.0.0:3000/people/1/phones/1/edit</uri> ähneln denen
        vom View für <methodname>new</methodname>:<programlisting>&lt;h1&gt;Editing phone&lt;/h1&gt;

&lt;%= render 'form' %&gt;

&lt;%= link_to 'Show', <emphasis role="bold">person_phone_path(@person, @phone)</emphasis> %&gt; |
&lt;%= link_to 'Back', <emphasis role="bold">person_phones_path(@person)</emphasis> %&gt;</programlisting></para>

        <para>Das Formular im Partial
        <filename>app/views/phones/_form.html.erb</filename> brauchen wir
        natürlich nichts mehr zu ändern.</para>
      </section>
    </section>
  </section>

  <section xml:id="routes_weitere_informationen">
    <title xml:id="routes_weitere_informationen.title">Weitere Informationen
    zum Thema Routes</title>

    <para>Das Thema Routes ist weit komplexer als hier vorgestellt. So kann
    man z. B. auch die HTTP-Methoden mit einbeziehen. Folgende Webseiten geben
    Ihnen einen tieferen Einblick in das Thema Routes:<itemizedlist>
        <listitem>
          <para><link
          xlink:href="http://guides.rubyonrails.org/routing.html">http://guides.rubyonrails.org/routing.html</link></para>
        </listitem>

        <listitem>
          <para><link
          xlink:href="http://railscasts.com/episodes/203-routing-in-rails-3">http://railscasts.com/episodes/203-routing-in-rails-3</link></para>
        </listitem>

        <listitem>
          <para><link
          xlink:href="http://yehudakatz.com/2009/12/26/the-rails-3-router-rack-it-up/">http://yehudakatz.com/2009/12/26/the-rails-3-router-rack-it-up/</link></para>
        </listitem>

        <listitem>
          <para><link
          xlink:href="http://rizwanreza.com/2009/12/20/revamped-routes-in-rails-3">http://rizwanreza.com/2009/12/20/revamped-routes-in-rails-3</link></para>
        </listitem>
      </itemizedlist></para>
  </section>
</chapter>
