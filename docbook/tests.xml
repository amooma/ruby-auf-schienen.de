<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="testing" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="testing.title">Testing</title>

  <section xml:id="testing_einleitung">
    <title xml:id="testing_einleitung.title">Einleitung</title>

    <para>Ich programmiere seit über 20 Jahren und die meiste Zeit bin ich
    sehr gut ohne Testing zurecht gekommen. Ich bin Ihnen also nicht böse,
    wenn Sie dieses Kapitel überspringen. Sie können Rails-Applikationen auch
    ohne Tests erstellen und werden deshalb kein schlechtes Karma bekommen
    (hoffentlich, sicher kann man bei der Karma-Sache ja nie sein).</para>

    <para>Aber sollten Sie sich auf Test-Driven-Development (TDD) einlassen,
    so kann ich Ihnen versprechen, das es eine kleine Erleuchtung ist. Die
    Grundidee von TDD ist, das man für jede Programmfunktion einen Test
    schreibt, der diese Funktion überprüft. Ja, man hat initial doppelt so
    viel Aufwand. Aber danach kann man alle Tests durchlaufen lassen und
    sieht, das die Applikation genau so funktioniert, wie man es sich
    vorgestellt hat. Der Gag kommt aber erst nach ein paar Wochen oder
    Monaten, wenn man sich das Projekt wieder mal vornimmt und eine
    Erweiterung oder Veränderung schreibt. Dann kann man recht gefahrlos den
    Code verändern und danach die Funktionsweise anhand der Tests überprüfen.
    Es gibt dann kein "hmm... das ist jetzt dumm gelaufen, aber an diese
    Besonderheit habe ich nicht gedacht." mehr.</para>

    <note>
      <para>Testen ist wie Autofahren. Autofahren kann man auch nur beim
      Autofahren lernen.</para>
    </note>
  </section>

  <section xml:id="testing_beispiel_webshop">
    <title xml:id="testing_beispiel_webshop.title">Beispiel für einen User in
    einem Webshop</title>

    <para>Fangen wir mal mit einem User-Scaffold in einem imaginären Webshop
    an:<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new webshop</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd webshop</command>
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rails generate scaffold user login_name:string firstname:string lastname:string birthday:date</command>
      invoke  active_record
      create    db/migrate/20110526094713_create_users.rb
      create    app/models/user.rb
      invoke    test_unit
      create      test/unit/user_test.rb
      create      test/fixtures/users.yml
       route  resources :users
      invoke  scaffold_controller
      create    app/controllers/users_controller.rb
      invoke    erb
      create      app/views/users
      create      app/views/users/index.html.erb
      create      app/views/users/edit.html.erb
      create      app/views/users/show.html.erb
      create      app/views/users/new.html.erb
      create      app/views/users/_form.html.erb
      invoke    test_unit
      create      test/functional/users_controller_test.rb
      invoke    helper
      create      app/helpers/users_helper.rb
      invoke      test_unit
      create        test/unit/helpers/users_helper_test.rb
      create  app/assets/stylesheets/scaffold.css.scss
      invoke  assets
      create    app/assets/javascripts/users.js.coffee
      create    app/assets/stylesheets/users.css.scss
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake db:migrate</command>
==  CreateUsers: migrating ====================================================
-- create_table(:users)
   -&gt; 0.0016s
==  CreateUsers: migrated (0.0017s) ===========================================
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ 
</screen></para>

    <para>Sie kennen sich ja mit Scaffold aus (falls nicht, bitte erst <xref
    linkend="scaffolding" /> lesen) und wissen was die gerade erstellte
    Applikation macht. Sie haben auch gesehen, das Scaffold einige Tests
    angelegt hat (die sind immer leicht am Wort <code>test</code> im
    Dateinamen zu erkennen).</para>

    <para>Die komplete Test-Suite eines Rails-Projektes wird mit dem Befehl
    <command>rake test</command> abgearbeitet. Probieren wir mal aus, was ein
    Test an dieser Stelle der Entwicklung ausgibt:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004183 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     PASS should create user (0.10s) 
     PASS should destroy user (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     PASS should update user (0.01s) 

Finished in 0.216057 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Die Ausgabe <code>0 failures, 0 errors, 0 skips</code> sieht gut
    aus. Per Default läuft ein Test in einem Standard-Scaffold korrekt
    durch.</para>

    <para>Verändern wir mal die <filename>app/models/user.rb</filename> und
    fügen ein paar Validierungen (falls nicht ganz klar bitte <xref
    linkend="activerecord_validation" /> lesen) ein:<programlisting>class User &lt; ActiveRecord::Base
  # Die folgenden Felder muessen immer enthalten sein
  #
  validates_presence_of :login_name
  validates_presence_of :lastname
  validates_presence_of :birthday
  
  # Der login_name darf nur aus den Buchstaben a-z, Zahlen und den 
  # Sonderzeichen -._ bestehen
  #
  validates_format_of :login_name, :with =&gt; /[a-z0-9\-_.]+/i,
                      :message =&gt; "only characters, numbers and the special character -_. are allowed"
  
  # Der login_name muss mindestens eins der folgenden Sonderzeichen 
  # enthalten: -._
  #
  validates_format_of :login_name, :with =&gt; /^.*(?=.*[\-_.]).*$/,
                      :message =&gt; "must include at least one of the special characters -_."
  
  # User des Webshops muessen volljaehrig sein
  #
  validate :check_the_birthday
  
  private
  def check_the_birthday
    if self.birthday.nil? or Date.today &lt; self.birthday + 18.years
      errors.add(:birthday, "You have to be at least 18 years old.")
    end
  end
end
</programlisting></para>

    <para>Jetzt führen wir noch mal alles Tests durch:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004198 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     FAIL should create user (0.21s) 
          #&lt;Proc:0x00000100c87c50@/Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:49 (lambda)&gt; didn't change by 1.
&lt;3&gt; expected but was
&lt;2&gt;.
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:58:in `block in assert_difference'

     PASS should destroy user (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     FAIL should update user (0.02s) 
          Expected response to be a &lt;:redirect&gt;, but was &lt;200&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:45:in `assert_response'


Finished in 0.283337 seconds.

7 tests, 9 assertions, 2 failures, 0 errors, 0 skips
Errors running test:functionals!
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

    <para>Diesmal haben wir <code>2 failures</code>. Der Fehler passiert beim
    <code>should create user</code> und beim <code>should update user</code>.
    Scaffold muss also Beispieldaten angelegt haben, die beim ersten mal (ohne
    Validierungen) durchgelaufen sind und beim zweiten mal (mit Validierungen)
    nicht mehr.</para>

    <para>Diese Beispieldaten werden als sogennate Fixtures im YAML Format im
    Verzeichnis <filename>test/fixtures/</filename> angelegt. Schauen wir uns
    mal die Beispieldaten für <classname>User</classname> in der Datei
    <filename>test/fixtures/users.yml</filename> an:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: MyString
  firstname: MyString
  lastname: MyString
  birthday: 2011-05-26

two:
  login_name: MyString
  firstname: MyString
  lastname: MyString
  birthday: 2011-05-26
</programlisting></para>

    <para>Dort sind zwei Beispieldatensätze angelegt, die unserer Validierung
    nicht standhalten. Der <methodname>login_name</methodname> braucht
    mindestens ein Sonderzeichen und der User muss mindestens 18 Jahre alt
    sein. Ändern wir <code>login_name</code> und <code>birthday</code> in
    <filename>test/fixtures/users.yml</filename> entsprechend
    ab:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: My-String
  firstname: MyString
  lastname: MyString
  birthday: 1970-01-01

two:
  login_name: My-String
  firstname: MyString
  lastname: MyString
  birthday: 1970-01-01
</programlisting></para>

    <para>Ein <command>rake test</command> läuft jetzt wieder ohne Fehler
    durch:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004292 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     PASS should create user (0.11s) 
     PASS should destroy user (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     PASS should update user (0.01s) 

Finished in 0.229877 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ </screen></para>

    <para>Wir wissen jetzt, das in der
    <filename>test/fixtures/users.yml</filename> valide Daten stehen müssen,
    damit der mit Scaffold erstellte Standard-Test durchläuft. Aber auch nicht
    mehr. Ändern wir mal die <filename>test/fixtures/users.yml</filename> auf
    ein Minimum (wir brauchen keinen <code>firstname</code>) und mit für
    Menschen leichter lesbaren Daten ab:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
  birthday: 1970-01-01

two:
  login_name: emil.maier
  lastname: Maier
  birthday: 1950-01-01
</programlisting></para>

    <para>Sicherheitshalber nach der Veränderung noch mal ein <command>rake
    test</command> (das kann man gar nicht oft genug machen):<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test</command>
[...]
7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ </screen></para>

    <important>
      <para>Alle Fixtures werden beim Starten eines Tests in die Datenbank
      geladen. Besonders wenn man
      <methodname>validates_uniqueness_of</methodname> (siehe <xref
      linkend="validates_uniqueness_of" />) in der Validierung benutzt, muss
      man dies beim Test im Hinterkopf behalten.</para>
    </important>

    <section xml:id="testing_beispiel_webshop_functional_tests">
      <title
      xml:id="testing_beispiel_webshop_functional_tests.title">Functional
      Tests</title>

      <para>Schauen wir uns mal genau an, an welcher Stelle die ursprünglichen
      Fehler aufgetreten sind:<screen>UsersControllerTest:
     FAIL should create user (0.21s) 
          #&lt;Proc:0x00000100c87c50@/Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:49 (lambda)&gt; didn't change by 1.
&lt;3&gt; expected but was
&lt;2&gt;.
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/activesupport-3.1.0.rc1/lib/active_support/testing/assertions.rb:58:in `block in assert_difference'

     PASS should destroy user (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     FAIL should update user (0.02s) 
          Expected response to be a &lt;:redirect&gt;, but was &lt;200&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:45:in `assert_response'
</screen></para>

      <para>Im <code>UsersControllerTest</code> konnte der User nicht angelegt
      und nicht verändert werden. Die Controller-Tests befinden sich im
      Verzeichnis <filename>test/functional/</filename>. Schauen wir uns mal
      die Datei <filename>test/functional/users_controller_test.rb</filename>
      genau an:<programlisting>require 'test_helper'

class UsersControllerTest &lt; ActionController::TestCase
  setup do
    @user = users(:one)
  end

  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:users)
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should create user" do
    assert_difference('User.count') do
      post :create, user: @user.attributes
    end

    assert_redirected_to user_path(assigns(:user))
  end

  test "should show user" do
    get :show, id: @user.to_param
    assert_response :success
  end

  test "should get edit" do
    get :edit, id: @user.to_param
    assert_response :success
  end

  test "should update user" do
    put :update, id: @user.to_param, user: @user.attributes
    assert_redirected_to user_path(assigns(:user))
  end

  test "should destroy user" do
    assert_difference('User.count', -1) do
      delete :destroy, id: @user.to_param
    end

    assert_redirected_to users_path
  end
end
</programlisting></para>

      <para>Die verschiedenen Test-Namen kennen wir von der Bildschirmausgabe
      von <command>rake test</command>. Am Anfang finden wir eine
      <code>setup</code> Anweisung: <programlisting>  setup do
    @user = users(:one)
  end
</programlisting></para>

      <para>Diese drei Zielen Code bedeuten, das zum Start dieses Tests ein
      Instanz <varname>@user</varname> mit den Daten des Eintrages
      <code>one</code> aus der Datei
      <filename>test/fixtures/users.yml</filename> angelegt werden
      soll.</para>

      <important>
        <para>Bei jedem Test (also bei jedem Durchlauf von <command>rake
        test</command>) wird automatisch eine frische und damit leere
        Test-Datenbank angelegt. Das ist eine andere Datenbank als die auf die
        Sie per Default mit <command>rails console</command> zugreifen (das
        ist die Development-Datenbank). Die Datenbanken werden in der
        Konfigurationsdatei <filename>config/database.yml</filename>
        definiert. Auf die Test-Datenbank können Sie zu Debug-Zwecken mit
        <command>rails console test</command> zugreifen.</para>
      </important>

      <para>Danach werden in diesem Functional-Test verschiedene
      Web-Seiten-Funktionen getestet. Als erstes der Zugriff auf die
      Index-Seite:<programlisting>  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:users)
  end
</programlisting></para>

      <para>Der Befehl <code>get :index</code> ruft die Seite
      <uri>/users</uri> auf. <code>assert_response :success</code> bedeutet,
      das die Seite ausgeliefert wurde. Die Zeile <code>assert_not_nil
      assigns(:users)</code> stellt sicher, das die Instanz-Variable
      <varname>@users</varname> vom Controller nicht mit dem Wert
      <code>nil</code> zum View gegeben wird.<footnote>
          <para>Dabei wird hier das Symbol <varname>:users</varname> genommen,
          um sicher zu stellen, das <varname>@users</varname> in der zu
          testenden Controller-Klasse und nicht <varname>@users</varname> in
          der Test-Klasse genommen wird.</para>
        </footnote></para>

      <para>Schauen wir uns mal die beiden Probleme von vorhin genauer an. Als
      erstes <code>should create user</code>:<programlisting>  test "should create user" do
    assert_difference('User.count') do
      post :create, user: @user.attributes
    end

    assert_redirected_to user_path(assigns(:user))
  end
</programlisting></para>

      <para>Die <code>assert_difference('User.count') do ... end</code>
      Schleife erwartet eine Veränderung vom Anfang bis zum Ende der Schleife.
      <code>User.count</code> müsste am Anfang 1 ergeben und am Ende 2. Da wir
      aber in der ersten <filename>test/fixtures/users.yml</filename> Variante
      einen nicht gültigen Datensatz hatten ergab <code>User.count</code> am
      Anfang und am Ende 0. 0 und nicht 1 am Anfang, weil auch das <code>setup
      do ... end</code> nicht funktioniert haben kann.</para>

      <para>Die letzte Zeile <code>assert_redirected_to
      user_path(assigns(:user))</code> überprüft, ob nach einem neu angelegten
      Datensatz auch auf den entsprechenden <code>show</code> View geleitet
      wird.</para>

      <para>Den zweiten Fehler gab es bei <code>should update
      user</code>:<programlisting>  test "should update user" do
    put :update, id: @user.to_param, user: @user.attributes
    assert_redirected_to user_path(assigns(:user))
  end
</programlisting></para>

      <para>Hier sollte der Datensatz mit der <code>id</code> des
      <varname>@user</varname> Datensatzes mit den Attributen des
      <varname>@user</varname> Datensatzes geupdatet werden. Danach soll auch
      wieder der <code>show</code> View zu diesem Datensatz angezeigt werden.
      Logischweise ging dieser Test auch nicht, da a) der
      <varname>@user</varname> Datensatz gar nicht in der Datenbank existierte
      und b) er auch nicht geupdatet werden konnte, da er nicht valide
      war.</para>

      <para>Ohne jetzt auf jeden einzelnen Functional Test Zeile für Zeile
      einzugehen wird klar, was diese Tests machen: Sie führen echte Anfragen
      an das Web-Interface aus und können somit dazu benutzt werden die Views
      und die Controller zu testen.</para>

      <tip>
        <para>Mit <command>rake test:functionals</command> können Sie auch nur
        die Functional Tests im Verzeichnis
        <filename>test/functional/</filename> durchlaufen lassen.<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UsersControllerTest:
     PASS should create user (0.11s) 
     PASS should destroy user (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show user (0.01s) 
     PASS should update user (0.01s) 

Finished in 0.227522 seconds.

7 tests, 10 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$ </screen></para>
      </tip>
    </section>

    <section xml:id="testing_beispiel_webshop_unit_tests">
      <title>Unit Tests</title>

      <para>Zum Testen der Validierungen, die wir in
      <filename>app/models/user.rb</filename> eingetragen haben, sind Unit
      Tests besser geeignet. Diese testen nicht wie die Functional Tests die
      GUI und damit die Controller und die Views, sondern nur die
      Models.</para>

      <tip>
        <para>Mit <command>rake test</command> werden alle im Rails-Projekt
        vorhanden Tests ausgeführt. Mit <command>rake test:units</command>
        werden nur die Unit Tests im Verzeichnis
        <filename>test/unit/</filename> ausgeführt.</para>
      </tip>

      <para>Die Unit-Tests befinden sich im Verzeichnis
      <filename>test/unit/</filename>. Ein Blick in die Datei
      <filename>test/unit/user_test.rb</filename> ist aber
      ernüchternd:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  # test "the truth" do
  #   assert true
  # end
end
</programlisting></para>

      <para>Per Default schreibt Scaffold nur einen mit Kommentarzeichen
      deaktivierten Dummy-Test rein. Deshalb läuft <command>rake
      test:units</command> auch so inhaltslos durch:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

Finished in 0.004243 seconds.

0 tests, 0 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

      <para>Füllen wir den ersten Test in der
      <filename>test/unit/user_test.rb</filename> mit Leben:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
<emphasis>  test "an empty user is not valid" do
    assert !User.new.valid?
  end</emphasis>
end
</programlisting></para>

      <para>Dieser Test überprüft, ob eine neu angelegter
      <classname>User</classname>, der keine Daten enthält valide ist. Da
      <code>assert</code> nur auf <code>true</code> reagiert, habe ich vor
      <code>User.new.valid?</code> ein <code>!</code> gesetzt, um aus dem
      <code>false</code> ein <code>true</code> zu machen, denn ein leerer User
      kann ja nicht valide sein.</para>

      <para>Ein <command>rake test:units</command> läuft dann auch direkt
      durch:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS an empty user is not valid (0.07s) 

Finished in 0.075614 seconds.

1 tests, 1 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

      <para>Jetzt bauen wir zwei Asserts in einem Test ein, die überprüfen, ob
      die beiden Fixture-Einträge in der
      <filename>test/fixtures/users.yml</filename> auch valide
      sind:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  test "an empty user is not valid" do
    assert !User.new.valid?
  end
  
<emphasis>  test "the two fixture users are valide" do
    assert User.new(users(:one).attributes)
    assert User.new(users(:two).attributes)
  end
</emphasis>end</programlisting></para>

      <para>Danach wieder ein <command>rake test:units</command>:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS an empty user is not valid (0.07s) 
     PASS the two fixture users are valide (0.00s) 

Finished in 0.078738 seconds.

2 tests, 3 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

      <para>Jetzt erweitern wir <filename>test/unit/user_test.rb</filename> um
      einem Test, ob ein 17 jähriger User der morgen 18 wird nicht valide und
      ein User der heute 18 Jahre alt geworden ist valide ist:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  test "an empty user is not valid" do
    assert !User.new.valid?
  end
  
  test "the two fixture users are valide" do
    assert User.new(users(:one).attributes)
    assert User.new(users(:two).attributes)
  end
  
<emphasis>  test "a user who has tomorrow his 18th birthday is not valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years + 1.day
    assert !User.new(user.attributes).valid?
  end

  test "a user who has today his 18th birthday is valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years
    assert User.new(user.attributes).valid?
  end</emphasis>
end
</programlisting></para>

      <para>Der Test läuft sauber durch:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS a user who has today his 18th birthday is valid (0.04s) 
     PASS a user who has tomorrow his 18th birthday is not valid (0.00s) 
     PASS an empty user is not valid (0.01s) 
     PASS the two fixture users are valide (0.00s) 

Finished in 0.087012 seconds.

4 tests, 5 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

      <para>Was müssen wir noch testen? Ob bestimmte Attribute nicht nil sind.
      Dafür können wir einfach die folgende Schleife
      hinzufügen:<programlisting>  ['lastname', 'login_name', 'birthday'].each do |attribute_name|
    test "a user has to have a not nil #{attribute_name} attribute" do
      assert !User.new(users(:one).attributes.except(attribute_name)).valid?
    end
  end
</programlisting></para>

      <para>Mit zwei weiteren Tests für verschiedene valide und nicht valide
      <code>login_name</code> Werte sieht die
      <filename>test/unit/user_test.rb</filename> dann so aus:<programlisting>require 'test_helper'

class UserTest &lt; ActiveSupport::TestCase
  test "an empty user is not valid" do
    assert !User.new.valid?
  end
  
  test "the two fixture users are valide" do
    assert User.new(users(:one).attributes)
    assert User.new(users(:two).attributes)
  end
  
  test "a user who has tomorrow his 18th birthday is not valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years + 1.day
    assert !User.new(user.attributes).valid?
  end

  test "a user who has today his 18th birthday is valid" do
    user = users(:one)
    user.birthday = Date.today - 18.years
    assert User.new(user.attributes).valid?
  end

  ['lastname', 'login_name', 'birthday'].each do |attribute_name|
    test "a user has to have a not nil #{attribute_name} attribute" do
      assert !User.new(users(:one).attributes.except(attribute_name)).valid?
    end
  end
  
  ['hans.meier', 'hans-meier', 'h-meier', 'h_meier', 'h.meier2'].each do |valid_login_name|
    test "the login_name '#{valid_login_name}' is valid" do
      assert User.new(users(:one).attributes.except('login_name').merge({'login_name' =&gt; valid_login_name})).valid?
    end
  end

  ['hansmeier', 'hmeier', 'hmeier2'].each do |invalid_login_name|
    test "the login_name '#{invalid_login_name}' is invalid" do
      assert !User.new(users(:one).attributes.except('login_name').merge({'login_name' =&gt; invalid_login_name})).valid?
    end
  end
end</programlisting></para>

      <para>Der Durchlauf der Test-Suite zeigt die Ergebnisse:<screen>Stefan-Wintermeyers-MacBook-Air:webshop stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

UserTest:
     PASS a user has to have a not nil birthday attribute (0.07s) 
     PASS a user has to have a not nil lastname attribute (0.00s) 
     PASS a user has to have a not nil login name attribute (0.00s) 
     PASS a user who has today his 18th birthday is valid (0.00s) 
     PASS a user who has tomorrow his 18th birthday is not valid (0.00s) 
     PASS an empty user is not valid (0.00s) 
     PASS the login name 'h-meier' is valid (0.00s) 
     PASS the login name 'h.meier2' is valid (0.00s) 
     PASS the login name 'h meier' is valid (0.00s) 
     PASS the login name 'hans-meier' is valid (0.00s) 
     PASS the login name 'hans.meier' is valid (0.00s) 
     PASS the login name 'hansmeier' is invalid (0.00s) 
     PASS the login name 'hmeier' is invalid (0.00s) 
     PASS the login name 'hmeier2' is invalid (0.00s) 
     PASS the two fixture users are valide (0.00s) 

Finished in 0.099514 seconds.

15 tests, 16 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:webshop stefan$</screen></para>

      <para>Mit <command>rake test</command> könnten Sie jetzt alle Tests
      durchlaufen lassen.</para>
    </section>
  </section>

  <section xml:id="testing_fixtures">
    <title xml:id="testing_fixtures.title">Fixtures</title>

    <para>Mit Fixtures werden Beispieldaten für Tests generiert. Das
    Default-Format dafür ist YAML. Die Dateien dafür finden sich im
    Verzeichnis <filename>test/fixtures/</filename> und werden <command>rails
    generate</command> automatisch mit erstellt. Sie können aber natürlich
    auch eigene Dateien definieren. Alle Fixtures werden per Default bei jedem
    Test neu in die Test-Datenbank geladen.<footnote>
        <para>Beispiele für Alternativformate (z.B. CSV) dazu finden Sie unter
        <uri
        xlink:href="http://api.rubyonrails.org/classes/Fixtures.html">http://api.rubyonrails.org/classes/Fixtures.html</uri>.</para>
      </footnote></para>

    <section xml:id="statische_fixtures">
      <title xml:id="statische_fixtures.title">Statische Fixtures</title>

      <para>Die einfachste Variante für Fixtures sind statische Daten. Das in
      <xref linkend="testing_beispiel_webshop" /> benutze Fixture für
      <varname>person</varname> sieht statisch so aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
  birthday: 1970-01-01

two:
  login_name: emil.maier
  lastname: Maier
  birthday: 1950-01-01
</programlisting></para>

      <para>Man schreibt die Daten einfach im YAML-Format in die entsprechende
      Datei.</para>
    </section>

    <section xml:id="fixtures_mit_erb">
      <title xml:id="fixtures_mit_erb.title">Fixtures mit ERB</title>

      <para>Statische YAML Fixtures sind manchmal zu unintelligent. In diesen
      Fällen kann man mit ERB arbeiten (siehe <xref
      linkend="erb-programmieren" />). Das in <xref
      linkend="testing_beispiel_webshop" /> benutze Fixture sah statisch so
      aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
  birthday: 1970-01-01

two:
  login_name: emil.maier
  lastname: Maier
  birthday: 1950-01-01
</programlisting></para>

      <para>Wenn wir für die Geburtstage dynamisch den heutigen Tag vor 20
      Jahren eintragen möchten, so können wir das einfach mit ERB
      realisieren:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;</emphasis>

two:
  login_name: emil.maier
  lastname: Maier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;</emphasis></programlisting></para>

      <para>Wenn wir noch zusätzliche 100 Beispiel-User bräuchten, dann könnte
      wir das auch mit ein paar Zeilen ERB realisieren:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  login_name: horst_meier
  lastname: Meier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;</emphasis>

two:
  login_name: emil.maier
  lastname: Maier
<emphasis>  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;

&lt;% for i in 1..100 %&gt;
user_&lt;%= i %&gt;:
  login_name: person_&lt;%= 1 %&gt;
  lastname: Meyer
  birthday: &lt;%= 20.years.ago.to_s(:db) %&gt;
&lt;% end %&gt;</emphasis></programlisting></para>
    </section>

    <section xml:id="has_many_und_belongs_to_fixtures">
      <title xml:id="has_many_und_belongs_to_fixtures.title">has_many und
      belongs_to Fixtures</title>

      <para>Bei <methodname>has_many</methodname> und
      <methodname>belongs_to</methodname> Verbindungen müssen natürlich auch
      die Fixtures entsprechend geschrieben werden, sonst passen die Daten
      nicht zu einander.</para>

      <para>Nehmen wir einmal an, wir haben eine Telefonbuch Applikation mit
      Personen die beliebig viele Telefonnummern haben (siehe <xref
      linkend="activerecord_has_many" />):<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new phonebook</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd phonebook</command>
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails generate scaffold person firstname:string lastname:string</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails generate scaffold phone person_id:integer name:string number:string</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake db:migrate</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

      <para>In <filename>app/models/person.rb</filename>
      steht:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phones

  validates_presence_of :lastname
end</programlisting></para>

      <para>In <filename>app/models/phone.rb</filename> steht:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :person

  validates_presence_of :number
  validates_presence_of :person_id
  
  validate :person_exists

  private
  def person_exists 
    errors.add("person_id", "person is not existant") unless Person.exists?(self.person_id) 
  end   
end</programlisting></para>

      <section xml:id="has_many_und_belongs_to_fixtures_statisch">
        <title
        xml:id="has_many_und_belongs_to_fixtures_statisch.title">Statische
        Variante</title>

        <para>Wir können statische IDs von Hand vergeben. Dann sieht die
        <filename>test/fixtures/people.yml</filename> wie folgt
        aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  id: 1
  firstname: Horst
  lastname: Meier

two:
  id: 2
  firstname: Emil
  lastname: Obermeier
</programlisting></para>

        <para>Und in der <filename>test/fixtures/phones.yml</filename> werden
        die person_id Einträge passend zum Inhalt von
        <filename>test/fixtures/people.yml</filename> gesetzt:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  person_id: 1
  name: Handy
  number: 0171 1234567

two:
  person_id: 1
  name: Zu Hause
  number: 030 1234567
  
three:
  person_id: 2
  name: Handy
  number: 0172 9876543
</programlisting></para>

        <para>Die <filename>test/unit/person_test.rb</filename> enhält die
        Tests für <classname>Person</classname>:<programlisting>require 'test_helper'

class PersonTest &lt; ActiveSupport::TestCase
  test "the fixture people data are valid" do
    assert Person.new(people(:one).attributes).valid?
    assert Person.new(people(:two).attributes).valid?
  end
end
</programlisting></para>

        <para>Und <filename>test/unit/phone_test.rb</filename> enthält die
        Tests für <classname>Phone</classname>:<programlisting>require 'test_helper'

class PhoneTest &lt; ActiveSupport::TestCase
  test "the fixture phone entry data is valid" do
    assert Phone.new(phones(:one).attributes).valid?
    assert Phone.new(phones(:two).attributes).valid?
    assert Phone.new(phones(:three).attributes).valid?
  end
  
  test "a phone without a person is not valid" do
    phone = Phone.new(phones(:one).attributes)
    phone.person.destroy
    assert !phone.valid?
  end
end
</programlisting></para>

        <para>Ein <command>rake test:units</command> sagt, das alles OK
        ist:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PersonTest:
     PASS the fixture people data are valid (0.04s) 

PhoneTest:
     PASS a phone without a person is not valid (0.07s) 
     PASS the fixture phone entry data is valid (0.00s) 

Finished in 0.119441 seconds.

3 tests, 6 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>
      </section>

      <section xml:id="has_many_und_belongs_to_fixtures_label_referenz">
        <title
        xml:id="has_many_und_belongs_to_fixtures_label_referenz.title">Die
        Label Referenz Variante</title>

        <para>Eine etwas charmantere Alternative zu <xref
        linkend="has_many_und_belongs_to_fixtures_statisch" /> ist die
        Verwendung von Label Referenzen.</para>

        <para>Label sind die Namen für einzelne Fixtures. Damit sieht die
        <filename>test/fixtures/people.yml</filename> wie folgt
        aus:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

<emphasis>horst_meier:</emphasis>
  firstname: Horst
  lastname: Meier

<emphasis>emil_meier:</emphasis>
  firstname: Emil
  lastname: Obermeier
</programlisting></para>

        <para>In der <filename>test/fixtures/phones.yml</filename> verweisen
        wir jetzt nicht mehr auf die <varname>person_id</varname>, sondern auf
        das Label der <varname>person</varname>:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
<emphasis>  person: horst_meier</emphasis>
  name: Handy
  number: 0171 1234567

two:
<emphasis>  person: horst_meier</emphasis>
  name: Zu Hause
  number: 030 1234567
  
three:
<emphasis>  person: emil_meier</emphasis>
  name: Handy
  number: 0172 9876543</programlisting></para>

        <para>Die <filename>test/unit/person_test.rb</filename> enhält die
        Tests für Person:<programlisting>require 'test_helper'

class PersonTest &lt; ActiveSupport::TestCase
  test "the fixture people data are valid" do
    assert Person.new(people(:horst_meier).attributes).valid?
    assert Person.new(people(:emil_meier).attributes).valid?
  end
end
</programlisting></para>

        <para>Und <filename>test/unit/phone_test.rb</filename> ändert sich
        nicht:<programlisting>require 'test_helper'

class PhoneTest &lt; ActiveSupport::TestCase
  test "the fixture phone entry data is valid" do
    assert Phone.new(phones(:one).attributes).valid?
    assert Phone.new(phones(:two).attributes).valid?
    assert Phone.new(phones(:three).attributes).valid?
  end
  
  test "a phone without a person is not valid" do
    phone = Phone.new(phones(:one).attributes)
    phone.person.destroy
    assert !phone.valid?
  end
end
</programlisting></para>

        <para>Mit einem <command>rake test:units</command> können wir
        kontrollieren, ob alles korrekt ist:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake test:units</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PersonTest:
     PASS the fixture people data are valid (0.04s) 

PhoneTest:
     PASS a phone without a person is not valid (0.07s) 
     PASS the fixture phone entry data is valid (0.00s) 

Finished in 0.119441 seconds.

3 tests, 6 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="unit_tests">
    <title xml:id="unit_tests.title">Unit Tests</title>

    <para>In <xref linkend="testing_beispiel_webshop" /> wurde die Grundidee
    von Unit Tests erklärt. Es geht bei Unit Tests darum die Funktionsweise
    der Model zu testen. Also unabhängig von Controllern und Views. Alle Unit
    Tests werden im Verzeichnis <filename>test/unit/</filename> gespeichert.
    <command>rake generate</command> generiert automatisch diese Dateien. Sie
    können aber natürlich auch per Hand erstellt werden. Vor dem Ausführen der
    Tests wird die Test-Datenbank mit Test-Daten gefüllt (siehe <xref
    linkend="testing_fixtures" />).</para>

    <para>In der perfekten Welt würde man im Unit-Test alles Testen, das
    irgendwie schief gehen kann und zwar einmal mit einem Positiv- und einmal
    mit einem Negativ-Test. Das heißt man würde beispielsweise für jede
    Validierung mindestens ein Beispiel durchgehen, in dem jeweils ein
    korrekter und ein inkorrekter Datensatz geprüft wird. Das gleiche gilt für
    jede Methode des Models.</para>

    <para>Schauen wir uns noch mal die Datei
    <filename>test/unit/phone_test.rb</filename> aus <xref
    linkend="has_many_und_belongs_to_fixtures_label_referenz" />
    an:<programlisting>require 'test_helper'

class PhoneTest &lt; ActiveSupport::TestCase
  test "the fixture phone entry data is valid" do
    assert Phone.new(phones(:one).attributes).valid?
    assert Phone.new(phones(:two).attributes).valid?
    assert Phone.new(phones(:three).attributes).valid?
  end
  
  test "a phone without a person is not valid" do
    phone = Phone.new(phones(:one).attributes)
    phone.person.destroy
    assert !phone.valid?
  end
end
</programlisting></para>

    <para>Ein Test besteht also immer aus folgender Struktur:<programlisting>test "eine Behauptung" do
  assert etwas_ist_true_oder_false
end</programlisting></para>

    <para>Das Wort <code>assert</code> bedeutet in diesem Kontext behaupten
    oder feststellen. Es wird also eine Behauptung aufgestellt. Wenn diese
    Behauptung <code>true</code> ist, dann läuft der Test durch und alles ist
    OK. Wenn diese Behauptung <code>false</code> ist, schlägt der Test fehl
    und wir haben ein Fehler im Programm. Wenn Sie sich einmal auf <uri
    xlink:href="http://guides.rubyonrails.org/testing.html">http://guides.rubyonrails.org/testing.html</uri>
    umschauen, dann werden Sie sehen, das es noch ein paar andere
    <code>assert</code>-Varianten gibt:<itemizedlist>
        <listitem>
          <para><code>assert( boolean, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_equal( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_not_equal( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_same( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_not_same( obj1, obj2, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_nil( obj, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_not_nil( obj, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_match( regexp, string, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_no_match( regexp, string, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_in_delta( expecting, actual, delta, [msg]
          )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_throws( symbol, [msg] ) { block }</code></para>
        </listitem>

        <listitem>
          <para><code>assert_raise( exception1, exception2, ... ) { block
          }</code></para>
        </listitem>

        <listitem>
          <para><code>assert_nothing_raised( exception1, exception2, ... ) {
          block }</code></para>
        </listitem>

        <listitem>
          <para><code>assert_instance_of( class, obj, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_kind_of( class, obj, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_respond_to( obj, symbol, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_operator( obj1, operator, obj2, [msg]
          )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_send( array, [msg] )</code></para>
        </listitem>

        <listitem>
          <para><code>assert_difference(expressions, difference = 1, message =
          nil) {...}</code></para>
        </listitem>

        <listitem>
          <para><code>assert_no_difference(expressions, message = nil,
          &amp;block)</code></para>
        </listitem>

        <listitem>
          <para><code>assert_recognizes(expected_options, path, extras={},
          message=nil)</code></para>
        </listitem>

        <listitem>
          <para><code>assert_generates(expected_path, options, defaults={},
          extras = {}, message=nil)</code></para>
        </listitem>

        <listitem>
          <para><code>assert_response(type, message = nil)</code></para>
        </listitem>

        <listitem>
          <para><code>assert_redirected_to(options = {},
          message=nil)</code></para>
        </listitem>

        <listitem>
          <para><code>assert_template(expected = nil,
          message=nil)</code></para>
        </listitem>
      </itemizedlist></para>

    <para>Leider habe ich ein schlechtes Gedächnis und kann mir diese ganzen
    Spezialfälle nicht merken. Ist aber auch kein Problem, denn eigentlich
    kann man auch alles mit einem <code>assert</code> abdecken. Wenn ich also
    einen Spezialfall mit dem entsprechendem Spezial-assert abbilden will,
    dann muss ich es auf <uri
    xlink:href="http://guides.rubyonrails.org/testing.html">http://guides.rubyonrails.org/testing.html</uri>
    nachschlagen. Oder ich baue mir mit einem einfachen assert die gleiche
    Behauptung als false/true Szenario auf.</para>
  </section>

  <section xml:id="functional_tests">
    <title xml:id="functional_tests.title">Functional Tests</title>

    <para>In <xref linkend="testing_beispiel_webshop" /> wurde die Grundidee
    für Functional Tests erklärt. Es geht bei Functional Tests darum die
    Funktionsweise der Webseite zu testen. Dabei werden sowohl die Views wie
    auch die Controller zu den Views getestet. Der Befehl <command>rake
    test:functionals</command> führt während des Tests echte Abfragen auf die
    Rails-Application aus, die vorher mit Test-Daten gefüllt wurden (siehe
    <xref linkend="testing_fixtures" />) aus. Alle Functional Tests werden im
    Verzeichnis <filename>test/functional/</filename> gespeichert.
    <command>rake generate</command> generiert automatisch diese Dateien. Sie
    können aber natürlich auch per Hand erstellt werden.</para>

    <para>Das Grundgerüst für einen Functional Test sieht immer so
    aus:<programlisting>require 'test_helper'

class PeopleControllerTest &lt; ActionController::TestCase

  test "should get something" do
    get :something
    assert_response :success
  end

end</programlisting></para>

    <para>Die von <command>rails generate scaffold</command> automatisch
    erzeugten Functional Tests sind meistens eine sehr gute Ausgangsplattform.
    Diese kann man Schritt für Schritt erweitern. </para>

    <section xml:id="workflow_veraenderung_mit_functional_test">
      <title xml:id="workflow_veraenderung_mit_functional_test.title">Workflow
      für eine Veränderung im Functional-Test und im Controller</title>

      <para>Nehmen wir noch einmal eine Telefonbuch Applikation mit Personen
      die beliebig viele Telefonnummern haben (siehe <xref
      linkend="activerecord_has_many" />) als Grundlage:<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new phonebook</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd phonebook</command>
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails generate scaffold person firstname:string lastname:string</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rails generate scaffold phone person_id:integer name:string number:string</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake db:migrate</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

      <para>In <filename>app/models/person.rb</filename>
      steht:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phones

  validates_presence_of :lastname
end</programlisting></para>

      <para>In <filename>app/models/phone.rb</filename> steht:<programlisting>class Phone &lt; ActiveRecord::Base
  belongs_to :person

  validates_presence_of :number
  validates_presence_of :person_id
  
  validate :person_exists

  private
  def person_exists 
    errors.add("person_id", "person is not existant") unless Person.exists?(self.person_id) 
  end   
end</programlisting></para>

      <para>Für unsere Tests brauchen wir noch sinnvolle Beispieldaten. Die
      <filename>test/fixtures/people.yml</filename> füllen wir wie
      folgt:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  id: 1
  firstname: Horst
  lastname: Meier

two:
  id: 2
  firstname: Emil
  lastname: Obermeier
</programlisting></para>

      <para>Und in der <filename>test/fixtures/phones.yml</filename> werden
      die person_id Einträge passend zum Inhalt von
      <filename>test/fixtures/people.yml</filename> gesetzt:<programlisting># Read about fixtures at http://api.rubyonrails.org/classes/Fixtures.html

one:
  person_id: 1
  name: Handy
  number: 0171 1234567

two:
  person_id: 1
  name: Zu Hause
  number: 030 1234567
  
three:
  person_id: 2
  name: Handy
  number: 0172 9876543
</programlisting></para>

      <note>
        <para>Eigentlich sollten Sie jetzt noch die Unit Tests aus <xref
        linkend="has_many_und_belongs_to_fixtures" /> übernehmen.</para>
      </note>

      <para><command>rake generate scaffold</command> hat uns die beiden
      Functional Test Dateien <filename>people_controller_test.rb</filename>
      und <filename>phones_controller_test.rb</filename> automatisch erstellt.
      Diese Dateien bilden eine perfekte Grundlage für uns.</para>

      <para>Als erstes überprüfen wir, ob die Tests durchlaufen:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PeopleControllerTest:
     PASS should create person (0.11s) 
     PASS should destroy person (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show person (0.01s) 
     PASS should update person (0.01s) 

PhonesControllerTest:
     PASS should create phone (0.05s) 
     PASS should destroy phone (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.05s) 
     PASS should get new (0.01s) 
     PASS should show phone (0.01s) 
     PASS should update phone (0.01s) 

Finished in 0.357404 seconds.

14 tests, 20 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ </screen></para>

      <para>Schauen wir uns mal
      <filename>test/functional/people_controller_test.rb</filename>
      an:<programlisting>require 'test_helper'

class PeopleControllerTest &lt; ActionController::TestCase
  setup do
    @person = people(:one)
  end

  test "should get index" do
    get :index
    assert_response :success
    assert_not_nil assigns(:people)
  end

  test "should get new" do
    get :new
    assert_response :success
  end

  test "should create person" do
    assert_difference('Person.count') do
      post :create, person: @person.attributes
    end

    assert_redirected_to person_path(assigns(:person))
  end

  test "should show person" do
    get :show, id: @person.to_param
    assert_response :success
  end

  test "should get edit" do
    get :edit, id: @person.to_param
    assert_response :success
  end

  test "should update person" do
    put :update, id: @person.to_param, person: @person.attributes
    assert_redirected_to person_path(assigns(:person))
  end

  test "should destroy person" do
    assert_difference('Person.count', -1) do
      delete :destroy, id: @person.to_param
    end

    assert_redirected_to people_path
  end
end
</programlisting></para>

      <para>Wir möchten folgende Änderung in der Applikation vornehmen:
      Nachdem eine neue <classname>person</classname> anlegt wird, soll nicht
      <code>person#show</code> (<code>person_path</code>), sondern
      <code>person#index</code> (<code>people_path</code>) angesprungen
      werden. Es soll also nicht der eben gerade angelegte Datensatz einzelnd
      sondern alle Datensätze in einer Tabelle angezeigt werden. </para>

      <para>Dazu müssen wir folgenden Test ändern:<programlisting>  test "should create person" do
    assert_difference('Person.count') do
      post :create, person: @person.attributes
    end

    assert_redirected_to person_path(assigns(:person))
  end
</programlisting></para>

      <para>Und zwar muss der <code>assert_redirect_to</code> wie folgt
      geändert werden:<programlisting>  test "should create person" do
    assert_difference('Person.count') do
      post :create, person: @person.attributes
    end

    <emphasis>assert_redirected_to people_path</emphasis>
  end</programlisting></para>

      <para>Der Test wird natürlich jetzt einen Fehler ausgeben:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PeopleControllerTest:
     FAIL should create person (0.11s) 
          Expected response to be a redirect to &lt;http://test.host/people&gt; but was a redirect to &lt;http://test.host/people/3&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:74:in `assert_redirected_to'

     PASS should destroy person (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show person (0.01s) 
     PASS should update person (0.01s) 

PhonesControllerTest:
     PASS should create phone (0.05s) 
     PASS should destroy phone (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.05s) 
     PASS should get new (0.01s) 
     PASS should show phone (0.01s) 
     PASS should update phone (0.01s) 

Finished in 0.357209 seconds.

14 tests, 21 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:functionals
(See full trace by running task with --trace)
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>

      <para>Die Fehlermeldung <errortext>Expected response to be a redirect to
      &lt;http://test.host/people&gt; but was a redirect to
      &lt;http://test.host/people/3&gt;</errortext> ist dabei selbsterklärend.
      Wir müssen im Controller
      <filename>app/controllers/people_controller.rb</filename> die
      <methodname>create</methodname> Methode so verändern, das nach dem
      Anlegen des Datensatzes ein Redirect auf die <code>people_url</code>
      erfolgt:<programlisting>  def create
    @person = Person.new(params[:person])

    respond_to do |format|
      if @person.save
        <emphasis>format.html { redirect_to people_url }</emphasis>
        format.json { render json: @person, status: :created, location: @person }
      else
        format.html { render action: "new" }
        format.json { render json: @person.errors, status: :unprocessable_entity }
      end
    end
  end
</programlisting></para>

      <para>Jetzt läuft <command>rake test:functionals</command> wieder sauber
      durch:<screen>Stefan-Wintermeyers-MacBook-Air:phonebook stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

PeopleControllerTest:
     PASS should create person (0.11s) 
     PASS should destroy person (0.01s) 
     PASS should get edit (0.07s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show person (0.01s) 
     PASS should update person (0.01s) 

PhonesControllerTest:
     PASS should create phone (0.08s) 
     PASS should destroy phone (0.01s) 
     PASS should get edit (0.01s) 
     PASS should get index (0.01s) 
     PASS should get new (0.01s) 
     PASS should show phone (0.01s) 
     PASS should update phone (0.01s) 

Finished in 0.349060 seconds.

14 tests, 20 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:phonebook stefan$</screen></para>
    </section>

    <section>
      <title>Flash-Nachrichten testen</title>

      <para>Mit Funktional-Tests kann man auch die Übergabe und das Anzeigen
      von Flash-Nachrichten (siehe <xref linkend="flash" />) überprüfen. Ich
      zeige Ihnen das mal an einer kleinen Ping-Pong
      Rails-Applikation:<screen>Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>rails new ping-pong</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ stefan$ <command>cd ping-pong</command>
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>rails generate controller Home ping pong</command>
      create  app/controllers/home_controller.rb
       route  get "home/pong"
       route  get "home/ping"
      invoke  erb
      create    app/views/home
      create    app/views/home/ping.html.erb
      create    app/views/home/pong.html.erb
      invoke  test_unit
      create    test/functional/home_controller_test.rb
      invoke  helper
      create    app/helpers/home_helper.rb
      invoke    test_unit
      create      test/unit/helpers/home_helper_test.rb
      invoke  assets
      create    app/assets/javascripts/home.js.coffee
      create    app/assets/stylesheets/home.css.scss
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>rake db:migrate</command>
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$</screen></para>

      <para>Ziel der Applikation soll es sein, beim Aufruf der Seite
      <uri>/home/ping</uri> auf die Seite <uri>/home/pong</uri> umgeleitet zu
      werden und eine Flashnachricht "<code>Sie wurden von Ping nach Pong
      umgeleitet.</code>" zu sehen. Wenn man direkt <uri>/home/pong</uri>
      öffnet wird keine Flash-Nachricht angezeigt.</para>

      <para>Der von <command>rails generate controller Home ping
      pong</command> generiete Standardtest in der Datei
      <filename>test/functional/home_controller_test.rb</filename> sieht so
      aus:<programlisting>require 'test_helper'

class HomeControllerTest &lt; ActionController::TestCase
  test "should get ping" do
    get :ping
    assert_response :success
  end

  test "should get pong" do
    get :pong
    assert_response :success
  end

end
</programlisting></para>

      <para>Als erstes ändern wir den "<code>should get ping</code>" Test so
      ab, das ein Redirect auf <uri>/home/pong</uri> erwartet
      wird:<programlisting>require 'test_helper'

class HomeControllerTest &lt; ActionController::TestCase
<emphasis>  test "ping should be redirected to pong" do
    get :ping
    assert_redirected_to home_pong_url
  end</emphasis>

  test "should get pong" do
    get :pong
    assert_response :success
  end

end
</programlisting></para>

      <para>Ein <command>rake test:functionals</command> Lauf zeigt das
      erwartete Ergebenis:<screen>Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     FAIL ping should be redirected to pong (0.09s) 
          Expected response to be a &lt;:redirect&gt;, but was &lt;200&gt;
          /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/actionpack-3.1.0.rc1/lib/action_dispatch/testing/assertions/response.rb:45:in `assert_response'

     PASS should get pong (0.00s) 

Finished in 0.096260 seconds.

2 tests, 2 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:functionals
(See full trace by running task with --trace)
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$</screen></para>

      <para>Die Rails-Applikation hat die Seite <uri>/home/ping</uri> ganz
      normal mit einem HTTP-Code 200 (erfolgreich) ausgeliefert. Da der
      erwartete Redirect nicht stattgefunden hat, wird dies als Fehler
      (<code>FAIL</code>) angezeigt.</para>

      <para>Ändern wir mal den Controller in der Datei
      <filename>app/controllers/home_controller.rb</filename> so ab, das ein
      Redirect ausgeführt wird:<programlisting>class HomeController &lt; ApplicationController
  def ping
    redirect_to home_pong_url
  end

  def pong
  end

end
</programlisting></para>

      <para>Damit läuft der Test problemlos durch:<screen>Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     PASS ping should be redirected to pong (0.04s) 
     PASS should get pong (0.05s) 

Finished in 0.095929 seconds.

2 tests, 2 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ </screen></para>

      <para>Es fehlt aber noch die "<code>Sie wurden von Ping nach Pong
      umgeleitet.</code>" Flash-Meldung. Erweitern wir den Test
      entsprechend:<programlisting>require 'test_helper'

class HomeControllerTest &lt; ActionController::TestCase
  test "ping should be redirected to pong" do
    get :ping
    assert_redirected_to home_pong_url
    <emphasis>assert_equal 'Sie wurden von Ping nach Pong umgeleitet.', flash[:notice]</emphasis>
  end

  test "should get pong" do
    get :pong
    assert_response :success
  end

end
</programlisting></para>

      <para>Erwartungsgemäß liefert er einen Fehler:<screen>Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     FAIL ping should be redirected to pong (0.04s) 
          &lt;"Sie wurden von Ping nach Pong umgeleitet."&gt; expected but was
&lt;nil&gt;.
          /Users/stefan/ping-pong/test/functional/home_controller_test.rb:7:in `block in &lt;class:HomeControllerTest&gt;'

     PASS should get pong (0.05s) 

Finished in 0.097190 seconds.

2 tests, 3 assertions, 1 failures, 0 errors, 0 skips
rake aborted!
Command failed with status (1): [/Users/stefan/.rvm/rubies/ruby-1.9.2-p180/...]

Tasks: TOP =&gt; test:functionals
(See full trace by running task with --trace)
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$</screen></para>

      <para>Erweitern wir den Controller:<programlisting>class HomeController &lt; ApplicationController
  def ping
    <emphasis>redirect_to home_pong_url, :notice =&gt; 'Sie wurden von Ping nach Pong umgeleitet.'</emphasis>
  end

  def pong
  end

end
</programlisting></para>

      <para>Der Test läuft sauber durch:<screen>Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$ <command>rake test:functionals</command>
Loaded suite /Users/stefan/.rvm/gems/ruby-1.9.2-p180/gems/rake-0.9.0/lib/rake/rake_test_loader
Started

HomeControllerTest:
     PASS ping should be redirected to pong (0.04s) 
     PASS should get pong (0.05s) 

Finished in 0.094714 seconds.

2 tests, 3 assertions, 0 failures, 0 errors, 0 skips
Stefan-Wintermeyers-MacBook-Air:ping-pong stefan$</screen></para>

      <para>Die Sache hat aber noch einen Hacken: Starten Sie einmal mit
      <command>rails server</command> die Applikation und gehen Sie mit Ihrem
      Browser auf <uri
      xlink:href="http://0.0.0.0:3000/home/ping">http://0.0.0.0:3000/home/ping</uri>.
      Sie werden korrekt auf <uri
      xlink:href="http://0.0.0.0:3000/home/pong">http://0.0.0.0:3000/home/pong</uri>
      umgeleitet, sehen aber keine Flash-Nachricht. Diese wird im Controller
      <filename>app/controllers/home_controller.rb</filename> korrekt
      definiert, aber im View
      <filename>app/views/home/pong.html.erb</filename> nicht
      angezeigt.</para>

      <para></para>
    </section>
  </section>
</chapter>
