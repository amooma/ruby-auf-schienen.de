<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_polymorphic"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_polymorphic.title">Polymorphe Assoziationen
  (polymorphic associations)</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Polymorphic Associations</secondary>
  </indexterm>

  <para>Schon das Wort "polymorph" lässt einen angespannt werden. Was mag
  damit gemeint sein? Auf <uri
  xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
  steht dazu: <quote>Polymorphic associations on models are not restricted on
  what types of models they can be associated with.</quote> Na, das ist ja
  jetzt klar wir Kloßbrühe! ;-)</para>

  <para>Ein Beispiel! Nehmen wir an, dass wir zu den Personen und den
  Telefonnummern in unserer Applikation Kommentare einbauen wollen. Und zwar
  beliebig viele Kommentare (Comment). Mit dem Wissen aus <xref
  linkend="activerecord_has_many_through" /> könnten wir uns zwei Modelle
  anlegen und jeweils eine <methodname>has_many</methodname>-Verbindung zu
  <classname>Person</classname> oder zu <classname>Phonenumber</classname>
  aufbauen. Bei zweien würde das sogar noch halbwegs praktikabel sein. Aber
  stellen Sie sich mal vor, Sie hätten gerne bei mehr Daten solche Kommentare.
  Dafür jedesmal ein eigenes <foreignphrase
  xml:lang="en">Model</foreignphrase> bauen? Genau da kommt die <foreignphrase
  xml:lang="en">Polymorphic Association</foreignphrase> zum Tragen. Damit
  können Sie ein <foreignphrase xml:lang="en">Model</foreignphrase>
  <classname>Comment</classname> mit beliebig vielen anderen Modellen
  verknüpfen.</para>

  <para>Erstellen wir erst mal das <foreignphrase
  xml:lang="en">Model</foreignphrase> <classname>Comment</classname>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model Comment commentable_type:string commentable_id:integer comment:string</command>
      invoke  active_record
      create    db/migrate/20101011084411_create_comments.rb
      create    app/models/comment.rb
      invoke    test_unit
      create      test/unit/comment_test.rb
      create      test/fixtures/comments.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0013s
==  CreateComments: migrated (0.0013s) ========================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <para>Das Suffix <quote><foreignphrase
  xml:lang="en">able</foreignphrase></quote> (<replaceable>…</replaceable>bar)
  beim Namen <quote><foreignphrase
  xml:lang="en">commentable</foreignphrase></quote> (kommentierbar) ist
  Rails-üblich, muss aber nicht sein. Wir brauchen ja zum Verknüpfen jetzt
  nicht nur die ID des Eintrags, sondern müssen auch noch wissen, um welches
  <foreignphrase xml:lang="en">Model</foreignphrase> es sich eigentlich
  handelt. Da macht der Begriff <quote><foreignphrase
  xml:lang="en">commentable_type</foreignphrase></quote> halbwegs Sinn.</para>

  <para>Jetzt müssen wir in <filename>app/models/comment.rb</filename>
  folgenden Eintrag machen:<programlisting>class Comment &lt; ActiveRecord::Base
  belongs_to :commentable, :polymorphic =&gt; true
end</programlisting></para>

  <para>Jetzt den Eintrag in
  <filename>app/models/person.rb</filename><programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

  <para>Und noch den Eintrag in
  <filename>app/models/phonenumber.rb</filename><programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

  <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
  brauchbaren Testdaten an:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

  <para>Die Datenbank löschen und neu mit der <filename>db/seeds.rb</filename>
  befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("comments", {:force=&gt;true})
   -&gt; 0.0053s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0058s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0067s
-- initialize_schema_migrations_table()
   -&gt; 0.0004s
-- assume_migrated_upto_version(20101011084411, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <para>Gehen wir mal in die <foreignphrase
  xml:lang="en">Console</foreignphrase> und versuchen mal zwei Kommentare zu
  Herrn Fritz Meier anzulegen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 09:00:51", updated_at: "2010-10-11 09:00:51"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; <command>fritz.comments.create( :comment =&gt; 'Ein Beispiel' )</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.create( :comment =&gt; 'Noch ein Beispiel' )</command>
 =&gt; #&lt;Comment id: 2, commentable_type: "Person", commentable_id: 1, comment: "Noch ein Beispiel", created_at: "2010-10-11 09:07:44", updated_at: "2010-10-11 09:07:44"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 2 

ruby-1.9.2-p0 &gt; </screen></para>

  <para>Das funktioniert also. Schauen wir uns mal den ersten Kommentar
  an:<screen>ruby-1.9.2-p0 &gt; <command>Comment.first</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 

ruby-1.9.2-p0 &gt; </screen></para>

  <para>Alles logisch. Alles gut. Aber so wie ich Sie einschätze wollen Sie
  jetzt auch sehen wie das mit Telefonnummern geht. Kein Problem:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create( :comment =&gt; 'Und wieder ein Beispiel.' )</command>
 =&gt; #&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create( :comment =&gt; 'xyz Beispiel' )</command>
 =&gt; #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments</command>
 =&gt; [#&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt;, #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

  <note>
    <para><foreignphrase xml:lang="en">Polymorphic
    Associations</foreignphrase> sind sehr praktisch. Man sollte aber auch
    immer daran denken, dass sie mehr Last auf der Datenbank erzeugen als eine
    normale 1:n-Verknüpfung. Normalerweise macht das den Bock nicht fett, aber
    man sollte es bei der Planung im Hinterkopf haben.</para>
  </note>
</section>
