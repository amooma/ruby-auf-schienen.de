<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="rails_production_webserver"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="rails_production_webserver.title">Webserver im
  Produktionsbetrieb</title>

  <indexterm>
    <primary>Webserver</primary>

    <secondary>Production</secondary>
  </indexterm>

  <indexterm>
    <primary>Nginx</primary>
  </indexterm>

  <indexterm>
    <primary>Unicorn</primary>
  </indexterm>

  <section xml:id="production_webserver_einleitung">
    <title xml:id="production_webserver_einleitung.title">Einleitung</title>

    <para>Im Rest des Buches arbeiten wir immer mit dem Entwicklungssystem.
    Dazu starten wir Rails mit <command>rails server</command>. Schauen wir
    uns die Ausgabe noch mal genau an:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.6 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-07-09 12:19:40] INFO  WEBrick 1.3.1
[2012-07-09 12:19:40] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-07-09 12:19:40] INFO  WEBrick::HTTPServer#start: pid=86773 port=3000</screen></para>

    <para>Die zweite Zeile sagt aus, das wir im "development" Modus sind und
    das die Applikation unter der URL <uri
    xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri> erreichbar ist.
    Als Webserver wird dabei WEBrick verwendet (siehe <uri
    xlink:href="http://de.wikipedia.org/wiki/WEBrick">http://de.wikipedia.org/wiki/WEBrick</uri>).
    WEBrick ist ein sehr einfacher HTTP Webserver und Bestandteil der Ruby
    Standardbibliothek. WEBrick ist aber nur zur Entwicklung geeignet.</para>

    <para>Für ein Produktivsystem nimmt man normalerweise einen Standard
    Webserver wie Apache, lighttpd oder Nginx, der als Reverse-Proxy und
    Loadbalancer zum Rails-System agiert. Das Rails-System wird dann aber
    nicht vom langsamen WEBrick betrieben, sondern von performanten Lösungen
    wie Unicorn (<uri
    xlink:href="http://unicorn.bogomips.org/">http://unicorn.bogomips.org/</uri>),
    Mongrel (<uri
    xlink:href="http://de.wikipedia.org/wiki/Mongrel">http://de.wikipedia.org/wiki/Mongrel</uri>),
    Thin (<uri
    xlink:href="http://code.macournoyer.com/thin/">http://code.macournoyer.com/thin/</uri>)
    oder Puma (<uri
    xlink:href="http://puma.io/">http://puma.io/</uri>).</para>

    <para>Bei einem typischen PHP-Projekt reicht es den PHP-Code einfach in
    ein bestimmtes Verzeichnis zu legen und in 9 von 10 Fällen kann der zur
    Verfügung stehende Apache-Webserver bereits PHP Code automatisch
    abarbeiten (das entsprechende Modul ist fast immer installiert). Bei Rails
    sieht es leider anders aus. Die Hürden sind wesentlich höher und des
    Aufwand größer. Es gibt eine grosse Menge an möglichen Kombinationen (z.B.
    "Apache, lighttpd oder Nginx?" und "Unicorn, Thin, Puma oder Mongrel?").
    Es ist unmöglich alle Varianten hier detailiert zu beschreiben. Ich habe
    mich für meine Lieblingskombination von Nginx und Unicorn entschieden.
    Dies heißt aber nicht, das andere Kombinationen schlechter sind. Es ist
    eine subjektive Wahl.</para>

    <section xml:id="production_webserver_debian6">
      <title xml:id="production_webserver_debian6.title">Debian 6</title>

      <para>Wir setzen unseren Produktions-Webserver auf einem minimalen
      Debian 6 System auf.</para>

      <note>
        <para>Diese Beschreibung setzt ein frisch installiertes Debian
        GNU/Linux 6.0 (<quote>Squeeze</quote>) voraus. Ein ISO-Image für die
        Installation finden Sie auf <uri
        xlink:href="http://www.debian.org/releases/squeeze/debian-installer/">http://www.debian.org/releases/squeeze/debian-installer/</uri>.
        Ich empfehle das etwa 160 MByte große Netzinstallations-CD-Image. Eine
        Debian-GNU/Linux-Installationsanleitung findet sich unter <uri
        xlink:href="http://www.debian.org/releases/squeeze/i386/">http://www.debian.org/releases/squeeze/i386/</uri>;
        ein allgemeines Anwenderhandbuch unter <uri
        xlink:href="http://debiananwenderhandbuch.de">http://debiananwenderhandbuch.de</uri>.</para>
      </note>

      <para>Ruby 1.9.3 installieren wir per RVM mit dem neuen User
      <code>deployer</code>. Die von uns benutze Rails-Applikation heißt
      <code>blog</code>.</para>

      <important>
        <para>Zum Durchführen dieser Installation benötigen Sie Root-Rechte
        auf dem Webserver!</para>
      </important>
    </section>
  </section>

  <section xml:id="deployment_grundinstallation_webserver">
    <title
    xml:id="deployment_grundinstallation_webserver.title">Grundinstallation
    Webserver</title>

    <para>Bitte loggen Sie sich als <code>root</code> auf dem Webserver
    ein.</para>

    <section xml:id="deployment_grundinstallation_webserver_buildsystem">
      <title
      xml:id="deployment_grundinstallation_webserver_buildsystem.title">Buildsystem</title>

      <para>Als erstes installieren wir ein paar Pakete die wir
      brauchen.<screen>root@debian:~# <command>apt-get -y install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion python</command>
[...]
root@debian:~# </screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_nodejs">
      <title
      xml:id="deployment_grundinstallation_webserver_nodejs.title">Node.js</title>

      <para>Zum optimalen Einsatz der Asset Pipeline installieren wir Node.js.
      Bitte gehen Sie dafür auf die Homepage von Node.js (<uri
      xlink:href="http://nodejs.org/">http://nodejs.org/</uri>), suchen Sie
      dort nach dem aktuellen stabilen Release und passen Sie die hier
      angegebenen Kommandos entsprechend an.<screen>root@debian:~# <command>cd /usr/src</command>
root@debian:/usr/src# <command>wget http://nodejs.org/dist/v0.8.1/node-v0.8.1.tar.gz</command>
[...]
root@debian:/usr/src# <command>tar xzf node-v0.8.1.tar.gz</command> 
root@debian:/usr/src# <command>cd node-v0.8.1</command>
root@debian:/usr/src/node-v0.8.1# <command>./configure</command> 
[...]
root@debian:/usr/src/node-v0.8.1# <command>make</command>
[...]
root@debian:/usr/src/node-v0.8.1# <command>make install</command>
[...]
root@debian:/usr/src/node-v0.8.1# <command>cd</command>
[...]
root@debian:~# </screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_nginx">
      <title
      xml:id="deployment_grundinstallation_webserver_nginx.title">nginx</title>

      <para>Nginx wird unser Webserver zur Aussenwelt. Er fungiert als Proxy
      und Loadbalancer. Da in der Debian-Distribution eine recht alte
      Nginx-Version vertrieben wird, installieren wir die von Nginx direkt
      vertriebenen Pakete hinzu.<screen>root@debian:~# <command>curl http://nginx.org/keys/nginx_signing.key | apt-key add -</command>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1561  100  1561    0     0   3887      0 --:--:-- --:--:-- --:--:--  8819
OK
root@debian:~# <command>echo 'deb http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>echo 'deb-src http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>apt-get update</command>
[...]
root@debian:~# <command>apt-get -y install nginx</command>
[...]
root@debian:~# </screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_deployer_anlegen">
      <title
      xml:id="deployment_grundinstallation_webserver_deployer_anlegen.title">User
      Deployer anlegen</title>

      <para>Unser Rails-Projekt wird innerhalb eines mit RVM im User-Space
      installierten Ruby und Rails laufen. Dafür erstellen wir einen neuen
      User mit dem Namen <code>deployer</code>:<screen>root@debian:~# <command>adduser deployer</command>
Lege Benutzer »deployer« an ...
Lege neue Gruppe »deployer« (1002) an ...
Lege neuen Benutzer »deployer« (1002) mit Gruppe »deployer« an ...
Erstelle Home-Verzeichnis »/home/deployer« ...
Kopiere Dateien aus »/etc/skel« ...
Geben Sie ein neues UNIX-Passwort ein: 
Geben Sie das neue UNIX-Passwort erneut ein: 
passwd: Passwort erfolgreich geändert
Benutzerinformationen für deployer werden geändert.
Geben Sie einen neuen Wert an oder drücken Sie ENTER für den Standardwert
 Vollständiger Name []: Deployer
 Raumnummer []: 
 Telefon geschäftlich []: 
 Telefon privat []: 
 Sonstiges []: 
Sind die Informationen korrekt? [J/n] J
root@debian:~#</screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_verzeichnisstruktur_anlegen">
      <title
      xml:id="deployment_grundinstallation_webserver_verzeichnisstruktur_anlegen.title">Verzeichnisstruktur
      anlegen</title>

      <para>Jetzt legen wir ein Verzeichnis <filename>/var/www</filename> an
      und setzten die Rechte dafür:<screen>root@debian:~# <command>mkdir -p /var/www</command>
root@debian:~# <command>usermod -a -G www-data nginx</command>
root@debian:~# <command>usermod -a -G www-data deployer</command>
root@debian:~# <command>chgrp -R www-data /var/www</command>
root@debian:~# <command>chmod -R 775 /var/www</command>
root@debian:~#</screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_rails_umgebung_deployer">
      <title
      xml:id="deployment_grundinstallation_webserver_rails_umgebung_deployer.title">Rails-Umgebung
      für den User Deployer aufsetzen</title>

      <para>Weiter geht es mit dem User <code>deployer</code>:<screen>root@debian:~# <command>su - deployer</command>
deployer@debian:~$ </screen></para>

      <para>Bitte führen Sie als User <code>deployer</code> die in <xref
      linkend="rails3-install-debian"/> aufgeführten Schritte zur Installation
      von Ruby 1.9.3 und Rails 3.2 per rvm aus. Hier ist die
      Ein-Zeilen-Cut-and-Paste-Kurzversion:<screen>deployer@debian:~$ <command>curl -L https://get.rvm.io | bash -s stable &amp;&amp; source ~/.rvm/scripts/'rvm' &amp;&amp; rvm install 1.9.3 &amp;&amp; gem install rails</command>
[...]
deployer@debian:~$</screen></para>

      <para>Um Unicorn mit der RVM Umgebung aus einen Init.d Skript starten zu
      können, müssen wir jetzt noch einen entsprechenden Wrapper
      generieren:<screen>deployer@debian:~$ <command>gem install unicorn</command>
[...]
deployer@debian:~$ <command>rvm wrapper 1.9.3 bootup unicorn</command>
deployer@debian:~$ <command>exit</command>
root@debian:~$</screen></para>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_datenbank">
      <title
      xml:id="deployment_grundinstallation_webserver_datenbank.title">Datenbank</title>

      <para>Meistens will man in einem Produktivsystem eine "große" Datenbank
      wie PostgreSQL oder MySQL. Deshalb hier noch die Anleitung wie man eine
      MySQL-Datenbank auf diesem System installieren kann und welche
      Anpassungen man im Rails-Projekt vornehmen muss.</para>

      <section xml:id="deployment_grundinstallation_webserver_mysql_installation">
        <title
        xml:id="deployment_grundinstallation_webserver_mysql_installation.title">MySQL
        Installation</title>

        <para>Als nächstes installieren wir die Datenbank MySQL. Dabei werden
        Sie nach einem Datenbankpasswort gefragt. Bitte merken Sie sich dieses
        Passwort. Damit kann sich später <code>root</code> auf der Datenbank
        einlogen.<screen>root@debian:~# <command>apt-get -y install mysql-server libmysql-ruby libmysqlclient-dev</command>
[...]
root@debian:~# </screen></para>
      </section>

      <section xml:id="deployment_grundinstallation_webserver_create_database">
        <title
        xml:id="deployment_grundinstallation_webserver_create_database.title">Datenbank
        mit Rechten anlegen</title>

        <para>In der MySQL-Datenbank müssen wir die Datenbank
        <code>blog</code> mit Zugriffsrechten für den User
        <code>deployer</code> anlegen:<screen>deployer@debian:~$ <command>mysql -u root -p</command>
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 40
Server version: 5.1.63-0+squeeze1 (Debian)

Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; <command>CREATE DATABASE blog;</command>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <command>GRANT USAGE ON *.* TO deployer@localhost IDENTIFIED BY 'IhrLieblingsPasswort';</command>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <command>GRANT ALL PRIVILEGES ON blog.* TO deployer@localhost;</command>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <command>exit</command>;
Bye
deployer@debian:~$</screen></para>
      </section>
    </section>

    <section xml:id="deployment_grundinstallation_webserver_memcached">
      <title
      xml:id="deployment_grundinstallation_webserver_memcached.title">Memcache
      installieren</title>

      <para>Wer mit einem Cache-Server arbeitet (was sehr zu empfehlen ist),
      der muss natürlich noch eine entsprechende Software installieren. Bei
      memcached (<uri
      xlink:href="http://memcached.org/">http://memcached.org/</uri>) wären
      das die folgende Eingabe:<screen>root@debian:~# <command>apt-get -y install memcached</command>
[...]
root@debian:~#</screen></para>
    </section>
  </section>

  <section xml:id="webserver_ohne_deployment">
    <title xml:id="webserver_ohne_deployment.title">Webserver ohne
    Deployment</title>

    <para>Bitte loggen Sie sich als <code>root</code> auf dem Webserver
    ein.</para>

    <warning>
      <para>Bitte beachten Sie bei der Verwendung dieser
      Installationsanleitung für andere Rails-Projekte, das der Name "blog"
      (für die jeweilige Rails-Applikation) in allen Konfigurationsdateien und
      Skripten mit dem jeweiligen Projektnamen ersetzt werden muss.</para>
    </warning>

    <section xml:id="webserver_ohne_deployment_neues_rails_projekt">
      <title
      xml:id="webserver_ohne_deployment_neues_rails_projekt.title">Neues
      Rails-Projekt aufsetzen</title>

      <para>Um diese Anleitung zu einfach wie möglich zu halten, erstellen wir
      als User <code>deployer</code> ein einfaches Blog direkt auf dem
      Server.<screen>root@debian:~# <command>su - deployer</command>
deployer@debian:~$ <command>rails new blog</command>
[...]
deployer@debian:~$ <command>cd blog</command>
deployer@debian:~/blog$ <command>rails generate scaffold post subject content:text</command>
[...]
deployer@debian:~/blog$</screen></para>

      <section>
        <title>Gemfile anpassen</title>

        <para>Bitte schreiben Sie in die Datei <filename>Gemfile</filename>
        folgenden Inhalt:<programlisting>source 'https://rubygems.org'

gem 'rails', '3.2.6'

gem 'sqlite3'

# Gems used only for assets and not required
# in production environments by default.
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'

  # See https://github.com/sstephenson/execjs#readme for more supported runtimes
  # gem 'therubyracer', :platforms =&gt; :ruby

  gem 'uglifier', '&gt;= 1.0.3'
end

gem 'jquery-rails'

# To use ActiveModel has_secure_password
# gem 'bcrypt-ruby', '~&gt; 3.0.0'

group :production do
  # Use MySQL as the production database
  gem 'mysql'

  # Use unicorn as the app server
  gem 'unicorn'
end
</programlisting></para>

        <para>Danach mit <command>bundle install</command> alle Gems
        installieren:<screen>deployer@debian:~/blog$ <command>bundle install</command>
[...]
deployer@debian:~/blog$</screen></para>
      </section>

      <section xml:id="production_webserver_database_yml">
        <title xml:id="production_webserver_database_yml.title">Production
        Datenbank Konfiguration</title>

        <para>In der Datei <filename>config/database.yml</filename> müssen wir
        für das Produktionssystem die Datenbankkonfiguration für die
        MySQL-Datenbank eintragen. Bitte achten Sie darauf das korrekte
        Passwort einzutragen.<programlisting># SQLite version 3.x
#   gem install sqlite3
#
#   Ensure the SQLite 3 gem is defined in your Gemfile
#   gem 'sqlite3'
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

<emphasis>production:
  adapter: mysql
  encoding: utf8
  database: blog
  username: deployer
  password: IhrLieblingsPasswort</emphasis></programlisting></para>
      </section>

      <section xml:id="production_webserver_unicorn_gem_installieren">
        <title
        xml:id="production_webserver_unicorn_gem_installieren.title">Unicon
        Konfiguration</title>

        <para>Für die Unicorn Konfiguration nehmen wir als Basis die Datei
        <uri
        xlink:href="https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb">https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</uri>
        und speichern Sie an unseren Server angepasst wie folgt in der Datei
        <filename>config/unicorn.rb</filename> ab:<programlisting># Use at least one worker per core if you're on a dedicated server,
# more will usually help for _short_ waits on databases/caches.
worker_processes 4

# Since Unicorn is never exposed to outside clients, it does not need to
# run on the standard HTTP port (80), there is no reason to start Unicorn
# as root unless it's from system init scripts.
# If running the master process as root and the workers as an unprivileged
# user, do this to switch euid/egid in the workers (also chowns logs):
user "deployer", "www-data"

# Help ensure your application will always spawn in the symlinked
# "current" directory that Capistrano sets up.
APP_PATH = "/var/www/blog/current"
working_directory APP_PATH

# listen on both a Unix domain socket and a TCP port,
# we use a shorter backlog for quicker failover when busy
listen "/tmp/unicorn.blog.sock", :backlog =&gt; 64
listen 8080, :tcp_nopush =&gt; true

# nuke workers after 30 seconds instead of 60 seconds (the default)
timeout 30

# feel free to point this anywhere accessible on the filesystem
pid APP_PATH + "/tmp/pids/unicorn.pid"

# By default, the Unicorn logger will write to stderr.
# Additionally, some applications/frameworks log to stderr or stdout,
# so prevent them from going to /dev/null when daemonized here:
stderr_path APP_PATH + "/log/unicorn.blog.stderr.log"
stdout_path APP_PATH + "/log/unicorn.blog.stdout.log"

before_fork do |server, worker|
  # the following is highly recomended for Rails + "preload_app true"
  # as there's no need for the master process to hold a connection
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.connection.disconnect!
  end

  # Before forking, kill the master process that belongs to the .oldbin PID.
  # This enables 0 downtime deploys.
  old_pid = "/tmp/unicorn.my_site.pid.oldbin"
  if File.exists?(old_pid) &amp;&amp; server.pid != old_pid
    begin
      Process.kill("QUIT", File.read(old_pid).to_i)
    rescue Errno::ENOENT, Errno::ESRCH
      # someone else did our job for us
    end
  end
end

after_fork do |server, worker|
  # the following is *required* for Rails + "preload_app true",
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.establish_connection
  end

  # if preload_app is true, then you may also want to check and
  # restart any other shared sockets/descriptors such as Memcached,
  # and Redis.  TokyoCabinet file handles are safe to reuse
  # between any number of forked children (assuming your kernel
  # correctly implements pread()/pwrite() system calls)
end

before_exec do |server|
  ENV["BUNDLE_GEMFILE"] = "/var/www/blog/current/Gemfile"
end</programlisting></para>
      </section>

      <section>
        <title>rake db:migration</title>

        <para>Wir müssen noch die Datenbank anlegen:<screen>deployer@debian:~/blog$ <command>rake db:migrate RAILS_ENV=production</command>
[...]
deployer@debian:~/blog$ </screen></para>

        <important>
          <para>Bitte beachten Sie das <command>rake db:migrate</command> mit
          einem <command>RAILS_ENV=production</command> abgeschlossen wird.
          Nur so wird die Produktionsdatenbank migriert.</para>
        </important>
      </section>

      <section>
        <title>rake assets:precompile</title>

        <para><command>rake assets:precompile</command> stellt sicher, das
        alle in der Asset Pipeline vorhandenen Assets für die
        Produktionsumgebung bereit gestellt werden (siehe <xref
        linkend="asset_pipeline"/>).<screen>deployer@debian:~/blog$ <command>rake assets:precompile</command>
/home/deployer/.rvm/rubies/ruby-1.9.3-p194/bin/ruby /home/deployer/.rvm/gems/ruby-1.9.3-p194@global/bin/rake assets:precompile:all RAILS_ENV=production RAILS_GROUPS=assets
deployer@debian:~/blog$</screen></para>
      </section>

      <section xml:id="production_webserver_unicorn_init_script">
        <title xml:id="production_webserver_unicorn_init_script.title">Unicorn
        Init-Skript</title>

        <para>Jetzt müssen Sie als User <code>root</code>
        weiterarbeiten:<screen>deployer@debian:~$ <command>exit</command>
Abgemeldet
root@debian:~# </screen></para>

        <para>Das Init-Skript <filename>/etc/init.d/unicorn_blog</filename>
        mit folgendem Inhalt erstellen:<programlisting>#!/bin/bash

### BEGIN INIT INFO
# Provides:          unicorn
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Unicorn webserver
# Description:       Unicorn webserver for the blog
### END INIT INFO

UNICORN=/home/deployer/.rvm/bin/bootup_unicorn
UNICORN_ARGS="-D -c /home/deployer/blog/config/unicorn.rb -E production"
KILL=/bin/kill
PID=/home/deployer/tmp/unicorn.pid

sig () {
  test -s "$PID" &amp;&amp; kill -$1 `cat $PID`
}

case "$1" in
        start)
                echo "Starting unicorn..."
                $UNICORN $UNICORN_ARGS
                ;;
        stop)
                sig QUIT &amp;&amp; exit 0
                echo &gt;&amp;2 "Not running"
                ;;
        restart)
                $0 stop
                $0 start
                ;;
        status)
                ;;
        *)
                echo "Usage: $0 {start|stop|restart|status}"
                ;;
esac</programlisting></para>

        <para>Das Init-Skript muss jetzt noch scharf geschaltet und Unicorn
        gestartet werden:<screen>root@debian:~# <command>chmod +x /etc/init.d/unicorn_blog</command> 
root@debian:~# <command>update-rc.d -f unicorn_blog defaults</command>
update-rc.d: using dependency based boot sequencing
root@debian:~# <command>/etc/init.d/unicorn_blog start</command>
root@debian:~# </screen></para>

        <para>Ihr Rails-Projekt ist jetzt über die IP-Adresse des Webservers
        erreichbar.</para>
      </section>

      <section xml:id="production_webserver_nginx_konfiguration">
        <title xml:id="production_webserver_nginx_konfiguration.title">nginx
        Konfiguration</title>

        <para>Für das Rails-Projekt fügen wir eine neue Konfigurationdatei
        <filename>/etc/nginx/conf.d/blog.conf</filename> mit folgendem Inhalt
        hinzu:<programlisting>upstream unicorn {
  server unix:/tmp/unicorn.blog.sock fail_timeout=0;
}

server {
  listen 80 default deferred;
  # server_name example.com;
  root /home/deployer/blog/public;

  location / {
    gzip_static on;
  }

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 4G;
  keepalive_timeout 10;
}</programlisting></para>

        <para>Die Default Konfigurationsdatei benennen wir um, damit sie nicht
        mehr ausgeführt wird. Danach restarten wir nginx.<screen>root@debian:~# <command>mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.backup</command>
root@debian:~# <command>/etc/init.d/nginx restart</command>
Restarting nginx: nginx.
root@debian:~#</screen></para>
      </section>
    </section>

    <section xml:id="webserver_ohne_deployment_neues_version_des_rails_projekts_einspielen">
      <title
      xml:id="webserver_ohne_deployment_neues_version_des_rails_projekts_einspielen.title">Neue
      Version des Rails-Projektes einspielen</title>

      <para>Wie die Überschrift schon sagt, haben wir bei dieser Variante
      keine automatische Deployment-Mechanismen zur Verfügung. Diese können
      Sie sich aber leicht selbst per Skript realisieren.</para>

      <para>Wenn Sie Veränderungen am Rails-Projekt aktivieren wollen, so
      müssen Sie als User <code>deployer</code> nach einem Update des Codes
      mit <command>rake assets:precompile</command> sicher stellen, das alle
      in der Asset Pipeline vorhandenen Assets für die Produktionsumgebung
      wieder bereit gestellt werden (siehe <xref
      linkend="asset_pipeline"/>).<screen>deployer@debian:~/blog$ <command>rake assets:precompile</command>
/home/deployer/.rvm/rubies/ruby-1.9.3-p194/bin/ruby /home/deployer/.rvm/gems/ruby-1.9.3-p194@global/bin/rake assets:precompile:all RAILS_ENV=production RAILS_GROUPS=assets
deployer@debian:~/blog$</screen></para>

      <para>Sollten Sie neue Migrationen einspielen, so müssen Sie natürlich
      auch <command>rake db:migrate RAILS_ENV=production</command>
      ausführen:<screen>deployer@debian:~/blog$ <command>rake db:migrate RAILS_ENV=production</command>
[...]
deployer@debian:~/blog$ </screen></para>

      <para>Danach müssen Sie als User <code>root</code> Unicorn neu
      starten:<screen>root@debian:~# <command>/etc/init.d/unicorn_blog restart</command>
root@debian:~# </screen></para>

      <tip>
        <para>In den meisten Fällen ist eine Installation mit einem
        Capistrano-Deployment sinnvoller. Es ist initial ein Tick mehr Aufwand
        (siehe <xref linkend="webserver_mit_capistrano"/>), aber bietet dann
        mehr Komfort und Sicherheit.</para>
      </tip>
    </section>
  </section>

  <section xml:id="webserver_mit_capistrano">
    <title xml:id="webserver_mit_capistrano.title">Webserver mit
    Capistrano-Deployment</title>

    <indexterm>
      <primary>Deployment</primary>
    </indexterm>

    <indexterm>
      <primary>Capistrano</primary>
    </indexterm>

    <para>In <xref linkend="webserver_ohne_deployment"/> haben wir ein neues
    Rails-Projekt auf dem Produktivsystem erstellt. Das ist logischweise
    meistens nicht der normale Weg. Normalerweise wird das Rails-Projekt von
    einem oder mehreren Entwicklern auf den eigenen Rechnern entwickelt und
    dann später auf den Produktiv-Server upgeloadet.</para>

    <para>Gerade bei der Arbeit mit mehreren Entwicklern ist der Einsatz einer
    Versionsverwaltung angebracht. Mit Capistrano können Sie dann aus dieser
    Versionsverwaltung Updates des Rails-Projektes auf einen oder mehrere
    Webserver verteilen. In diesem Kapitel benutzen wir Git als verteilte
    Versionsverwaltung und Github (<uri
    xlink:href="http://github.com">http://github.com</uri>) als Server zum
    Hosten des Gits.</para>

    <para>Für dieses Tutorial benötigen Sie einen bereits fertig installierten
    Produktiv-Server mit nginx und einem mit RVM mit dem User
    <code>deployer</code> installierten Ruby 1.9.3 und Rails 3.2 (eine genaue
    Anleitung dazu finden Sie unter <xref
    linkend="deployment_grundinstallation_webserver"/>).</para>

    <section xml:id="webserver_mit_capistrano_entwicklungssystem">
      <title
      xml:id="webserver_mit_capistrano_entwicklungssystem.title">Entwicklungssystem</title>

      <para>Wir fangen wieder mit einer neuen Rails-Applikation an. Bitte
      erstellen Sie diese Applikation auf Ihrem Entwicklungsrechner.</para>

      <section>
        <title>rails new blog</title>

        <para>Wir erstellen die Mini-Blog Rail-Applikation:<screen>Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>rails new blog</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>cd blog</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails generate scaffold post subject content:text</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

        <note>
          <para>Falls Sie mit diesem System in der Entwicklungsumgebung
          arbeiten wollen, fehlt jetzt noch ein <screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rake db:migrate</command>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -&gt; 0.0015s
==  CreatePosts: migrated (0.0016s) ===========================================

Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>
        </note>

        <section>
          <title>Benötigte Gems für das Deployment</title>

          <para>Für das Deployment und den Webserver benötigen wir einige
          Gems. Bitte fügen Sie diese Konfiguration die Datei
          <filename>Gemfile</filename>:<programlisting>source 'https://rubygems.org'

gem 'rails', '3.2.6'

gem 'sqlite3'

# Gems used only for assets and not required
# in production environments by default.
group :assets do
  gem 'sass-rails',   '~&gt; 3.2.3'
  gem 'coffee-rails', '~&gt; 3.2.1'

  # See https://github.com/sstephenson/execjs#readme for more supported runtimes
  # gem 'therubyracer', :platforms =&gt; :ruby

  gem 'uglifier', '&gt;= 1.0.3'
end

gem 'jquery-rails'

# To use ActiveModel has_secure_password
# gem 'bcrypt-ruby', '~&gt; 3.0.0'

group :production do
  # Use MySQL as the production database
  gem 'mysql'

  # Use unicorn as the app server
  gem 'unicorn'
end


group :development do
  # Use Capistrano for the deployment
  gem 'capistrano'
  gem 'rvm-capistrano'
end
</programlisting></para>

          <para>Danach ein <command>bundle install</command>
          ausführen:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>
        </section>
      </section>

      <section>
        <title>Unicorn Konfiguration</title>

        <para>Für die Unicorn Konfiguration nehmen wir als Basis die Datei
        <uri
        xlink:href="https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb">https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</uri>
        und speichern Sie an unseren Server angepasst wie folgt in der Datei
        <filename>config/unicorn.rb</filename> ab:<programlisting># Use at least one worker per core if you're on a dedicated server,
# more will usually help for _short_ waits on databases/caches.
worker_processes 4

# Since Unicorn is never exposed to outside clients, it does not need to
# run on the standard HTTP port (80), there is no reason to start Unicorn
# as root unless it's from system init scripts.
# If running the master process as root and the workers as an unprivileged
# user, do this to switch euid/egid in the workers (also chowns logs):
user "deployer", "www-data"

# Help ensure your application will always spawn in the symlinked
# "current" directory that Capistrano sets up.
APP_PATH = "/var/www/blog/current"
working_directory APP_PATH

# listen on both a Unix domain socket and a TCP port,
# we use a shorter backlog for quicker failover when busy
listen "/tmp/unicorn.blog.sock", :backlog =&gt; 64
listen 8080, :tcp_nopush =&gt; true

# nuke workers after 30 seconds instead of 60 seconds (the default)
timeout 30

# feel free to point this anywhere accessible on the filesystem
pid APP_PATH + "/tmp/pids/unicorn.pid"

# By default, the Unicorn logger will write to stderr.
# Additionally, ome applications/frameworks log to stderr or stdout,
# so prevent them from going to /dev/null when daemonized here:
stderr_path APP_PATH + "/log/unicorn.blog.stderr.log"
stdout_path APP_PATH + "/log/unicorn.blog.stdout.log"

before_fork do |server, worker|
  # the following is highly recomended for Rails + "preload_app true"
  # as there's no need for the master process to hold a connection
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.connection.disconnect!
  end

  # Before forking, kill the master process that belongs to the .oldbin PID.
  # This enables 0 downtime deploys.
  old_pid = "/tmp/unicorn.my_site.pid.oldbin"
  if File.exists?(old_pid) &amp;&amp; server.pid != old_pid
    begin
      Process.kill("QUIT", File.read(old_pid).to_i)
    rescue Errno::ENOENT, Errno::ESRCH
      # someone else did our job for us
    end
  end
end

after_fork do |server, worker|
  # the following is *required* for Rails + "preload_app true",
  if defined?(ActiveRecord::Base)
    ActiveRecord::Base.establish_connection
  end

  # if preload_app is true, then you may also want to check and
  # restart any other shared sockets/descriptors such as Memcached,
  # and Redis.  TokyoCabinet file handles are safe to reuse
  # between any number of forked children (assuming your kernel
  # correctly implements pread()/pwrite() system calls)
end

before_exec do |server|
  ENV["BUNDLE_GEMFILE"] = "/var/www/blog/current/Gemfile"
end</programlisting></para>
      </section>

      <section>
        <title>Capistrano Konfiguration</title>

        <para>Wir richten eine Capistrano Standardkonfiguration ein:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>capify .</command>  
[add] writing './Capfile'
[add] writing './config/deploy.rb'
[done] capified!
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

        <para>Danach richten wir die <filename>config/deploy.rb</filename> mit
        folgendem Inhalt ein. Bitte denken Sie daran den Text
        ip.addresse.ihres.servers mit der IP-Addresse Ihres Web-Servers
        auszutauschen!<programlisting>require "bundler/capistrano"
require "rvm/capistrano"
set :rvm_ruby_string, '1.9.3'

server "ip.addresse.ihres.servers", :web, :app, :db, primary: true

set :application, "blog"
set :user, "deployer"
set :deploy_to, "/var/www/#{application}"
set :deploy_via, :remote_cache
set :use_sudo, false

set :scm, "git"
set :repository, "git@github.com:ihr_github_account/#{application}.git"
set :branch, "master"

default_run_options[:pty] = true
ssh_options[:forward_agent] = true

after 'deploy', 'deploy:cleanup'
after 'deploy', 'deploy:migrate'

namespace :deploy do
  %w[start stop restart reload].each do |command|
    desc "#{command} unicorn server"
    task command, roles: :app, except: {no_release: true} do
      run "sudo /etc/init.d/unicorn_#{application} #{command}"
    end
  end

  # Use this if you know what you are doing.
  #
  # desc "Zero-Downtime restart of Unicorn"
  # task :restart, :except =&gt; { :no_release =&gt; true } do
  #   run "sudo /etc/init.d/unicorn_#{application} reload"
  # end
end</programlisting></para>

        <para>Und die Datei <filename>Capfile</filename> müssen wir noch wie
        folgt abändern:<programlisting>load 'deploy'
# Uncomment if you are using Rails' asset pipeline
<emphasis>load 'deploy/assets'</emphasis>
Dir['vendor/gems/*/recipes/*.rb','vendor/plugins/*/recipes/*.rb'].each { |plugin| load(plugin) }
load 'config/deploy' # remove this line to skip loading any of the default tasks
</programlisting></para>
      </section>

      <section>
        <title>Github als Repository einrichten</title>

        <para>Bitte legen Sie sich unter <uri
        xlink:href="https://github.com">https://github.com</uri> einen neuen
        Account an oder benutzen Sie einen bereits existierenden
        Github-Account. Legen Sie mit diesem Account ein neues Repository mit
        dem Namen "<code>blog</code>" an.</para>

        <tip>
          <para>Für ein einfacheres Arbeiten empfehle ich Ihnen Ihren SSH Key
          in Ihrem Github-Account unter <uri
          xlink:href="https://github.com/settings/ssh">https://github.com/settings/ssh</uri>
          einzutragen.</para>
        </tip>

        <para>Jetzt können Sie Ihr Projekt commiten und pushen. Bitte tauschen
        Sie dabei <code>ihr_github_account</code> mit Ihrem Github-Account
        aus:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git init</command>
Initialized empty Git repository in /Users/xyz/blog/.git/
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git add .</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git commit -m 'first commit'</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git remote add origin git@github.com:ihr_github_account/blog.git</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git push -u origin master</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

        <para>Jetzt ist Ihr Rails-Projekt in einem Github-Repository gehostet
        und kann von Ihnen unter <uri
        xlink:href="https://github.com/ihr_github_account/blog">https://github.com/ihr_github_account/blog</uri>
        eingesehen werden.</para>
      </section>
    </section>

    <section>
      <title>Webserver</title>

      <para>Folgende Schritte müssen Sie auf dem Webserver-System
      durchführen.</para>

      <section>
        <title>SSH Key generieren</title>

        <para>Für den User <code>deployer</code> erstellen wir einen public
        SSH-Key. Bitte loggen Sie sich auf dem Webserver als User
        <code>deployer</code> ein. Am einfachsten ist das Deployment später
        bei der Verwendung einer leeren Passphrase.<screen>deployer@debian:~$ <command>ssh-keygen</command>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/deployer/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/deployer/.ssh/id_rsa.
Your public key has been saved in /home/deployer/.ssh/id_rsa.pub.
The key fingerprint is:
ba:11:90:2a:e3:8f:5b:2e:70:99:50:86:a1:9a:2c:b7 deployer@debian
The key's randomart image is:
+--[ RSA 2048]----+
|.o               |
|o o  .           |
|.o  o            |
|+. . .           |
|*ooo  . S        |
|+++.   o         |
|.oE.  o          |
| .=    o         |
| ooo  .          |
+-----------------+
deployer@debian:~$ <command>cat .ssh/id_rsa.pub</command> 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDJEGixOcPRdBMry7PPG/Rgla50EM+JPKGYGD/yJ8v7bdrfT68t2/eVbj6+YebWh1tRebE3qqouqmZjIlocr1j67SmfXZ/sswBT/pXOhP89JtHPMolx7rUQ8wQF3aDrnVDJG0gdvRm212vN2bou3N5dzhekmWmbS3R0ZGNM9ZgTw8rhTOd1M2QVTzyV1i1PehoFxOu1WIc1gN5C42zihbJ6fGgVb45WeKzXSi6bQ6PMKD1gAMJpXHPvKLhi0wLN0wNOJwa6BKR3pmgICSBuoziAhhCS/7gBDJnqRmx1zax/1CShJD3QEGHvofA9okYuYVqyrJi1hdF8ZgMnQCb31I21 deployer@debian
deployer@debian:~$</screen></para>

        <para>Der erzeugte Key liegt in der Datei
        <filename>/home/deployer/.ssh/id_rsa.pub</filename>.</para>

        <important>
          <para>Bitte loggen Sie sich jetzt in Ihren Github-Account ein und
          fügen im Admin Bereich Ihres Github-Projektes diesen Key bei Deploy
          Keys hinzu. Siehe <uri
          xlink:href="https://github.com/ihr_github_account/blog/admin/keys">https://github.com/ihr_github_account/blog/admin/keys</uri></para>
        </important>

        <para>Danach verbinden Sie sich mit ssh bitte auf der Console einmal
        mit dem Github SSH-Server und bestätigen Sie die "Are you sure you
        want to continue connection (yes/no)?" Frage mit einem yes. <screen>deployer@debian:~$ <command>ssh git@github.com</command>
The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)? <command>yes</command>
Warning: Permanently added 'github.com,207.97.227.239' (RSA) to the list of known hosts.
PTY allocation request failed on channel 0
Hi ihr_github_account/blog! You've successfully authenticated, but GitHub does not provide shell access.
                 Connection to github.com closed.
deployer@debian:~$</screen></para>

        <para>Jetzt können Sie auf Ihrem Entwicklungssystem mit dem Deployen
        anfangen.</para>
      </section>
    </section>

    <section>
      <title>cap deploy:setup</title>

      <para>Mit <command>cap deploy:setup</command> können wir die notwendige
      Verzeichnisstruktur auf dem Zielsystem einrichten. Wenn Sie Ihren
      SSH-Key nicht auf dem Zielsystem abgelegt haben, werden Sie vom Skript
      nach dem Passwort des Users <code>deployer</code> gefragt. Je nach
      Anbindung und CPU-Power kann dieser initialle Setup-Schritt länger
      dauern.<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>cap deploy:setup</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ </screen></para>

      <para>Nach dem <command>cap deploy:setup</command> finden Sie auf Ihrem
      Webserver die folgende Verzeichnisstruktur:<screen>/var/www/blog
├── releases
└── shared
    ├── log
    ├── pids
    └── system</screen></para>

      <para>Das erste Deploy können wir mit <command>cap deploy</command>
      starten:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>cap deploy</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ </screen></para>

      <para>Danach sehen wir das Ergebnis des Deploys wieder in der
      Verzeichnisstruktur des Webservers:<screen>/var/www/blog
├── current -&gt; /var/www/blog/releases/20120711131031
├── releases
│   └── 20120711131031
└── shared
    ├── assets
    ├── bundle
    ├── cached-copy
    ├── log
    ├── pids
    └── system</screen></para>

      <para>Capistrano hat für die neue Applikations-Version im
      Unterverzeichnis <filename>/var/www/blog/releases</filename> ein neues
      Verzeichnis angelegt und dieses mit dem
      <filename>/var/www/blog/current</filename> Verzeichnis verlinkt.</para>
    </section>

    <section xml:id="webserver_mit_capistrano_webserver_konfiguration">
      <title
      xml:id="webserver_mit_capistrano_webserver_konfiguration.title">Webserver
      Konfiguration</title>

      <para>Jetzt müssen wir noch ein Init-Skript und eine Konfigurationsdatei
      auf dem Webserver schreiben und aktivieren.</para>

      <section xml:id="production_webserver_capistrano_unicorn_init_script">
        <title
        xml:id="production_webserver_capistrano_unicorn_init_script.title">Unicorn
        Init-Skript</title>

        <para>Bitte loggen Sie sich als User <code>root</code> auf dem
        Webserver ein und erstellen Sie das Init-Skript
        <filename>/etc/init.d/unicorn_blog</filename> mit folgendem
        Inhalt:<programlisting>#!/bin/bash

### BEGIN INIT INFO
# Provides:          unicorn
# Required-Start:    $remote_fs $syslog
# Required-Stop:     $remote_fs $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Unicorn webserver
# Description:       Unicorn webserver for the blog
### END INIT INFO

UNICORN=/home/deployer/.rvm/bin/bootup_unicorn
UNICORN_ARGS="-D -c /var/www/blog/current/config/unicorn.rb -E production"
KILL=/bin/kill
PID=/var/www/blog/shared/pids/unicorn.pid

sig () {
  test -s "$PID" &amp;&amp; kill -$1 `cat $PID`
}

case "$1" in
        start)
                echo "Starting unicorn..."
                $UNICORN $UNICORN_ARGS
                ;;
        stop)
                sig QUIT &amp;&amp; exit 0
                echo &gt;&amp;2 "Not running"
                ;;
        reload)
                sig USR2 &amp;&amp; exit 0
                ;;
        restart)
                $0 stop
                $0 start
                ;;
        status)
                ;;
        *)
                echo "Usage: $0 {start|stop|reload|restart|status}"
                ;;
esac</programlisting></para>

        <para>Das Init-Skript muss jetzt noch scharf geschaltet und Unicorn
        gestartet werden:<screen>root@debian:~# <command>chmod +x /etc/init.d/unicorn_blog</command> 
root@debian:~# <command>update-rc.d -f unicorn_blog defaults</command>
update-rc.d: using dependency based boot sequencing
root@debian:~# <command>/etc/init.d/unicorn_blog start</command>
root@debian:~# </screen></para>

        <para>Ihr Rails-Projekt ist jetzt über die IP-Adresse des Webservers
        erreichbar.</para>
      </section>

      <section xml:id="production_webserver_capistrano_nginx_konfiguration">
        <title
        xml:id="production_webserver_capistrano_nginx_konfiguration.title">nginx
        Konfiguration</title>

        <para>Für das Rails-Projekt fügen wir eine neue Konfigurationdatei
        <filename>/etc/nginx/conf.d/blog.conf</filename> mit folgendem Inhalt
        hinzu:<programlisting>upstream unicorn {
  server unix:/tmp/unicorn.blog.sock fail_timeout=0;
}

server {
  listen 80 default deferred;
  # server_name example.com;
  root /var/www/blog/current/public;

  location / {
    gzip_static on;
  }

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 4G;
  keepalive_timeout 10;
}</programlisting></para>

        <para>Die Default Konfigurationsdatei benennen wir um, damit sie nicht
        mehr ausgeführt wird. Danach restarten wir nginx.<screen>root@debian:~# <command>mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.backup</command>
root@debian:~# <command>/etc/init.d/nginx restart</command>
Restarting nginx: nginx.
root@debian:~#</screen></para>
      </section>
    </section>

    <section>
      <title>sudo</title>

      <para>Im Capistrano Deploy-Skript brauchen wir eine Möglichkeit Unicorn
      per Init-Skript zu stoppen und starten. Dazu müssen wir sudo auf dem
      Webserver installieren:<screen>root@debian:~# <command>apt-get install sudo</command>
[...]
root@debian:~# </screen></para>

      <para>Und in der Datei <filename>/etc/sudoers</filename> die folgende
      Zeile hinzufügen:<programlisting>deployer ALL= NOPASSWD: /etc/init.d/unicorn_blog</programlisting></para>
    </section>

    <section xml:id="webserver_mit_capistrano_webserver_deployment">
      <title
      xml:id="webserver_mit_capistrano_webserver_deployment.title">Deployment</title>

      <para>Der grosse Vorteil von der Arbeit mit Capistrano ist das einfache
      Einspielen neuer Versionen (das Deployment). Dies geht immer vom
      Entwicklungssystem aus mit dem Befehl <command>cap deploy</command>.
      Nach einem zweiten <command>cap deploy</command> sieht die
      Verzeichnisstruktur so aus:<screen>/var/www/blog
├── current -&gt; /var/www/blog/releases/20120711132357
├── releases
│   ├── 20120711131031
│   └── 20120711132357
└── shared
    ├── assets
    ├── bundle
    ├── cached-copy
    ├── log
    ├── pids
    └── system</screen></para>

      <para>So werden im Verzeichnis
      <filename>/var/www/blog/releases</filename> immer die jeweiligen
      Releases gespeichert.</para>

      <para>Im Verzeichnis <filename>/var/www/blog/shared</filename> finden
      Sie Verzeichnisse, die vom jeweiligen Release geteilt (shared) werden.
      Diese werden immer automatisch innerhalb von
      <filename>/var/www/blog/current</filename> verlinkt.</para>

      <para>Mit der von uns verwendeten Konfiguration werden automatisch die
      letzten 5 Releases gespeichert und alle älteren gelöscht.</para>

      <tip>
        <para>Capistrano ist ein sehr mächtiges Tool. Es lohnt sich für jeden
        Admin mal einen Blick auf das Capistrano Wiki (<uri
        xlink:href="https://github.com/capistrano/capistrano/wiki">https://github.com/capistrano/capistrano/wiki</uri>)
        zu werfen.</para>
      </tip>
    </section>
  </section>

  <section xml:id="production_webserver_sonstiges">
    <title xml:id="production_webserver_sonstiges.title">Sonstiges</title>

    <section xml:id="production_webserver_was_noch_zu_tun_ist">
      <title xml:id="production_webserver_was_noch_zu_tun_ist.title">Was noch
      zu tun ist.</title>

      <para>Bitte denken Sie immer an folgende Punkte, die jeder Admin für
      sich selbst entscheiden und umsetzen muss:<itemizedlist>
          <listitem>
            <para>Automatisches und regelmässiges Backup der Datenbank und des
            Rails-Projektes.</para>
          </listitem>

          <listitem>
            <para>Logrotate der Logdateien einrichten.</para>
          </listitem>

          <listitem>
            <para>Monitor für Systemlast und Festplattenplatz
            einrichten.</para>
          </listitem>

          <listitem>
            <para>Regelmässig Debian Sicherheitsupdates einspielen, so bald
            diese verfügbar sind.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section xml:id="production_webserver_404">
      <title xml:id="production_webserver.title">404 und Co.</title>

      <para>Schauen Sie zum Schluss bitte in Ihrem Rails-Projekt in das
      Verzeichnis <filename>public</filename> und passen Sie die dort
      gespeicherten HTML-Seiten Ihren Bedürfnissen an. Dabei geht es in erster
      Linie um das Design der Seiten. Diese sind per Default etwas spärlich
      und haben auch keinen Bezug zu Ihrer restlichen Webseite. Wenn Sie Ihr
      Webseite updaten und dazu den Unicorn-Server runterfahren, so wird nginx
      in der Zwischenzeit die Webseite <filename>public/500.html</filename>
      ausliefern.</para>

      <para>Eine Auflistung von HTTP-Fehlercodes finden Sie auf <uri
      xlink:href="http://de.selfhtml.org/servercgi/server/httpstatuscodes.htm">http://de.selfhtml.org/servercgi/server/httpstatuscodes.htm</uri></para>
    </section>

    <section xml:id="production_webserver_mehrere_server">
      <title xml:id="production_webserver_mehrere_server.title">Mehrere
      Rails-Server auf einem System</title>

      <para>Sie können problemlos mehrere Rails-Server auf einem System laufen
      lassen. Sie müssen dafür für jeden Rails-Server einen eigenen Unicorn
      aufsetzen. Auf diesen können Sie dann vom nginx aus verteilen. Mit dem
      nginx können Sie auch definieren, auf welche IP-Adresse ein Rails-Server
      von Aussen erreichbar ist.</para>
    </section>
  </section>

  <section xml:id="production_webserver_paas">
    <title xml:id="production_webserver_paas.title">Cloud platform as a
    service Provider</title>

    <para>Wer selber keinen Webserver im Internet zur Verfügung hat oder von
    Anfang an direkt auf ein PaaS (Platform as a Service) System deployen
    möchte, der sollte sich einmal die Angebote der entsprechenden Anbieter
    anschauen. Die beiden US Marktführer sind aktuell Heroku (<uri
    xlink:href="http://www.heroku.com/">http://www.heroku.com/</uri>) und
    Engine Yard (<uri
    xlink:href="http://www.engineyard.com/">http://www.engineyard.com/</uri>).</para>

    <para>PaaS als Platform bietet meistens weniger Möglichkeiten als der
    eigene Server. Allerdings bieten Sie einen 7x24 Support für diese
    Plattform, falls mal etwas nicht funktioniert.</para>
  </section>
</chapter>
