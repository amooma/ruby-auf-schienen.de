<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="rails_production_webserver"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="rails_production_webserver.title">Rails
  Production-Webserver</title>

  <indexterm>
    <primary>Webserver</primary>

    <secondary>Production</secondary>
  </indexterm>

  <indexterm>
    <primary>Nginx</primary>
  </indexterm>

  <indexterm>
    <primary>Unicorn</primary>
  </indexterm>

  <section xml:id="production_webserver_einleitung">
    <title xml:id="production_webserver_einleitung.title">Einleitung</title>

    <para>Im Rest des Buches arbeiten wir immer mit dem Entwicklungssystem.
    Dazu starten wir Rails mit <command>rails server</command>. Schauen wir
    uns die Ausgabe noch mal genau an:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.6 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-07-09 12:19:40] INFO  WEBrick 1.3.1
[2012-07-09 12:19:40] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-07-09 12:19:40] INFO  WEBrick::HTTPServer#start: pid=86773 port=3000</screen></para>

    <para>Die zweite Zeile sagt aus, das wir im "development" Modus sind und
    das die Applikation unter der URL <uri
    xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri> erreichbar ist.
    Als Webserver wird dabei WEBrick verwendet (siehe <uri
    xlink:href="http://de.wikipedia.org/wiki/WEBrick">http://de.wikipedia.org/wiki/WEBrick</uri>).
    WEBrick ist ein sehr einfacher HTTP Webserver und Bestandteil der Ruby
    Standardbibliothek. WEBrick ist aber nur zur Entwicklung geeignet.</para>

    <para>Für ein Produktivsystem nimmt man normalerweise einen Standard
    Webserver wie Apache, lighttpd oder Nginx, der als Reverse-Proxy und
    Loadbalancer zum Rails-System agiert. Das Rails-System wird dann aber
    nicht vom langsamen WEBrick betrieben, sondern von performanten Lösungen
    wie Unicorn (<uri
    xlink:href="http://unicorn.bogomips.org/">http://unicorn.bogomips.org/</uri>),
    Mongrel (<uri
    xlink:href="http://de.wikipedia.org/wiki/Mongrel">http://de.wikipedia.org/wiki/Mongrel</uri>)
    oder Thin (<uri
    xlink:href="http://code.macournoyer.com/thin/">http://code.macournoyer.com/thin/</uri>).</para>

    <para>Bei einem typischen PHP-Projekt reicht es den PHP-Code einfach in
    ein bestimmtes Verzeichnis zu legen und in 9 von 10 Fällen kann der zur
    Verfügung stehende Apache-Webserver bereits PHP Code automatisch
    abarbeiten (das entsprechende Modul ist fast immer installiert). Bei Rails
    sieht es leider anders aus. Die Hürden sind wesentlich höher und des
    Aufwand größer. Es gibt eine grosse Menge an möglichen Kombinationen (z.B.
    "Apache, lighttpd oder Nginx?" und "Unicorn, Thin oder Mongrel?"). Es ist
    unmöglich alle Varianten hier detailiert zu beschreiben. Ich habe mich für
    meine Lieblingskombination von Nginx und Unicorn entschieden. Dies heißt
    aber nicht, das andere Kombinationen schlechter sind. Es ist eine
    subjektive Wahl.</para>

    <section xml:id="production_webserver_zielsystem">
      <title xml:id="production_webserver_zielsystem.title">Das
      Zielsystem</title>

      <para>Wir setzen unseren Produktions-Webserver auf einem Debian 6 System
      auf. Ruby 1.9.3 installieren wir per RVM mit dem neuen User
      <code>deployer</code>. Die von uns benutze Rails-Applikation heißt
      <code>blog</code>. Als Datenbank benutzen wir SQLite.</para>

      <important>
        <para>Zum Durchführen dieser Installation benötigen Sie Root-Rechte
        auf dem Webserver!</para>
      </important>
    </section>
  </section>

  <section xml:id="production_webserver_installation">
    <title
    xml:id="production_webserver_installation.title">Installation</title>

    <para>Bitte loggen Sie sich als <code>root</code> auf dem Webserver
    ein.</para>

    <warning>
      <para>Bitte beachten Sie bei der Verwendung dieser
      Installationsanleitung für andere Rails-Projekte, das der Name "blog"
      (für die jeweilige Rails-Applikation) in allen Konfigurationsdateien und
      Skripten mit dem jeweiligen Projektnamen ersetzt werden muss.</para>
    </warning>

    <para>Als erstes installieren wir ein paar Pakete die wir
    brauchen.<screen>root@debian:~# <command>apt-get -y install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion python</command>
[...]
root@debian:~# </screen></para>

    <para>Jetzt installieren wir Node.js. Bitte gehen Sie dafür auf die
    Homepage von Node.js (<uri
    xlink:href="http://nodejs.org/">http://nodejs.org/</uri>) und suchen Sie
    dort nach dem aktuellen stabilen Release.<screen>root@debian:~# <command>cd /usr/src</command>
root@debian:/usr/src# <command>wget http://nodejs.org/dist/v0.8.1/node-v0.8.1.tar.gz</command>
[...]
root@debian:/usr/src# <command>tar xzf node-v0.8.1.tar.gz</command> 
root@debian:/usr/src# <command>cd node-v0.8.1</command>
root@debian:/usr/src/node-v0.8.1# <command>./configure</command> 
[...]
root@debian:/usr/src/node-v0.8.1# <command>make</command>
[...]
root@debian:/usr/src/node-v0.8.1# <command>make install</command>
[...]
root@debian:/usr/src/node-v0.8.1# <command>cd</command>
[...]
root@debian:~# </screen></para>

    <para>Als nächstes installieren wir den Webserver nginx:<screen>root@debian:~# <command>curl http://nginx.org/keys/nginx_signing.key | apt-key add -</command>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1561  100  1561    0     0   3887      0 --:--:-- --:--:-- --:--:--  8819
OK
root@debian:~# <command>echo 'deb http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>echo 'deb-src http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>apt-get update</command>
[...]
root@debian:~# <command>apt-get -y install nginx</command>
[...]
root@debian:~# </screen></para>

    <para>Wir erstellen einen neuen User mit dem Namen
    <code>deployer</code>:<screen>root@debian:~# <command>adduser deployer</command>
Lege Benutzer »deployer« an ...
Lege neue Gruppe »deployer« (1002) an ...
Lege neuen Benutzer »deployer« (1002) mit Gruppe »deployer« an ...
Erstelle Home-Verzeichnis »/home/deployer« ...
Kopiere Dateien aus »/etc/skel« ...
Geben Sie ein neues UNIX-Passwort ein: 
Geben Sie das neue UNIX-Passwort erneut ein: 
passwd: Passwort erfolgreich geändert
Benutzerinformationen für deployer werden geändert.
Geben Sie einen neuen Wert an oder drücken Sie ENTER für den Standardwert
 Vollständiger Name []: Deployer
 Raumnummer []: 
 Telefon geschäftlich []: 
 Telefon privat []: 
 Sonstiges []: 
Sind die Informationen korrekt? [J/n] J
root@debian:~#</screen></para>

    <para>Jetzt legen wir ein Verzeichnis <filename>/var/www</filename> an und
    setzten die Rechte dafür:<screen>root@debian:~# <command>mkdir -p /var/www</command>
root@debian:~# <command>usermod -a -G www-data nginx</command>
root@debian:~# <command>usermod -a -G www-data deployer</command>
root@debian:~# <command>chgrp -R www-data /var/www</command>
root@debian:~# <command>chmod -R 775 /var/www</command>
root@debian:~#</screen></para>

    <para>Für unser Rails-Projekt fügen wir eine neue Konfigurationdatei
    <filename>/etc/nginx/conf.d/blog.conf</filename> mit folgendem Inhalt
    hinzu:<programlisting>upstream unicorn {
  server unix:/tmp/unicorn.blog.sock fail_timeout=0;
}

server {
  listen 80 default deferred;
  # server_name example.com;
  root /var/www/blog/current/public;

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 4G;
  keepalive_timeout 10;
}</programlisting></para>

    <para>Die Default Konfigurationsdatei benennen wir um, damit sie nicht
    mehr ausgeführt wird. Danach restarten wir nginx.<screen>root@debian:~# <command>mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.backup</command>
root@debian:~# <command>/etc/init.d/nginx restart</command>
Restarting nginx: nginx.
root@debian:~# </screen></para>

    <para>Weiter geht es mit dem User deployer:<screen>root@debian:~# <command>su - deployer</command>
deployer@debian:~$ </screen></para>

    <section>
      <title>Das Rails-Projekt</title>

      <important>
        <para>Bitte führen Sie <emphasis>jetzt</emphasis> als User
        <code>deployer</code> die in <xref linkend="rails3-install-debian" />
        aufgeführten Schritte zur Installation von Ruby 1.9.3 und Rails 3.2
        per rvm aus. Hier ist die Kurzversion:<screen>deployer@debian:~$ <command>curl -L https://get.rvm.io | bash -s stable &amp;&amp; source ~/.rvm/scripts/'rvm' &amp;&amp; rvm install 1.9.3 &amp;&amp; gem install rails</command>
[...]
deployer@debian:~$</screen></para>
      </important>

      <para>Um diese Anleitung zu einfach wie möglich zu halten, erstellen wir
      ein einfaches Blog auf dem Server. Das entsprechende Rails-Projekt
      können Sie natürlich auch schon fertig vorbereiten und dann per scp oder
      rsync auf den Server spielen. Bitte achten Sie dann aber auf die
      richtigen Verzeichnisse.<screen>deployer@debian:~$ <command>rails new blog</command>
[...]
deployer@debian:~$ <command>cd blog</command>
deployer@debian:~/blog$ <command>rails generate scaffold post subject content:text</command>
[...]
deployer@debian:~/blog$ <command>rake db:migrate RAILS_ENV=production</command>
[...]
deployer@debian:~/blog$ <command>rake assets:precompile</command>
/home/deployer/.rvm/rubies/ruby-1.9.3-p194/bin/ruby /home/deployer/.rvm/gems/ruby-1.9.3-p194@global/bin/rake assets:precompile:all RAILS_ENV=production RAILS_GROUPS=assets
deployer@debian:~/blog$</screen></para>

      <important>
        <para>Bitte beachten Sie das <command>rake db:migrate</command> mit
        einem <command>RAILS_ENV=production</command> abgeschlossen wird. Nur
        so wird die Produktionsdatenbank migriert. <command>rake
        assets:precompile</command> stellt sicher, das alle in der Asset
        Pipeline vorhandenen Assets für die Produktionsumgebung bereit
        gestellt werden (siehe <xref linkend="asset_pipeline" />).</para>
      </important>

      <para>In diesem Rails-Projekt müssen wir den Webserver Unicorn einbauen.
      Das geht durch hinzufügen der folgenden Zeile in der Datei
      <filename>Gemfile</filename>:<programlisting>gem 'unicorn'</programlisting></para>

      <para>Danach ein <command>bundle install</command> durchführen:<screen>deployer@debian:~/blog$ <command>bundle install</command>
[...]
deployer@debian:~/blog$ </screen></para>

      <para>Um Unicorn mit der RVM Umgebung aus einen Init.d Skript starten zu
      können, müssen wir jetzt noch einen entsprechenden Wrapper
      generieren:<screen>deployer@debian:~/blog$ <command>rvm wrapper 1.9.3 bootup unicorn</command>
deployer@debian:~/blog$</screen></para>

      <para>Für die Unicorn Konfiguration nehmen wir als Basis die Datei <uri
      xlink:href="https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb">https://raw.github.com/defunkt/unicorn/master/examples/unicorn.conf.rb</uri>
      und speichern Sie an unseren Server angepasst wie folgt in der Datei
      <filename>config/unicorn.rb</filename> ab:<programlisting># Use at least one worker per core if you're on a dedicated server,
# more will usually help for _short_ waits on databases/caches.
worker_processes 4

# Since Unicorn is never exposed to outside clients, it does not need to
# run on the standard HTTP port (80), there is no reason to start Unicorn
# as root unless it's from system init scripts.
# If running the master process as root and the workers as an unprivileged
# user, do this to switch euid/egid in the workers (also chowns logs):
user "deployer", "www-data"

# Help ensure your application will always spawn in the symlinked
# "current" directory that Capistrano sets up.
<emphasis>working_directory "/var/www/blog/current"</emphasis> # available in 0.94.0+

# listen on both a Unix domain socket and a TCP port,
# we use a shorter backlog for quicker failover when busy
<emphasis>listen "/tmp/unicorn.blog.sock", :backlog =&gt; 64</emphasis>
listen 8080, :tcp_nopush =&gt; true

# nuke workers after 30 seconds instead of 60 seconds (the default)
timeout 30

# feel free to point this anywhere accessible on the filesystem
<emphasis>pid "/tmp/unicorn.blog.pid"</emphasis>

# By default, the Unicorn logger will write to stderr.
# Additionally, ome applications/frameworks log to stderr or stdout,
# so prevent them from going to /dev/null when daemonized here:
<emphasis>stderr_path "/var/www/blog/current/log/unicorn.blog.stderr.log"
stdout_path "/var/www/blog/current/log/unicorn.blog.stdout.log"</emphasis>

# combine Ruby 2.0.0dev or REE with "preload_app true" for memory savings
# http://rubyenterpriseedition.com/faq.html#adapt_apps_for_cow
preload_app true
GC.respond_to?(:copy_on_write_friendly=) and
  GC.copy_on_write_friendly = true

before_fork do |server, worker|
  # the following is highly recomended for Rails + "preload_app true"
  # as there's no need for the master process to hold a connection
  defined?(ActiveRecord::Base) and
    ActiveRecord::Base.connection.disconnect!
end

after_fork do |server, worker|
  # per-process listener ports for debugging/admin/migrations
  # addr = "127.0.0.1:#{9293 + worker.nr}"
  # server.listen(addr, :tries =&gt; -1, :delay =&gt; 5, :tcp_nopush =&gt; true)

  # the following is *required* for Rails + "preload_app true",
  defined?(ActiveRecord::Base) and
    ActiveRecord::Base.establish_connection
end</programlisting></para>

      <para>Jetzt müssen wir noch das aktuelle Verzeichnis der Applikation mit
      dem Verzeichnis <filename>/var/www/blog/current</filename>
      verlinken:<screen>deployer@debian:~$ <command>mkdir -p /var/www/blog</command>
deployer@debian:~$ <command>ln -s /home/deployer/blog /var/www/blog/current</command>
deployer@debian:~$</screen></para>

      <para>Jetzt müssen Sie als User <code>root</code>
      weiterarbeiten:<screen>deployer@debian:~$ <command>exit</command>
Abgemeldet
root@debian:~# </screen></para>

      <para>Das Init-Skript <filename>/etc/init.d/unicorn_blog</filename> mit
      folgendem Inhalt erstellen:<programlisting>#! /bin/sh
### BEGIN INIT INFO
# Provides:          unicorn 
# Required-Start:    $local_fs $remote_fs $network $syslog
# Required-Stop:     $local_fs $remote_fs $network $syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: starts unicorn blog
# Description:       starts the unicorn webserver for the blog
### END INIT INFO

PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="Unicorn for /var/www/blog"
NAME=unicorn_blog
DAEMON=/home/deployer/.rvm/bin/bootup_unicorn
DAEMON_ARGS="-D -c /var/www/blog/current/config/unicorn.rb -E production"
PIDFILE=/var/run/$NAME.pid
SCRIPTNAME=/etc/init.d/$NAME

# Exit if the package is not installed
[ -x "$DAEMON" ] || exit 0

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] &amp;&amp; . /etc/default/$NAME

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (&gt;= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
do_start()
{
  # Return
  #   0 if daemon has been started
  #   1 if daemon was already running
  #   2 if daemon could not be started
  start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON --test &gt; /dev/null \
    || return 1
  start-stop-daemon --start --quiet --pidfile $PIDFILE --exec $DAEMON -- \
    $DAEMON_ARGS \
    || return 2
  # Add code here, if necessary, that waits for the process to be ready
  # to handle requests from services started subsequently which depend
  # on this one.  As a last resort, sleep for some time.
}

#
# Function that stops the daemon/service
#
do_stop()
{
  # Return
  #   0 if daemon has been stopped
  #   1 if daemon was already stopped
  #   2 if daemon could not be stopped
  #   other if a failure occurred
  start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile $PIDFILE --name $NAME
  RETVAL="$?"
  [ "$RETVAL" = 2 ] &amp;&amp; return 2
  # Wait for children to finish too if this is a daemon that forks
  # and if the daemon is only ever run from this initscript.
  # If the above conditions are not satisfied then add some other code
  # that waits for the process to drop all resources that could be
  # needed by services started subsequently.  A last resort is to
  # sleep for some time.
  start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec $DAEMON
  [ "$?" = 2 ] &amp;&amp; return 2
  # Many daemons don't delete their pidfiles when they exit.
  rm -f $PIDFILE
  return "$RETVAL"
}

#
# Function that sends a SIGHUP to the daemon/service
#
do_reload() {
  #
  # If the daemon can reload its configuration without
  # restarting (for example, when it is sent a SIGHUP),
  # then implement that here.
  #
  start-stop-daemon --stop --signal 1 --quiet --pidfile $PIDFILE --name $NAME
  return 0
}

case "$1" in
  start)
  [ "$VERBOSE" != no ] &amp;&amp; log_daemon_msg "Starting $DESC" "$NAME"
  do_start
  case "$?" in
    0|1) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 0 ;;
    2) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 1 ;;
  esac
  ;;
  stop)
  [ "$VERBOSE" != no ] &amp;&amp; log_daemon_msg "Stopping $DESC" "$NAME"
  do_stop
  case "$?" in
    0|1) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 0 ;;
    2) [ "$VERBOSE" != no ] &amp;&amp; log_end_msg 1 ;;
  esac
  ;;
  status)
       status_of_proc "$DAEMON" "$NAME" &amp;&amp; exit 0 || exit $?
       ;;
  #reload|force-reload)
  #
  # If do_reload() is not implemented then leave this commented out
  # and leave 'force-reload' as an alias for 'restart'.
  #
  #log_daemon_msg "Reloading $DESC" "$NAME"
  #do_reload
  #log_end_msg $?
  #;;
  restart|force-reload)
  #
  # If the "reload" option is implemented then remove the
  # 'force-reload' alias
  #
  log_daemon_msg "Restarting $DESC" "$NAME"
  do_stop
  case "$?" in
    0|1)
    do_start
    case "$?" in
      0) log_end_msg 0 ;;
      1) log_end_msg 1 ;; # Old process is still running
      *) log_end_msg 1 ;; # Failed to start
    esac
    ;;
    *)
      # Failed to stop
    log_end_msg 1
    ;;
  esac
  ;;
  *)
  #echo "Usage: $SCRIPTNAME {start|stop|restart|reload|force-reload}" &gt;&amp;2
  echo "Usage: $SCRIPTNAME {start|stop|status|restart|force-reload}" &gt;&amp;2
  exit 3
  ;;
esac

:</programlisting></para>

      <para>Das Init-Skript muss jetzt noch scharf geschaltet und Unicorn
      gestartet werden:<screen>root@debian:~# <command>chmod +x /etc/init.d/unicorn_blog</command> 
root@debian:~# <command>update-rc.d -f unicorn_blog defaults</command>
update-rc.d: using dependency based boot sequencing
root@debian:~# <command>/etc/init.d/unicorn_blog start</command>
root@debian:~# </screen></para>

      <para>Fertig.</para>
    </section>
  </section>

  <section>
    <title>Capistrano</title>

    <indexterm>
      <primary>Deployment</primary>
    </indexterm>

    <para>Bis jetzt haben wir immer in der Entwicklungsumgebung gearbeitet.
    Irgendwann kommt natürlich der Fall, das man die erstellte Rails-Anwendung
    auch auf einen Server spielen will.<warning>
        <para>Dieses Howto ist noch nicht fertig. Bitte erst benutzen, wenn
        diese Warnung nicht mehr angezeigt wird.</para>
      </warning></para>
  </section>

  <section>
    <title>Das Entwicklungssystem</title>

    <para>Wir fangen mit einer neuen Rails-Applikation an.</para>

    <section>
      <title>rails new blog</title>

      <para>Wir erstellen die Mini-Blog Rail-Applikation:<screen>Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>rails new blog</command>
[...]
Stefan-Wintermeyers-MacBook-Air:~ xyz$ <command>cd blog</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rails generate scaffold post subject content:text</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>rake db:migrate</command>
==  CreatePosts: migrating ====================================================
-- create_table(:posts)
   -&gt; 0.0015s
==  CreatePosts: migrated (0.0016s) ===========================================

Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

      <section>
        <title>Gems für das Deployment</title>

        <para>Für das Deployment und den Webserver benötigen wir einige Gems.
        Bitte fügen Sie diese Konfiguration in der Datei
        <filename>Gemfile</filename> hinzu:<programlisting><emphasis>group :production do
  # Use MySQL as the database
  gem 'mysql'

  # Use unicorn as the app server
  gem 'unicorn'
end

group :development do
  # Use Capistrano and rvm for deployment
  gem 'capistrano'
  gem 'rvm-capistrano'
end

group :assets do
  gem 'therubyracer', :platforms =&gt; :ruby
end</emphasis></programlisting></para>

        <para>Danach ein <command>bundle install</command> ausführen:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>
      </section>
    </section>

    <section>
      <title>Production Datenbank Konfiguration</title>

      <para>In der Datei <filename>config/database.yml</filename> müssen wir
      für das Produktionssystem die Datenbankkonfiguration für die
      MySQL-Datenbank eintragen. Bitte achten Sie darauf das korrekte Passwort
      einzutragen.<programlisting># SQLite version 3.x
#   gem install sqlite3
#
#   Ensure the SQLite 3 gem is defined in your Gemfile
#   gem 'sqlite3'
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

<emphasis>production:
  adapter: mysql
  encoding: utf8
  database: blog
  username: deployer
  password: IhrLieblingsPasswort</emphasis></programlisting></para>
    </section>

    <section>
      <title>Unicorn Konfiguration</title>

      <para>Bitte fügen Sie die Konfigurationsdatei
      <filename>config/unicorn.rb</filename> mit folgendem Inhalt
      hinzu:<programlisting>root = "/home/deployer/apps/blog/current"
working_directory root
pid "#{root}/tmp/pids/unicorn.pid"
stderr_path "#{root}/log/unicorn.log"
stdout_path "#{root}/log/unicorn.log"

listen "/tmp/unicorn.blog.sock"
worker_processes 2
timeout 30</programlisting></para>
    </section>

    <section>
      <title>Capistrano Konfiguration</title>

      <para>Wir richten eine Capistrano Standardkonfiguration ein:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>capify .</command>  
[add] writing './Capfile'
[add] writing './config/deploy.rb'
[done] capified!
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

      <para>Danach richten wir die <filename>config/deploy.rb</filename> mit
      folgendem Inhalt ein. Bitte denken Sie daran den Text
      ip.addresse.ihres.servers mit der IP-Addresse Ihres Web-Servers
      auszutauschen!<programlisting>require "bundler/capistrano"
require "rvm/capistrano" 

server "ip.addresse.ihres.servers", :web, :app, :db, primary: true

set :application, "blog"
set :user, "deployer"
set :deploy_to, "/home/#{user}/apps/#{application}"
set :deploy_via, :remote_cache
set :use_sudo, false

set :scm, "git"
set :repository, "git@github.com:wintermeyer/#{application}.git"
set :branch, "master"

default_run_options[:pty] = true
ssh_options[:forward_agent] = true

set :rvm_install_type, :stable
set :rvm_ruby_string, '1.9.3'

# Install RVM
before 'deploy:setup', 'rvm:install_rvm'
# Install Ruby
before 'deploy:setup', 'rvm:install_ruby'

after 'deploy:restart', 'deploy:cleanup'
after 'deploy', 'deploy:migrate'</programlisting></para>

      <para>Und die Datei <filename>Capfile</filename> müssen wir noch wie
      folgt abändern:<programlisting>load 'deploy'
# Uncomment if you are using Rails' asset pipeline
<emphasis>load 'deploy/assets'</emphasis>
Dir['vendor/gems/*/recipes/*.rb','vendor/plugins/*/recipes/*.rb'].each { |plugin| load(plugin) }
load 'config/deploy' # remove this line to skip loading any of the default tasks
</programlisting></para>
    </section>

    <section>
      <title>Github als Repository einrichten</title>

      <para>Bitte legen Sie sich unter <uri
      xlink:href="https://github.com">https://github.com</uri> einen neuen
      Account an oder benutzen Sie einen bereits existierenden Github-Account.
      Legen Sie mit diesem Account ein neues Repository mit dem Namen
      "<code>blog</code>" an.</para>

      <tip>
        <para>Für ein einfacheres Arbeiten empfehle ich Ihnen Ihren SSH Key in
        Ihrem Github-Account unter <uri
        xlink:href="https://github.com/settings/ssh">https://github.com/settings/ssh</uri>
        einzutragen. </para>
      </tip>

      <para>Jetzt können Sie Ihr Projekt commiten und pushen. Bitte tauschen
      Sie dabei <code>ihr_github_account</code> mit Ihrem Github-Account
      aus:<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git init</command>
Initialized empty Git repository in /Users/xyz/blog/.git/
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git add .</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git commit -m 'first commit'</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git remote add origin git@github.com:ihr_github_account/blog.git</command>
Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>git push -u origin master</command>
[...]
Stefan-Wintermeyers-MacBook-Air:blog xyz$</screen></para>

      <para>Jetzt ist Ihr Rails-Projekt in einem Github-Repository gehostet
      und kann von Ihnen unter <uri
      xlink:href="https://github.com/ihr_github_account/blog">https://github.com/ihr_github_account/blog</uri>
      eingesehen werden.</para>
    </section>
  </section>

  <section>
    <title>Schritte auf dem Webserver</title>

    <para>Folgende Schritte müssen Sie auf dem Webserver-System
    durchführen.</para>

    <section>
      <title>Installation auf Debian 6</title>

      <para>Bitte loggen Sie sich als <code>root</code> auf dem Debian Server
      ein.</para>

      <para>Als erstes installieren wir ein paar Pakete die wir
      brauchen.<screen>root@debian:~# <command>apt-get -y install build-essential openssl libreadline6 libreadline6-dev curl git-core zlib1g zlib1g-dev libssl-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt-dev autoconf libc6-dev ncurses-dev automake libtool bison subversion</command>
[...]
root@debian:~# </screen></para>

      <para>Als nächstes installieren wir die Datenbank MySQL. Dabei werden
      Sie nach einem Datenbankpasswort gefragt. Bitte merken Sie sich dieses
      Passwort. Damit kann sich später <code>root</code> auf der Datenbank
      einlogen.<screen>root@debian:~# <command>apt-get -y install mysql-server libmysql-ruby libmysqlclient-dev</command>
[...]
root@debian:~# </screen></para>

      <para>Wir erstellen einen neuen User mit dem Namen
      <code>deployer</code>:<screen>root@debian:~# <command>adduser deployer</command>
Lege Benutzer »deployer« an ...
Lege neue Gruppe »deployer« (1002) an ...
Lege neuen Benutzer »deployer« (1002) mit Gruppe »deployer« an ...
Erstelle Home-Verzeichnis »/home/deployer« ...
Kopiere Dateien aus »/etc/skel« ...
Geben Sie ein neues UNIX-Passwort ein: 
Geben Sie das neue UNIX-Passwort erneut ein: 
passwd: Passwort erfolgreich geändert
Benutzerinformationen für deployer werden geändert.
Geben Sie einen neuen Wert an oder drücken Sie ENTER für den Standardwert
 Vollständiger Name []: Deployer
 Raumnummer []: 
 Telefon geschäftlich []: 
 Telefon privat []: 
 Sonstiges []: 
Sind die Informationen korrekt? [J/n] J
root@debian:~#</screen></para>

      <para>Für diesen User erstellen wir einen public SSH-Key. Für ein
      einfacheres Deployment verwenden Sie an dieser Stelle bitte eine leere
      (also keine) Passphrase.<screen>root@debian:~# <command>su - deployer</command>
deployer@debian:~$ <command>ssh-keygen</command>
Generating public/private rsa key pair.
Enter file in which to save the key (/home/deployer/.ssh/id_rsa): 
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /home/deployer/.ssh/id_rsa.
Your public key has been saved in /home/deployer/.ssh/id_rsa.pub.
The key fingerprint is:
ba:11:90:2a:e3:8f:5b:2e:70:99:50:86:a1:9a:2c:b7 deployer@debian
The key's randomart image is:
+--[ RSA 2048]----+
|.o               |
|o o  .           |
|.o  o            |
|+. . .           |
|*ooo  . S        |
|+++.   o         |
|.oE.  o          |
| .=    o         |
| ooo  .          |
+-----------------+
deployer@debian:~$ <command>cat .ssh/id_rsa.pub</command> 
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDJEGixOcPRdBMry7PPG/Rgla50EM+JPKGYGD/yJ8v7bdrfT68t2/eVbj6+YebWh1tRebE3qqouqmZjIlocr1j67SmfXZ/sswBT/pXOhP89JtHPMolx7rUQ8wQF3aDrnVDJG0gdvRm212vN2bou3N5dzhekmWmbS3R0ZGNM9ZgTw8rhTOd1M2QVTzyV1i1PehoFxOu1WIc1gN5C42zihbJ6fGgVb45WeKzXSi6bQ6PMKD1gAMJpXHPvKLhi0wLN0wNOJwa6BKR3pmgICSBuoziAhhCS/7gBDJnqRmx1zax/1CShJD3QEGHvofA9okYuYVqyrJi1hdF8ZgMnQCb31I21 deployer@debian
deployer@debian:~$</screen></para>

      <para>Der erzeugte Key liegt in der Datei
      <filename>/home/deployer/.ssh/id_rsa.pub</filename>.</para>

      <important>
        <para>Bitte loggen Sie sich jetzt in Ihren Github-Account ein und
        fügen im Admin Bereich Ihres Github-Projektes diesen Key bei Deploy
        Keys hinzu. Siehe <uri
        xlink:href="https://github.com/ihr_github_account/blog/admin/keys">https://github.com/ihr_github_account/blog/admin/keys</uri></para>
      </important>

      <para>Danach verbinden Sie sich mit ssh bitte auf der Console einmal mit
      dem Github SSH-Server und bestätigen Sie die "Are you sure you want to
      continue connection (yes/no)?" Frage mit einem yes. <screen>deployer@debian:~$ <command>ssh git@github.com</command>
The authenticity of host 'github.com (207.97.227.239)' can't be established.
RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.
Are you sure you want to continue connecting (yes/no)? <command>yes</command>
Warning: Permanently added 'github.com,207.97.227.239' (RSA) to the list of known hosts.
PTY allocation request failed on channel 0
Hi ihr_github_account/blog! You've successfully authenticated, but GitHub does not provide shell access.
                 Connection to github.com closed.
deployer@debian:~$</screen></para>

      <para>Jetzt machen wir wieder als <code>root</code> weiter:<screen>deployer@debian:~$ <command>exit</command>
Abgemeldet
root@debian:~#</screen></para>

      <para>In der MySQL-Datenbank müssen wir noch die Database
      <code>blog</code> mit Zugriffsrechten für den User <code>deployer</code>
      anlegen:<screen>deployer@debian:~$ <command>mysql -u root -p</command>
Enter password: 
Welcome to the MySQL monitor.  Commands end with ; or \g.
Your MySQL connection id is 40
Server version: 5.1.63-0+squeeze1 (Debian)

Copyright (c) 2000, 2011, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type 'help;' or '\h' for help. Type '\c' to clear the current input statement.

mysql&gt; <command>CREATE DATABASE blog;</command>
Query OK, 1 row affected (0.00 sec)

mysql&gt; <command>GRANT USAGE ON *.* TO deployer@localhost IDENTIFIED BY 'IhrLieblingsPasswort';</command>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <command>GRANT ALL PRIVILEGES ON blog.* TO deployer@localhost;</command>
Query OK, 0 rows affected (0.00 sec)

mysql&gt; <command>exit</command>
Bye
deployer@debian:~$</screen></para>

      <para>Als nächstes installieren wir den Webserver nginx:<screen>root@debian:~# <command>curl http://nginx.org/keys/nginx_signing.key | apt-key add -</command>
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
100  1561  100  1561    0     0   3887      0 --:--:-- --:--:-- --:--:--  8819
OK
root@debian:~# <command>echo 'deb http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>echo 'deb-src http://nginx.org/packages/debian/ squeeze nginx' &gt;&gt; /etc/apt/sources.list</command>
root@debian:~# <command>apt-get update</command>
[...]
root@debian:~# <command>apt-get -y install nginx</command>
[...]
root@debian:~# </screen></para>

      <para>Für unser Rails-Projekt fügen wir eine neue Konfigurationdatei
      <filename>/etc/nginx/conf.d/blog.conf</filename> mit folgendem Inhalt
      hinzu:<programlisting>upstream unicorn {
  server unix:/tmp/unicorn.blog.sock fail_timeout=0;
}

server {
  listen 80 default deferred;
  # server_name example.com;
  root /home/deployer/apps/blog/current/public;

  location ^~ /assets/ {
    gzip_static on;
    expires max;
    add_header Cache-Control public;
  }

  try_files $uri/index.html $uri @unicorn;
  location @unicorn {
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header Host $http_host;
    proxy_redirect off;
    proxy_pass http://unicorn;
  }

  error_page 500 502 503 504 /500.html;
  client_max_body_size 4G;
  keepalive_timeout 10;
}</programlisting></para>

      <para>Die Default Konfigurationsdatei benennen wir um, damit sie nicht
      mehr ausgeführt wird. Danach stoppen wir den Webserver erst mal.<screen>root@debian:~# <command>mv /etc/nginx/conf.d/default.conf /etc/nginx/conf.d/default.backup</command>
root@debian:~# <command>/etc/init.d/nginx stop</command>
Stopping nginx: nginx.
root@debian:~# </screen></para>

      <para>Für Unicorn benötigen wir noch ein Init-Script. Bitte legen Sie
      die Datei <filename>/etc/init.d/unicorn_blog</filename> mit folgendem
      Inhalt an:<programlisting>#!/bin/sh
set -e

# Feel free to change any of the following variables for your app:
TIMEOUT=${TIMEOUT-60}
APP_ROOT=/home/deployer/apps/blog/current
PID=$APP_ROOT/tmp/pids/unicorn.pid
CMD="cd $APP_ROOT; bundle exec unicorn -D -c $APP_ROOT/config/unicorn.rb -E production"
AS_USER=deployer
set -u

OLD_PIN="$PID.oldbin"

sig () {
  test -s "$PID" &amp;&amp; kill -$1 `cat $PID`
}

oldsig () {
  test -s $OLD_PIN &amp;&amp; kill -$1 `cat $OLD_PIN`
}

run () {
  if [ "$(id -un)" = "$AS_USER" ]; then
    eval $1
  else
    su -c "$1" - $AS_USER
  fi
}

case "$1" in
start)
  sig 0 &amp;&amp; echo &gt;&amp;2 "Already running" &amp;&amp; exit 0
  run "$CMD"
  ;;
stop)
  sig QUIT &amp;&amp; exit 0
  echo &gt;&amp;2 "Not running"
  ;;
force-stop)
  sig TERM &amp;&amp; exit 0
  echo &gt;&amp;2 "Not running"
  ;;
restart|reload)
  sig HUP &amp;&amp; echo reloaded OK &amp;&amp; exit 0
  echo &gt;&amp;2 "Couldn't reload, starting '$CMD' instead"
  run "$CMD"
  ;;
upgrade)
  if sig USR2 &amp;&amp; sleep 2 &amp;&amp; sig 0 &amp;&amp; oldsig QUIT
  then
    n=$TIMEOUT
    while test -s $OLD_PIN &amp;&amp; test $n -ge 0
    do
      printf '.' &amp;&amp; sleep 1 &amp;&amp; n=$(( $n - 1 ))
    done
    echo

    if test $n -lt 0 &amp;&amp; test -s $OLD_PIN
    then
      echo &gt;&amp;2 "$OLD_PIN still exists after $TIMEOUT seconds"
      exit 1
    fi
    exit 0
  fi
  echo &gt;&amp;2 "Couldn't upgrade, starting '$CMD' instead"
  run "$CMD"
  ;;
reopen-logs)
  sig USR1
  ;;
*)
  echo &gt;&amp;2 "Usage: $0 &lt;start|stop|restart|upgrade|force-stop|reopen-logs&gt;"
  exit 1
  ;;
esac</programlisting></para>

      <para>Dann müssen wir dieses Init-Script noch scharf schalten:<screen>root@debian:~# <command>chmod a+x /etc/init.d/unicorn_blog</command> 
root@debian:~# <command>update-rc.d unicorn_blog defaults</command>
update-rc.d: using dependency based boot sequencing
root@debian:~#</screen></para>

      <para>Jetzt haben wir alle notwendigen Schritte auf dem Webserver-System
      ausgeführt und können im Entwicklungssystem weiter machen.</para>
    </section>
  </section>

  <section>
    <title>Deployen</title>

    <para>Als erstes richten wir mit <command>cap deploy:setup</command> das
    Zielsystem ein. Wenn Sie Ihren SSH-Key nicht auf dem Zielsystem abgelegt
    haben, werden Sie vom Skript nach dem Passwort des Users
    <code>deployer</code> gefragt. Je nach Anbindung und CPU-Power kann dieser
    initialle Setup-Schritt länger dauern.<screen>Stefan-Wintermeyers-MacBook-Air:blog xyz$ <command>cap deploy:setup</command>
  * executing `deploy:setup'
    triggering before callbacks for `deploy:setup'
  * executing `rvm:install_rvm'
  * executing "curl -L get.rvm.io |  bash -s stable --path $HOME/.rvm/"

[...]

  * executing "chmod g+w /home/deployer/apps/blog /home/deployer/apps/blog/releases /home/deployer/apps/blog/shared /home/deployer/apps/blog/shared/system /home/deployer/apps/blog/shared/log /home/deployer/apps/blog/shared/pids"
    servers: ["172.16.14.130"]
    [172.16.14.130] executing command
    command finished in 1211ms
Stefan-Wintermeyers-MacBook-Air:blog xyz$ </screen></para>

    <para></para>

    <para>Rest kommt noch. ...</para>

    <para></para>
  </section>

  <section>
    <title>Heroku</title>

    <para></para>
  </section>

  <section>
    <title>Engineyard</title>

    <para></para>
  </section>
</chapter>
