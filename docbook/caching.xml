<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="caching" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="caching.title">Caching</title>

  <indexterm>
    <primary>Caching</primary>
  </indexterm>

  <section xml:id="caching_einleitung">
    <title xml:id="caching_einleitung.title">Einleitung</title>

    <para>Im allgemeinen wird mit Caching bei Webapplikationen immer so lange
    gewartet, bis man an Performanceprobleme kommt. Als erstes schaut sich der
    Admin dann die Datenbank an und fügt hier und dort noch einen Index hinzu.
    Wenn das alles nicht mehr hilft, schaut man sich dann die Views an und
    fügt Fragment-Caching hinzu. Das ist aber der suboptimale Ansatz für die
    Arbeit mit Caches. Ziel dieses Kapitels ist Ihnen ein Verständnis für die
    Funktionsweise von Key-Based-Cache-Expiration zu geben. Damit können Sie
    dann neue Applikationen schon auf Datenbank-Struktur-Ebene so planen, das
    Sie bei der Entwicklung optimal cachen können.</para>

    <para>Dabei gibt es zwei Hauptargumente für die Benutzung von
    Caching:<itemizedlist>
        <listitem>
          <para>Die Applikation wird für den Anwender schneller. Eine
          schnellere Webseite resultiert in glücklichere Anwender.</para>
        </listitem>

        <listitem>
          <para>Sie brauchen weniger Hardware für den Webserver, weil sie
          weniger Resourcen zum Abarbeiten der Anfragen benötigen. Im
          Durchschnitt benötigt ein gut gecachetes System nur ein fünftel der
          Rechenleistung eines nicht gecacheten Systems. Meistens ist die
          Ersparnis noch höher.</para>
        </listitem>
      </itemizedlist></para>

    <para>Wenn beide Punkte für Sie irrelevant sind, dann brauchen Sie dieses
    Kapitel nicht zu lesen.</para>

    <para>Wir betrachten drei verschiedene Caching-Methoden:<itemizedlist>
        <listitem>
          <para>HTTP-Caching</para>

          <para>Das ist der Vorschlaghammer unter den Cache-Methoden und ist
          die ultimative Performance-Waffe. Gerade Webseiten die für mobile
          Endgeräte gedacht sind (z.B. iPhone), sollte versuchen HTTP-Caching
          maximal auszunutzen. Bei der Kombination aus
          Key-Based-Cache-Expiration mit HTTP-Caching sparen Sie massiv
          Rechenzeit auf dem Server und Bandbreite.</para>
        </listitem>

        <listitem>
          <para>Page-Caching</para>

          <para>Das ist der Schraubenzieher unter den Cache-Methoden. Man kann
          sehr viel Performance rausholen, aber es ist nicht so gut wie
          HTTP-Caching.</para>
        </listitem>

        <listitem>
          <para>Fragment-Caching</para>

          <para>Quasi die Pinzette unter den Cache-Methoden. Aber nicht zu
          unterschätzen. Kleinvieh macht auch Mist.</para>
        </listitem>
      </itemizedlist></para>

    <tip>
      <para>Das Ziel ist es alle drei Methoden optimal mit einander zu
      verknüpfen.</para>
    </tip>

    <section xml:id="caching_beispielapplikation">
      <title xml:id="caching_beispielapplikation.title">Eine einfache
      Beispielapplikation</title>

      <para>Um die Caching-Methoden auszuprobieren, brauchen wir eine
      Beispielapplikation. Wir verwenden ein einfaches Telefonbuch mit einem
      Model für die Firma und ein Model für die Mitarbeiter der Firmen.</para>

      <important>
        <para>Bitte bedenken: Wenn die später aufgezeigten Einsparungen schon
        bei einer solch einfachen Applikation so gross sind, dann werden sie
        bei komplexeren Applikationen mit komplexeren Views um so grösser
        sein.</para>
      </important>

      <para>Wir erstellen die neue Rails-App:<screen>MacBook:~ xyz$ <command>rails new phone_book</command>
[...]
MacBook:~ xyz$ <command>cd phone_book</command> 
MacBook:phone_book xyz$ <command>rails generate scaffold company name</command>
[...]
MacBook:phone_book xyz$ <command>rails generate scaffold employee company_id:integer last_name first_name phone_number</command>
[...]
MacBook:phone_book xyz$ <command>rake db:migrate</command>
[...]
MacBook:phone_book xyz$</screen></para>

      <section>
        <title>Models</title>

        <para>Wir fügen ein paar rudimentäre Regeln in die beiden Models
        ein.</para>

        <para><filename>app/models/company.rb</filename><programlisting>class Company &lt; ActiveRecord::Base
  attr_accessible :name

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true

  has_many :employees, :dependent =&gt; :destroy

  def to_s
    name
  end
end
</programlisting></para>

        <para><filename>app/models/employee.rb</filename><programlisting>class Employee &lt; ActiveRecord::Base
  attr_accessible :company_id, :first_name, :last_name, :phone_number

  belongs_to :company, :touch =&gt; true

  validates :first_name,
            :presence =&gt; true

  validates :last_name,
            :presence =&gt; true

  validates :company,
            :presence =&gt; true

  def to_s
    "#{first_name} #{last_name}"
  end
end</programlisting></para>
      </section>

      <section>
        <title>Views</title>

        <para>Die folgenden zwei Company Views verändern wir, um im Index-View
        die Anzahl der Mitarbeiter und im Show-View alle Mitarbeiter
        aufzulisten.</para>

        <para><filename>app/views/companies/index.html.erb</filename><programlisting>&lt;h1&gt;Listing companies&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Number of employees&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @companies.each do |company| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= company.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= company.employees.count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', company %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_company_path(company) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', company, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Company', new_company_path %&gt;
</programlisting></para>

        <para><filename>app/views/companies/show.html.erb</filename><programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Name:&lt;/b&gt;
  &lt;%= @company.name %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_company_path(@company) %&gt; |
&lt;%= link_to 'Back', companies_path %&gt;

&lt;h2&gt;Listing employees&lt;/h2&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Last name&lt;/th&gt;
    &lt;th&gt;First name&lt;/th&gt;
    &lt;th&gt;Phone number&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @company.employees.each do |employee| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= employee.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= employee.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= employee.phone_number %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</programlisting></para>
      </section>

      <section>
        <title>Beispieldaten</title>

        <para>Für das einfache Befüllen der Datenbank benutzen wir das Faker
        Gem (siehe <uri
        xlink:href="http://faker.rubyforge.org/">http://faker.rubyforge.org/</uri>).
        Mit Faker kann man zufällige Namen und Telefonnummern generieren.
        Bitte fügen Sie in der <filename>Gemfile</filename> Datei diese Zeile
        hinzu:<programlisting>gem 'faker'</programlisting></para>

        <para>Danach ein <command>bundle install</command> starten:<screen>MacBook:phone_book xyz$ <command>bundle install</command>
[...]
MacBook:phone_book xyz$</screen></para>

        <para>In der <filename>db/seeds.rb</filename> lassen wir 30 Firmen mit
        einer jeweils zufälligen Anzahl an Mitarbeitern
        erstellen:<programlisting>30.times do
  company = Company.new(:name =&gt; Faker::Company.name)
  if company.save
    SecureRandom.random_number(100).times do
      company.employees.create(
                               :first_name =&gt; Faker::Name.first_name, 
                               :last_name =&gt; Faker::Name.last_name, 
                               :phone_number =&gt; Faker::PhoneNumber.phone_number
                              )
    end
  end
end</programlisting></para>

        <para>Das Einspielen erfolgt mit <command>rake
        db:seed</command><screen>MacBook:phone_book xyz$ <command>rake db:seed</command>
MacBook:phone_book xyz$</screen></para>

        <para>Sie können die Applikation mit <command>rails server</command>
        starten und mit einem Webbrowser die Beispieldaten unten den URLs <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
        und <uri
        xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/1</uri>
        abrufen.</para>
      </section>
    </section>

    <section xml:id="caching_einleitung_normale_geschwindigkeit">
      <title xml:id="caching_einleitung_normale_geschwindigkeit.title">Normale
      Geschwindigkeit der zu optimierenden Seiten</title>

      <para>Wir optimieren in diesem Kapitel die folgenden Webseiten. Die
      Rails-Applikation wird mit <command>rails server</command> im
      Development-Modus gestartet. Die jeweiligen Zahlen hängen natürlich
      immer von der eingesetzen Hardware ab.<screen>MacBook:phone_book xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.6 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-07-13 14:31:45] INFO  WEBrick 1.3.1
[2012-07-13 14:31:45] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.4.0]
[2012-07-13 14:31:45] INFO  WEBrick::HTTPServer#start: pid=14357 port=3000</screen></para>

      <para>Zum Aufruf der Webseiten benutzen wir das Kommandozeilentool curl
      (<uri xlink:href="http://curl.haxx.se/">http://curl.haxx.se/</uri>).
      Natürlich können Sie die Webseiten auch mit anderen Webbrowsern
      aufrufen. Wir betrachten die im Rails-Log angezeigte Zeit zum Erstellen
      der Seite. Dazu muss man in der Realität noch das Ausliefern der Seite
      an den Webbrowser hinzurechnen.</para>

      <section xml:id="caching_einleitung_normale_geschwindigkeit_index_view">
        <title
        xml:id="caching_einleitung_normale_geschwindigkeit_index_view.title">Liste
        aller Firmen (Index-View)</title>

        <para>Unter der URL <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
        bekommt der Anwender eine Liste aller gespeicherten Firmen mit der
        jeweiligen Anzahl von Mitarbeitern angezeigt.</para>

        <para>Das Generieren der Seite dauert 85ms.<screen>Completed 200 OK in 85ms (Views: 71.9ms | ActiveRecord: 12.5ms)</screen></para>
      </section>

      <section xml:id="caching_einleitung_normale_geschwindigkeit_show_view">
        <title
        xml:id="caching_einleitung_normale_geschwindigkeit_show_view.title">Detailansicht
        einer einzelnen Firma (Show-View)</title>

        <para>Unter der URL <uri
        xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/1</uri>
        bekommt der Anwender die Detailsansicht der ersten Firma mit allen
        Mitarbeitern angezeigt.</para>

        <para>Das Generieren der Seite dauert 21ms.<screen>Completed 200 OK in 21ms (Views: 19.1ms | ActiveRecord: 1.1ms)</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="http_caching">
    <title xml:id="http_caching.title">HTTP-Caching</title>

    <indexterm>
      <primary>Caching</primary>

      <secondary>HTTP-Caching</secondary>
    </indexterm>

    <para>HTTP-Caching versucht bereits geladene Webseiten oder Dateien wieder
    zu verwenden. Wenn Sie z.B. mehrmals am Tag auf eine Webseite wie <uri
    xlink:href="http://www.heise.de">http://www.heise.de</uri> oder <uri
    xlink:href="http://www.spiegel.de">http://www.spiegel.de</uri> gehen, um
    sich dort immer die aktuellen Nachrichten durch zu lesen, dann werden
    bestimmte Elemente dieser Seite (z.B. die Logo-Grafik am Kopf der Seite)
    beim zweiten Laden nicht noch mal geladen. Ihr Browser hat diese Dateien
    bereits im Cache und spart somit Zugriffszeit und Bandbreite.</para>

    <para>Innerhalb des Rails-Frameworks ist es unser Ziel die Fragestellung
    "Hat sich eine Seite verändert?" bereits im Controller zu beantworten.
    Denn normalerweise wird die meiste Zeit beim Rendern der Seite in einem
    View verbraucht. In <xref
    linkend="caching_einleitung_normale_geschwindigkeit_index_view"/> kann man
    das gut sehen: Von insgesamt 85ms werden alleine 71,9ms und damit mehr als
    80% der Gesamtzeit mit dem Rendern des Views verbraucht.</para>

    <section xml:id="http_caching_last_modified">
      <title xml:id="http_caching_last_modified.title">Last-Modified</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>HTTP-Caching</secondary>

        <tertiary>Last-Modified</tertiary>
      </indexterm>

      <important>
        <para>Bitte passen Sie die in den Beispielen verwendeten Uhrzeiten an
        Ihre Gegenheiten an.</para>
      </important>

      <para>Der Webbrowser weiß, wann er eine Webseite downgeloadet und danach
      in den Cache gelegt hat. Diese Information kann er dem Webserver in
      einem <code>If-Modified-Since:</code> Header übergeben. Der Webserver
      kann diese Information dann mit der entsprechenden Datei vergleichen und
      entweder eine neuere Version ausliefern oder einen HTTP 304 Not Modified
      Code als Antwort liefern. Bei einem 304 liefert der Webbrowser die
      gecachete Version. Sie werden jetzt sagen "Das ist ja schön bei
      Grafiken, aber das nützt mir ja bei dynamisch generierten Webseiten wie
      dem Index-View der Firmen nichts". Da haben Sie aber die Fähigkeiten von
      Rails unterschätzt. ;-)</para>

      <para>Ändern Sie bitte in der Controller-Datei
      <filename>app/controllers/companies_controller.rb</filename> die
      <methodname>index</methodname> und <methodname>show</methodname>
      Methoden wie folgt ab:<programlisting>  def index
    @companies = Company.order(:id)

    fresh_when last_modified: @companies.maximum(:updated_at)
  end

  def show
    @company = Company.find(params[:id])

    fresh_when last_modified: @company.updated_at
  end</programlisting></para>

      <note>
        <para>Wie nehmen <code>@companies = Company.order(:id)</code> anstelle
        von <code>@companies = Company.all</code> um ActiveRecords Lazy
        Loading (siehe <xref linkend="lazy_loading"/>) benutzen zu
        können.</para>
      </note>

      <para>Nach einem Neustart der Rails-Applikation schauen wir uns mal den
      HTTP-Header von <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      an:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies</command>
HTTP/1.1 200 OK 
<emphasis>Last-Modified: Fri, 13 Jul 2012 12:14:50 GMT</emphasis>
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
X-Ua-Compatible: IE=Edge
X-Request-Id: a2b4f9bc64f53637691a4665563568f6
X-Runtime: 0.066358
Content-Length: 0
Server: WEBrick/1.3.1 (Ruby/1.9.3/2012-04-20)
Date: Fri, 13 Jul 2012 14:22:24 GMT
Connection: Keep-Alive
Set-Cookie: _phone_book_session=BAh7B0kiD3Nlc3Npb25faWQGOgZFRkkiJTliNWQxOTQ4ZDNmNTI2M2Q0ZjZiZTI5ZjdjYzIyY2EwBjsAVEkiEF9jc3JmX3Rva2VuBjsARkkiMVg1ZjNBNFBWcWxZSWJQRzM3aVczS2hiTzBtckx4SzFjeWQwOEZGWHVwNkU9BjsARg%3D%3D--08bd7983f93a82133df64e0c742953808c2e6d1f; path=/; HttpOnly

MacBook:~ xyz$</screen></para>

      <para>Der <code>Last-Modified</code> Eintrag im HTTP-Header wurde von
      <methodname>fresh_when</methodname> im Controller generiert. Wenn wir
      später die gleiche Webseite abrufen und dabei diese Uhrzeit mit angeben,
      dann bekommen wir nicht die Webseite, sondern einen <code>304 Not
      Modified</code> zurück:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies --header 'If-Modified-Since: Fri, 13 Jul 2012 12:14:50 GMT'</command>
HTTP/1.1 304 Not Modified 
Last-Modified: Fri, 13 Jul 2012 12:14:50 GMT
Cache-Control: max-age=0, private, must-revalidate
X-Ua-Compatible: IE=Edge
X-Request-Id: 7802f078add46dc372adaec92f343fe2
X-Runtime: 0.008647
Server: WEBrick/1.3.1 (Ruby/1.9.3/2012-04-20)
Date: Fri, 13 Jul 2012 14:27:15 GMT
Connection: close

MacBook:~ xyz$</screen></para>

      <para>Im Rails-Log finden wir folgendes:<screen>Started HEAD "/companies" for 127.0.0.1 at 2012-07-13 16:29:53 +0200
Processing by CompaniesController#index as */*
   (0.2ms)  SELECT MAX("companies"."updated_at") AS max_id FROM "companies" 
<emphasis>Completed 304 Not Modified in 2ms (ActiveRecord: 0.2ms)</emphasis></screen></para>

      <para>Rails hat für die Beantwortung dieser Anfrage 2ms im Vergleich zu
      67ms zur Standard-Variante benötigt. Das ist mehr als 40 mal schneller!
      Sie haben also rund 40 mal weniger Resourcen auf dem Server benötigt.
      Und es wurde massiv Bandbreite eingespart. Der Anwender bekommt die
      Seite viel schneller angezeigt.</para>

      <para>Erzielt wurde dieses Ergebnis durch
      <code>@companies.maximum(:updated_at)</code> im Controller. Wir haben
      nur abfragen müssen, wann das letzte Update in der Datenbank gemacht
      wurde. Sobald sich ein einzelner Company Datensatz ändert, so wird der
      Wert auf den dann aktuellen Zeitpunkt gesetzt und es wird wieder die
      ganze Webseite ausgeliefert. Mit dieser Methode können Sie auch
      dynamisch generierte Webseiten per <code>Last-Modified</code> Header
      ausliefern lassen.</para>
    </section>

    <section xml:id="http_caching_etag">
      <title xml:id="http_caching_etag.title">Etag</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>HTTP-Caching</secondary>

        <tertiary>Etag</tertiary>
      </indexterm>

      <para>Manchmal ist das <varname>update_at</varname> Feld eines
      bestimmten Objektes nicht alleine aussagefähig. Wenn Sie z.B. eine
      Webseite haben, auf der sich Anwender einloggen können und die
      Webseiten-Inhalte dann anhand eines Rollen-Models generiert. Dann kann
      es sein, das der Anwender A als Admin einen Edit-Link angezeigt bekommt
      und Anwender B als normaler User diesen Edit-Link nicht angezeigt
      bekommt. Bei solchen Szenarien nützt uns der in <xref
      linkend="http_caching_last_modified"/> erklärte Last-Modified Header
      nichts.</para>

      <para>Bei solchen Szeanrien können wir den Etag Header benutzen. Das
      Etag wird vom Webserver generiert und beim ersten Aufruf einer Webseite
      mitgeliefert. Der Browser kann bei späteren Abfragen der gleichen URL
      mit der Anfrage <code>If-None-Match:</code> beim Webserver anfragen, ob
      sich die entsprechende Webseite geändert hat.</para>

      <para>Ändern Sie bitte in der Controller-Datei
      <filename>app/controllers/companies_controller.rb</filename> die
      <methodname>index</methodname> und <methodname>show</methodname>
      Methoden wie folgt ab:<programlisting>  def index
    @companies = Company.all

    fresh_when etag: @companies
  end

  def show
    @company = Company.find(params[:id])

    fresh_when etag: @company
  end</programlisting></para>

      <para>Beim Etag kommt allerdings noch eine Rails Besonderheit ins Spiel:
      Rails setzt automatisch bei jedem neuen Besucher der Webseite ein neues
      CSRF-Token. Damit werden Cross-Site Request Forgery Angriffe vermieden
      (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/Cross-Site_Request_Forgery">http://de.wikipedia.org/wiki/Cross-Site_Request_Forgery</uri>).
      Dadurch bekommt aber auch jeder neue Anwender einer Webseite ein neues
      Etag für die an sich gleiche Seite. Um bei gleichen Anwendern auch
      identische CSRF-Tokens zu bekommen, werden diese vom Webbrowser in einem
      Cookie gespeichert und somit bei jedem Aufruf einer Webseite an den
      Webserver zurückgeschickt. Das von uns zum Entwickeln benutzte curl
      macht das aber nicht standardmässig. Wir können Curl aber sagen, das
      alle Cookies in einer Datei gespeichert werden sollen und diese Cookies
      später bei einer Anfrage auch übertragen.</para>

      <para>Das Abspeichern erfolgt mit dem <code>-c cookies.txt</code>
      Parameter.<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -c cookies.txt</command>
HTTP/1.1 200 OK 
Etag: "b5f711016cb2e5fce352230e607ceffe"
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$</screen></para>

      <para>Mit dem <code>-b cookies.txt</code> Parameter sendet curl bei
      einer Anfrage diese Cookies an den Webserver. Jetzt bekommen wir bei
      zwei aufeinander folgenden Anfragen den gleichen ETag geliefert:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -b cookies.txt</command>
HTTP/1.1 200 OK 
<emphasis>Etag: "132c1be24595b9b5f7b2c08b300592b1"</emphasis>
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -b cookies.txt</command>
HTTP/1.1 200 OK 
<emphasis>Etag: "132c1be24595b9b5f7b2c08b300592b1"</emphasis>
Content-Type: text/html; charset=utf-8
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$</screen></para>

      <para>Jetzt benutzen wir diesen Etag, um mit If-None-Match in der
      Anfrage rauszubekommen, ob die von uns gecachete Version noch aktuell
      ist:<screen>MacBook:~ xyz$ <command>curl -I http://0.0.0.0:3000/companies -b cookies.txt --header 'If-None-Match: "132c1be24595b9b5f7b2c08b300592b1"'</command>
<emphasis>HTTP/1.1 304 Not Modified</emphasis> 
Etag: "132c1be24595b9b5f7b2c08b300592b1"
Cache-Control: max-age=0, private, must-revalidate
[...]

MacBook:~ xyz$</screen></para>

      <para>Wir bekommen einen <code>304 Not Modified</code> geliefert.
      Schauen wir noch ins Rails-Log:<screen>Started HEAD "/companies" for 127.0.0.1 at 2012-07-13 18:45:38 +0200
Processing by CompaniesController#index as */*
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" 
<emphasis>Completed 304 Not Modified in 3ms (ActiveRecord: 0.3ms)</emphasis></screen></para>

      <para>Rails hat für die Verarbeitung der Anfrage nur 3ms benötigt. Fast
      30 mal schneller als die Variante ohne Cache! Plus wieder die
      eingesparte Bandbreite. Der Anwender freut sich wieder über die schnelle
      Webapplikation.</para>

      <section xml:id="http_caching_etag_current_user">
        <title xml:id="http_caching_etag_current_user.title">current_user und
        andere potentielle Parameter</title>

        <para>Wir können als Grundlage für die Generierung eines Etags nicht
        nur ein Objekt, sondern auch ein Array von Objekten übergeben. So
        können wir das Problem mit dem eingeloggten User lösen. Nehmen wir
        einmal an, das ein eingelogter User mit der Methode
        <methodname>current_user</methodname> ausgegeben wird. Dann würden die
        <methodname>index</methodname> und <methodname>show</methodname>
        Methoden im
        <filename>app/controllers/companies_controller.rb</filename>
        Controller so ausssehen:<programlisting>  def index
    @companies = Company.all

    <emphasis>fresh_when etag: [@companies, current_user]</emphasis>
  end

  def show
    @company = Company.find(params[:id])

    <emphasis>fresh_when etag: [@company, current_user]</emphasis>
  end</programlisting></para>

        <para>Sie können beliebig viele Objekte in diesem Array unterbringen
        und somit definieren, wann eine Seite sich nicht verändert hat.</para>
      </section>
    </section>

    <section xml:id="http_caching_etag_and_last_modified">
      <title xml:id="http_caching_etag_and_last_modified.title">Etag und
      Last-Modified kombinieren</title>

      <para>Sie können <code>Etag</code> und <code>Last-Modified</code> auch
      zusammen anwenden. Das sieht dann so aus:<programlisting>  def index
    @companies = Company.order(:id)

    fresh_when :etag =&gt; @companies.all, 
               :last_modified =&gt; @companies.maximum(:updated_at)
  end

  def show
    @company = Company.find(params[:id])

    fresh_when @company
  end</programlisting></para>

      <para>Sie sehen, das es beim show View eine Kurzform gibt. Das liegt
      daran, das <varname>@company</varname> eine Methode
      <methodname>updated_at</methodname> hat. Diese wird dann automatisch von
      <methodname>fresh_when</methodname> benutzt.</para>
    </section>

    <section xml:id="http_caching_touch">
      <title xml:id="http_caching_touch.title">Die Magie von touch</title>

      <para>Was passiert, wenn ein <classname>Employee</classname> verändert
      oder gelöscht wird? Dann würde sich auf jeden Fall der Show-View und
      evt. auch der Index-View ändern müssen. Das ist der Grund für die Zeile
      <programlisting>belongs_to :company, :touch =&gt; true</programlisting>
      im Employee Model. Jedesmal, wenn ein Objekt der Klasse
      <classname>Employee</classname> verändert abgespeichert wird, updatet
      ActiveRecord bei der Benutzung von <code>:touch =&gt; true</code> das
      darüberliegende <classname>Company</classname> Element in der Datenbank.
      Das <varname>updated_at</varname> Feld wird auf die aktuelle Uhrzeit
      gesetzt. Es wird ge-"touch"-t.</para>

      <para>Deshalb ist sichergestellt, das auch dann wieder eine korrekte
      Webseite ausgeliefert wird.</para>
    </section>

    <section xml:id="http_caching_stale">
      <title xml:id="http_caching_stale.title">stale?</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>HTTP-Caching</secondary>

        <tertiary>stale?</tertiary>
      </indexterm>

      <para>Bis jetzt sind wir immer davon ausgegangen, das nur HTML-Seiten
      ausgeliefert werden. Deshalb konnten wir
      <methodname>fresh_when</methodname> benutzen und danach auf den
      <code>respond_to do |format|</code> Block verzichten. HTTP-Caching ist
      aber nicht auf HTML-Seiten beschränkt. Wenn wir allerdings zusätzlich
      z.B. JSON rendern und via HTTP-Caching ausliefern wollen, so müssen wir
      die <methodname>stale?</methodname> Methode benutzen. Die Anwendung von
      <methodname>stale?</methodname> ähnelt sonst der von
      <methodname>fresh_when</methodname>. Das Beispiel aus <xref
      linkend="http_caching_etag_and_last_modified"/> würde bei Verwendung von
      <methodname>stale?</methodname> und beim zusätzlichen Rendern von JSON
      so aussehen:<programlisting>  def index
    @companies = Company.order(:id)

    if stale? :etag =&gt; @companies.all, 
              :last_modified =&gt; @companies.maximum(:updated_at)
      respond_to do |format|
        format.html
        format.json { render json: @companies }
      end
    end
  end

  def show
    @company = Company.find(params[:id])

    if stale? @company
      respond_to do |format|
        format.html
        format.json { render json: @company }
      end
    end
  end</programlisting></para>
    </section>

    <section xml:id="http_caching_public">
      <title xml:id="http_caching_public.title">Proxies mitbenutzen
      (public)</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>HTTP-Caching</secondary>

        <tertiary>public</tertiary>
      </indexterm>

      <para>Bis jetzt sind wir immer von einem Cache im Webbrowser
      ausgegangen. Es gibt aber im Internet sehr viele Proxies, die oft näher
      beim Anwender sind und deshalb bei Seiten die nicht personalisiert sind
      sinnvoll cachen können. Wenn es sich in unserem Beispiel um ein
      öffentlich zugängliches Telefonbuch handeln würde, dann könnten wir die
      für uns kostenlose Dienste der Proxies mit dem Parameter <code>public:
      true</code> in <methodname>fresh_when</methodname> oder
      <methodname>stale?</methodname> aktivieren. Das Beispiel aus <xref
      linkend="http_caching_etag_and_last_modified"/> würde bei Verwendung von
      <code>public: true</code> so aussehen:<programlisting>  def index
    @companies = Company.order(:id)

    fresh_when :etag =&gt; @companies.all, 
               :last_modified =&gt; @companies.maximum(:updated_at),
               :public =&gt; true
  end

  def show
    @company = Company.find(params[:id])

    fresh_when @company, public: true
  end</programlisting></para>

      <para>Beim Aufruf der Webseite bekommen wir die Ausgabe:<screen>MacBook:rails-buch stefan$ <command>curl -I http://0.0.0.0:3000/companies</command>
HTTP/1.1 200 OK 
Etag: "d45a37972109e8ccea1160d81a6ff79d"
Last-Modified: Sat, 14 Jul 2012 12:40:25 GMT
Content-Type: text/html; charset=utf-8
<emphasis>Cache-Control: public</emphasis>
[...]</screen></para>

      <para>Der Header <code>Cache-Control: public</code> sagt allen Proxies,
      das sie diese Webseite auch cachen können.</para>

      <warning>
        <para>Die Benutzung von Proxies muss immer mit grosser Vorsicht
        geschehen. Auf der einen Seite sind sie hervorrangend geeignet, die
        eigene Webseite schneller an mehr User auszuliefern, aber auf der
        anderen Seite muss man auch ganz sicher sein, das keine
        personalisierten Seiten auf öffentlichen Proxies gecachet werden. So
        haben CSRF-Tags und Flash-Nachrichten nichts in einem öffentlichen
        Proxy zu suchen. Um bei CSRF-Tags ganz sicher zu gehen empfiehlt es
        sich im Default
        <filename>app/views/layouts/application.html.erb</filename> Layout die
        Ausgabe von <methodname>csrf_meta_tag</methodname> davon abhängig zu
        machen, ob die Seite öffentlich gecachet werden darf oder
        nicht:<programlisting>&lt;%= csrf_meta_tag unless response.cache_control[:public] %&gt;</programlisting></para>
      </warning>
    </section>

    <section>
      <title>Cache-Control mit einem Zeitlimit</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>HTTP-Caching</secondary>

        <tertiary>Zeitlimit</tertiary>
      </indexterm>

      <indexterm>
        <primary>Caching</primary>

        <secondary>HTTP-Caching</secondary>

        <tertiary>Cache-Control</tertiary>
      </indexterm>

      <para>Bei der Benutzung von <code>Etag</code> und
      <code>Last-Modified</code> gehen wir in <xref
      linkend="http_caching_etag"/> und <xref
      linkend="http_caching_last_modified"/> davon aus, das der Webbrowser auf
      jeden Fall noch mal beim Webserver nachfragt, ob die gecachete Version
      einer Webseite noch aktuell ist. Das ist eine sehr sicherere
      Vorgehensweise.</para>

      <para>Allerdings kann man die Optimierung durch eine Prognose in die
      Zukunft noch ein Stück weiter treiben: Wenn ich mir beim Ausliefern
      einer Webseite sicher bin, das diese Webseite sich in den nächsten zwei
      Minuten, Stunden oder Tagen nicht verändert, dann kann ich das dem
      Webbrowser direkt mitteilen. Dann braucht er in dieser Zeitspanne nicht
      noch einmal nachzufragen. Diese Overhead-Einsparung hat besonders bei
      Mobilen-Webbrowsern mit relativ hohen Latenzen Vorteile. Ausserdem spart
      man natürlich auf dem Webserver noch einmal Server-Load.</para>

      <para>Bei der Ausgabe des HTTP-Headers wird Ihnen bei den
      <code>Etag</code> und <code>Last-Modified</code> Beispielen vielleicht
      schon die entsprechende Zeile <screen>Cache-Control: max-age=0, private, must-revalidate</screen>aufgefallen
      sein. Der Eintrag <code>must-revalidate</code> sagt dem Webbrowser, das
      er auf jeden Fall noch mal beim Webserver nachfragen soll, ob sich eine
      Webseite mittlerweile verändert hat. Der zweite Parameter
      <code>private</code> bedeutet, das nur der Webbrowser diese Seite cachen
      darf. Auf dem Weg liegende Proxies dürfen diese Seite nicht
      cachen.</para>

      <para>Wenn wir bei unserem Telefonbuch sagen, das die Webseite
      mindestens für 2 Minuten so bleiben wird, so können wir das <xref
      linkend="http_caching_etag_and_last_modified"/> Beispiel um die dafür
      vorgesehene Methode <methodname>expires_in</methodname> erweitern. Der
      Controller <filename>app/controllers/companies.rb</filename> würde dann
      folgenden Code für die <methodname>index</methodname> und
      <methodname>show</methodname> Methode enthalten:<programlisting>  def index
    @companies = Company.order(:id)

    expires_in 2.minutes
    fresh_when :etag =&gt; @companies.all, :last_modified =&gt; @companies.maximum(:updated_at)
  end

  def show
    @company = Company.find(params[:id])

    expires_in 2.minutes
    fresh_when @company
  end
</programlisting></para>

      <para>Jetzt bekommen wir bei einer Abfrage eine andere Cache-Control
      Information:<screen>MacBook:rails-buch stefan$ <command>curl -I http://0.0.0.0:3000/companies</command>
HTTP/1.1 200 OK 
Etag: "d45a37972109e8ccea1160d81a6ff79d"
Last-Modified: Sat, 14 Jul 2012 12:40:25 GMT
Content-Type: text/html; charset=utf-8
<emphasis>Cache-Control: max-age=120, private</emphasis>
[...]</screen></para>

      <para>Die zwei Minuten werden in Sekunden angegeben
      (<code>max-age=120</code>) und zusätzlich entfällt
      <code>must-revalidate</code>. Der Webbrowser muss also in den nächsten
      120 Sekunden nicht mehr beim Webserver nachfragen, ob sich der Inhalt
      dieser Seite geändert hat.</para>

      <note>
        <para>Dieser Mechanismus wird auch von der Asset Pipeline benutzt.
        Dort im Produktivbetrieb erstellte Asssets sind durch die Prüfsumme im
        Dateinamen eindeutig identifizierbar und können sehr lange sowohl im
        Webbrowser wie auch in öffentlichen Proxies gecachet werden. Deswegen
        haben wir in <xref
        linkend="production_webserver_capistrano_nginx_konfiguration"/> in der
        nginx Konfigurationsdatei den Abschnitt<programlisting>location ^~ /assets/ {
  gzip_static on;
  expires max;
  add_header Cache-Control public;
}</programlisting></para>
      </note>
    </section>
  </section>

  <section xml:id="page_caching">
    <title xml:id="page_caching.title">Page Caching</title>

    <indexterm>
      <primary>Caching</primary>

      <secondary>Page Caching</secondary>
    </indexterm>

    <para>Beim Page Caching geht es darum komplette HTML-Seite (also das
    Render-Ergebnis eines Views) in einem Unterverzeichnis der
    <filename>public</filename> Verzeichnisses abzulegen und beim nächsten
    Aufruf dieser Webseite von dort direkt vom Webserver (z.B. Nginx)
    ausliefern zu lassen. Zusätzlich kann man auch direkt eine komprimierte
    gz-Version der HTML-Seite dort abspeichern. Ein Produktiv-Webserver wird
    Dateien unterhabl von <filename>public</filename> automatisch selbst
    ausliefern und kann auch so konfiguriert werden, das - falls gz-Dateien
    vorhanden sind - diese direkt ausgeliefert werden.</para>

    <para>Bei komplexen Views die auch mal 500ms und mehr zum Rendern brauchen
    ist die Zeitersparnis natürlich bedeutend. Als Webseitenbetreiber spart
    man wieder wertvolle Serverresourcen und kann mehr Besucher mit der
    gleichen Hardware bedienen. Der Besucher der Webseite profitiert durch
    eine schnellere Auslieferung der Seite.</para>

    <warning>
      <para>Achten Sie bei der Programmierung Ihrer Rails-Applikation darauf
      diese Seite auch selbst upzudaten, bzw. zu löschen! Eine Beschreibung
      dazu finden Sie in <xref linkend="page_caches_automatisch_loeschen"/>.
      Sonst enden Sie später mit einem veralteten Cache.</para>

      <para>Achten Sie bitte ebenfalls darauf, das Page Caching per Default
      alle URL-Parameter verwirft. So wird die Abfrage <uri
      xlink:href="http://0.0.0.0:3000/companies?search=abc">http://0.0.0.0:3000/companies?search=abc</uri>
      zu <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>.
      Das lässt sich aber leicht mit einer besserer Routen-Logik lösen.</para>
    </warning>

    <para>Bitte installieren Sie eine frische Beispielapplikation (siehe <xref
    linkend="caching_beispielapplikation"/>).</para>

    <section xml:id="page_caching_im_devel_modus_aktivieren">
      <title xml:id="page_caching_im_devel_modus_aktivieren.title">Page
      Caching im Development-Modus aktivieren</title>

      <para>Als erstes müssen wir in der Datei
      <filename>config/environments/development.rb</filename> den Eintrag
      <code>config.action_controller.perform_caching</code> auf
      <code>true</code> setzen:<programlisting>config.action_controller.perform_caching = true</programlisting></para>

      <para>Sonst können wir das Page Caching im Development-Modus nicht
      ausprobieren. Im Production-Modus ist Page Caching per Default
      aktiviert.</para>
    </section>

    <section xml:id="page_caching_fuer_index_und_show">
      <title>Company Index- und Show-View cachen</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Page Caching</secondary>

        <tertiary>caches_page</tertiary>
      </indexterm>

      <para>Page Caching wird im Controller aktiviert. Wenn wir für Company
      die Index- und Show-Views cachen wollen, dann müssen wir im Controller
      <filename>app/controllers/companies_controller.rb</filename> am Kopf den
      <code>caches_page :index, :show</code> Befehl eingeben:<programlisting>class CompaniesController &lt; ApplicationController
  <emphasis>caches_page :index, :show</emphasis>

  # GET /companies
  # GET /companies.json
  def index
    @companies = Company.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @companies }
    end
  end

[...]</programlisting></para>

      <para>Vor dem Starten der Applikation sieht das
      <filename>public</filename> Verzeichnis so aus:<screen>public/
|-- 404.html
|-- 422.html
|-- 500.html
|-- favicon.ico
|-- index.html
`-- robots.txt</screen></para>

      <para>Nach dem Starten der Applikation mit <command>rails
      server</command> und dem Abruf der URLs <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/1</uri>
      mit einem Webbrowser sieht es so aus:<screen>public/
|-- 404.html
|-- 422.html
|-- 500.html
|-- companies
|   `-- 1.html
|-- companies.html
|-- favicon.ico
|-- index.html
`-- robots.txt</screen></para>

      <para>Die Dateien <filename>public/companies.html</filename> und
      <filename>public/companies/1.html</filename> wurden vom Page Caching
      erstellt. Ab sofort wird der Webserver beim Aufruf dieser Seiten nur
      noch die gecachten Versionen liefern.</para>

      <section xml:id="page_caching_gz_compression">
        <title>gz Versionen</title>

        <indexterm>
          <primary>Caching</primary>

          <secondary>Page Caching</secondary>

          <tertiary>:gzip =&gt; :best_compression</tertiary>
        </indexterm>

        <para>Wenn man Page Cache einsetzt, dann sollte man auch direkt
        gezippte gz-Dateien cachen. Das geht mit der Option <code>:gzip =&gt;
        true</code> oder anstatt <code>true</code> einen bestimmten
        Kompressionsparameter als Symbol (z.B.
        <code>:best_compression</code>).</para>

        <para>Der Controller
        <filename>app/controllers/companies_controller.rb</filename> würde
        dann am Anfang so aussehen:<programlisting>class CompaniesController &lt; ApplicationController
  <emphasis>caches_page :index, :show, :gzip =&gt; :best_compression</emphasis>

  # GET /companies
  # GET /companies.json
  def index
    @companies = Company.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @companies }
    end
  end

[...]</programlisting></para>

        <para>Damit werden automatisch eine komprimierte und eine
        unkomprimierte Variante eines jeden Page Caches abgespeichert:<screen>public/
|-- 404.html
|-- 422.html
|-- 500.html
|-- companies
|   |-- 1.html
|   `-- 1.html.gz
|-- companies.html
|-- companies.html.gz
|-- favicon.ico
|-- index.html
`-- robots.txt</screen></para>
      </section>

      <section xml:id="page_caching_html_ending_nginx_rewrite">
        <title>Die Dateiendung .html</title>

        <para>Rails speichert die mit <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
        aufgerufene Seite unter dem Dateinamen
        <filename>companies.html</filename>. Damit wird der vorgeschaltete
        Webserver zwar diese Datei beim Aufruf von <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies.html</uri>
        finden und ausliefern, aber nicht beim Aufruf von <uri
        xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>,
        denn es fehlt ja das <filename>.html</filename> am Ende der
        URI.</para>

        <para>Bei der Verwendung des in <xref
        linkend="rails_production_webserver"/> erklärten Nginx-Servers geht
        das am leichtesten mit der folgenden Anpassung der
        <code>try_files</code> Anweisung in der
        Nginx-Konfiguration-Datei:<programlisting>try_files $uri/index.html $uri $uri.html @unicorn;
</programlisting></para>

        <para>Nginx schaut damit nach, ob eine Datei mit der Endung
        <filename>.html</filename> von der aktuell aufgerufenen URI
        existiert.</para>
      </section>
    </section>

    <section xml:id="page_caches_automatisch_loeschen">
      <title xml:id="page_caches_automatisch_loeschen.title">Page Caches
      automatisch löschen</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Page Caching</secondary>

        <tertiary>löschen</tertiary>
      </indexterm>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Page Caching</secondary>

        <tertiary>Sweeper</tertiary>
      </indexterm>

      <para>Sobald sich die im View verwendeten Daten verändern, müssen
      natürlich die gespeicherten Cache-Dateien gelöscht werden. Sonst wäre
      der Cache nicht mehr aktuell.</para>

      <para>Laut offizieller Rails-Doku ist die Lösung für dieses Problem die
      Klasse <classname>ActionController::Caching::Sweeper</classname>. Dieser
      auf <uri
      xlink:href="http://guides.rubyonrails.org/caching_with_rails.html#sweepers">http://guides.rubyonrails.org/caching_with_rails.html#sweepers</uri>
      beschriebene Weg hat aber einen großen Nachteil: Er beschränkt sich nur
      auf Aktionen, die innerhalb des Controllers geschehen. Wenn ein Objekt
      z.B. in der Console gelöscht wird, dann werden keine Sweepers
      getriggert. Deshalb stelle ich Ihnen den Ansatz vor das Löschen der
      Cache-Dateien im Model zu triggern.</para>

      <para>In unserer Telefonbuchapplikation müssen wir bei der Veränderung
      einer Firma immer den Cache für <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/companies/1">http://0.0.0.0:3000/companies/id_der_firma</uri>
      löschen. Bei einer Veränderung eines Angestellten müssen wir zusätzlich
      noch die entsprechenden Caches zu dem Angestellten löschen.</para>

      <important>
        <para>Wir müssen wir darauf achten keine Seiten mit einer
        Flash-Nachricht zu cachen. Weiterhin macht es auch keinen Sinn bei
        diesen gecacheten Seiten einen CSRF-Meta-Tag einzubauen. Beides wird
        im folgenden Code beachtet.</para>
      </important>

      <section>
        <title>Controller</title>

        <para>Fangen wir mit den Controllern an. Bitte ändern Sie den Anfang
        von <filename>app/controllers/companies_controller.rb</filename> wie
        folgt ab:<programlisting>class CompaniesController &lt; ApplicationController
<emphasis>  caches_page :index, :show, :gzip =&gt; :best_compression, 
                             :if =&gt; Proc.new { flash.count == 0 }
  before_filter(only: [:index, :show]) { @page_caching_is_active = true if flash.count == 0 }</emphasis>

  # GET /companies
  # GET /companies.json
  def index
    @companies = Company.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @companies }
    end
  end

[...]</programlisting></para>

        <para>Bitte fügen Sie die <methodname>cache_page</methodname>
        Anweisung auch in den Controller
        <filename>app/controllers/employees_controller.rb</filename>
        ein:<programlisting>class EmployeesController &lt; ApplicationController
<emphasis>  caches_page :index, :show, :gzip =&gt; :best_compression, 
                             :if =&gt; Proc.new { flash.count == 0 }
  before_filter(only: [:index, :show]) { @page_caching_is_active = true if flash.count == 0 }</emphasis>

  # GET /employees
  # GET /employees.json
  def index
    @employees = Employee.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @employees }
    end
  end

[...]</programlisting></para>
      </section>

      <section>
        <title>Models</title>

        <para>Jetzt müssen wir in den Models noch eintragen, das die
        entsprechenden Caches automatisch gelöscht werden, sobald sich ein
        Objekt erstellt, verändert oder gelöscht wird.</para>

        <para><filename>app/models/company.rb</filename><programlisting>class Company &lt; ActiveRecord::Base
  attr_accessible :name

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true

  has_many :employees, :dependent =&gt; :destroy

<emphasis>  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache
</emphasis>
  def to_s
    name
  end

<emphasis>  def expire_cache
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.company_path(self))
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.companies_path)
  end
</emphasis>
end</programlisting></para>

        <para><filename>app/models/employee.rb</filename><programlisting>class Employee &lt; ActiveRecord::Base
  attr_accessible :company_id, :first_name, :last_name, :phone_number

  belongs_to :company, :touch =&gt; true

  validates :first_name,
            :presence =&gt; true

  validates :last_name,
            :presence =&gt; true

  validates :company,
            :presence =&gt; true

<emphasis>  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache</emphasis>

  def to_s
    "#{first_name} #{last_name}"
  end

<emphasis>  def expire_cache
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.employee_path(self))
    ActionController::Base.expire_page(Rails.application.routes.url_helpers.employees_path)
    self.company.expire_cache
  end</emphasis>

end</programlisting></para>
      </section>

      <section>
        <title>application.html.erb</title>

        <para>In der
        <filename>app/views/layouts/application.html.erb</filename> müssen wir
        noch berücksichtigen, ob ein CSRF-Meta-Tag eingebaut wird. Dies ist
        bei gecacheten Seiten nicht der Fall.<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;PhoneBook&lt;/title&gt;
  &lt;%= stylesheet_link_tag    "application", :media =&gt; "all" %&gt;
  &lt;%= javascript_include_tag "application" %&gt;
  <emphasis>&lt;%= csrf_meta_tag unless @page_caching_is_active %&gt;</emphasis>
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="fragment_caching">
    <title xml:id="fragment_caching.title">Fragment Caching</title>

    <indexterm>
      <primary>Caching</primary>

      <secondary>Fragment Caching</secondary>
    </indexterm>

    <para>Mit Fragment Caching können Sie einzelne Teile eines Views cachen.
    Es kann problemlos zusammen mit <xref linkend="http_caching"/> und <xref
    linkend="page_caching"/> eingesetzt werden. Die Vorteile liegen auch hier
    in der Reduzierung der Server-Load und der schnelleren
    Webseitengenerierung und damit einer besseren Usability.</para>

    <para>Bitte installieren Sie eine frische Beispielapplikation (siehe <xref
    linkend="caching_beispielapplikation"/>).</para>

    <section xml:id="fragment_caching_im_devel_modus_aktivieren">
      <title
      xml:id="fragment_caching_im_devel_modus_aktivieren.title">Fragment
      Caching im Development-Modus aktivieren</title>

      <para>Als erstes müssen wir in der Datei
      <filename>config/environments/development.rb</filename> den Eintrag
      <code>config.action_controller.perform_caching</code> auf
      <code>true</code> setzen:<programlisting>config.action_controller.perform_caching = true</programlisting></para>

      <para>Sonst können wir das Fragement Caching im Development-Modus nicht
      ausprobieren. Im Production-Modus ist Fragement Caching per Default
      aktiviert.</para>
    </section>

    <section xml:id="fragment_caching_tabelle_cachen">
      <title xml:id="fragment_caching_tabelle_cachen.title">Tabelle des
      Index-View cachen</title>

      <para>Auf der Seite <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      wird eine sehr rechenintensive Tabelle mit allen Firmen gerendert. Diese
      Tabelle können wir im gesamten cachen. Dazu müssen wir die Tabelle in
      einen <code>&lt;% cache('name_des_caches') do %&gt; ... &lt;% end
      %&gt;</code> Block einbauen:<programlisting>&lt;% cache('name_des_caches') do %&gt;

[...]

&lt;% end %&gt;</programlisting></para>

      <para>Bitte verändern Sie die Datei
      <filename>app/views/companies/index.html.erb</filename> wie
      folgt:<programlisting>&lt;h1&gt;Listing companies&lt;/h1&gt;

<emphasis>&lt;% cache('table_of_all_companies') do %&gt;</emphasis>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Number of employees&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @companies.each do |company| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= company.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= company.employees.count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', company %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_company_path(company) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', company, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;
<emphasis>&lt;% end %&gt;</emphasis>

&lt;br /&gt;

&lt;%= link_to 'New Company', new_company_path %&gt;</programlisting></para>

      <para>Danach können Sie den Rails-Server mit <command>rails
      server</command> starten und die URL <uri
      xlink:href="http://0.0.0.0:3000/companies">http://0.0.0.0:3000/companies</uri>
      aufrufen. Im Development-Log werden Sie dann den folgenden Eintrag
      finden:<screen><emphasis>Write fragment views/table_of_all_companies (2.9ms)</emphasis>
  Rendered companies/index.html.erb within layouts/application (119.8ms)
Completed 200 OK in <emphasis>209ms</emphasis> (Views: 143.1ms | ActiveRecord: 15.0ms)</screen></para>

      <para>Das Schreiben des Caches hat 2.0ms gedauert. Im Gesamten hat das
      Rendern der Seite 209 ms gedauert.</para>

      <para>Bei einem wiederholten Aufruf der gleichen Seite bekommen Sie eine
      andere Ausgabe im Log:<screen><emphasis>Read fragment views/table_of_all_companies (0.2ms)</emphasis>
  Rendered companies/index.html.erb within layouts/application (0.8ms)
Completed 200 OK in <emphasis>37ms</emphasis> (Views: 34.6ms | ActiveRecord: 0.3ms)</screen></para>

      <para>Das Lesen des Caches dauerte 0.2ms und das gesamte Rendern der
      Seite 37ms. Nur ein Fünftel Rechenzeit!</para>
    </section>

    <section xml:id="fragment_cache_loeschen">
      <title xml:id="fragment_cache_loeschen.title">Fragment Cache
      löschen</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Fragment Caching</secondary>

        <tertiary>Cache löschen</tertiary>
      </indexterm>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Fragment Caching</secondary>

        <tertiary>expire_fragment</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>expire_fragment</methodname> können
      Sie gezielt Fragment Caches löschen. Von der Grundidee können wir das
      genauso im Model einbauen wie in <xref
      linkend="page_caches_automatisch_loeschen"/> gezeigt.</para>

      <para>Die Model-Datei <filename>app/models/company.rb</filename> würde
      dann so aussehen:<programlisting>class Company &lt; ActiveRecord::Base
  attr_accessible :name

  validates :name,
            :presence =&gt; true,
            :uniqueness =&gt; true

  has_many :employees, :dependent =&gt; :destroy

  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache

  def to_s
    name
  end

  def expire_cache
    <emphasis>ActionController::Base.new.expire_fragment('table_of_all_companies')</emphasis>
  end
end</programlisting></para>

      <para>Da sich die Anzahl der Employees auch auf diese Tabelle auswirkt,
      müssten wir auch die Datei <filename>app/models/employees.rb</filename>
      entsprechend erweitern:<programlisting>class Employee &lt; ActiveRecord::Base
  attr_accessible :company_id, :first_name, :last_name, :phone_number

  belongs_to :company, :touch =&gt; true

  validates :first_name,
            :presence =&gt; true

  validates :last_name,
            :presence =&gt; true

  validates :company,
            :presence =&gt; true

  after_create   :expire_cache
  after_update   :expire_cache
  before_destroy :expire_cache

  def to_s
    "#{first_name} #{last_name}"
  end

  def expire_cache
    <emphasis>ActionController::Base.new.expire_fragment('table_of_all_companies')</emphasis>
  end  
end</programlisting></para>

      <para>Das gezielte Löschen von Fragment Caches ist programmiertechnisch
      oft aufwendig. Erstens übersieht man häufig etwas und zweitens ist es
      auch nicht einfach in grossen Projekten über die verschiedenen Namen der
      Caches den Überblick zu bewahren. Oft ist es einfacher mit der
      <methodname>cache_key</methodname> Methode automatische Namen zu
      erstellen, die im Cache automatisch altern (siehe <xref
      linkend="fragment_auto_expiring"/>).</para>
    </section>

    <section xml:id="fragment_auto_expiring">
      <title xml:id="fragment_auto_expiring.title">Auto-Expiring
      Caches</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Fragment Caching</secondary>

        <tertiary>cache_key</tertiary>
      </indexterm>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Fragment Caching</secondary>

        <tertiary>Auto-Expiring</tertiary>
      </indexterm>

      <indexterm>
        <primary>cache_key</primary>
      </indexterm>

      <para>Die Verwaltung von Fragment Caches ist bei der in <xref
      linkend="fragment_caching_tabelle_cachen"/> verwendeten Namenskonvention
      nicht trivial. Man kann zwar bei sauberer Programmierung sicher sein,
      das der Cache keinen überflüssigen Balast mitschleppt, aber auf der
      anderen Seite kann einem das auch eigentlich egal sein. Ein Cache ist
      immer so aufgebaut, das er selbstständig alte und nicht benötigte
      Elemente löscht. Wenn wir ähnlich wie in der Asset Pipeline (siehe <xref
      linkend="asset_pipeline"/>) einen Mechanismus einsetzen, der einen
      Fragment Cache unique benennt, dann müssten wir nicht aufwendig Fragment
      Caches löschen.</para>

      <para>Genau dafür gibt es die Methode
      <methodname>cache_key</methodname>. <methodname>cache_key</methodname>
      gibt Ihnen einen unique Namen für ein Element. Probieren wir es einmal
      in der Console aus. Als erstes lassen wir uns drei mal den immer
      identischen <methodname>cache_key</methodname> des ersten Company
      Eintrages geben ("companies/2-20120716190032"), dann touchen wir den
      Eintrag (mit einem <methodname>touch</methodname> wird das Attribute
      <varname>updated_at</varname> auf die aktuelle Uhrzeit gesetzt) und zum
      Schluss geben wir noch mal drei mal den neuen
      <methodname>cache_key</methodname> aus
      ("companies/2-20120716192035"):<screen>MacBook:phone_book xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.6)
1.9.3p194 :001 &gt; <command>Company.first.cache_key</command>
  Company Load (0.1ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716190032" 
1.9.3p194 :002 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716190032" 
1.9.3p194 :003 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716190032" 
1.9.3p194 :004 &gt; <command>Company.first.touch</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
  SQL (2.0ms)  UPDATE "companies" SET "updated_at" = '2012-07-16 19:20:35.223146' WHERE "companies"."id" = 2
 =&gt; true 
1.9.3p194 :005 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716192035" 
1.9.3p194 :006 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716192035" 
1.9.3p194 :007 &gt; <command>Company.first.cache_key</command>
  Company Load (0.3ms)  SELECT "companies".* FROM "companies" LIMIT 1
 =&gt; "companies/2-20120716192035" 
1.9.3p194 :008 &gt; <command>exit</command>
MacBook:phone_book xyz$</screen></para>

      <para>Verändern wir einmal mit diesem Wissen den Index-View in der Datei
      <filename>app/views/companies/index.html.erb</filename>:<programlisting>&lt;h1&gt;Listing companies&lt;/h1&gt;

<emphasis>&lt;% cache(@companies) do %&gt;</emphasis>
&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Name&lt;/th&gt;
    &lt;th&gt;Number of employees&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @companies.each do |company| %&gt;
  <emphasis>&lt;% cache(company) do %&gt;</emphasis>
  &lt;tr&gt;
    &lt;td&gt;&lt;%= company.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= company.employees.count %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', company %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_company_path(company) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', company, method: :delete, data: { confirm: 'Are you sure?' } %&gt;&lt;/td&gt;
  &lt;/tr&gt;
  <emphasis>&lt;% end %&gt;</emphasis>
&lt;% end %&gt;
&lt;/table&gt;<emphasis>
&lt;% end %&gt;</emphasis>

&lt;br /&gt;

&lt;%= link_to 'New Company', new_company_path %&gt;</programlisting></para>

      <para>Wir benutzen hier nicht nur einen Fragment Cache für die ganze
      Tabelle, sondern auch jeweils einen für jede Zeile. Der erste Aufruf
      dauert damit auch länger als vorher. Aber wenn sich einzelne Firmen
      ändern, muss immer nur eine Zeile neu gerendet werden.</para>

      <note>
        <para>In welcher Detailtiefe man Fragment Cacheing einsetzen sollte,
        kann nicht allgemein beantwortet werden. Experimentieren Sie damit und
        schauen Sie sich im Log an, was wie lange dauert.</para>
      </note>
    </section>

    <section xml:id="fragment_cache_software_version">
      <title
      xml:id="fragment_cache_software_version.title">Software-Versionierung
      und current_user</title>

      <para>Als Entwickler sollten Sie beim Einsatz von Fragment Caches immer
      einen Versionsstand mit eincodieren. Nur so können Sie sicher sein, das
      bei einer neuen Software-Version nicht ein alter Cache mit einem alten
      Inhalt ausgeliefert wird. Sie können dazu den Namen des Fragment Caches
      nicht als String, sondern als Array angeben. Beispiel:<programlisting>&lt;% cache(['V3.23', @companies]) do %&gt;

[...]

&lt;% end %&gt;</programlisting></para>

      <para>Über diesen Mechanismus können Sie auch Caches für einzelne User
      realisieren. Wenn Sie ein User-Objekt mit dem Namen
      <code>current_user</code> haben, so können Sie folgenden Code zum
      Fragment Cachen benutzen:<programlisting>&lt;% cache(['V3.23', current_user, @companies]) do %&gt;

[...]

&lt;% end %&gt;</programlisting></para>

      <para>Wenn kein User eingelogt ist, dann ist <code>current_user</code>
      nil und funktioniert dann für alle nicht angemeldeten User.</para>

      <tip>
        <para>Es sprengt den Rahmen eines Anfänger-Buches, aber bei der
        Benutzung einer Versionsverwaltung von Dateien (z.B. git) ist es
        praktisch anstatt des 'V3.23' eine Konstante einzubauen und diese in
        einem Initializer mit dem aktuellen Commit SHA aus dem benutzten
        Repository zu setzen.</para>
      </tip>
    </section>

    <section xml:id="fragment_cache_cache_store">
      <title xml:id="fragment_cache_cache_store.title">Cache Store</title>

      <indexterm>
        <primary>Caching</primary>

        <secondary>Fragment Caching</secondary>

        <tertiary>Cache Store</tertiary>
      </indexterm>

      <indexterm>
        <primary>Cache Store</primary>
      </indexterm>

      <para>Der Cache Store verwaltet die gespeicherten Fragment Caches. Wenn
      nicht anders konfiguriert ist dies der MemoryStore von Rails. Dieser
      Cache Store ist gut zum Entwicklen geeignet, aber für ein
      Produktivsystem weniger, weil er pro Ruby on Rails Prozess eigenständig
      agiert. Wenn Sie also im Produktivsystem mehrere Ruby on Rails Prozesse
      parallel laufen lassen, dann hält jeder Prozess einen eigenen
      MemoryStore vor.</para>

      <section xml:id="fragment_cache_memcachestore">
        <title
        xml:id="fragment_cache_memcachestore.title">MemCacheStore</title>

        <indexterm>
          <primary>Cache Store</primary>

          <secondary>MemCacheStore</secondary>
        </indexterm>

        <indexterm>
          <primary>memcached</primary>
        </indexterm>

        <para>Die meistens Produktivsysteme benutzen memcached (<uri
        xlink:href="http://memcached.org/">http://memcached.org/</uri>) als
        Cache Store. Um memcached als Cache Store im Produktivsystem zu
        aktieren, müssen Sie in der Datei
        <filename>config/environments/production.rb</filename> die folgende
        Zeile hinzufügen:<programlisting>config.cache_store = :mem_cache_store</programlisting></para>

        <para>Zusätzlich müssen Sie in der Datei Gemfile noch einen Eintrag
        für das Laden des memcache-client Gems eintragen:<programlisting>group :production do
  gem 'memcache-client'
end</programlisting></para>

        <para>Danach müssen Sie ein <command>bundle install</command>
        ausführen:<screen>Stefan-Wintermeyers-MacBook-Air:phone_book xyz$ <command>bundle install</command>
[...]
Stefan-Wintermeyers-MacBook-Air:phone_book xyz$</screen></para>

        <para>Die Kombination von sinnvoll eingesetzten Auto-Expiring Caches
        und memcached ist ein sehr gutes Rezept für eine performante
        Webseite.</para>

        <para>Eine Installationsbeschreibung für ein Rails-Produktiv-System
        mit memcached finden Sie in <xref
        linkend="rails_production_webserver"/>.</para>
      </section>

      <section>
        <title>Andere Cache Stores</title>

        <para>In der offiziellen Rails Doku finden Sie unter <uri
        xlink:href="http://guides.rubyonrails.org/caching_with_rails.html#cache-stores">http://guides.rubyonrails.org/caching_with_rails.html#cache-stores</uri>
        eine Liste mit anderen Cache Stores.</para>
      </section>
    </section>
  </section>

  <section xml:id="cache_vorheizen">
    <title xml:id="cache_vorheizen.title">Vorheizen</title>

    <indexterm>
      <primary>Caching</primary>

      <secondary>Vorheizen</secondary>
    </indexterm>

    <para>Nachdem Sie das ganze Caching-Kapitel durchgelesen haben, gibt es
    zum Schluss noch einen Tipp: Heizen Sie Ihren Cache vor!</para>

    <para>Wenn Sie z.B. eine Webapplikation in einer Deutschen Firma betreiben
    und wissen, das sich morgens um 09:00 Uhr alle Mitarbeiter einloggen und
    dann erst mal auf diese Webapplikation zugreifen, dann lassen Sie Ihren
    Webserver ein paar Stunden vorher schon mal per cron-job diese ganzen
    Views durchgehen. Nachts langweilt sich ihr Server wahrscheinlich
    eh.</para>

    <para>Beobachten Sie einmal das User-Verhalten Ihrer Anwender. Bei
    öffentlichen Webseiten geht das z.B. sehr gut mit Google Analytics (<uri
    xlink:href="http://www.google.com/intl/de/analytics/">http://www.google.com/intl/de/analytics/</uri>).
    Sie werden feststellen, das zu bestimmten Tageszeiten wesentlich mehr
    Traffic reinkommt. Wenn Sie davor eine ruhige Phase haben, können Sie
    diese nutzen, um Ihren Cache vorzuheizen.</para>

    <para>Auch beim Vorheizen geht es um Einsparung von Resourcen beim Server
    und eine bessere Qualität - weil die Webseite schneller angezeigt wird -
    für den Anwender.</para>
  </section>
</chapter>
