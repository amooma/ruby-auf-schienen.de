<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="erste_schritte_mit_rails" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="erste_schritte_mit_rails.title">Erste Schritte mit
  Rails</title>

  <section>
    <title>Einleitung</title>

    <para>Nachdem Sie sich im <xref linkend="ruby-grundlagen" /> mühsam in die
    Ruby-Grundlagen eingelesen haben, können wir jetzt spannender
    weitermachen. In diesem Kapitel starten wir ein erstes Rails-Projekt und
    arbeiten uns damit Stück für Stück in die Materie ein.</para>

    <para>Auch in diesem Kapitel wird es manchmal hoppla-hopp zu gehen. Wir
    stossen auf typische Henne-Ei-Probleme wir zum Beispiel: "Wie erkläre ich
    MVC (Model-View-Controller)?". Ich habe mich für den "Wir fangen mal an
    und erklären bei der Arbeit."-Ansatz entschieden.</para>

    <section xml:id="arbeits-umgebung-development">
      <title>Arbeits-Umgebung (Development)</title>

      <para>Rails kennt drei verschiedene Arbeits-Umgebungen:<itemizedlist>
          <listitem>
            <para>Development</para>
          </listitem>

          <listitem>
            <para>Testing</para>
          </listitem>

          <listitem>
            <para>Production</para>
          </listitem>
        </itemizedlist></para>

      <para>Wir arbeiten in diesem Kapitel nur mit der Development Umgebung.
      So bald Sie ein besseres Gefühl für Rails bekommen haben, starten wir
      mit Tests und benötigen dafür die entsprechende Umgebung (dort wird z.B.
      beim Start eines Tests die Test-Datenbank neu gefühlt und beim Beenden
      wird gelöscht). Später erkläre ich Ihnen dann die verschiedenen
      Szenarien, wie Sie Ihre Rails-Applikation aus der Development-Umgebung
      in die Production-Umgebung ausrollen können.</para>

      <para>Die Development-Umgebung bringt bis auf einen Editor und einen
      Webbrowser alles mit, was Sie zum Entwickeln benötigen. So müssen Sie
      nicht extra einen Webserver installieren, sondern können den eingebauten
      Rails-Webserver benutzen. Der besticht nicht durch extreme Performance,
      aber das benötigen wir bei der Entwicklung ja auch nicht. Später kann
      man dann auf grosse Systeme wie <application>Apache</application>
      umsteigen. Das gleiche gilt für die Datenbank.</para>

      <para>Um in der Development-Umgebung zu arbeiten, müssen Sie erst mal
      nichts verändern. Alle Befehle gelten per Default auf die
      Development-Umgebung.</para>

      <section xml:id="sqlite3_datenbank_default">
        <title>sqlite3 Datenbank</title>

        <para>Auch bei der Datenbank geht es in diesem Kapitel nicht um
        optimale Performance, sondern um einen einfachen Einstieg. Deshalb
        benutzen wir die sqlite3 Datenbank. Dafür haben Sie bereits alles
        fertig installiert und müssen sich keinen Kopf machen. Später erkläre
        ich Ihnen dann wie Sie andere Datenbank (z.B. MySQL) ansteuern
        können.</para>
      </section>

      <section>
        <title>Warum alle Feldnamen, Methoden und Klassen auf
        Englisch?</title>

        <para>Ganz tief im Herzen liebt Rails die englische Sprache. Damit
        muss man sich abfinden und versuchen diese Liebe zu übernehmen. So
        verwenden sehr viele Mechanismen automagisch Plural oder Singular von
        Englischen Wörtern. Wenn man sich damit anfreundet Datenbankfelder und
        Datenbanken an sich mit englischen Wörter zu benennen, dann kann man
        die ganze Macht dieser Magie ausnutzen.</para>
      </section>
    </section>
  </section>

  <section xml:id="statische_webseiten">
    <title xml:id="statische_webseiten.title">Einfache Webseiten und
    Grafiken</title>

    <para>Jeder der diesen Text liest wird sich darüber im Klaren sein, das
    man mit Rails irgendwie Webseiten ausliefern kann. Die Frage ist nur wie.
    Legen wir erst mal eine neues Railsprojekte an.</para>

    <section>
      <title>Railsprojekt anlegen</title>

      <para>Bevor wir hier überhaupt mit dem aller einfachsten starten,
      überprüfen Sie bitte, ob Sie eine Ruby Version 1.9.2 einsetzen:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>ruby -v</command>
ruby 1.9.2p0 (2010-08-18 revision 29036) [x86_64-darwin10.4.0]
stefan@swmbp 0 1.9.2-p0 ~$</screen></para>

      <para>Und als nächstes überprüfen wir, ob auch Rails 3.0 oder höher
      installiert ist:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails -v</command>
Rails 3.0.0
stefan@swmbp 0 1.9.2-p0 ~$</screen></para>

      <para>Das sieht gut aus. Falls Sie eine ältere Ruby- oder Rails-Version
      installiert haben, dann installieren Sie bitte vor dem Weiterlesen die
      aktuelle Version (siehe <xref
      linkend="installation-und-versionsauswahl" />).</para>

      <para>Jetzt erstellen wir erst mal ein neues Rails-Projekt mit dem Namen
      <code>testproject</code>. Da Ruby on Rails ein Framework ist, müssen wir
      erst mal die entsprechende Verzeichnisstruktur und die
      Grundkonfiguration inkl. einiger Skripte einrichten. Das geht aber mit
      dem Befehl <command>rails new testproject</command> ratz-fatz:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new testproject</command>
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/views/layouts/application.html.erb
      create  app/mailers
      create  app/models
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      create  config/initializers
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/secret_token.rb
      create  config/initializers/session_store.rb
      create  config/locales
      create  config/locales/en.yml
      create  config/boot.rb
      create  config/database.yml
      create  db
      create  db/seeds.rb
      create  doc
      create  doc/README_FOR_APP
      create  lib
      create  lib/tasks
      create  lib/tasks/.gitkeep
      create  log
      create  log/server.log
      create  log/production.log
      create  log/development.log
      create  log/test.log
      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js
      create  script
      create  script/rails
      create  test
      create  test/performance/browsing_test.rb
      create  test/test_helper.rb
      create  test/fixtures
      create  test/functional
      create  test/integration
      create  test/unit
      create  tmp
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ </screen></para>

      <para>Als erstes führen wir jetzt ein <command>bundle install</command>
      aus und stellen damit dem Rails Projekt alle benötigten Gems zur
      Verfügung. Ein Gem ist eine Art Softwarebibliothek. Man kann damit
      bestimmte Funktionalitäten fix und fertig einbinden ohne das Rad neu
      erfinden zu müssen.<important>
          <para>Es ist völlig egal, ob Sie die entsprechenden Gems schon auf
          Ihrem System installiert haben oder nicht. Sie müssen
          <emphasis>immer</emphasis> ein <command>bundle install</command> in
          ihrem jeweiligen Rails Projekt ausführen! Am besten direkt ins Hirn
          brennen: Nach einen <command>rails new projectname</command> kommt
          immer ein <command>cd projectname &amp;&amp; bundle
          install</command>!</para>
        </important><screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>cd testproject</command>
stefan@swmbp 0 1.9.2-p0 testproject$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
Using abstract (1.0.0) 
Using activesupport (3.0.0) 
Using builder (2.1.2) 
Using i18n (0.4.1) 
Using activemodel (3.0.0) 
Using erubis (2.6.6) 
Using rack (1.2.1) 
Installing rack-mount (0.6.13) 
Using rack-test (0.5.4) 
Using tzinfo (0.3.23) 
Using actionpack (3.0.0) 
Using mime-types (1.16) 
Using polyglot (0.3.1) 
Using treetop (1.4.8) 
Using mail (2.2.5) 
Using actionmailer (3.0.0) 
Using arel (1.0.1) 
Using activerecord (3.0.0) 
Using activeresource (3.0.0) 
Using bundler (1.0.0) 
Using thor (0.14.0) 
Using railties (3.0.0) 
Using rails (3.0.0) 
Using sqlite3-ruby (1.3.1) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Als nächstes prüfen wir, ob die neue Rails-Applikation
      funktioniert. Dazu starten wir den mitgelieferten kleinen
      Web-Server.<footnote>
          <para>Nein, keine Angst. Das ist nicht der Webserver, mit dem wir
          später auch Produktiv gehen. Aber zum Entwickeln ist diese Variante
          sehr praktisch.</para>
        </footnote><note>
          <para>Bei verschiednen Betriebssystemen (z.B. Mac OS X) kommt beim
          ersten Starten einer Rails-Applikation, je nach Firewall
          Einstellung, ein Fenster, das Sie fragt, ob die Firewall die
          entsprechende Verbindung erlauben soll. Da wir lokal arbeiten,
          können Sie das mit ruhigen Gewissen bejahen.</para>
        </note><screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 09:39:58] INFO  WEBrick 1.3.1
[2010-09-01 09:39:58] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 09:39:58] INFO  WEBrick::HTTPServer#start: pid=40688 port=3000

</screen></para>

      <para>Der Start der Rails Applikation sieht gut aus. Er sagt
      uns:<screen>=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000</screen></para>

      <para>Dann rufen wir doch mal genau diese URI (<uri
      xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri>) im
      Webbrowser auf.<screenshot>
          <info>
            <title>Default Index-Seite in einem frischen
            Rails-Projekt.</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/virgin_rails_app.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Sieht gut aus. Rails scheint zu funktionieren. Wenn wir jetzt auf
      den "About your application's environment" Link klicken erscheint eine
      Aufstellung der aktuellen Umgebung.<screenshot>
          <info>
            <title>Auflistung der Start-Umgebung der
            Rails-Applikation.</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/virgin_rails_app_env_info.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Gleichzeitig wird im Log des Webservers folgendes
      angezeigt:<screen>Started GET "/rails/info/properties" for 127.0.0.1 at 2010-09-01 09:44:41 +0200
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.4ms)
Completed 200 OK in 60ms (Views: 1.2ms | ActiveRecord: 0.3ms)
</screen></para>

      <para>Da beim Aufruf der ersten Startseite kein entsprechender Eintrag
      erschien, muss es sich um zwei verschiedenartige Seiten handeln. Die
      erste Seite ist tatsächlich eine statische HTML-Seite, die unter
      <filename>public/index.html</filename> abgespeichert ist und der Link,
      auf den wir geklickt haben führt ein Rails Programm aus.</para>

      <para>Mit <keycode>CTRL + C</keycode> können Sie den Webserver wieder
      stoppen.</para>
    </section>

    <section>
      <title>Statische Seiten</title>

      <para>Wie eben gesehen gibt es bestimmte statische Seiten und Grafiken
      die von Rails automatisch und per default sogar ohne Logging
      ausgeliefert werden. Errinnern wir uns noch mal an eine Teilausgabe vom
      Befehl <command>rails new testproject</command>: <screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new testproject</command>

      [...]

      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js

      [...]
</screen></para>

      <para>Der Verzeichnisname <filename>public</filename> und die darin
      enthaltenen Dateien sehen schon sehr nach statischen Seiten aus.
      Probieren wir es einfach mal aus und legen die Datei
      <filename>public/hello-world.html</filename> mit folgendem Inhalt
      an:<programlisting>&lt;html&gt;
&lt;title&gt;Hello World!&lt;/title&gt;
&lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;p&gt;Eine Beispielseite.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

      <note>
        <para>Ich gehe davon aus, das Sie rudimentäre HTML-Kenntnisse haben -
        für viel mehr reicht mein HTML-Wissen auch nicht ;-).</para>
      </note>

      <para>Jetzt noch den Rails Webserver starten:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 09:49:58] INFO  WEBrick 1.3.1
[2010-09-01 09:49:58] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 09:49:58] INFO  WEBrick::HTTPServer#start: pid=40688 port=3000

</screen></para>

      <para>Diese Webseite können wir uns mit der URI <uri
      xlink:href="http://0.0.0.0:3000/hello-world">http://0.0.0.0:3000/hello-world</uri>
      anschauen:<screenshot>
          <info>
            <title>Hello-World HTML Seite</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/hello-world-html.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Wir können natürlich auch die URI <uri
      xlink:href="http://0.0.0.0:3000/hello-world.html">http://0.0.0.0:3000/hello-world.html</uri>
      nehmen. Allerdings sieht Rails HTML und damit die Datei-Endung
      <filename>html</filename> quasi als Standard-Ausgabe-Format an und
      deshalb kann man sich das ".html" hier sparen.</para>

      <para>So, jetzt wissen Sie schon mal, wie man ganz statische Seiten in
      Rails integrieren kann. Das ist manchmal für Seiten praktisch, die sich
      nie, aber wirklich gar nie ändern. Natürlich gilt dies für jegliche Art
      von Datei. So sind Klassiker die Favicon-Datei und die
      <filename>robots.txt</filename> Datei. Beide legt man einfach in das
      <filename>public/</filename> Verzeichnis.</para>

      <para><qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Wo speichern Sie Ihr Firmenlogo
                (<filename>logo.png</filename>)?</para>
              </question>

              <answer>
                <para>Natürlich im <filename>public/</filename> Verzeichnis.
                Denn es ist eine statische Datei.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>
    </section>

    <section>
      <title>Seiten mit dynamischen Inhalt (erb)</title>

      <para>Kennen Sie PHP? Dann wird Ihnen der Inhalt eine erb-Datei sehr
      bekannt vorkommen. Es ist eine Mischung aus HTML und Ruby-Code.
      Allerdings können wir eine solche erb-Webseite nicht einfach in das
      <filename>public</filename> Verzeichnis legen, da dort abgelegte Seite
      1:1 ausgeliefert werden und nicht durch einen erb-Parser gehen.
      Dummerweise müssen wir dafür jetzt direkt mit dem MVC-Modell anrücken.
      Wir brauchen einen Controler. Den können wir mit <command>rails generate
      controller</command> anlegen. Schauen wir uns mal die Hilfe an:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails generate controller</command>
Usage:
  rails generate controller NAME [action action] [options]

Options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
  -t, [--test-framework=NAME]   # Test framework to be invoked
                                # Default: test_unit
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Stubs out a new controller and its views. Pass the controller name, either
    CamelCased or under_scored, and a list of views as arguments.

    To create a controller within a module, specify the controller name as a
    path like 'parent_module/controller_name'.

    This generates a controller class in app/controllers and invokes helper,
    template engine and test framework generators.

Example:
    `rails generate controller CreditCard open debit credit close`

    Credit card controller with URLs like /credit_card/debit.
        Controller:      app/controllers/credit_card_controller.rb
        Functional Test: test/functional/credit_card_controller_test.rb
        Views:           app/views/credit_card/debit.html.erb [...]
        Helper:          app/helpers/credit_card_helper.rb
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

      <para>A-ha! Unten ist freundlicherweise direkt ein Beispiel angegeben
      "<code>rails generate controller CreditCard open debit credit
      close</code>". Passt aber nicht direkt für unseren Fall.</para>

      <para>Ich bin mutig und schlage vor, das wir einfach mal was
      ausprobieren:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails generate controller Example test</command>
      create  app/controllers/example_controller.rb
       route  get "example/test"
      invoke  erb
      create    app/views/example
      create    app/views/example/test.html.erb
      invoke  test_unit
      create    test/functional/example_controller_test.rb
      invoke  helper
      create    app/helpers/example_helper.rb
      invoke    test_unit
      create      test/unit/helpers/example_helper_test.rb
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Puhhh... da wird ja direkt ne ganze Menge erstellt. Unter anderem
      eine Datei <filename>app/views/example/test.html.erb</filename>. Schauen
      wir uns die mal an:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat app/views/example/test.html.erb </command>
&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Ist also auch HTML. Fehlt oben und unten etwas, aber prinzipiel
      sieht das stark nach HTML aus. Zum Testen starten wir den
      Webserver<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 10:30:50] INFO  WEBrick 1.3.1
[2010-09-01 10:30:50] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 10:30:50] INFO  WEBrick::HTTPServer#start: pid=40964 port=3000
</screen></para>

      <para>und schauen uns die Webseite mit der URI <uri
      xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
      mal im Browser an:<screenshot>
          <info>
            <title>test.html.erb Screenshot</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/example-test-erb.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Im Log <filename>log/development.log</filename> finden wir den
      folgenden Eintrag:<programlisting>Started GET "/example/test" for 127.0.0.1 at 2010-09-01 10:31:24 +0200
  Processing by ExampleController#test as HTML
Rendered example/test.html.erb within layouts/application (2.1ms)
Completed 200 OK in 21ms (Views: 20.7ms | ActiveRecord: 0.0ms)
</programlisting></para>

      <para>Das ist fast schon verständlich geschrieben. Es kam also vom
      localhost (127.0.0.1) ein HTTP GET-Request für die URI "/example/test"
      rein. Die wurde dann anscheinend vom Controller
      <code>ExampleController</code> mit der Methode
      <methodname>test</methodname> als HTML gerendert. Das ganze hat hier
      ungefähr 21ms gedauert.</para>

      <para>Jetzt müssen wir nur noch den Controller finden. Aber Sie haben
      Glück ... ich weiß es nämlich. ;-) Alle Controller befinden sich im
      Verzeichnis <filename>app/controllers</filename> und siehe da, dort ist
      auch tatsächlich die entsprechende Datei
      <filename>app/controllers/example_controller.rb</filename>. Schauen wir
      mal rein:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>ls -l app/controllers/</command>
total 16
-rw-r--r--  1 stefan  staff  80  1 Sep 09:29 application_controller.rb
-rw-r--r--  1 stefan  staff  70  1 Sep 10:29 example_controller.rb
stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat app/controllers/example_controller.rb</command> 
class ExampleController &lt; ApplicationController
  def test
  end

end
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

      <para>Das ist jetzt sehr übersichtlich. Der Controller
      <code>ExampleController</code> stammt vom
      <code>ApplicationController</code> ab und besteht aktuell aus genau
      einer Methode mit dem Namen <methodname>test</methodname>. Und diese
      Methode macht nichts.</para>

      <para>Sie werden sich fragen, woher Rails weiß, das bei der URI
      <uri>/example/test</uri> der Controller <code>example</code> und die
      Methode <code>test</code> abzuarbeiten ist. Das wird nämlich nicht durch
      eine magische Logik, sondern durch eine einfache Routing-Konfiguration
      gesteuert. Diese finden Sie in der Datei
      <filename>config/routes.rb</filename> in der zweiten Zeile:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat config/routes.rb | grep example</command>
  get "example/test"
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Diese Zeile wurde vom <command>rails generate controller</command>
      automatisch eingefügt. In der Routing-Datei können Sie auch beliebiges
      Mapping vornehmen. Aber dazu später mehr. Aktuell sehen unsere Routen
      sehr einfach aus. Mit dem Befehl <command>rake routes</command> können
      wir diese abfragen:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rake routes</command>
(in /Users/stefan/testproject)
example_test GET /example/test(.:format) {:controller=&gt;"example", :action=&gt;"test"}
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Wir kümmern uns später noch genauer um die Routen. Ich wollte es
      an dieser Stelle nur nicht gänzlich überspringen.</para>

      <important>
        <para>Eine statische Datei im Verzeichnis <filename>public</filename>
        hat immer eine höhere Priorität als eine Route in der
        <filename>config/routes.rb</filename>! Wenn wir also eine statische
        Datei <filename>public/example/test</filename> abspeichern würden, so
        würde die Route nicht mehr greifen.</para>
      </important>

      <section>
        <title>Programmieren in einer erb-Datei</title>

        <para>Erb-Seiten können Ruby-Code enthalten. Damit kann programmiert
        werden und damit können diese Seite dynamischen Inhalt
        bekommen.</para>

        <para>Fangen wir mal mit etwas ganz einfachem an: Der Addition von 1
        und 1. Als erstes probieren wir den Code im irb aus:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>1 + 1</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

        <para>Das war einfach. Die darum erweiterte erb-Datei
        <filename>app/views/example/test.html.erb</filename> füllen wir wie
        folgt:<programlisting>&lt;h1&gt;Erste Versuche mit erb&lt;/h1&gt;
&lt;p&gt;Addition:
&lt;%= 1 + 1 %&gt;
&lt;/p&gt;
</programlisting></para>

        <para>Danach mit <command>rails server</command> den Server starten
        (falls noch nicht getan) und per Webserver auf die Seite
        gehen:<screenshot>
            <info>
              <title>Einfache Addition</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/erb_einfache_addition.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Ruby Code dessen Ergebnis ausgegeben werden soll, wird von einem
        <code>&lt;%=</code> und einem <code>%&gt;</code> eingeschlossen.
        Ausgegeben werden können nur Strings.</para>

        <para>Jetzt werden Sie sich vielleicht fragen: Wie kann den das
        Ergebnis einer Addion von zwei Fixnums als Text angezeigt werden?
        Schauen wir erst mal im irb nach, ob es wirklich ein Fixnum
        ist:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>1.class</command>
 =&gt; Fixnum 
ruby-1.9.2-p0 &gt; <command>(1 + 1).class</command>
 =&gt; Fixnum 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

        <para>Ja, sowohl die Zahl 1 wie auch das Ergebnis von 1 + 1 ist ein
        Fixnum. Was ist passiert? Rails ist so intelligent alle Objekte in
        einem View (das ist die Datei <filename>test.html.erb</filename>) die
        nicht ein String sind automatisch mit der Methode
        <methodname>.to_s</methodname> aufzurufen. Noch mal kurz ins
        irb:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>(1 + 1).class</command>
 =&gt; Fixnum 
ruby-1.9.2-p0 &gt; <command>(1 + 1).to_s.class</command>
 =&gt; String 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

        <para>Das mit dem Ruby-Code schauen wir uns mal genauer an. In einer
        <filename>html.erb</filename> Datei gibt zusätzlich zu den
        HTML-Elementen zwei Arten von Ruby-Code Elementen:<itemizedlist>
            <listitem>
              <para><code>&lt;% ... %&gt;</code></para>

              <para>Führt den enthaltenen Ruby-Code aus, aber gibt nichts
              aus.</para>
            </listitem>

            <listitem>
              <para><code>&lt;%= ... %&gt;</code></para>

              <para>Führt den enthaltenen Ruby-Code aus und gibt das Ergebnis
              als Text aus. Dabei werden seit Ruby 3.0 automatisch
              "problematische" Zeichen escaped. Falls Sie einmal nicht
              escapeten Text ausgeben möchten, so müssen Sie das mit
              <code>raw(string)</code> realisieren.</para>

              <para>So lange also ein Objekt eine Methode
              <methodname>.to_s</methodname> hat oder das Objekt selber schon
              ein String ist, kann man es als Ergebnis im View innerhalb einer
              <code>&lt;%= ... %&gt;</code> Kapselung ausgeben.</para>
            </listitem>
          </itemizedlist>Um ganz sicher zu sein, noch ein Beispiel. Wir ändern
        die <filename>app/views/example/test.html.erb</filename> wie
        folgt:<programlisting>&lt;p&gt;Schleife von 0 bis 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;
</programlisting></para>

        <para>Das sieht dann im Browser so aus:<screenshot>
            <info>
              <title>Einfache Addition</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/erb_einfache_schleife.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Schauen wir uns mal den HTML-Source-Code im Browser
        an:<programlisting>&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;head&gt; 
  &lt;title&gt;Testproject&lt;/title&gt; 
  
  &lt;script src="/javascripts/prototype.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/effects.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/dragdrop.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/controls.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/rails.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/application.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
  &lt;meta name="csrf-param" content="authenticity_token"/&gt; 
&lt;meta name="csrf-token" content="7vy1+iQpYWFUhvXS2UHPXZOFjkpePZj/gBOkUASWoyY="/&gt; 
&lt;/head&gt; 
&lt;body&gt; 
 
&lt;p&gt;Schleife von 0 bis 5:
0, 
1, 
2, 
3, 
4, 
5, 
&lt;/p&gt; 
 
 
&lt;/body&gt; 
&lt;/html&gt;</programlisting></para>

        <para>Alles klar? Es gibt zwei mögliche offene Fragen:<qandaset>
            <qandadiv>
              <qandaentry>
                <question>
                  <para>Ich verstehe gar nichts. Mit dem Ruby-Code komme ich
                  nicht zurecht. Können Sie das noch mal erklären?</para>
                </question>

                <answer>
                  <para>Kann es sein, das Sie <xref
                  linkend="ruby-grundlagen" /> nicht komplett durchgearbeitet
                  haben? Bitte die Zeit dafür nehmen. Sonst macht hier das
                  alles keinen Sinn.</para>
                </answer>
              </qandaentry>

              <qandaentry>
                <question>
                  <para>Ich verstehe den Ruby-Code und die HTML-Ausgabe.
                  Allerdings verstehe ich nicht, warum drum rum noch HTML-Code
                  gerendert wurde, den ich gar nicht geschrieben habe. Woher
                  kommt der und kann ich Ihn beeinflussen?</para>
                </question>

                <answer>
                  <para>Sehr gute Frage! Dazu kommen wir sofort (siehe <xref
                  linkend="erb_layouts" />).</para>
                </answer>
              </qandaentry>
            </qandadiv>
          </qandaset></para>

        <para>Die Feinheiten von erb werden Sie jetzt Stück für Stück
        erlernen. Es handelt sich dabei nicht um Zauberei.</para>
      </section>
    </section>

    <section xml:id="erb_layouts">
      <title xml:id="erb_layouts.title">Layouts</title>

      <para>Die erb Datei im Verzeichnis
      <filename>app/views/example/</filename> bilden nur den Kern der späteren
      HTML-Seite. Per default wird immer eine automatisch generierte
      <filename>app/views/layouts/application.html.erb</filename> drum rum
      gerendert. Schauen wir uns die mal an:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat app/views/layouts/application.html.erb</command>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Testproject&lt;/title&gt;
  &lt;%= stylesheet_link_tag :all %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

      <para>Ich löse das Rätsel auf: Interessant ist die Zeile<programlisting>&lt;%= yield %&gt;</programlisting></para>

      <para>Mit <code>&lt;%= yield %&gt;</code> wird die View-Datei
      inkludiert. Die drei Zeilen mit den Stylesheets und dem JavaScript
      lassen wir erst mal so wie sie sind. Darum kümmern wir uns
      später.</para>

      <para>Die <filename>app/views/layouts/application.html.erb</filename>
      bietet Ihnen die Möglichkeit das Grundlayout über die gesamte
      Rails-Applikation fest zu legen. Sie können aber auch im Verzeichnis
      <filename>app/views/layouts/</filename> noch andere Layouts anlegen und
      diese je nach Situation anwenden. Ich bin hin und hergerissen dieses
      Thema jetzt zu vertiefen, aber lassen wir es jetzt erst mal. Wichtig ist
      jetzt, das Sie die Grundidee verstehen.</para>
    </section>

    <section xml:id="erb_mit_programmierlogik">
      <title>Instance-Variablen vom Controller zum View übergeben</title>

      <para>Einer der todsünden im MVC Model ist ja bekanntlich zu viel
      Programmierlogic im View unterzubringen. Quasi so wie man früher oft in
      PHP programmiert hat. Bei MVC ist eins der Ziele, das quasi jeder
      beliebige HTML-Designer einen View erstellen kann ohne sich über die
      Programmierung gedanken machen zu müssen. Ja, ja, ... wenn das mal immer
      so einfach wäre. Trotzdem gehen wir das mal gedanklich weiter: Wenn ich
      im Controller einen Wert habe, den ich im View anzeigen will, so
      benötige ich dafür einen Mechanismus. Dieser heißt Instance-Variable.
      Wer sich nicht mehr 100% sicher welche Variable welchen Scope hat, der
      sollte ganz fix noch mal einen Blick in <xref
      linkend="scope_von_variablen" /> werfen (geht schnell und lohnt
      sich).</para>

      <para>Wir brechen jetzt einfach mal ein Beispiel vom Zaun und fügen im
      Controller eine Instance-Variable für die aktuelle Uhrzeit ein und fügen
      diese dann im View ein. Wir nehmen also Programmierintelligenz aus dem
      View in den Controller.</para>

      <para>Die Controller Datei
      <filename>app/controllers/example_controller.rb</filename> sieht dann so
      aus:<programlisting>class ExampleController &lt; ApplicationController
  def test
    <emphasis>@current_time</emphasis> = Time.now
  end

end
</programlisting></para>

      <para>In der View Datei
      <filename>app/views/example/test.html.erb</filename> können wir dann auf
      diese Instance-Variable zurückgreifen:<programlisting>&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= <emphasis>@current_time</emphasis> %&gt;
&lt;/p&gt;
</programlisting></para>

      <para>Wir haben jetzt eine klare Trennung von Programmierlogik und
      Darstellungslogik mit dem Controller und dem View. So können wir im
      Controller die Uhrzeit je nach Zeitzone des Users automatisch anpassen,
      ohne das sich der Designer der Seite darum kümmern muss.</para>

      <para>Mir ist klar, das jetzt keiner aufspringen und schreien wird
      "Danke für die Erleuchtung! Ich werde nur noch sauber nach MVC
      programmieren". Das obige Beispiel ist der erste kleine Schritt in die
      Richtung und zeigt wie wir einfach mit Instance-Variablen (das sind die
      mit dem @-Zeichen davor) Werte aus dem Controller in den View bringen
      können.</para>
    </section>

    <section xml:id="partials">
      <title xml:id="partials.title">Partials</title>

      <para>Selbst schon bei kleinen Webprojekten gibt es oft wiederkehrende
      Elemente. Das kann zum Beispiel ein Footer der Seite mit den
      Kontaktdaten sein oder ein Menü. Rails gibt uns die Möglichkeit diesen
      HTML-Code in sogenannte Partials abzuspeichern und dann innerhalb eines
      Views einzubinden. Ein Partial wird ebenfalls im
      <filename>app/views/example/</filename> Verzeichnis abgespeichert.
      Allerdings muss der Dateinamen mit einem Unterstrich (Underscore = _)
      anfangen.</para>

      <para>Als Beispiel fügen wir unser Seite jetzt einen Mini-Footer hinzu.
      Dafür schreiben wir in die neue Datei
      <filename>app/views/example/_footer.html.erb</filename> den folgenden
      Inhalt:<programlisting>&lt;hr /&gt;
&lt;p&gt;
Copyright 2009 - &lt;%= Date.today.year %&gt; beim Osterhasen
&lt;/p&gt;</programlisting></para>

      <para>Die Datei <filename>app/views/example/test.html.erb</filename>
      verändern wir wie folgt und fügen mit dem Befehl <code>render</code> das
      Partial ein:<programlisting>&lt;p&gt;Schleife von 0 bis 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;

<emphasis>&lt;%= render "footer" %&gt;</emphasis></programlisting></para>

      <para>Es sind also jetzt folgende Dateien im Verzeichnis
      <filename>app/views/example</filename>:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>ls -l app/views/example</command>
total 16
-rw-r--r--  1 stefan  staff   63  1 Sep 20:12 _footer.html.erb
-rw-r--r--  1 stefan  staff  105  1 Sep 20:14 test.html.erb
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Die neue Webseite sieht jetzt so aus:<screenshot>
          <info>
            <title>Footer mit Partials</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/partials_footer.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para><important>
          <para>Der Name eines Partials im Code wird immer
          <emphasis>ohne</emphasis> den Unterstrich am Anfang und
          <emphasis>ohne</emphasis> die erb und HTML Endung angegeben. Aber
          die wirkliche Datei muss im Dateinamen mit einem Unterstrich
          anfangen und auch am Ende mir der erb und HTML Endung
          aufhören.</para>
        </important></para>

      <para>Partials können auch aus anderen Bereichen des Unterverzeichnisses
      <filename>app/views</filename> eingebunden werden. So können Sie für
      wiederkehrende und übergreifende Inhalte beispielsweise ein Verzeichnis
      <filename>app/views/shared</filename> anlegen und dort eine Datei
      <filename>_footer.html.erb</filename> anlegen. Das Einbetten im erb Code
      würde dann mit folgender Zeile erfolgen:<programlisting>&lt;%= render "shared/footer" %&gt;</programlisting></para>

      <note>
        <para>Das Footer-Problem würde man in einem richtigen Projekt
        wahrscheinlich nicht mit einem Partial lösen, das überall aufgerufen
        wird, sondern eher zentral in der
        <filename>app/views/layouts/application.html.erb</filename>.</para>
      </note>

      <section xml:id="partials_locale_variables">
        <title xml:id="partials_locale_variables.title">Variablen an ein
        Partial übergeben</title>

        <para>Partials sind im DRY (<emphasis>D</emphasis>on't
        <emphasis>R</emphasis>epeat <emphasis>Y</emphasis>ourself) Gedanken
        sehr gut. Aber was sie erst richtig praktisch macht, ist die
        Möglichkeit Variablen zu übergeben. Erweitern wir einmal die
        <filename>app/views/example/_footer.html.erb</filename> Datei wie
        folgt:<programlisting>&lt;hr /&gt;
&lt;p&gt;
Copyright 2009 - &lt;%= Date.today.year %&gt; beim Osterhasen
&lt;/p&gt;
&lt;% if (defined? additional_info) != nil %&gt;
&lt;p&gt;
&lt;%= additional_info %&gt;
&lt;/p&gt;
&lt;% end %&gt;
</programlisting></para>

        <para>Wenn wir jetzt die URI <uri
        xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
        aufrufen, so sehen wir die gleiche Seite wie vorhin. Das liegt daran,
        weil <varname>additional_info</varname> nicht als Local Variable
        übergeben wurde. Ändern wir dazu die
        <filename>app/views/example/test.html.erb</filename> wie
        folgt:<programlisting>&lt;p&gt;Schleife von 0 bis 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;

&lt;%= render :partial =&gt; 'footer', :locals =&gt; {:additional_info =&gt; "abcdef"} %&gt;
</programlisting></para>

        <para>Der Aufruf von <uri
        xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
        erzeugt erwartungsgemäß folgende Seite:<screenshot>
            <info>
              <title>Partial mit Locals</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/footer_partial_mit_locals.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Sie sehen ebenfalls, das ich beim Einbinden eines einfaches
        Partials eine kürzere Schreibweise benutzen kann, als bei der Version
        mit locals.</para>
      </section>

      <section xml:id="weitere_doku_zu_partials">
        <title xml:id="weitere_doku_zu_partials.title">Weitere Dokumentation
        zum Thema Partials</title>

        <para>Wir haben hier wirklich nur die Oberfläche angekratzt. Partials
        sind sehr mächtige Werkzeuge. Unter <uri
        xlink:href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials</uri>
        finden Sie die Ruby on Rails Doku zum Thema Partials.</para>
      </section>
    </section>
  </section>

  <section xml:id="redirects">
    <title xml:id="redirects.title">Redirects</title>

    <para>Redirects sind Befehle, mit denen Sie innerhalb des Controllers auf
    andere Methoden oder auch auf ganz andere Webseiten "springen" also
    redirecten können. Legen wir ein neues Rails-Projekt für ein
    entsprechendes Beispiel an:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new redirect_beispiel</command>
      create  
      create  README
      create  Rakefile
      create  config.ru

      [...]

      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd redirect_beispiel</command>
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
Using abstract (1.0.0) 

[...]

Using rails (3.0.0) 
Using sqlite3-ruby (1.3.1) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Um zu springen brauchen wir mindestens einen Controller und in dem
    mindestens zwei verschiedene Methoden. Und auf gehts:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>rails generate controller Game ping pong</command>
      create  app/controllers/game_controller.rb
       route  get "game/pong"
       route  get "game/ping"
      invoke  erb
      create    app/views/game
      create    app/views/game/ping.html.erb
      create    app/views/game/pong.html.erb
      invoke  test_unit
      create    test/functional/game_controller_test.rb
      invoke  helper
      create    app/helpers/game_helper.rb
      invoke    test_unit
      create      test/unit/helpers/game_helper_test.rb
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Starten wir mal den Rails-Server und rufen mit dem Browser erst <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    und dann <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    auf:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 23:29:44] INFO  WEBrick 1.3.1
[2010-09-01 23:29:44] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 23:29:44] INFO  WEBrick::HTTPServer#start: pid=46878 port=3000


Started GET "/game/ping" for 127.0.0.1 at 2010-09-01 23:29:52 +0200
  Processing by GameController#ping as HTML
Rendered game/ping.html.erb within layouts/application (1.7ms)
Completed 200 OK in 6ms (Views: 5.7ms | ActiveRecord: 0.0ms)


Started GET "/game/pong" for 127.0.0.1 at 2010-09-01 23:29:55 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.5ms)
Completed 200 OK in 5ms (Views: 5.1ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Alles ganz normal. Das Projekt verfügt über zwei mögliche
    Routen:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>rake routes</command>
(in /Users/stefan/redirect_beispiel)
game_ping GET /game/ping(.:format) {:controller=&gt;"game", :action=&gt;"ping"}
game_pong GET /game/pong(.:format) {:controller=&gt;"game", :action=&gt;"pong"}
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Der Controller
    <filename>app/controllers/game_controller.rb</filename> hat folgenden
    Inhalt:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>cat app/controllers/game_controller.rb</command> 
class GameController &lt; ApplicationController
  def ping
  end

  def pong
  end

end
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Jetzt zum Redirect: Wie können wir es erreichen, das wir beim Aufruf
    von <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    direkt auf die Methode <methodname>pong</methodname> weitergeleitet
    werden? Einfach werden Sie sagen, in dem wir die Route in der
    <filename>config/routes.rb</filename> ändern. Da haben Sie recht. Dafür
    brauchen wir also nicht zwingend ein Redirect.</para>

    <para>Machen wir die Aufgabe etwas schwieriger: Wie können wir es
    erreichen, das zwischen 9 und 17 Uhr beim Aufruf von <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    direkt auf die Methode <methodname>pong</methodname> weitergeleitet wird?
    Das können wir nur mit einem Redirect im Controller realisieren. Bitte
    ändern Sie die Datei
    <filename>app/controllers/game_controller.rb</filename> wie folgt
    ab:<programlisting>class GameController &lt; ApplicationController
  def ping
    if (Time.now.hour &gt; 8) and (Time.now.hour &lt; 17)
      <emphasis>redirect_to game_pong_path</emphasis>
    end    
  end

  def pong
  end

end
</programlisting></para>

    <para>Aber was ist <code>game_pong_path</code>? Schauen wir uns dazu die
    für diese Rails-Applikation generierten Routen an:<screen>stefan@swmbp 1 1.9.2-p0 pingpong$ <command>rake routes</command>
(in /Users/stefan/pingpong)
game_ping GET /game/ping(.:format) {:controller=&gt;"game", :action=&gt;"ping"}
game_pong GET /game/pong(.:format) {:controller=&gt;"game", :action=&gt;"pong"}
stefan@swmbp 0 1.9.2-p0 pingpong$</screen></para>

    <para>Sie sehen, das die Route zur Action "ping" des Controllers "game"
    den Namen <varname>game_ping</varname> bekommen hat. Wir könnten das
    Redirect auch so schreiben:<programlisting>redirect_to :action =&gt; 'pong'</programlisting></para>

    <para>Aber die Schreibweise mit den Routen ist sauberer und lässt sich
    später besser warten.</para>

    <para>Wenn wir jetzt zwischen 9 und 17 Uhr mit dem Browser die Seite <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    aufrufen, werden wir automatisch auf die Seite <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    geleitet. Schauen wir uns das mal im Log an:<screen>Started GET "/game/ping" for 127.0.0.1 at 2010-09-01 13:44:37 +0200
  Processing by GameController#ping as HTML
Redirected to http://0.0.0.0:3000/game/pong
Completed 302 Found in 1ms


Started GET "/game/pong" for 127.0.0.1 at 2010-09-01 13:44:38 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.6ms)
Completed 200 OK in 5ms (Views: 4.9ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Wie Sie sehen, wurde zwar im ersten Schritt mit
    <code>GameController#ping as HTML</code> die Methode
    <methodname>ping</methodname> im Controller <code>GameController</code>
    aufgerufen, aber danach fand ein Redirect zur Methode
    <methodname>pong</methodname> statt.</para>

    <para>Auf die Details und einzelnen Möglichkeiten des Redirects gehen wir
    später im jeweils konkreten Fall ein. Nur schon so viel vorweg: Man kann
    nicht nur auf eine andere Methode, sondern auch auf einen anderen
    Controller oder eine ganze andere Seite redirecten.</para>

    <section>
      <title>Warum Redirects?</title>

      <para>Beim obigen Beispiel fragt man sich natürlich, warum man denn im
      Controller einen Redirect einbaut und nicht direkt die Routen ändert.
      Das ist der Nachteil von der "wir benutzen nur bisheriges
      Wissen"-Methode. Schon im <xref linkend="scaffolding" /> werden Sie
      verstehen warum Redirects so praktisch sind. Sie können z.B. in einem
      Controller überprüfen, ob bestimmte Eingabedaten valide sind oder nicht
      und wenn etwas fehlt zur ursprünglichen Eingabeseite redirecten. Das
      wäre mit einer statischen Route nicht lösbar.</para>

      <para>Allerdings muss man beim Programmieren auch darauf achten, nicht
      beliebig viele Redirects einzubauen. Wenn man tatsächlich mal in der
      Versuchung kommen zwei oder mehr Redirects hinter einander zu schachteln
      (also in verschiedene Methoden), dann sollte man einen Schritt zurück
      gehen und sich Gedanken über die Gesamtidee machen. Meist geht es dann
      anders einfacher und sauberer.</para>
    </section>
  </section>

  <section xml:id="flash">
    <title xml:id="flash.title">Flash Nachrichten</title>

    <para>Der Begriff "Flash Message" oder "Flash Nachricht" ist meiner
    Meinung nach denkbar ungeeignet gewählt worden. Mit dem Wort "Flash"
    assoziiert fast jeder mehr oder weniger bunte Webseiten, die mit dem
    Adobe-Flash-Plug-in realisiert wurden. Aber in Rails sind Flash
    Nachrichten etwas ganz anderes. Sie sind Nachrichten, die über ein
    Redirect (siehe <xref linkend="redirects" />) auf eine andere Seite weiter
    geleitet werden können.</para>

    <para>Flash Nachrichten sind quasi gute Freunde von Redirects. Nicht
    selten arbeiten beide ihm Team, um dem User ein Feedback über eine gerade
    vollzogene Aktion zu geben. Ein typisches Beispiel einer Flash-Nachricht
    ist das Feedback des Systems, wenn ein User sich eingeloggt hat. Dann wird
    er oft wieder auf die ursprüngliche Seite redirected und bekommt
    zusätzlich noch ein Feedback "Sie sind jetzt eingeloggt.".</para>

    <para>Wir bauen als Beispiel noch mal das Ping-Pong Szenario aus <xref
    linkend="redirects" /> auf:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new pingpong</command>
      create  
      create  README
      [...]
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd pingpong</command>
stefan@swmbp 0 1.9.2-p0 pingpong$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
[...]
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 pingpong$ <command>rails generate controller Game ping pong</command>
      create  app/controllers/game_controller.rb
      [...]
      create      test/unit/helpers/game_helper_test.rb
stefan@swmbp 0 1.9.2-p0 pingpong$</screen></para>

    <para>Die <filename>app/controllers/game_controller.rb</filename> füllen
    wir mit folgendem Inhalt:<programlisting>class GameController &lt; ApplicationController
  def ping
    <emphasis>redirect_to game_pong_path</emphasis>
  end

  def pong
  end

end
</programlisting></para>

    <para>Jetzt starten wir den Rails Webserver und browsen einmal auf <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    und einmal auf <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>:<screen>stefan@swmbp 0 1.9.2-p0 pingpong$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-02 14:30:31] INFO  WEBrick 1.3.1
[2010-09-02 14:30:31] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-02 14:30:31] INFO  WEBrick::HTTPServer#start: pid=49354 port=3000


Started GET "/game/pong" for 127.0.0.1 at 2010-09-02 14:31:04 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.6ms)
Completed 200 OK in 5ms (Views: 4.8ms | ActiveRecord: 0.0ms)


Started GET "/game/ping" for 127.0.0.1 at 2010-09-02 14:31:08 +0200
  Processing by GameController#ping as HTML
Redirected to http://0.0.0.0:3000/game/pong
Completed 302 Found in 1ms


Started GET "/game/pong" for 127.0.0.1 at 2010-09-02 14:31:08 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.4ms)
Completed 200 OK in 5ms (Views: 4.5ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Wie nicht anders zu erwarten war: Egal, welche der beiden URIs wir
    aufrufen, am Ende wird immer <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    angezeigt. Wäre es nicht schön, wenn wir beim Redirect von ping auf pong
    dem User eine Nachricht anzeigen könnten? Jetzt raten Sie mal, wie so eine
    Nachricht bei Rails genannt wird? Ja, genau! Eine Flash-Nachricht!</para>

    <para>Bitte erweitern Sie die Datei
    <filename>app/controllers/game_controller.rb</filename> wie
    folgt:<programlisting>class GameController &lt; ApplicationController
  def ping
    <emphasis>redirect_to game_pong_path, :notice =&gt; 'Ich wurde von Ping redirected.'</emphasis>
  end

  def pong
  end

end</programlisting></para>

    <para>Und in der
    <filename>app/views/layouts/application.html.erb</filename> müssen wir
    auch noch eine Kleinigkeit einbauen:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Pingpong&lt;/title&gt;
  &lt;%= stylesheet_link_tag :all %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

<emphasis>&lt;% if (defined? notice) != nil and !notice.blank? %&gt;
&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;% end %&gt;</emphasis>

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

    <para>Beim Aufruf von <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    bekommen wir weiterhin normal die Pong-Seite angezeigt. Beim Aufruf von
    <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/ping</uri>
    werden wir aber zur Pong-Seite redirected und bekommen oben die
    Flash-Nachricht angezeigt:<screenshot>
        <info>
          <title>Pong-Seite mit Flash-Nachricht</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/flash_pong_notice.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <tip>
      <para>Wenn Sie später mal eine Flash-Nachricht nicht angezeigt bekommen,
      dann überprüfen Sie im View, ob dort die Flash-Nachricht überhaupt
      ausgegeben wird.</para>
    </tip>

    <section xml:id="verschiedene_arten_von_flash_nachrichten">
      <title
      xml:id="verschiedene_arten_von_flash_nachrichten.title">Verschiedene
      Arten von Flash Nachrichten</title>

      <para>Per default werden die Arten "error", "notice" und "warning"
      unterschieden. Allerdings kann man auch selber eine Kategorie erfinden
      und diese später im View abfragen. Beim Arbeiten mit <xref
      linkend="scaffolding" /> werden Sie Beispiele für die verschiedenen
      Arten finden.</para>
    </section>

    <section xml:id="neue_flash_redirect_schreibweise">
      <title xml:id="neue_flash_redirect_schreibweise.title">Verschiedene
      Syntaxen</title>

      <para>Je nach Wissen und Vorliebe eines Programmierers werden Sie in der
      Praxis auf verschiedene Syntaxen von Flash-Nachrichten treffen. Ich will
      mich nicht an der Diskussion über die beste Syntax beteildigen (dafür
      finde ich es einfach zu unwichtig), aber ich möchte Ihnen kurz die zwei
      häufigsten Möglichkeiten darstellen:<itemizedlist>
          <listitem>
            <para><programlisting>redirect_to game_pong_path, :notice =&gt; 'Ich wurde von Ping redirected.'</programlisting></para>
          </listitem>

          <listitem>
            <para><programlisting>flash[:notice] = 'Ich wurde von Ping redirected.'
redirect_to :action =&gt; :pong</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Warum gibt es überhaupt Flash-Nachrichten?</title>

      <para>Sie werden sich vielleicht fragen "Warum gibt es
      Flash-Nachrichten? Das kann ich mir ja auch selber bauen, wenn ich es
      brauche." Stimmt. Flash-Nachrichten haben hauptsächlich den Vorteil, das
      sie einen definierten und für alle Programmierer gleichen Weg zur
      Verfügung stellen. So muss man nicht das Rad neu erfinden.</para>
    </section>
  </section>

  <section xml:id="scaffolding">
    <title xml:id="scaffolding.title">Scaffolding</title>

    <para>Nach so viel recht trockenem Ruby- und Rails-Handwerk schauen wir
    uns mal Scaffolding an. Sie werden bestimmt schon mal ein "Rails in 15
    Minuten" Screencast gesehen haben, in dem mit Scaffolding ein Blog oder
    sonst was in rasenhafter Geschwindigkeit erstellt wurde. Dumm ist nur, das
    man danach nichts mit dem Code anfangen konnte, weil alle Grundlagen
    fehlten. Gut das Sie sich dieses Buch gekauft und schon fleissig bis
    hierhin gelesen haben! Mit diesem Vorwissen kann ich Ihnen jetzt die Magie
    des Scaffolding erklären.</para>

    <section>
      <title>Was ist Scaffolding?</title>

      <para>Scaffolding ist ein Generator-Skript, das dem Programmierer einen
      Haufen Arbeit abnimmt. Man bekommt mit einem Aufruf ein Daten-Model,
      einen Controller und eine Hand voll Views generiert, mit denen man die
      Datenbank via Webinterface einfach administrieren kann. In gefühlten 50%
      aller Fälle kann man mit Scaffolding Zeit sparen. </para>
    </section>

    <section>
      <title>Neues Rails Projekt erstellen</title>

      <para>Als Beispiel nehmen wir eine kleine Bücherliste mit den folgenden
      Feldern:<itemizedlist>
          <listitem>
            <para><varname>title:string</varname> - Titel des Buches</para>
          </listitem>

          <listitem>
            <para><varname>production_year:integer</varname> -
            Produktionsjahr</para>
          </listitem>

          <listitem>
            <para><varname>rating:integer</varname> - Bewertung (als Ganzahl
            von 1 bis 5 Sterne)</para>
          </listitem>
        </itemizedlist></para>

      <para>Erstellen wir mal eine neue Rails Applikation erstellen:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new bibliography</command>
      create  
      create  README
      [...]
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd bibliography</command>
stefan@swmbp 0 1.9.2-p0 bibliography$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
[...]
Using rails (3.0.0) 
Using sqlite3-ruby (1.3.1) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>
    </section>

    <section xml:id="rails_generate_scaffold">
      <title xml:id="rails_generade_scaffold.title">rails generate
      scaffold</title>

      <para>Mit dem Rails-Skript-Aufruf <command>rails generate
      scaffold</command> kann man fertige Code generieren. Wer (wie ich) gerne
      mal vergisst wie das Skript aufgerufen werden muss, der gibt einfach
      <command>rails generate scaffold</command> ein und bekommt die folgende
      Hilfe angezeigt:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME                  # Orm to be invoked
                                  # Default: active_record
      [--force-plural]            # Forces the use of a plural ModelName
  -c, --scaffold-controller=NAME  # Scaffold controller to be invoked
                                  # Default: scaffold_controller
  -y, [--stylesheets]             # Indicates when to generate stylesheets
                                  # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Create rails files for scaffold generator.
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Wir müssen also nach <command>rails generate scaffold</command>
      den Namen des Models (bei uns <varname>book</varname>) und danach die
      Datenbankfelder mit den entsprechenden Feldtypen angeben.</para>

      <para>Dann legen wir mal los:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rails generate scaffold book title:string production_year:integer rating:integer</command>
      invoke  active_record
      create    db/migrate/20100902141449_create_books.rb
      create    app/models/book.rb
      invoke    test_unit
      create      test/unit/book_test.rb
      create      test/fixtures/books.yml
       route  resources :books
      invoke  scaffold_controller
      create    app/controllers/books_controller.rb
      invoke    erb
      create      app/views/books
      create      app/views/books/index.html.erb
      create      app/views/books/edit.html.erb
      create      app/views/books/show.html.erb
      create      app/views/books/new.html.erb
      create      app/views/books/_form.html.erb
      invoke    test_unit
      create      test/functional/books_controller_test.rb
      invoke    helper
      create      app/helpers/books_helper.rb
      invoke      test_unit
      create        test/unit/helpers/books_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
stefan@swmbp 0 1.9.2-p0 bibliography$</screen>Und schon ist alles fertig.
      Allerdings ist in der Datenbank noch keine entsprechende Tabelle
      angelegt.</para>
    </section>

    <section xml:id="migration">
      <title xml:id="migration.title">Migrationen</title>

      <para><application>In der zweiten Ausgabezeile des Scaffoldings sehen
      wir die Ausgabe:</application><screen>      create    db/migrate/20100902141449_create_books.rb
</screen></para>

      <para>In der Datei
      <filename>db/migrate/20100902141449_create_books.rb</filename> finden
      sich die Anweisung, mit der die Datenbank erstellt und auch beim
      Roll-Back wieder gelöscht werden kann.<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>cat db/migrate/20100902141449_create_books.rb</command> 
class CreateBooks &lt; ActiveRecord::Migration
  def self.up
    create_table :books do |t|
      t.string :title
      t.integer :production_year
      t.integer :rating

      t.timestamps
    end
  end

  def self.down
    drop_table :books
  end
end
stefan@swmbp 0 1.9.2-p0 bibliography$ </screen></para>

      <para>Die in dieser Ruby-Datei angelegte Klasse
      <classname>CreateBooks</classname> ist ein Kind der Klasse
      <classname>ActiveRecord::Migration</classname> (siehe Zeile 1) und hat
      zwei Methoden:<itemizedlist>
          <listitem>
            <para><methodname>self.up</methodname> (Zeile 2). Wird aufgerufen,
            wenn die Migration durchgeführt wird.</para>
          </listitem>

          <listitem>
            <para><methodname>self.down</methodname> (Zeile 14). Wird
            aufgerufen, wenn für eine Migration ein Rollback durchgeführt
            wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Die Migration (also das Anlegen der Datenbank) wird mit
      <command>rake db:migrate</command> durchgeführt:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake db:migrate</command>
(in /Users/stefan/bibliography)
==  CreateBooks: migrating ====================================================
-- create_table(:books)
   -&gt; 0.0015s
==  CreateBooks: migrated (0.0016s) ===========================================

stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Die Datenbank-Tabelle <varname>books</varname> wird angelegt.
      Dabei sehen wir, das Tabellen-Namen automatisch den Plural der Models
      bekommen. Aber welche Datenbank wird überhaupt benutzt? Das wird in der
      Konfigurationsdatei <filename>config/database.yml</filename>
      definiert:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>cat config/database.yml</command> 
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe
      <uri xlink:href="http://www.yaml.org/">http://www.yaml.org/</uri> bzw.
      <uri
      xlink:href="http://de.wikipedia.org/wiki/YAML">http://de.wikipedia.org/wiki/YAML</uri>)
      definiert. Für uns wichtig ist erst mal nur die development-Datenbank
      (erster Eintrag). Per default benutzt Rails dort
      <application>SQLite3</application>. SQLite3 mag nicht die richtige Wahl
      für die Analyse der weltweit gesammelten Wetterdaten sein, aber für die
      schnelle und unkompliziete Entwicklung von Rails-Anwendungen lernt man
      sie schnell zu schätzen. In der Produktions-Umgebung kann man später
      immer noch auf "grosse" Datenbanken wie MySQL oder PostgreSQL
      umsteigen.<footnote>
          <para>Einige Entwickler sind der Ansicht, das man auf jeden Fall
          immer mit der gleichen Datenbank entwicklen soll, die man später
          auch in der Produktion und im Testing benutzt. Andere sagen, das
          diese bei der Verwendung von Abstraktions-Layern nicht notwendig
          sei. Bitte entscheiden Sie hier selber. Ich programmiere eine Rails
          Applikation fast nur mit SQLite und verwende in der Produktion fast
          nur MySQL.</para>
        </footnote></para>

      <para>Um Ihre sicherlich vorhandene Neugierde zu befriedigen, schauen
      wir uns kurz noch die Datenbank mit dem Command-Line-Tool
      <application>sqlite3</application> an.<screen>stefan@swmbp 1 1.9.2-p0 bibliography$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
books              schema_migrations
sqlite&gt; <command>.schema books</command>
CREATE TABLE "books" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "rating" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; <command>.quit</command>
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Das Anlegen der Tabelle mit <command>rake db:migrate</command>
      wurde natürlich auch im <filename>log/development.log</filename>
      eingetragen:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>cat log/development.log </command>
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  select sqlite_version(*)
  SQL (1.7ms)  CREATE TABLE "schema_migrations" ("version" varchar(255) NOT NULL) 
  SQL (0.0ms)  PRAGMA index_list("schema_migrations")
  SQL (2.0ms)  CREATE UNIQUE INDEX "unique_schema_migrations" ON "schema_migrations" ("version")
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
Migrating to CreateBooks (20100902141449)
  SQL (0.5ms)  CREATE TABLE "books" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "rating" integer, "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20100902141449')
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.0ms)  PRAGMA index_list("books")
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <section xml:id="active-record-auto-felder">
        <title>Automatisch zugefügte Felder (id, created_at und
        updated_at)</title>

        <para>Rails ist so freundlich uns beim Scaffolding automatisch
        folgende Felder hinzuzufügen:<itemizedlist>
            <listitem>
              <para><varname>id:integer</varname></para>

              <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von
              der Datenbank automatisch hochgezählt. Für alle SQL-Fans:
              AUTOINCREMENT NOT NULL</para>
            </listitem>

            <listitem>
              <para><varname>created_at:datetime</varname></para>

              <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
              eines Datensatzes gefüllt.</para>
            </listitem>

            <listitem>
              <para><varname>updated_at:datetime</varname></para>

              <para>Das Feld wird bei jeder Veränderung des Datensatzes
              automatisch an die aktuelle Zeit angepasst.</para>
            </listitem>
          </itemizedlist></para>

        <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
        Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten
        Felder schätzen. Sie weg zu lassen ist meist am falschen Ende
        gespart.</para>
      </section>

      <section xml:id="migration-rollback">
        <title>Migration Rollback</title>

        <para>Es soll schon vorgekommen sein, das übereilt eine Migration
        durchgeführt wurde. Natürlich passiert weder Ihnen noch mir so was.
        ;-) Aber falls mal ein Freund von Ihnen in diese Predulie gerät: Keine
        Panik! Dafür wurde in der Migrations-Class die Methode
        <methodname>self.down</methodname> angelegt. Testweise können wir ja
        mal unsere letzte Migration zurückrollen:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake db:rollback</command>
(in /Users/stefan/bibliography)
==  CreateBooks: reverting ====================================================
-- drop_table(:books)
   -&gt; 0.0016s
==  CreateBooks: reverted (0.0017s) ===========================================

stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

        <para>Sie können alles auf einmal zurück-rollen oder auch nur einzelne
        Migrationen. Mit dem Schalter <parameter>-T</parameter> bekommen Sie
        eine Hilfe zu allen möglichen Wegen aufgezeigt:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake -T db</command>
(in /Users/stefan/bibliography)
rake db:create          # Create the database from config/database.yml for th...
rake db:drop            # Drops the database for the current Rails.env (use d...
rake db:fixtures:load   # Load fixtures into the current environment's database.
rake db:migrate         # Migrate the database (options: VERSION=x, VERBOSE=f...
rake db:migrate:status  # Display status of migrations
rake db:rollback        # Rolls the schema back to the previous version (spec...
rake db:schema:dump     # Create a db/schema.rb file that can be portably use...
rake db:schema:load     # Load a schema.rb file into the database
rake db:seed            # Load the seed data from db/seeds.rb
rake db:setup           # Create the database, load the schema, and initializ...
rake db:structure:dump  # Dump the database structure to an SQL file
rake db:version         # Retrieves the current schema version number
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

        <para>Und mit <command>rake -T db:rollback</command> die Hilfe zu
        diesem bestimmten Befehl:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake -T db:rollback</command>
(in /Users/stefan/bibliography)
rake db:rollback  # Rolls the schema back to the previous version (specify st...
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

        <para>Aber spielen wir lieber unsere Migration wieder ein:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake db:migrate</command>
(in /Users/stefan/bibliography)
==  CreateBooks: migrating ====================================================
-- create_table(:books)
   -&gt; 0.0016s
==  CreateBooks: migrated (0.0022s) ===========================================

stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>
      </section>
    </section>

    <section xml:id="restful_datenbankzugriff_per_webbrowser">
      <title xml:id="restful_datenbankzugriff_per_webbrowser.title">RESTful
      Datenbankzugriff per Webbrowser</title>

      <para>Die Datenbank ist angelegt. Und der Vorteil von Scaffolding
      besteht darin, das wir jetzt auch direkt per Webbrowser in einer ersten
      Web-GUI darauf zugreifen können.</para>

      <para>Gemäss der CRUD Idee (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/CRUD">http://de.wikipedia.org/wiki/CRUD</uri>)
      bietet Rails dafür ein RESTful Webinterface an. Was heisst das? Sie
      können auf jede Resource innerhalb einer normalen Rails-Umgeben über
      definierte URLs zugreifen und damit folgende Datenbank-Operationen
      ausführen:<itemizedlist>
          <listitem>
            <para>C für CREATE</para>

            <para>SQL: <code>INSERT INTO books (title) VALUES ('The
            Journey')</code></para>
          </listitem>

          <listitem>
            <para>R für READ</para>

            <para>SQL: <code>SELECT * FROM books</code></para>
          </listitem>

          <listitem>
            <para>U für UPDATE</para>

            <para>SQL: <code>UPDATE books SET title = 'The Journey' WHERE id =
            1</code></para>
          </listitem>

          <listitem>
            <para>D für DELETE</para>

            <para>SQL: <code>DELETE FROM books WHERE id = 1</code></para>
          </listitem>
        </itemizedlist>Für den Rails-Neuling ist nicht direkt ersichtlich, wo
      den hier der grosse Vorteil liegt. Nachfolgend eine Mini-FAQ:<qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Warum wird um das RESTful Interface in Ruby on Rails so
                ein Bohei gemacht?</para>
              </question>

              <answer>
                <para>Damit bekommt man ein sauberes und für alle
                Programmierer leicht verständliches Interface zu Ihrem System.
                Sie brauchen nur die URI
                <uri>http://localhost:3000/books</uri> und das Wissen, das es
                sich um ein RESTful Webdienst handelt und Sie können direkt
                loslegen.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful nur für die automatische Abfrage zwischen
                Computern gut?</para>
              </question>

              <answer>
                <para>Nein. RESTful ist auch ein guter Denkansatz, um URLs und
                damit ganze Webseiten strukturierter zu gestalten.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful Teil der <emphasis>Convention over
                Configuration</emphasis> Idee?</para>
              </question>

              <answer>
                <para>Ja! Jeder Rails-Entwickler kann sich so in kurzer Zeit
                in ein ihm neues Rails-Projekt einarbeiten.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>

      <section>
        <title>Routen</title>

        <para>Schauen wir uns als erstes mal die vom Scaffolding erstellten
        Routen an:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake routes</command>
(in /Users/stefan/bibliography)
    books GET    /books(.:format)          {:action=&gt;"index", :controller=&gt;"books"}
    books POST   /books(.:format)          {:action=&gt;"create", :controller=&gt;"books"}
 new_book GET    /books/new(.:format)      {:action=&gt;"new", :controller=&gt;"books"}
edit_book GET    /books/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"books"}
     book GET    /books/:id(.:format)      {:action=&gt;"show", :controller=&gt;"books"}
     book PUT    /books/:id(.:format)      {:action=&gt;"update", :controller=&gt;"books"}
     book DELETE /books/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"books"}
stefan@swmbp 0 1.9.2-p0 bibliography$ </screen></para>

        <para>In der zweiten Spalte der Ausgabe finden Sie eine Auflistung der
        URIs.</para>
      </section>

      <section>
        <title>Start des Webservers</title>

        <para>Als erstes starten wir wie immer mit rails server unseren
        Entwicklungswebserver:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-02 16:32:22] INFO  WEBrick 1.3.1
[2010-09-02 16:32:22] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-02 16:32:22] INFO  WEBrick::HTTPServer#start: pid=54146 port=3000

</screen></para>
      </section>

      <section xml:id="restful_create">
        <title xml:id="restful_create.title">Create (Erstellen)</title>

        <para>Legen wir als erstes einmal einen neuen Datensatz an. Sie können
        das entsprechende Interface über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/new">http://0.0.0.0:3000/books/new</uri>
        abrufen. Bitte benutzen Sie dieses Interface um einen Beispiel-Film
        einzutragen:<screenshot>
            <info>
              <title>Neuen Film in die Datenbank eintragen.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/new_book.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Sieht ja schon mal nicht schlecht aus. Jetzt gehen wir mal
        Schritt für Schritt durch, was Rails gemacht hat. Die URI <uri
        xlink:href="http://0.0.0.0:3000/books/new">http://0.0.0.0:3000/books/new</uri>
        wird von der <code>new_book</code> Route gematched: <screen> new_book GET    /books/new(.:format)      {:action=&gt;"new", :controller=&gt;"books"}
</screen></para>

        <para>Dann öffnen wir mal die Datei für den Controller books
        (<filename>app/controllers/books_controller.rb</filename>) und schauen
        uns dort die Methode <methodname>new</methodname> an:<programlisting>  # GET /books/new
  # GET /books/new.xml
  def new
    @book = Book.new

    respond_to do |format|
      format.html # new.html.erb
      format.xml  { render :xml =&gt; @book }
    end
  end
</programlisting></para>

        <para>Nachdem Sie auf "Create Movie" geklickt haben, können Sie im
        Log-File folgenden Eintrag verfolgen:<screen>Started POST "/movies" for 127.0.0.1 at 2010-08-31 22:01:13 +0200
  Processing by MoviesController#create as HTML
  Parameters: {"utf8"=&gt;"✓", "authenticity_token"=&gt;"SeHUgt9pHvJh9YdI8RaPdVncr+T4AMARbRLE/+vQRg0=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Create Movie"}
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.5ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-08-31 20:01:13.717959', 133, 'Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.', 1988, 5, 'Rain Man', '2010-08-31 20:01:13.717959')
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 141ms


Started GET "/movies/1" for 127.0.0.1 at 2010-08-31 22:01:13 +0200
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/application (11.3ms)
Completed 200 OK in 51ms (Views: 14.8ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Als Ergebnis bekommen Sie im Browserfenster den entsprechenden
        Eintrag angezeigt:<figure xml:id="screenshot_show_after_create">
            <title>Nach dem Abspeichern wird der neue Eintrag
            angezeigt.</title>

            <screenshot>
              <info>
                <title>Nach dem Abspeichern wird der neue Eintrag
                angezeigt.</title>
              </info>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="screenshots/movies_new_show.jpg"></imagedata>
                </imageobject>
              </mediaobject>
            </screenshot>
          </figure></para>
      </section>

      <section xml:id="restful_show">
        <title xml:id="restful_show.title">Show (Anzeigen eines einzelnen
        Datensatzes)</title>

        <para>Nach dem Erstellen (Create) eines neuen Datensatzes, können wir
        uns diesen natürlich jetzt einzeln anschauen. Da unter ActiveRecord
        automatisch eine unique ID für jeden Datensatz erstellt wird, können
        wir diese zum Aufruf benutzen. In diesem Fall ist es die 1 für den
        ersten Datensatz. Das geht über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri><figure
            xml:id="screenshot_show">
            <title xml:id="screenshot_show.title">Anzeigen des ersten
            Datensatzes</title>

            <screenshot>
              <info>
                <title>Anzeigen des ersten Datensatzes</title>
              </info>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="screenshots/movies_show.jpg"
                             format="JPG"></imagedata>
                </imageobject>
              </mediaobject>
            </screenshot>
          </figure></para>

        <para>Im Log erscheint die folgende Ausgabe:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-08-31 22:02:12 +0200
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/application (36.3ms)
Completed 200 OK in 51ms (Views: 39.6ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Ihnen wird bestimmt beim Vergleich der Screenshots <xref
        linkend="screenshot_show" /> und <xref
        linkend="screenshot_show_after_create" /> aufgefallens ein, das bei
        <xref linkend="screenshot_show_after_create" /> am oben eine grüne
        Nachricht angezeigt wurde. Das ist eine sogenannte Flash-Nachricht.
        Dabei ist das Wording "Flash" meiner Meinung nach äusserst ungeschickt
        gewählt, weil bei "Flash" jeder automatisch an das Adobe-Flash-Format
        und nicht an eine Flash-artig (Flash = Blitz) erscheinende Nachricht
        denkt. So ist es aber bei Rails. Flash-Nachrichten werden immer auf
        der nächsten und nur auf der nächsten generierten Seite angezeigt. Wir
        kommen später auf Flash detailierter zu sprechen.</para>
      </section>

      <section xml:id="restful_edit">
        <title xml:id="restful_edit.title">Edit (Bearbeiten eines
        Datensatzes)</title>

        <para>Zum Editieren eines Datensatzes müssen wir wiederum die ID des
        Datensatzes kennen und können dann mit dieser (hier wieder die 1 als
        Beispiel) das Formular zum Bearbeiten des Filmes mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1/edit">http://0.0.0.0:3000/movies/1/edit</uri>
        aufrufen:<screenshot>
            <info>
              <title>Formular zum Editieren eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_edit.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File gibt es folgende Ausgabe:<screen>Started GET "/movies/1/edit" for 127.0.0.1 at 2010-08-31 22:03:15 +0200
  Processing by MoviesController#edit as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.1ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/_form.html.erb (13.2ms)
Rendered movies/edit.html.erb within layouts/application (16.4ms)
Completed 200 OK in 30ms (Views: 19.8ms | ActiveRecord: 0.1ms)
</screen></para>

        <para>Durch klicken auf "Update Movie" können wir dann den Datensatz
        updaten und bekommen ihn dann wieder im Show-View
        angezeigt:<screenshot>
            <info>
              <title>Der Show-View nach dem Update des Datensatzes.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show_after_update.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Auch hier wird wieder mit einer Flash-Message ein Feedback vom
        System zum User gegeben.</para>

        <para>Im Log-File sieht man das Update wie folgt:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-08-31 22:03:17 +0200
  Processing by MoviesController#update as HTML
  Parameters: {"utf8"=&gt;"✓", "authenticity_token"=&gt;"SeHUgt9pHvJh9YdI8RaPdVncr+T4AMARbRLE/+vQRg0=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Update Movie", "id"=&gt;"1"}
  Movie Load (0.1ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 21ms


Started GET "/movies/1" for 127.0.0.1 at 2010-08-31 22:03:18 +0200
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.1ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/application (37.8ms)
Completed 200 OK in 51ms (Views: 41.1ms | ActiveRecord: 0.1ms)
</screen></para>
      </section>

      <section xml:id="restful_index">
        <title xml:id="restful_index.title">Index (Anzeigen aller
        Datensätze)</title>

        <para>Über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
        können Sie sich eine Liste aller Filme in der Datenbank anzeigen
        lassen (logischerweise ist das bis jetzt nur ein Film):<screenshot
            xml:id="screenshot_movies_index">
            <info>
              <title xml:id="screenshot_movies_index.title">Index-Ansicht
              aller Filme</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_index.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File findet sich folgende Ausgabe:<screen>Started GET "/movies" for 127.0.0.1 at 2010-08-31 22:04:30 +0200
  Processing by MoviesController#index as HTML
  Movie Load (0.4ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/application (12.1ms)
Completed 200 OK in 23ms (Views: 15.8ms | ActiveRecord: 0.4ms)
</screen></para>
      </section>

      <section>
        <title>Löschen eines Datensatzes</title>

        <para>Wenn Sie auf der Index-Seite auf "Destroy" klicken, so bekommen
        Sie folgende Meldung angezeigt:<screenshot>
            <info>
              <title>Sicherheitsabfrage beim Löschen eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/destroy_r_u_sure.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Klicken wir jetzt mutig auf "OK", bekommen wir wieder die
        Index-Seite, aber diesmal ganz ohne einen Film angezeigt:<screenshot>
            <info>
              <title>Index-Ansicht nach dem Löschen des einzigen
              Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/index_after_destroy.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Zum Schluss noch der obligatorische Blick in das
        Log-File:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-08-31 22:04:55 +0200
  Processing by MoviesController#destroy as HTML
  Parameters: {"authenticity_token"=&gt;"SeHUgt9pHvJh9YdI8RaPdVncr+T4AMARbRLE/+vQRg0=", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.3ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 50ms


Started GET "/movies" for 127.0.0.1 at 2010-08-31 22:04:55 +0200
  Processing by MoviesController#index as HTML
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/application (2.3ms)
Completed 200 OK in 12ms (Views: 5.5ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>
    </section>

    <section xml:id="routen">
      <title xml:id="routen.title">Routen</title>

      <para>Fassen wir mal kurz zusammen: Man kann also mit Scaffolding eine
      Web-GUI erstellen und auf diese Web-GUI anscheinen über eine feste
      CRUD-Stuktur zugreifen. Jetzt wäre ja mal interessant zu wissen, ob es
      noch mehr URIs gibt. Rails steuert das über sogenannte Routen. Alle
      Routen werden in der Datei <filename>config/routes.rb</filename>
      definiert. Standardmässig sind in dieser Datei recht viele Beispiele als
      Kommentare eingebaut. Schauen wir uns mal an, wie die aktuelle
      Konfiguration ohne diese Kommentare aussieht:<screen>MacBook:movie-app sw$ <command>cat config/routes.rb | grep -v "#" | grep -v "^$"</command>
MovieApp::Application.routes.draw do |map|
  resources :movies
  get "example/test"
end
MacBook:movie-app sw$</screen></para>

      <para>Interessant ist die Zeile:<programlisting>  resources :movies</programlisting></para>

      <para>Diese Zeile sagt Rails, das es die Resource movies mit allen
      Standard Routen ausstatten soll. Diese Routen können wir uns mit
      <command>rake routes</command> anzeigen lassen.<screen>MacBook:movie-app sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
MacBook:movie-app sw$</screen></para>

      <para>Puh... das sind ja viel mehr, als wir oben benutzt haben. Oder
      doch nicht? Und jetzt muss ich das auch noch sinnvoll und strukturiert
      erklären! Die letzte Zeile ist dabei am einfachsten. Die kommt aus
      unserem ersten Beispiel. Kümmern wir uns also um die restlichen vom
      Scaffolding erzeugten Einträge.</para>

      <para>CRUD besteht zwar aus den vier Teilen Create, Read, Upate und
      Delete, aber diese Einzelelemente müssen in der RESTful Umsetzung weiter
      aufgeschlüsselt werden. Ziel bei REST ist es, das man eine
      Abfrage-Methodik definiert, die von allen Entwicklern gleich verstanden
      und auch benutzt werden kann. Dazu werden bei Webzugriffen die URIs und
      die HTTP-Verben benutzt. Was HTTP-Verben sind? Ich habe die Frage
      befürchtet. Bei der Entwicklung des HTTP-Protokolles wurden verschiedene
      Abfrage-Methoden definiert. Sie haben bestimmt bei einem HTML-Formular
      schon mal vom Unterschied zwischen GET und POST gelesen. GET und POST
      sind genau solche Verben. Für uns weiterhin interessant sind PUT und
      DELETE. Gerne verweise ich an dieser Stelle auf das RFC 2616 (<uri
      xlink:href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</uri>),
      falls Sie sich mit dieser Materie näher beschäftigen wollen.</para>

      <para>Für uns ist jetzt erst mal nur interessant, das gleiche URIs die
      mit unterschiedlichen Verben angesprochen werden unterschiedliche
      Aktionen in Ihrer Rails-Applikation auslösen. So können Sie in unserer
      Filmdatenbank über die URI <uri
      xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
      sowohl mit GET eine Liste (Index) aller Filme anfordern, als auch mit
      POST einen neuen Filmeintrag abspeichern.</para>

      <para>Die Kombination aus Verb und URI wird in Rails als Route
      bezeichnet. Ist eine Route nicht definiert, passiert auch nichts. Ist
      eine Route definiert, dann wird damit auf eine "Action" und einen
      "Controller" verwiesen. Ich würde jetzt gerne erklären, was es mit
      beidem auf sich hat, aber vorher will ich noch kurz <xref
      linkend="restful_mit_xml" /> besprechen, damit wir das aktuelle Thema
      RESTful Zugriff sauber abgeschlossen haben.</para>
    </section>

    <section xml:id="restful_mit_xml">
      <title xml:id="restful_mit_xml.title">RESTful Datenbankzugriff per XML
      und curl</title>

      <para><tip>
          <para>Wenn Sie sich nicht für den Austausch von Daten per XML
          interessieren, dann können Sie diesen Abschnitt ruhig
          überspringen.</para>
        </tip>Das XML-Interface erleichtert den Austausch von Daten zwischen
      Maschinen. Dabei wird der ganze HTML-Balast abgeworfen und nur noch die
      reinen Daten per XML ausgetauscht. Beispielhaft führen wir dies mit dem
      Programm curl durch. Logischerweise geht es natürlich auch mit anderen
      Programmen oder Programmiersprachen. Wer die Art und Weise verstanden
      hat, kann von beliebigen Systemen eine Rails Applikation bedienen. Da
      dies naturgemäss auch gewisse Gefahren in sich birgt (z.B. kann eine
      Maschine per Brute-Force-Attacke schnell wie Unheil anrichten), kann man
      per Default bestimmte Aktionen nicht durchführen. Dies wird in der Datei
      <filename>app/controllers/application_controller.rb</filename> mit
      <code>protect_from_forgery</code> konfiguriert. Bitte deaktiven Sie
      diese Zeile für diese Beispiele wie folgt mit einem
      #-Zeichen:<programlisting>class ApplicationController &lt; ActionController::Base
  # protect_from_forgery
end
</programlisting></para>

      <para>Dadurch entfällt eine per default aktivierte Sicherheitsschicht,
      die einen Token austauscht, um die anonyme Interaktion von aussen zu
      underbinden. Im Log-File werden Sie den Unterschied merken (es fehlt der
      Eintrag <code>"authenticity_token"=&gt;"xyz"</code>). In späteren
      Kapiteln besprechen wir Authentifizierungsmechanismen um diese Zugriffe
      mit Passwörtern abzusichern.</para>

      <section>
        <title>new</title>

        <para>Um einen neuen Film einzutragen, benötigen Sie als erstes die
        Felder die ausgefüllt werden müssen. Dazu können Sie die URL <uri
        xlink:href="http://0.0.0.0:3000/movies/new.xml">http://0.0.0.0:3000/movies/new.xml</uri>
        abrufen:<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/new.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime" nil="true"&gt;&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer" nil="true"&gt;&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title nil="true"&gt;&lt;/title&gt;
  &lt;updated-at type="datetime" nil="true"&gt;&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/new.xml" for 127.0.0.1 at 2010-04-04 19:28:19
  Processing by MoviesController#new as XML
Completed 200 OK in 124ms (Views: 111.1ms | ActiveRecord: 0.0ms)
</screen></para>

        <para>In der XML-Ausgabe können wir erkennen wie die einzelnen Felder
        heissen und welche Typen (z.B. Integer) sie darstellen. Mit diesen
        Informationen können wir jetzt einen create Aufruf mit dem neuen
        Datensatz zusammenstellen:</para>

        <para>Danach können Sie mit einem create Aufruf die Daten für einen
        neuen Datensatz uploaden:<screen>MacBook:~ sw$ <command>curl -X POST -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Ausgabe im Log:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 20:30:10
  Processing by MoviesController#create as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1988"}}
  SQL (0.3ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 18:30:10.440028', 133, NULL, 1988, 5, 'Rain Man', '2010-04-04 18:30:10.440028')
Redirected to http://0.0.0.0:3000/movies/6
Completed 302 Found in 27ms
</screen></para>

        <para>Als Ergebnis des curl Aufrufes bekommen Sie die den folgenden
        Code zurück:<screen>&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
</screen></para>

        <para>Das ist also quasi wie beim Aufruf mit dem Webbrowser, nur das
        ein Show des neuen Datensatzes so beim XML-Aufruf wenig Sinn
        macht.</para>
      </section>

      <section>
        <title>index</title>

        <para>Um das Ergebnis des Index-Aufrufes sinnvoller zu gestalten, habe
        ich vorher zwei mal den Film Rain Man eingetragen. Jetzt müssen wir
        mit curl die URI <uri
        xlink:href="http://0.0.0.0:3000/movies.xml">http://0.0.0.0:3000/movies.xml</uri>
        abrufen.<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movies type="array"&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;1&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
  &lt;/movie&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;2&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/updated-at&gt;
  &lt;/movie&gt;
&lt;/movies&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies.xml" for 127.0.0.1 at 2010-04-04 20:39:09
  Processing by MoviesController#index as XML
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies"
Completed 200 OK in 23ms (Views: 9.6ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>show</title>

        <para>Einen einzelnen Film kann man sich mit der ID des Eintrages
        (hier die 1) und der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri>
        anschauen. <screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/1.xml" for 127.0.0.1 at 2010-04-04 20:40:06
  Processing by MoviesController#show as XML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Completed 200 OK in 37ms (Views: 8.8ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>edit - update</title>

        <para>Zum Editieren eines Eintrages downloaden wir diesen Eintrag erst
        wieder von der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri><screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T19:05:23Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Danach übermitteln wir den entsprechenden Eintrag mit PUT neu
        auf die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Dabei ist es egal, ob wir wirklich neue oder wieder die gleichen Daten
        übermitteln. Wichtig dabei ist, das wir die <parameter>id</parameter>
        des Eintrages mit übertragen:<screen>MacBook:~ sw$ <command>curl -X PUT -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1989&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies/1</command>    
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/1"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started PUT "/movies/1" for 127.0.0.1 at 2010-04-04 21:12:32
  Processing by MoviesController#update as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1989"}, "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.4ms)  UPDATE "movies" SET "production_year" = 1989, "updated_at" = '2010-04-04 19:12:32.237009' WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 70ms
</screen></para>

        <para>ActiveRecord ist dabei intelligent genug nur wirkliche
        Veränderungen einzutragen.</para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
        und einem DELETE Aufruf wieder aus der Datenbank löschen.<screen>MacBook:~ sw$ <command>curl -X DELETE -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started DELETE "/movies/1" for 127.0.0.1 at 2010-04-04 21:14:44
  Processing by MoviesController#destroy as */*
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.2ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 22ms
</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="die_console" xml:lang="">
    <title xml:base="" xml:id="die_console.title">Die Console</title>

    <para>Die Console in Rails ist nichts weiter als ein aufgebohrtes irb
    (siehe <xref linkend="ruby-grundlagen" />). Sowohl beim Entwicklen wie
    auch beim Administrieren ist die Console sehr praktisch, da die komplete
    Rails-Umgebung abgebildet wird. So kann man leicht mal eine Methode
    ausprobieren ohne dafür direkt ein eigenes Programm zu schreiben.</para>

    <para>Die Console wird mit <command>rails console</command>
    gestartet:<screen>MacBook:movie-app sw$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt;</screen></para>

    <para>Zum Beenden der Console muss man <command>exit</command>
    eingeben:<screen>ruby-1.9.1-p378 &gt; <command>exit</command>
MacBook:movie-app sw$ </screen></para>

    <para>ActiveRecord ist ein Mechanismus, um innerhalb von Rails mit der
    Datenbank zu arbeiten. Innerhalb dieses Kapitels gehe ich nur auf die
    absoluten Basics ein, denn es geht ja jetzt nicht darum in ActiveRecord
    einen Meistertitel zu erringen, sondern darum Ruby on Rails zu verstehen.
    In einem späteren Kapitel werde ich mich noch einmal intensiv mit
    ActiveRecords beschäftigen.</para>

    <para>Sie haben im <xref linkend="ruby-grundlagen" /> gelernt mit irb
    umzugehen. In Rails gibt es dazu ein Pondon: Die Rails Console.
    <command>rails console</command></para>

    <para>Mit der Rails Console haben Sie nicht nur die normalen irb
    Mechanismen, sondern auch direkt alle Klassen und Methoden aus Ihrer
    Rails-Applikation. Und können somit auf die Datenbank zugreifen. Diese
    werden automagisch per ActiveRecord als Objekte zur Verfügung
    gestellt.</para>

    <para>Die Rails-Console kann parallel zum Webserver oder anstatt des
    Webservers gestartet werden. Wir führen als erstes auf der Shell ein
    <command>rake db:reset</command> aus, damit wir eine frische und leere
    Datenbank zum Üben vorfinden. <screen>MacBook:movie-app sw$ <command>rake db:reset</command>
(in /Users/sw/Development/movie-app)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("movies", {:force=&gt;true})
   -&gt; 0.0155s
-- initialize_schema_migrations_table()
   -&gt; 0.0049s
-- assume_migrated_upto_version(20100404113234, "db/migrate")
   -&gt; 0.0026s
MacBook:movie-app sw$ </screen></para>

    <para>Danach starten wir die Console:<screen>MacBook:movie-app sw$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta2)
ruby-1.9.1-p378 &gt;</screen></para>
  </section>

  <section xml:id="workflow-in-rails">
    <title xml:id="mvc-workflow-in-rails.title">MVC-Workflow innerhalb
    Rails</title>

    <para>Jetzt können wir eine Tabelle anlegen und auf diese via HTTP und via
    der Console zugreifen. Jetzt schauen wir uns mal an, was bei einer
    HTTP-Anfrage passiert und welchen Weg diese Anfrage geht. Hier kommt die
    versprochene Fortführung von <xref linkend="routen" />.</para>

    <section xml:id="dvd-show-html">
      <title>Beispiel movies/1</title>

      <para>Nehmen wir an, ein User ruft die URL <uri
      xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
      auf.</para>

      <section>
        <title>Routing</title>

        <para>Kommt ein Aufruf per HTTP rein, so wird die URL durch eine
        Routing-Engine verarbeitet. Diese wird durch die Datei
        <filename>config/routes.rb</filename> konfiguriert. Schauen wir noch
        mal rein. Diesmal mit allen Kommentaren.<programlisting>MovieApp::Application.routes.draw do |map|
  resources :movies

  get "example/test"

  # The priority is based upon order of creation:
  # first created -&gt; highest priority.

  # Sample of regular route:
  #   match 'products/:id' =&gt; 'catalog#view'
  # Keep in mind you can assign values other than :controller and :action

  # Sample of named route:
  #   match 'products/:id/purchase' =&gt; 'catalog#purchase', :as =&gt; :purchase
  # This route can be invoked with purchase_url(:id =&gt; product.id)

  # Sample resource route (maps HTTP verbs to controller actions automatically):
  #   resources :products

  # Sample resource route with options:
  #   resources :products do
  #     member do
  #       get :short
  #       post :toggle
  #     end
  #
  #     collection do
  #       get :sold
  #     end
  #   end

  # Sample resource route with sub-resources:
  #   resources :products do
  #     resources :comments, :sales
  #     resource :seller
  #   end

  # Sample resource route with more complex sub-resources
  #   resources :products do
  #     resources :comments
  #     resources :sales do
  #       get :recent, :on =&gt; :collection
  #     end
  #   end

  # Sample resource route within a namespace:
  #   namespace :admin do
  #     # Directs /admin/products/* to Admin::ProductsController
  #     # (app/controllers/admin/products_controller.rb)
  #     resources :products
  #   end

  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; "welcome#index"

  # See how all your routes lay out with "rake routes"

  # This is a legacy wild controller route that's not recommended for RESTful applications.
  # Note: This route will make all actions in every controller accessible via GET requests.
  # match ':controller(/:action(/:id(.:format)))'
end</programlisting></para>

        <para>Die Priorität einer Route wird anhand ihrer Position in dieser
        Datei bestimmt. Es können also mehrere Regeln auf die gleiche Route
        matchen. Die am weitesten oben stehende gewinnt.</para>

        <para>In der Zeile 2 steht eine für unsere Applikation bis jetzt die
        wichtige Konfiguration:<programlisting>resources :movies</programlisting></para>

        <para>Sie sorgt dafür das automagisch die Anfragen mit der RESTful
        Logik an die Methoden <methodname>index</methodname>,
        <methodname>show</methodname>, <methodname>new</methodname>,
        <methodname>edit</methodname>, <methodname>create</methodname>,
        <methodname>update</methodname> und <methodname>destroy</methodname>
        der Klasse <classname>MoviesController</classname> weitergeleitet
        werden.</para>

        <para>Diese Routen können wir uns mit <command>rake routes</command>
        anzeigen lassen.<screen>MacBook:movie-app sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
example_test GET    /example/test              {:controller=&gt;"example", :action=&gt;"test"}
MacBook:movie-app sw$</screen></para>

        <para>Diese Klasse wird in der Datei
        <filename>app/controllers/movies_controller.rb</filename> definiert.
        Schauen wir mal rein, was da bei der Methode
        <methodname>show</methodname> steht:<programlisting>  # GET /movies/1
  # GET /movies/1.xml
  def show
    @movie = Movie.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml =&gt; @movie }
    end
  end
</programlisting></para>

        <para>Direkt am Anfang wird die Instance-Variable
        <varname>@movie</varname> mit dem Ergebnis der Suche nach einer ID
        gefüllt (<code>Movie.find(params[:id])</code>). Die :id finden Sie
        oben in den Routen. Der Hash params wird automatisch von Rails gefühlt
        und steht dem Programmierer im Controller zur Verfügung.</para>

        <para>hmmmm... was hat es mit diesem Hash <varname>params[]</varname>
        auf sich? Machen wir mal testweise die Abfrage <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Ich gehe mal davon aus, das Sie mittlerweile den dazu passenden
        Browser-Screenshot vor Ihrem virtuellen Auge haben. Falls nicht =&gt;
        <xref linkend="screenshot_show" /></para>

        <para>Und gleichzeitig schauen wir uns die Log-Ausgabe des Webservers
        an:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-04-05 10:49:59
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (9.6ms)
Completed 200 OK in 30ms (Views: 12.5ms | ActiveRecord: 0.7ms)
</screen></para>

        <para>Da wird in der zweiten Zeile auf den Controller
        <classname>MoviesController</classname> und dort auf die Methode
        <methodname>show</methodname> verwiesen
        (<code>MoviesController#show</code>). Gleichzeitig wird ein Hash mit
        dem Namen <varname>params[]</varname> generiert und dort
        <varname>params[:id]</varname> auf 1 gesetzt.</para>

        <para>Danach wird überprüft, ob es sich um eine
        <filename>.html</filename> oder <filename>.xml</filename> Anfrage
        gehandelt hat. Wurde vom Browser nur <filename>1</filename> und nicht
        <filename>1.html</filename> abgefragt, setzt Rails den Default auf
        <filename>.html</filename>. In der Log-Ausgabe finden Sie den Eintrag
        "<code>as HTML</code>".</para>

        <para>Was passiert als nächstes? Denken wir noch mal über das
        MCV-Model nach. Wir haben schon das Model
        (<methodname>movies</methodname>) und wir haben den Controller
        (<classname>MoviesController</classname>). Was noch fehlt ist der View
        - also die Darstellung der Webseite. Die Views für unser Model finden
        sich alle im Unterverzeichnis
        <filename>app/view/movies</filename><screen>MacBook:movie-app sw$ <command>ls app/views/movies</command>
_form.html.erb edit.html.erb index.html.erb new.html.erb show.html.erb
MacBook:movie-app</screen></para>

        <para>Schauen wir uns mal die Datei <filename>show.html.erb</filename>
        an:<programlisting>&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%= @movie.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Production year:&lt;/b&gt;
  &lt;%= @movie.production_year %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Duration:&lt;/b&gt;
  &lt;%= @movie.duration %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Plot:&lt;/b&gt;
  &lt;%= @movie.plot %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Rating:&lt;/b&gt;
  &lt;%= @movie.rating %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_movie_path(@movie) %&gt; |
&lt;%= link_to 'Back', movies_path %&gt;
</programlisting></para>

        <para>Ist Ihnen aufgefallen, das bei dieser erb-Datei ja wichtige
        HTML-Elemente fehlen? Die sind in der Datei
        <filename>app/views/layouts/movies.html.erb</filename><programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Movies: &lt;%= controller.action_name %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag 'scaffold' %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class="alert"&gt;&lt;%= alert %&gt;&lt;/p&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

        <para>Das ist der Rahmen für alle Views des Models
        <varname>movies</varname>. Da es oft keinen Sinn macht für jedes Model
        ein eigenes Grundlayout zu generieren, kann man diese Datei auch
        löschen und stattdessen eine Datei
        <filename>app/views/layouts/application.html.erb</filename> mit dem
        Grundlayout erstellen. Die gilt dann für die gesamte
        Rails-Application. Die Zeile <code>&lt;%= yield %&gt;</code> wird
        dabei immer von der aufzurufenden View-Datei ersetzt.</para>
      </section>
    </section>

    <section xml:id="dvd-index-html">
      <title>Beispiel /movies (Index aller Datensätze)</title>

      <para>Da der Grundweg im letzten Segment erklärt wurde, gehe ich jetzt
      auf die schnelle durch die Anfrage <uri
      xlink:href="http://localhost:3000/movies">http://0.0.0.0:3000/movies</uri>.
      Hier noch mal den Screenshot dazu:<screenshot>
          <info>
            <title>Index-Ansicht aller Filme</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/movies_index.jpg" format="JPG"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Im Log erscheint:<screen>Started GET "/movies" for 127.0.0.1 at 2010-04-05 11:02:42
  Processing by MoviesController#index as HTML
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.6ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (28.2ms)
Completed 200 OK in 47ms (Views: 31.2ms | ActiveRecord: 1.1ms)
</screen></para>

      <para>Es geht also zu der Methode <methodname>index</methodname> der
      Klasse <classname>MoviesController</classname>
      (<code>MoviesController#index</code>). Diese Klasse wird in der Datei
      <filename>app/controllers/movies_controller.rb</filename> definiert.
      Schauen wir mal rein, was da bei der Methode
      <methodname>index</methodname> steht:<programlisting>  # GET /movies
  # GET /movies.xml
  def index
    @movies = Movie.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @movies }
    end
  end
</programlisting></para>

      <para>In der Instance-Variable <varname>@movies</varname> wird diesmal
      ein Array aus allen Datensätze die mit <code>Movie.all</code> angezeigt
      werden gespeichert. Da es sich um eine html-Anfrage handelt wird als
      nächstes der View <filename>app/views/movies/index.html.erb</filename>
      gerendert. Ein Blick in diese erb-Datei:<programlisting>&lt;h1&gt;Listing movies&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Production year&lt;/th&gt;
    &lt;th&gt;Duration&lt;/th&gt;
    &lt;th&gt;Plot&lt;/th&gt;
    &lt;th&gt;Rating&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @movies.each do |movie| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= movie.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.production_year %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.duration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.plot %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.rating %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', movie %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_movie_path(movie) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', movie, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Movie', new_movie_path %&gt;
</programlisting></para>

      <para>In der Zeile "<code>&lt;% @movies.each do |movie| %&gt;</code>"
      wird mit der Iternator-Methode <methodname>each</methodname> das Array
      <varname>@movies</varname> Eintrag für Eintrag angezeigt. Jeder Eintrag
      wird dann für den Block in der lokalen Variable <varname>movie</varname>
      gespeichert und die wird dann im Block der mit "<code>&lt;% end
      %&gt;</code>" endet dazu benutzt den Inhalt des Eintrages
      darzustellen.</para>
    </section>
  </section>
</chapter>
