<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="erste_schritte_mit_rails" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="erste_schritte_mit_rails.title">Erste Schritte mit
  Rails</title>

  <section>
    <title>Einleitung</title>

    <para>Nachdem Sie sich im <xref linkend="ruby-grundlagen" /> mühsam in die
    Ruby-Grundlagen eingelesen haben, können wir jetzt spannender
    weitermachen. In diesem Kapitel starten wir ein erstes Rails-Projekt und
    arbeiten uns damit Stück für Stück in die Materie ein.</para>

    <para>Auch in diesem Kapitel wird es manchmal hoppla-hopp zu gehen. Wir
    stossen auf typische Henne-Ei-Probleme wir zum Beispiel: "Wie erkläre ich
    MVC (Model-View-Controller)?". Ich habe mich für den "Wir fangen mal an
    und erklären bei der Arbeit."-Ansatz entschieden.</para>

    <section xml:id="arbeits-umgebung-development">
      <title>Arbeits-Umgebung (Development)</title>

      <para>Rails kennt drei verschiedene Arbeits-Umgebungen:<itemizedlist>
          <listitem>
            <para>Development</para>
          </listitem>

          <listitem>
            <para>Testing</para>
          </listitem>

          <listitem>
            <para>Production</para>
          </listitem>
        </itemizedlist></para>

      <para>Wir arbeiten in diesem Kapitel nur mit der Development Umgebung.
      So bald Sie ein besseres Gefühl für Rails bekommen haben, starten wir
      mit Tests und benötigen dafür die entsprechende Umgebung (dort wird z.B.
      beim Start eines Tests die Test-Datenbank neu gefühlt und beim Beenden
      wird gelöscht). Später erkläre ich Ihnen dann die verschiedenen
      Szenarien, wie Sie Ihre Rails-Applikation aus der Development-Umgebung
      in die Production-Umgebung ausrollen können.</para>

      <para>Die Development-Umgebung bringt bis auf einen Editor und einen
      Webbrowser alles mit, was Sie zum Entwickeln benötigen. So müssen Sie
      nicht extra einen Webserver installieren, sondern können den eingebauten
      Rails-Webserver benutzen. Der besticht nicht durch extreme Performance,
      aber das benötigen wir bei der Entwicklung ja auch nicht. Später kann
      man dann auf grosse Systeme wie <application>Apache</application>
      umsteigen. Das gleiche gilt für die Datenbank.</para>

      <para>Um in der Development-Umgebung zu arbeiten, müssen Sie erst mal
      nichts verändern. Alle Befehle gelten per Default auf die
      Development-Umgebung.</para>

      <section xml:id="sqlite3_datenbank_default">
        <title>sqlite3 Datenbank</title>

        <para>Auch bei der Datenbank geht es in diesem Kapitel nicht um
        optimale Performance, sondern um einen einfachen Einstieg. Deshalb
        benutzen wir die sqlite3 Datenbank. Dafür haben Sie bereits alles
        fertig installiert und müssen sich keinen Kopf machen. Später erkläre
        ich Ihnen dann wie Sie andere Datenbank (z.B. MySQL) ansteuern
        können.</para>
      </section>

      <section>
        <title>Warum alle Feldnamen, Methoden und Klassen auf
        Englisch?</title>

        <para>Ganz tief im Herzen liebt Rails die englische Sprache. Damit
        muss man sich abfinden und versuchen diese Liebe zu übernehmen. So
        verwenden sehr viele Mechanismen automagisch Plural oder Singular von
        Englischen Wörtern. Wenn man sich damit anfreundet Datenbankfelder und
        Datenbanken an sich mit englischen Wörter zu benennen, dann kann man
        die ganze Macht dieser Magie ausnutzen.</para>
      </section>
    </section>
  </section>

  <section xml:id="statische_webseiten">
    <title xml:id="statische_webseiten.title">Einfache Webseiten und
    Grafiken</title>

    <para>Jeder der diesen Text liest wird sich darüber im Klaren sein, das
    man mit Rails irgendwie Webseiten ausliefern kann. Die Frage ist nur wie.
    Legen wir erst mal eine neues Railsprojekte an.</para>

    <section>
      <title>Railsprojekt anlegen</title>

      <para>Bevor wir hier überhaupt mit dem aller einfachsten starten,
      überprüfen Sie bitte, ob Sie eine Ruby Version 1.9.2 einsetzen:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>ruby -v</command>
ruby 1.9.2p0 (2010-08-18 revision 29036) [x86_64-darwin10.4.0]
stefan@swmbp 0 1.9.2-p0 ~$</screen></para>

      <para>Und als nächstes überprüfen wir, ob auch Rails 3.0 oder höher
      installiert ist:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails -v</command>
Rails 3.0.0
stefan@swmbp 0 1.9.2-p0 ~$</screen></para>

      <para>Das sieht gut aus. Falls Sie eine ältere Ruby- oder Rails-Version
      installiert haben, dann installieren Sie bitte vor dem Weiterlesen die
      aktuelle Version (siehe <xref
      linkend="installation-und-versionsauswahl" />).</para>

      <para>Jetzt erstellen wir erst mal ein neues Rails-Projekt mit dem Namen
      <code>testproject</code>. Da Ruby on Rails ein Framework ist, müssen wir
      erst mal die entsprechende Verzeichnisstruktur und die
      Grundkonfiguration inkl. einiger Skripte einrichten. Das geht aber mit
      dem Befehl <command>rails new testproject</command> ratz-fatz:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new testproject</command>
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/views/layouts/application.html.erb
      create  app/mailers
      create  app/models
      create  config
      create  config/routes.rb
      create  config/application.rb
      create  config/environment.rb
      create  config/environments
      create  config/environments/development.rb
      create  config/environments/production.rb
      create  config/environments/test.rb
      create  config/initializers
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/secret_token.rb
      create  config/initializers/session_store.rb
      create  config/locales
      create  config/locales/en.yml
      create  config/boot.rb
      create  config/database.yml
      create  db
      create  db/seeds.rb
      create  doc
      create  doc/README_FOR_APP
      create  lib
      create  lib/tasks
      create  lib/tasks/.gitkeep
      create  log
      create  log/server.log
      create  log/production.log
      create  log/development.log
      create  log/test.log
      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js
      create  script
      create  script/rails
      create  test
      create  test/performance/browsing_test.rb
      create  test/test_helper.rb
      create  test/fixtures
      create  test/functional
      create  test/integration
      create  test/unit
      create  tmp
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ </screen></para>

      <para>Als erstes führen wir jetzt ein <command>bundle install</command>
      aus und stellen damit dem Rails Projekt alle benötigten Gems zur
      Verfügung. Ein Gem ist eine Art Softwarebibliothek. Man kann damit
      bestimmte Funktionalitäten fix und fertig einbinden ohne das Rad neu
      erfinden zu müssen.<important>
          <para>Es ist völlig egal, ob Sie die entsprechenden Gems schon auf
          Ihrem System installiert haben oder nicht. Sie müssen
          <emphasis>immer</emphasis> ein <command>bundle install</command> in
          ihrem jeweiligen Rails Projekt ausführen! Am besten direkt ins Hirn
          brennen: Nach einen <command>rails new projectname</command> kommt
          immer ein <command>cd projectname &amp;&amp; bundle
          install</command>!</para>
        </important><screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>cd testproject</command>
stefan@swmbp 0 1.9.2-p0 testproject$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
Using abstract (1.0.0) 
Using activesupport (3.0.0) 
Using builder (2.1.2) 
Using i18n (0.4.1) 
Using activemodel (3.0.0) 
Using erubis (2.6.6) 
Using rack (1.2.1) 
Installing rack-mount (0.6.13) 
Using rack-test (0.5.4) 
Using tzinfo (0.3.23) 
Using actionpack (3.0.0) 
Using mime-types (1.16) 
Using polyglot (0.3.1) 
Using treetop (1.4.8) 
Using mail (2.2.5) 
Using actionmailer (3.0.0) 
Using arel (1.0.1) 
Using activerecord (3.0.0) 
Using activeresource (3.0.0) 
Using bundler (1.0.0) 
Using thor (0.14.0) 
Using railties (3.0.0) 
Using rails (3.0.0) 
Using sqlite3-ruby (1.3.1) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Als nächstes prüfen wir, ob die neue Rails-Applikation
      funktioniert. Dazu starten wir den mitgelieferten kleinen
      Web-Server.<footnote>
          <para>Nein, keine Angst. Das ist nicht der Webserver, mit dem wir
          später auch Produktiv gehen. Aber zum Entwickeln ist diese Variante
          sehr praktisch.</para>
        </footnote><note>
          <para>Bei verschiednen Betriebssystemen (z.B. Mac OS X) kommt beim
          ersten Starten einer Rails-Applikation, je nach Firewall
          Einstellung, ein Fenster, das Sie fragt, ob die Firewall die
          entsprechende Verbindung erlauben soll. Da wir lokal arbeiten,
          können Sie das mit ruhigen Gewissen bejahen.</para>
        </note><screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 09:39:58] INFO  WEBrick 1.3.1
[2010-09-01 09:39:58] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 09:39:58] INFO  WEBrick::HTTPServer#start: pid=40688 port=3000

</screen></para>

      <para>Der Start der Rails Applikation sieht gut aus. Er sagt
      uns:<screen>=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000</screen></para>

      <para>Dann rufen wir doch mal genau diese URI (<uri
      xlink:href="http://0.0.0.0:3000">http://0.0.0.0:3000</uri>) im
      Webbrowser auf.<screenshot>
          <info>
            <title>Default Index-Seite in einem frischen
            Rails-Projekt.</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/virgin_rails_app.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Sieht gut aus. Rails scheint zu funktionieren. Wenn wir jetzt auf
      den "About your application's environment" Link klicken erscheint eine
      Aufstellung der aktuellen Umgebung.<screenshot>
          <info>
            <title>Auflistung der Start-Umgebung der
            Rails-Applikation.</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/virgin_rails_app_env_info.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Gleichzeitig wird im Log des Webservers folgendes
      angezeigt:<screen>Started GET "/rails/info/properties" for 127.0.0.1 at 2010-09-01 09:44:41 +0200
  Processing by Rails::InfoController#properties as */*
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Rendered inline template (0.4ms)
Completed 200 OK in 60ms (Views: 1.2ms | ActiveRecord: 0.3ms)
</screen></para>

      <para>Da beim Aufruf der ersten Startseite kein entsprechender Eintrag
      erschien, muss es sich um zwei verschiedenartige Seiten handeln. Die
      erste Seite ist tatsächlich eine statische HTML-Seite, die unter
      <filename>public/index.html</filename> abgespeichert ist und der Link,
      auf den wir geklickt haben führt ein Rails Programm aus.</para>

      <para>Mit <keycode>CTRL + C</keycode> können Sie den Webserver wieder
      stoppen.</para>
    </section>

    <section>
      <title>Statische Seiten</title>

      <para>Wie eben gesehen gibt es bestimmte statische Seiten und Grafiken
      die von Rails automatisch und per default sogar ohne Logging
      ausgeliefert werden. Errinnern wir uns noch mal an eine Teilausgabe vom
      Befehl <command>rails new testproject</command>: <screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new testproject</command>

      [...]

      create  public
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/favicon.ico
      create  public/index.html
      create  public/robots.txt
      create  public/images
      create  public/images/rails.png
      create  public/stylesheets
      create  public/stylesheets/.gitkeep
      create  public/javascripts
      create  public/javascripts/application.js
      create  public/javascripts/controls.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/effects.js
      create  public/javascripts/prototype.js
      create  public/javascripts/rails.js

      [...]
</screen></para>

      <para>Der Verzeichnisname <filename>public</filename> und die darin
      enthaltenen Dateien sehen schon sehr nach statischen Seiten aus.
      Probieren wir es einfach mal aus und legen die Datei
      <filename>public/hello-world.html</filename> mit folgendem Inhalt
      an:<programlisting>&lt;html&gt;
&lt;title&gt;Hello World!&lt;/title&gt;
&lt;body&gt;
  &lt;h1&gt;Hello World!&lt;/h1&gt;
  &lt;p&gt;Eine Beispielseite.&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</programlisting></para>

      <note>
        <para>Ich gehe davon aus, das Sie rudimentäre HTML-Kenntnisse haben -
        für viel mehr reicht mein HTML-Wissen auch nicht ;-).</para>
      </note>

      <para>Jetzt noch den Rails Webserver starten:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 09:49:58] INFO  WEBrick 1.3.1
[2010-09-01 09:49:58] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 09:49:58] INFO  WEBrick::HTTPServer#start: pid=40688 port=3000

</screen></para>

      <para>Diese Webseite können wir uns mit der URI <uri
      xlink:href="http://0.0.0.0:3000/hello-world">http://0.0.0.0:3000/hello-world</uri>
      anschauen:<screenshot>
          <info>
            <title>Hello-World HTML Seite</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/hello-world-html.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Wir können natürlich auch die URI <uri
      xlink:href="http://0.0.0.0:3000/hello-world.html">http://0.0.0.0:3000/hello-world.html</uri>
      nehmen. Allerdings sieht Rails HTML und damit die Datei-Endung
      <filename>html</filename> quasi als Standard-Ausgabe-Format an und
      deshalb kann man sich das ".html" hier sparen.</para>

      <para>So, jetzt wissen Sie schon mal, wie man ganz statische Seiten in
      Rails integrieren kann. Das ist manchmal für Seiten praktisch, die sich
      nie, aber wirklich gar nie ändern. Natürlich gilt dies für jegliche Art
      von Datei. So sind Klassiker die Favicon-Datei und die
      <filename>robots.txt</filename> Datei. Beide legt man einfach in das
      <filename>public/</filename> Verzeichnis.</para>

      <para><qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Wo speichern Sie Ihr Firmenlogo
                (<filename>logo.png</filename>)?</para>
              </question>

              <answer>
                <para>Natürlich im <filename>public/</filename> Verzeichnis.
                Denn es ist eine statische Datei.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>
    </section>

    <section>
      <title>Seiten mit dynamischen Inhalt (erb)</title>

      <para>Kennen Sie PHP? Dann wird Ihnen der Inhalt eine erb-Datei sehr
      bekannt vorkommen. Es ist eine Mischung aus HTML und Ruby-Code.
      Allerdings können wir eine solche erb-Webseite nicht einfach in das
      <filename>public</filename> Verzeichnis legen, da dort abgelegte Seite
      1:1 ausgeliefert werden und nicht durch einen erb-Parser gehen.
      Dummerweise müssen wir dafür jetzt direkt mit dem MVC-Modell anrücken.
      Wir brauchen einen Controler. Den können wir mit <command>rails generate
      controller</command> anlegen. Schauen wir uns mal die Hilfe an:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails generate controller</command>
Usage:
  rails generate controller NAME [action action] [options]

Options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
  -t, [--test-framework=NAME]   # Test framework to be invoked
                                # Default: test_unit
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Stubs out a new controller and its views. Pass the controller name, either
    CamelCased or under_scored, and a list of views as arguments.

    To create a controller within a module, specify the controller name as a
    path like 'parent_module/controller_name'.

    This generates a controller class in app/controllers and invokes helper,
    template engine and test framework generators.

Example:
    `rails generate controller CreditCard open debit credit close`

    Credit card controller with URLs like /credit_card/debit.
        Controller:      app/controllers/credit_card_controller.rb
        Functional Test: test/functional/credit_card_controller_test.rb
        Views:           app/views/credit_card/debit.html.erb [...]
        Helper:          app/helpers/credit_card_helper.rb
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

      <para>A-ha! Unten ist freundlicherweise direkt ein Beispiel angegeben
      "<code>rails generate controller CreditCard open debit credit
      close</code>". Passt aber nicht direkt für unseren Fall.</para>

      <para>Ich bin mutig und schlage vor, das wir einfach mal was
      ausprobieren:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails generate controller Example test</command>
      create  app/controllers/example_controller.rb
       route  get "example/test"
      invoke  erb
      create    app/views/example
      create    app/views/example/test.html.erb
      invoke  test_unit
      create    test/functional/example_controller_test.rb
      invoke  helper
      create    app/helpers/example_helper.rb
      invoke    test_unit
      create      test/unit/helpers/example_helper_test.rb
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Puhhh... da wird ja direkt ne ganze Menge erstellt. Unter anderem
      eine Datei <filename>app/views/example/test.html.erb</filename>. Schauen
      wir uns die mal an:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat app/views/example/test.html.erb </command>
&lt;h1&gt;Example#test&lt;/h1&gt;
&lt;p&gt;Find me in app/views/example/test.html.erb&lt;/p&gt;
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Ist also auch HTML. Fehlt oben und unten etwas, aber prinzipiel
      sieht das stark nach HTML aus. Zum Testen starten wir den
      Webserver<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 10:30:50] INFO  WEBrick 1.3.1
[2010-09-01 10:30:50] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 10:30:50] INFO  WEBrick::HTTPServer#start: pid=40964 port=3000
</screen></para>

      <para>und schauen uns die Webseite mit der URI <uri
      xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
      mal im Browser an:<screenshot>
          <info>
            <title>test.html.erb Screenshot</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/example-test-erb.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Im Log <filename>log/development.log</filename> finden wir den
      folgenden Eintrag:<programlisting>Started GET "/example/test" for 127.0.0.1 at 2010-09-01 10:31:24 +0200
  Processing by ExampleController#test as HTML
Rendered example/test.html.erb within layouts/application (2.1ms)
Completed 200 OK in 21ms (Views: 20.7ms | ActiveRecord: 0.0ms)
</programlisting></para>

      <para>Das ist fast schon verständlich geschrieben. Es kam also vom
      localhost (127.0.0.1) ein HTTP GET-Request für die URI "/example/test"
      rein. Die wurde dann anscheinend vom Controller
      <code>ExampleController</code> mit der Methode
      <methodname>test</methodname> als HTML gerendert. Das ganze hat hier
      ungefähr 21ms gedauert.</para>

      <para>Jetzt müssen wir nur noch den Controller finden. Aber Sie haben
      Glück ... ich weiß es nämlich. ;-) Alle Controller befinden sich im
      Verzeichnis <filename>app/controllers</filename> und siehe da, dort ist
      auch tatsächlich die entsprechende Datei
      <filename>app/controllers/example_controller.rb</filename>. Schauen wir
      mal rein:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>ls -l app/controllers/</command>
total 16
-rw-r--r--  1 stefan  staff  80  1 Sep 09:29 application_controller.rb
-rw-r--r--  1 stefan  staff  70  1 Sep 10:29 example_controller.rb
stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat app/controllers/example_controller.rb</command> 
class ExampleController &lt; ApplicationController
  def test
  end

end
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

      <para>Das ist jetzt sehr übersichtlich. Der Controller
      <code>ExampleController</code> stammt vom
      <code>ApplicationController</code> ab und besteht aktuell aus genau
      einer Methode mit dem Namen <methodname>test</methodname>. Und diese
      Methode macht nichts.</para>

      <para>Sie werden sich fragen, woher Rails weiß, das bei der URI
      <uri>/example/test</uri> der Controller <code>example</code> und die
      Methode <code>test</code> abzuarbeiten ist. Das wird nämlich nicht durch
      eine magische Logik, sondern durch eine einfache Routing-Konfiguration
      gesteuert. Diese finden Sie in der Datei
      <filename>config/routes.rb</filename> in der zweiten Zeile:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat config/routes.rb | grep example</command>
  get "example/test"
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Diese Zeile wurde vom <command>rails generate controller</command>
      automatisch eingefügt. In der Routing-Datei können Sie auch beliebiges
      Mapping vornehmen. Aber dazu später mehr. Aktuell sehen unsere Routen
      sehr einfach aus. Mit dem Befehl <command>rake routes</command> können
      wir diese abfragen:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>rake routes</command>
(in /Users/stefan/testproject)
example_test GET /example/test(.:format) {:controller=&gt;"example", :action=&gt;"test"}
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Wir kümmern uns später noch genauer um die Routen. Ich wollte es
      an dieser Stelle nur nicht gänzlich überspringen.</para>

      <important>
        <para>Eine statische Datei im Verzeichnis <filename>public</filename>
        hat immer eine höhere Priorität als eine Route in der
        <filename>config/routes.rb</filename>! Wenn wir also eine statische
        Datei <filename>public/example/test</filename> abspeichern würden, so
        würde die Route nicht mehr greifen.</para>
      </important>

      <section>
        <title>Programmieren in einer erb-Datei</title>

        <para>Erb-Seiten können Ruby-Code enthalten. Damit kann programmiert
        werden und damit können diese Seite dynamischen Inhalt
        bekommen.</para>

        <para>Fangen wir mal mit etwas ganz einfachem an: Der Addition von 1
        und 1. Als erstes probieren wir den Code im irb aus:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>1 + 1</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

        <para>Das war einfach. Die darum erweiterte erb-Datei
        <filename>app/views/example/test.html.erb</filename> füllen wir wie
        folgt:<programlisting>&lt;h1&gt;Erste Versuche mit erb&lt;/h1&gt;
&lt;p&gt;Addition:
&lt;%= 1 + 1 %&gt;
&lt;/p&gt;
</programlisting></para>

        <para>Danach mit <command>rails server</command> den Server starten
        (falls noch nicht getan) und per Webserver auf die Seite
        gehen:<screenshot>
            <info>
              <title>Einfache Addition</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/erb_einfache_addition.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Ruby Code dessen Ergebnis ausgegeben werden soll, wird von einem
        <code>&lt;%=</code> und einem <code>%&gt;</code> eingeschlossen.
        Ausgegeben werden können nur Strings.</para>

        <para>Jetzt werden Sie sich vielleicht fragen: Wie kann den das
        Ergebnis einer Addion von zwei Fixnums als Text angezeigt werden?
        Schauen wir erst mal im irb nach, ob es wirklich ein Fixnum
        ist:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>1.class</command>
 =&gt; Fixnum 
ruby-1.9.2-p0 &gt; <command>(1 + 1).class</command>
 =&gt; Fixnum 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

        <para>Ja, sowohl die Zahl 1 wie auch das Ergebnis von 1 + 1 ist ein
        Fixnum. Was ist passiert? Rails ist so intelligent alle Objekte in
        einem View (das ist die Datei <filename>test.html.erb</filename>) die
        nicht ein String sind automatisch mit der Methode
        <methodname>.to_s</methodname> aufzurufen. Noch mal kurz ins
        irb:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>(1 + 1).class</command>
 =&gt; Fixnum 
ruby-1.9.2-p0 &gt; <command>(1 + 1).to_s.class</command>
 =&gt; String 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

        <para>Das mit dem Ruby-Code schauen wir uns mal genauer an. In einer
        <filename>html.erb</filename> Datei gibt zusätzlich zu den
        HTML-Elementen zwei Arten von Ruby-Code Elementen:<itemizedlist>
            <listitem>
              <para><code>&lt;% ... %&gt;</code></para>

              <para>Führt den enthaltenen Ruby-Code aus, aber gibt nichts
              aus.</para>
            </listitem>

            <listitem>
              <para><code>&lt;%= ... %&gt;</code></para>

              <para>Führt den enthaltenen Ruby-Code aus und gibt das Ergebnis
              als Text aus. Dabei werden seit Ruby 3.0 automatisch
              "problematische" Zeichen escaped. Falls Sie einmal nicht
              escapeten Text ausgeben möchten, so müssen Sie das mit
              <code>raw(string)</code> realisieren.</para>

              <para>So lange also ein Objekt eine Methode
              <methodname>.to_s</methodname> hat oder das Objekt selber schon
              ein String ist, kann man es als Ergebnis im View innerhalb einer
              <code>&lt;%= ... %&gt;</code> Kapselung ausgeben.</para>
            </listitem>
          </itemizedlist>Um ganz sicher zu sein, noch ein Beispiel. Wir ändern
        die <filename>app/views/example/test.html.erb</filename> wie
        folgt:<programlisting>&lt;p&gt;Schleife von 0 bis 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;
</programlisting></para>

        <para>Das sieht dann im Browser so aus:<screenshot>
            <info>
              <title>Einfache Addition</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/erb_einfache_schleife.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Schauen wir uns mal den HTML-Source-Code im Browser
        an:<programlisting>&lt;!DOCTYPE html&gt; 
&lt;html&gt; 
&lt;head&gt; 
  &lt;title&gt;Testproject&lt;/title&gt; 
  
  &lt;script src="/javascripts/prototype.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/effects.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/dragdrop.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/controls.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/rails.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
&lt;script src="/javascripts/application.js?1283326173" type="text/javascript"&gt;&lt;/script&gt; 
  &lt;meta name="csrf-param" content="authenticity_token"/&gt; 
&lt;meta name="csrf-token" content="7vy1+iQpYWFUhvXS2UHPXZOFjkpePZj/gBOkUASWoyY="/&gt; 
&lt;/head&gt; 
&lt;body&gt; 
 
&lt;p&gt;Schleife von 0 bis 5:
0, 
1, 
2, 
3, 
4, 
5, 
&lt;/p&gt; 
 
 
&lt;/body&gt; 
&lt;/html&gt;</programlisting></para>

        <para>Alles klar? Es gibt zwei mögliche offene Fragen:<qandaset>
            <qandadiv>
              <qandaentry>
                <question>
                  <para>Ich verstehe gar nichts. Mit dem Ruby-Code komme ich
                  nicht zurecht. Können Sie das noch mal erklären?</para>
                </question>

                <answer>
                  <para>Kann es sein, das Sie <xref
                  linkend="ruby-grundlagen" /> nicht komplett durchgearbeitet
                  haben? Bitte die Zeit dafür nehmen. Sonst macht hier das
                  alles keinen Sinn.</para>
                </answer>
              </qandaentry>

              <qandaentry>
                <question>
                  <para>Ich verstehe den Ruby-Code und die HTML-Ausgabe.
                  Allerdings verstehe ich nicht, warum drum rum noch HTML-Code
                  gerendert wurde, den ich gar nicht geschrieben habe. Woher
                  kommt der und kann ich Ihn beeinflussen?</para>
                </question>

                <answer>
                  <para>Sehr gute Frage! Dazu kommen wir sofort (siehe <xref
                  linkend="erb_layouts" />).</para>
                </answer>
              </qandaentry>
            </qandadiv>
          </qandaset></para>

        <para>Die Feinheiten von erb werden Sie jetzt Stück für Stück
        erlernen. Es handelt sich dabei nicht um Zauberei.</para>
      </section>
    </section>

    <section xml:id="erb_layouts">
      <title xml:id="erb_layouts.title">Layouts</title>

      <para>Die erb Datei im Verzeichnis
      <filename>app/views/example/</filename> bilden nur den Kern der späteren
      HTML-Seite. Per default wird immer eine automatisch generierte
      <filename>app/views/layouts/application.html.erb</filename> drum rum
      gerendert. Schauen wir uns die mal an:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>cat app/views/layouts/application.html.erb</command>
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Testproject&lt;/title&gt;
  &lt;%= stylesheet_link_tag :all %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
stefan@swmbp 0 1.9.2-p0 testproject$ </screen></para>

      <para>Ich löse das Rätsel auf: Interessant ist die Zeile<programlisting>&lt;%= yield %&gt;</programlisting></para>

      <para>Mit <code>&lt;%= yield %&gt;</code> wird die View-Datei
      inkludiert. Die drei Zeilen mit den Stylesheets und dem JavaScript
      lassen wir erst mal so wie sie sind. Darum kümmern wir uns
      später.</para>

      <para>Die <filename>app/views/layouts/application.html.erb</filename>
      bietet Ihnen die Möglichkeit das Grundlayout über die gesamte
      Rails-Applikation fest zu legen. Sie können aber auch im Verzeichnis
      <filename>app/views/layouts/</filename> noch andere Layouts anlegen und
      diese je nach Situation anwenden. Ich bin hin und hergerissen dieses
      Thema jetzt zu vertiefen, aber lassen wir es jetzt erst mal. Wichtig ist
      jetzt, das Sie die Grundidee verstehen.</para>
    </section>

    <section xml:id="erb_mit_programmierlogik">
      <title>Instance-Variablen vom Controller zum View übergeben</title>

      <para>Einer der todsünden im MVC Model ist ja bekanntlich zu viel
      Programmierlogic im View unterzubringen. Quasi so wie man früher oft in
      PHP programmiert hat. Bei MVC ist eins der Ziele, das quasi jeder
      beliebige HTML-Designer einen View erstellen kann ohne sich über die
      Programmierung gedanken machen zu müssen. Ja, ja, ... wenn das mal immer
      so einfach wäre. Trotzdem gehen wir das mal gedanklich weiter: Wenn ich
      im Controller einen Wert habe, den ich im View anzeigen will, so
      benötige ich dafür einen Mechanismus. Dieser heißt Instance-Variable.
      Wer sich nicht mehr 100% sicher welche Variable welchen Scope hat, der
      sollte ganz fix noch mal einen Blick in <xref
      linkend="scope_von_variablen" /> werfen (geht schnell und lohnt
      sich).</para>

      <para>Wir brechen jetzt einfach mal ein Beispiel vom Zaun und fügen im
      Controller eine Instance-Variable für die aktuelle Uhrzeit ein und fügen
      diese dann im View ein. Wir nehmen also Programmierintelligenz aus dem
      View in den Controller.</para>

      <para>Die Controller Datei
      <filename>app/controllers/example_controller.rb</filename> sieht dann so
      aus:<programlisting>class ExampleController &lt; ApplicationController
  def test
    <emphasis>@current_time</emphasis> = Time.now
  end

end
</programlisting></para>

      <para>In der View Datei
      <filename>app/views/example/test.html.erb</filename> können wir dann auf
      diese Instance-Variable zurückgreifen:<programlisting>&lt;p&gt;
Die aktuelle Uhrzeit ist 
&lt;%= <emphasis>@current_time</emphasis> %&gt;
&lt;/p&gt;
</programlisting></para>

      <para>Wir haben jetzt eine klare Trennung von Programmierlogik und
      Darstellungslogik mit dem Controller und dem View. So können wir im
      Controller die Uhrzeit je nach Zeitzone des Users automatisch anpassen,
      ohne das sich der Designer der Seite darum kümmern muss.</para>

      <para>Mir ist klar, das jetzt keiner aufspringen und schreien wird
      "Danke für die Erleuchtung! Ich werde nur noch sauber nach MVC
      programmieren". Das obige Beispiel ist der erste kleine Schritt in die
      Richtung und zeigt wie wir einfach mit Instance-Variablen (das sind die
      mit dem @-Zeichen davor) Werte aus dem Controller in den View bringen
      können.</para>
    </section>

    <section xml:id="partials">
      <title xml:id="partials.title">Partials</title>

      <para>Selbst schon bei kleinen Webprojekten gibt es oft wiederkehrende
      Elemente. Das kann zum Beispiel ein Footer der Seite mit den
      Kontaktdaten sein oder ein Menü. Rails gibt uns die Möglichkeit diesen
      HTML-Code in sogenannte Partials abzuspeichern und dann innerhalb eines
      Views einzubinden. Ein Partial wird ebenfalls im
      <filename>app/views/example/</filename> Verzeichnis abgespeichert.
      Allerdings muss der Dateinamen mit einem Unterstrich (Underscore = _)
      anfangen.</para>

      <para>Als Beispiel fügen wir unser Seite jetzt einen Mini-Footer hinzu.
      Dafür schreiben wir in die neue Datei
      <filename>app/views/example/_footer.html.erb</filename> den folgenden
      Inhalt:<programlisting>&lt;hr /&gt;
&lt;p&gt;
Copyright 2009 - &lt;%= Date.today.year %&gt; beim Osterhasen
&lt;/p&gt;</programlisting></para>

      <para>Die Datei <filename>app/views/example/test.html.erb</filename>
      verändern wir wie folgt und fügen mit dem Befehl <code>render</code> das
      Partial ein:<programlisting>&lt;p&gt;Schleife von 0 bis 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;

<emphasis>&lt;%= render "footer" %&gt;</emphasis></programlisting></para>

      <para>Es sind also jetzt folgende Dateien im Verzeichnis
      <filename>app/views/example</filename>:<screen>stefan@swmbp 0 1.9.2-p0 testproject$ <command>ls -l app/views/example</command>
total 16
-rw-r--r--  1 stefan  staff   63  1 Sep 20:12 _footer.html.erb
-rw-r--r--  1 stefan  staff  105  1 Sep 20:14 test.html.erb
stefan@swmbp 0 1.9.2-p0 testproject$</screen></para>

      <para>Die neue Webseite sieht jetzt so aus:<screenshot>
          <info>
            <title>Footer mit Partials</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/partials_footer.jpg"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para><important>
          <para>Der Name eines Partials im Code wird immer
          <emphasis>ohne</emphasis> den Unterstrich am Anfang und
          <emphasis>ohne</emphasis> die erb und HTML Endung angegeben. Aber
          die wirkliche Datei muss im Dateinamen mit einem Unterstrich
          anfangen und auch am Ende mir der erb und HTML Endung
          aufhören.</para>
        </important></para>

      <para>Partials können auch aus anderen Bereichen des Unterverzeichnisses
      <filename>app/views</filename> eingebunden werden. So können Sie für
      wiederkehrende und übergreifende Inhalte beispielsweise ein Verzeichnis
      <filename>app/views/shared</filename> anlegen und dort eine Datei
      <filename>_footer.html.erb</filename> anlegen. Das Einbetten im erb Code
      würde dann mit folgender Zeile erfolgen:<programlisting>&lt;%= render "shared/footer" %&gt;</programlisting></para>

      <note>
        <para>Das Footer-Problem würde man in einem richtigen Projekt
        wahrscheinlich nicht mit einem Partial lösen, das überall aufgerufen
        wird, sondern eher zentral in der
        <filename>app/views/layouts/application.html.erb</filename>.</para>
      </note>

      <section xml:id="partials_locale_variables">
        <title xml:id="partials_locale_variables.title">Variablen an ein
        Partial übergeben</title>

        <para>Partials sind im DRY (<emphasis>D</emphasis>on't
        <emphasis>R</emphasis>epeat <emphasis>Y</emphasis>ourself) Gedanken
        sehr gut. Aber was sie erst richtig praktisch macht, ist die
        Möglichkeit Variablen zu übergeben. Erweitern wir einmal die
        <filename>app/views/example/_footer.html.erb</filename> Datei wie
        folgt:<programlisting>&lt;hr /&gt;
&lt;p&gt;
Copyright 2009 - &lt;%= Date.today.year %&gt; beim Osterhasen
&lt;/p&gt;
&lt;% if (defined? additional_info) != nil %&gt;
&lt;p&gt;
&lt;%= additional_info %&gt;
&lt;/p&gt;
&lt;% end %&gt;
</programlisting></para>

        <para>Wenn wir jetzt die URI <uri
        xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
        aufrufen, so sehen wir die gleiche Seite wie vorhin. Das liegt daran,
        weil <varname>additional_info</varname> nicht als Local Variable
        übergeben wurde. Ändern wir dazu die
        <filename>app/views/example/test.html.erb</filename> wie
        folgt:<programlisting>&lt;p&gt;Schleife von 0 bis 5:
&lt;% (0..5).each do |i| %&gt;
&lt;%= "#{i}, " %&gt;
&lt;% end %&gt;
&lt;/p&gt;

&lt;%= render :partial =&gt; 'footer', :locals =&gt; {:additional_info =&gt; "abcdef"} %&gt;
</programlisting></para>

        <para>Der Aufruf von <uri
        xlink:href="http://0.0.0.0:3000/example/test">http://0.0.0.0:3000/example/test</uri>
        erzeugt erwartungsgemäß folgende Seite:<screenshot>
            <info>
              <title>Partial mit Locals</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/footer_partial_mit_locals.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Sie sehen ebenfalls, das ich beim Einbinden eines einfaches
        Partials eine kürzere Schreibweise benutzen kann, als bei der Version
        mit locals.</para>
      </section>

      <section xml:id="weitere_doku_zu_partials">
        <title xml:id="weitere_doku_zu_partials.title">Weitere Dokumentation
        zum Thema Partials</title>

        <para>Wir haben hier wirklich nur die Oberfläche angekratzt. Partials
        sind sehr mächtige Werkzeuge. Unter <uri
        xlink:href="http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials">http://guides.rubyonrails.org/layouts_and_rendering.html#using-partials</uri>
        finden Sie die Ruby on Rails Doku zum Thema Partials.</para>
      </section>
    </section>
  </section>

  <section xml:id="redirects">
    <title xml:id="redirects.title">Redirects</title>

    <para>Redirects sind Befehle, mit denen Sie innerhalb des Controllers auf
    andere Methoden oder auch auf ganz andere Webseiten "springen" also
    redirecten können. Legen wir ein neues Rails-Projekt für ein
    entsprechendes Beispiel an:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new redirect_beispiel</command>
      create  
      create  README
      create  Rakefile
      create  config.ru

      [...]

      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd redirect_beispiel</command>
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
Using abstract (1.0.0) 

[...]

Using rails (3.0.0) 
Using sqlite3-ruby (1.3.1) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Um zu springen brauchen wir mindestens einen Controller und in dem
    mindestens zwei verschiedene Methoden. Und auf gehts:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>rails generate controller Game ping pong</command>
      create  app/controllers/game_controller.rb
       route  get "game/pong"
       route  get "game/ping"
      invoke  erb
      create    app/views/game
      create    app/views/game/ping.html.erb
      create    app/views/game/pong.html.erb
      invoke  test_unit
      create    test/functional/game_controller_test.rb
      invoke  helper
      create    app/helpers/game_helper.rb
      invoke    test_unit
      create      test/unit/helpers/game_helper_test.rb
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Starten wir mal den Rails-Server und rufen mit dem Browser erst <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    und dann <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    auf:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-01 23:29:44] INFO  WEBrick 1.3.1
[2010-09-01 23:29:44] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-01 23:29:44] INFO  WEBrick::HTTPServer#start: pid=46878 port=3000


Started GET "/game/ping" for 127.0.0.1 at 2010-09-01 23:29:52 +0200
  Processing by GameController#ping as HTML
Rendered game/ping.html.erb within layouts/application (1.7ms)
Completed 200 OK in 6ms (Views: 5.7ms | ActiveRecord: 0.0ms)


Started GET "/game/pong" for 127.0.0.1 at 2010-09-01 23:29:55 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.5ms)
Completed 200 OK in 5ms (Views: 5.1ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Alles ganz normal. Das Projekt verfügt über zwei mögliche
    Routen:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>rake routes</command>
(in /Users/stefan/redirect_beispiel)
game_ping GET /game/ping(.:format) {:controller=&gt;"game", :action=&gt;"ping"}
game_pong GET /game/pong(.:format) {:controller=&gt;"game", :action=&gt;"pong"}
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Der Controller
    <filename>app/controllers/game_controller.rb</filename> hat folgenden
    Inhalt:<screen>stefan@swmbp 0 1.9.2-p0 redirect_beispiel$ <command>cat app/controllers/game_controller.rb</command> 
class GameController &lt; ApplicationController
  def ping
  end

  def pong
  end

end
stefan@swmbp 0 1.9.2-p0 redirect_beispiel$</screen></para>

    <para>Jetzt zum Redirect: Wie können wir es erreichen, das wir beim Aufruf
    von <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    direkt auf die Methode <methodname>pong</methodname> weitergeleitet
    werden? Einfach werden Sie sagen, in dem wir die Route in der
    <filename>config/routes.rb</filename> ändern. Da haben Sie recht. Dafür
    brauchen wir also nicht zwingend ein Redirect.</para>

    <para>Machen wir die Aufgabe etwas schwieriger: Wie können wir es
    erreichen, das zwischen 9 und 17 Uhr beim Aufruf von <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    direkt auf die Methode <methodname>pong</methodname> weitergeleitet wird?
    Das können wir nur mit einem Redirect im Controller realisieren. Bitte
    ändern Sie die Datei
    <filename>app/controllers/game_controller.rb</filename> wie folgt
    ab:<programlisting>class GameController &lt; ApplicationController
  def ping
    if (Time.now.hour &gt; 8) and (Time.now.hour &lt; 17)
      <emphasis>redirect_to game_pong_path</emphasis>
    end    
  end

  def pong
  end

end
</programlisting></para>

    <para>Aber was ist <code>game_pong_path</code>? Schauen wir uns dazu die
    für diese Rails-Applikation generierten Routen an:<screen>stefan@swmbp 1 1.9.2-p0 pingpong$ <command>rake routes</command>
(in /Users/stefan/pingpong)
game_ping GET /game/ping(.:format) {:controller=&gt;"game", :action=&gt;"ping"}
game_pong GET /game/pong(.:format) {:controller=&gt;"game", :action=&gt;"pong"}
stefan@swmbp 0 1.9.2-p0 pingpong$</screen></para>

    <para>Sie sehen, das die Route zur Action "ping" des Controllers "game"
    den Namen <varname>game_ping</varname> bekommen hat. Wir könnten das
    Redirect auch so schreiben:<programlisting>redirect_to :action =&gt; 'pong'</programlisting></para>

    <para>Aber die Schreibweise mit den Routen ist sauberer und lässt sich
    später besser warten.</para>

    <para>Wenn wir jetzt zwischen 9 und 17 Uhr mit dem Browser die Seite <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>
    aufrufen, werden wir automatisch auf die Seite <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    geleitet. Schauen wir uns das mal im Log an:<screen>Started GET "/game/ping" for 127.0.0.1 at 2010-09-01 13:44:37 +0200
  Processing by GameController#ping as HTML
Redirected to http://0.0.0.0:3000/game/pong
Completed 302 Found in 1ms


Started GET "/game/pong" for 127.0.0.1 at 2010-09-01 13:44:38 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.6ms)
Completed 200 OK in 5ms (Views: 4.9ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Wie Sie sehen, wurde zwar im ersten Schritt mit
    <code>GameController#ping as HTML</code> die Methode
    <methodname>ping</methodname> im Controller <code>GameController</code>
    aufgerufen, aber danach fand ein Redirect zur Methode
    <methodname>pong</methodname> statt.</para>

    <para>Auf die Details und einzelnen Möglichkeiten des Redirects gehen wir
    später im jeweils konkreten Fall ein. Nur schon so viel vorweg: Man kann
    nicht nur auf eine andere Methode, sondern auch auf einen anderen
    Controller oder eine ganze andere Seite redirecten.</para>

    <section>
      <title>Warum Redirects?</title>

      <para>Beim obigen Beispiel fragt man sich natürlich, warum man denn im
      Controller einen Redirect einbaut und nicht direkt die Routen ändert.
      Das ist der Nachteil von der "wir benutzen nur bisheriges
      Wissen"-Methode. Schon im <xref linkend="scaffolding" /> werden Sie
      verstehen warum Redirects so praktisch sind. Sie können z.B. in einem
      Controller überprüfen, ob bestimmte Eingabedaten valide sind oder nicht
      und wenn etwas fehlt zur ursprünglichen Eingabeseite redirecten. Das
      wäre mit einer statischen Route nicht lösbar.</para>

      <para>Allerdings muss man beim Programmieren auch darauf achten, nicht
      beliebig viele Redirects einzubauen. Wenn man tatsächlich mal in der
      Versuchung kommen zwei oder mehr Redirects hinter einander zu schachteln
      (also in verschiedene Methoden), dann sollte man einen Schritt zurück
      gehen und sich Gedanken über die Gesamtidee machen. Meist geht es dann
      anders einfacher und sauberer.</para>
    </section>
  </section>

  <section xml:id="flash">
    <title xml:id="flash.title">Flash Nachrichten</title>

    <para>Der Begriff "Flash Message" oder "Flash Nachricht" ist meiner
    Meinung nach denkbar ungeeignet gewählt worden. Mit dem Wort "Flash"
    assoziiert fast jeder mehr oder weniger bunte Webseiten, die mit dem
    Adobe-Flash-Plug-in realisiert wurden. Aber in Rails sind Flash
    Nachrichten etwas ganz anderes. Sie sind Nachrichten, die über ein
    Redirect (siehe <xref linkend="redirects" />) auf eine andere Seite weiter
    geleitet werden können.</para>

    <para>Flash Nachrichten sind quasi gute Freunde von Redirects. Nicht
    selten arbeiten beide ihm Team, um dem User ein Feedback über eine gerade
    vollzogene Aktion zu geben. Ein typisches Beispiel einer Flash-Nachricht
    ist das Feedback des Systems, wenn ein User sich eingeloggt hat. Dann wird
    er oft wieder auf die ursprüngliche Seite redirected und bekommt
    zusätzlich noch ein Feedback "Sie sind jetzt eingeloggt.".</para>

    <para>Wir bauen als Beispiel noch mal das Ping-Pong Szenario aus <xref
    linkend="redirects" /> auf:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new pingpong</command>
      create  
      create  README
      [...]
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd pingpong</command>
stefan@swmbp 0 1.9.2-p0 pingpong$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
[...]
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 pingpong$ <command>rails generate controller Game ping pong</command>
      create  app/controllers/game_controller.rb
      [...]
      create      test/unit/helpers/game_helper_test.rb
stefan@swmbp 0 1.9.2-p0 pingpong$</screen></para>

    <para>Die <filename>app/controllers/game_controller.rb</filename> füllen
    wir mit folgendem Inhalt:<programlisting>class GameController &lt; ApplicationController
  def ping
    <emphasis>redirect_to game_pong_path</emphasis>
  end

  def pong
  end

end
</programlisting></para>

    <para>Jetzt starten wir den Rails Webserver und browsen einmal auf <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    und einmal auf <uri
    xlink:href="http://0.0.0.0:3000/game/ping">http://0.0.0.0:3000/game/ping</uri>:<screen>stefan@swmbp 0 1.9.2-p0 pingpong$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-02 14:30:31] INFO  WEBrick 1.3.1
[2010-09-02 14:30:31] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-02 14:30:31] INFO  WEBrick::HTTPServer#start: pid=49354 port=3000


Started GET "/game/pong" for 127.0.0.1 at 2010-09-02 14:31:04 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.6ms)
Completed 200 OK in 5ms (Views: 4.8ms | ActiveRecord: 0.0ms)


Started GET "/game/ping" for 127.0.0.1 at 2010-09-02 14:31:08 +0200
  Processing by GameController#ping as HTML
Redirected to http://0.0.0.0:3000/game/pong
Completed 302 Found in 1ms


Started GET "/game/pong" for 127.0.0.1 at 2010-09-02 14:31:08 +0200
  Processing by GameController#pong as HTML
Rendered game/pong.html.erb within layouts/application (1.4ms)
Completed 200 OK in 5ms (Views: 4.5ms | ActiveRecord: 0.0ms)
</screen></para>

    <para>Wie nicht anders zu erwarten war: Egal, welche der beiden URIs wir
    aufrufen, am Ende wird immer <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    angezeigt. Wäre es nicht schön, wenn wir beim Redirect von ping auf pong
    dem User eine Nachricht anzeigen könnten? Jetzt raten Sie mal, wie so eine
    Nachricht bei Rails genannt wird? Ja, genau! Eine Flash-Nachricht!</para>

    <para>Bitte erweitern Sie die Datei
    <filename>app/controllers/game_controller.rb</filename> wie
    folgt:<programlisting>class GameController &lt; ApplicationController
  def ping
    <emphasis>redirect_to game_pong_path, :notice =&gt; 'Ich wurde von Ping redirected.'</emphasis>
  end

  def pong
  end

end</programlisting></para>

    <para>Und in der
    <filename>app/views/layouts/application.html.erb</filename> müssen wir
    auch noch eine Kleinigkeit einbauen:<programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Pingpong&lt;/title&gt;
  &lt;%= stylesheet_link_tag :all %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

<emphasis>&lt;% if (defined? notice) != nil and !notice.blank? %&gt;
&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;% end %&gt;</emphasis>

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

    <para>Beim Aufruf von <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/pong</uri>
    bekommen wir weiterhin normal die Pong-Seite angezeigt. Beim Aufruf von
    <uri
    xlink:href="http://0.0.0.0:3000/game/pong">http://0.0.0.0:3000/game/ping</uri>
    werden wir aber zur Pong-Seite redirected und bekommen oben die
    Flash-Nachricht angezeigt:<screenshot>
        <info>
          <title>Pong-Seite mit Flash-Nachricht</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/flash_pong_notice.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <tip>
      <para>Wenn Sie später mal eine Flash-Nachricht nicht angezeigt bekommen,
      dann überprüfen Sie im View, ob dort die Flash-Nachricht überhaupt
      ausgegeben wird.</para>
    </tip>

    <section xml:id="verschiedene_arten_von_flash_nachrichten">
      <title
      xml:id="verschiedene_arten_von_flash_nachrichten.title">Verschiedene
      Arten von Flash Nachrichten</title>

      <para>Per default werden die Arten "error", "notice" und "warning"
      unterschieden. Allerdings kann man auch selber eine Kategorie erfinden
      und diese später im View abfragen. Beim Arbeiten mit <xref
      linkend="scaffolding" /> werden Sie Beispiele für die verschiedenen
      Arten finden.</para>
    </section>

    <section xml:id="neue_flash_redirect_schreibweise">
      <title xml:id="neue_flash_redirect_schreibweise.title">Verschiedene
      Syntaxen</title>

      <para>Je nach Wissen und Vorliebe eines Programmierers werden Sie in der
      Praxis auf verschiedene Syntaxen von Flash-Nachrichten treffen. Ich will
      mich nicht an der Diskussion über die beste Syntax beteildigen (dafür
      finde ich es einfach zu unwichtig), aber ich möchte Ihnen kurz die zwei
      häufigsten Möglichkeiten darstellen:<itemizedlist>
          <listitem>
            <para><programlisting>redirect_to game_pong_path, :notice =&gt; 'Ich wurde von Ping redirected.'</programlisting></para>
          </listitem>

          <listitem>
            <para><programlisting>flash[:notice] = 'Ich wurde von Ping redirected.'
redirect_to :action =&gt; :pong</programlisting></para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>Warum gibt es überhaupt Flash-Nachrichten?</title>

      <para>Sie werden sich vielleicht fragen "Warum gibt es
      Flash-Nachrichten? Das kann ich mir ja auch selber bauen, wenn ich es
      brauche." Stimmt. Flash-Nachrichten haben hauptsächlich den Vorteil, das
      sie einen definierten und für alle Programmierer gleichen Weg zur
      Verfügung stellen. So muss man nicht das Rad neu erfinden.</para>
    </section>
  </section>

  <section xml:id="die_console" xml:lang="">
    <title xml:base="" xml:id="die_console.title">Die Console</title>

    <para>Die Console in Rails ist nichts weiter als ein aufgebohrtes irb
    (siehe <xref linkend="ruby-grundlagen" />). Sowohl beim Entwicklen wie
    auch beim Administrieren ist die Console sehr praktisch, da die komplete
    Rails-Umgebung abgebildet wird. So kann man leicht mal eine Methode
    ausprobieren ohne dafür direkt ein eigenes Programm zu schreiben.</para>

    <para>Die Console wird mit <command>rails console</command>
    gestartet:<screen>MacBook:movie-app sw$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt;</screen></para>

    <para>Zum Beenden der Console muss man <command>exit</command>
    eingeben:<screen>ruby-1.9.1-p378 &gt; <command>exit</command>
MacBook:movie-app sw$ </screen></para>

    <para>ActiveRecord ist ein Mechanismus, um innerhalb von Rails mit der
    Datenbank zu arbeiten. Innerhalb dieses Kapitels gehe ich nur auf die
    absoluten Basics ein, denn es geht ja jetzt nicht darum in ActiveRecord
    einen Meistertitel zu erringen, sondern darum Ruby on Rails zu verstehen.
    In einem späteren Kapitel werde ich mich noch einmal intensiv mit
    ActiveRecords beschäftigen.</para>

    <para>Sie haben im <xref linkend="ruby-grundlagen" /> gelernt mit irb
    umzugehen. In Rails gibt es dazu ein Pondon: Die Rails Console.
    <command>rails console</command></para>

    <para>Mit der Rails Console haben Sie nicht nur die normalen irb
    Mechanismen, sondern auch direkt alle Klassen und Methoden aus Ihrer
    Rails-Applikation. Und können somit auf die Datenbank zugreifen. Diese
    werden automagisch per ActiveRecord als Objekte zur Verfügung
    gestellt.</para>

    <para>Die Rails-Console kann parallel zum Webserver oder anstatt des
    Webservers gestartet werden. Wir führen als erstes auf der Shell ein
    <command>rake db:reset</command> aus, damit wir eine frische und leere
    Datenbank zum Üben vorfinden. <screen>MacBook:movie-app sw$ <command>rake db:reset</command>
(in /Users/sw/Development/movie-app)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("movies", {:force=&gt;true})
   -&gt; 0.0155s
-- initialize_schema_migrations_table()
   -&gt; 0.0049s
-- assume_migrated_upto_version(20100404113234, "db/migrate")
   -&gt; 0.0026s
MacBook:movie-app sw$ </screen></para>

    <para>Danach starten wir die Console:<screen>MacBook:movie-app sw$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta2)
ruby-1.9.1-p378 &gt;</screen></para>
  </section>

  <section xml:id="workflow-in-rails">
    <title xml:id="mvc-workflow-in-rails.title">MVC-Workflow innerhalb
    Rails</title>

    <para>Jetzt können wir eine Tabelle anlegen und auf diese via HTTP und via
    der Console zugreifen. Jetzt schauen wir uns mal an, was bei einer
    HTTP-Anfrage passiert und welchen Weg diese Anfrage geht. Hier kommt die
    versprochene Fortführung von <xref linkend="routen" />.</para>

    <section xml:id="dvd-show-html">
      <title>Beispiel movies/1</title>

      <para>Nehmen wir an, ein User ruft die URL <uri
      xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
      auf.</para>

      <section>
        <title>Routing</title>

        <para>Kommt ein Aufruf per HTTP rein, so wird die URL durch eine
        Routing-Engine verarbeitet. Diese wird durch die Datei
        <filename>config/routes.rb</filename> konfiguriert. Schauen wir noch
        mal rein. Diesmal mit allen Kommentaren.<programlisting>MovieApp::Application.routes.draw do |map|
  resources :movies

  get "example/test"

  # The priority is based upon order of creation:
  # first created -&gt; highest priority.

  # Sample of regular route:
  #   match 'products/:id' =&gt; 'catalog#view'
  # Keep in mind you can assign values other than :controller and :action

  # Sample of named route:
  #   match 'products/:id/purchase' =&gt; 'catalog#purchase', :as =&gt; :purchase
  # This route can be invoked with purchase_url(:id =&gt; product.id)

  # Sample resource route (maps HTTP verbs to controller actions automatically):
  #   resources :products

  # Sample resource route with options:
  #   resources :products do
  #     member do
  #       get :short
  #       post :toggle
  #     end
  #
  #     collection do
  #       get :sold
  #     end
  #   end

  # Sample resource route with sub-resources:
  #   resources :products do
  #     resources :comments, :sales
  #     resource :seller
  #   end

  # Sample resource route with more complex sub-resources
  #   resources :products do
  #     resources :comments
  #     resources :sales do
  #       get :recent, :on =&gt; :collection
  #     end
  #   end

  # Sample resource route within a namespace:
  #   namespace :admin do
  #     # Directs /admin/products/* to Admin::ProductsController
  #     # (app/controllers/admin/products_controller.rb)
  #     resources :products
  #   end

  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; "welcome#index"

  # See how all your routes lay out with "rake routes"

  # This is a legacy wild controller route that's not recommended for RESTful applications.
  # Note: This route will make all actions in every controller accessible via GET requests.
  # match ':controller(/:action(/:id(.:format)))'
end</programlisting></para>

        <para>Die Priorität einer Route wird anhand ihrer Position in dieser
        Datei bestimmt. Es können also mehrere Regeln auf die gleiche Route
        matchen. Die am weitesten oben stehende gewinnt.</para>

        <para>In der Zeile 2 steht eine für unsere Applikation bis jetzt die
        wichtige Konfiguration:<programlisting>resources :movies</programlisting></para>

        <para>Sie sorgt dafür das automagisch die Anfragen mit der RESTful
        Logik an die Methoden <methodname>index</methodname>,
        <methodname>show</methodname>, <methodname>new</methodname>,
        <methodname>edit</methodname>, <methodname>create</methodname>,
        <methodname>update</methodname> und <methodname>destroy</methodname>
        der Klasse <classname>MoviesController</classname> weitergeleitet
        werden.</para>

        <para>Diese Routen können wir uns mit <command>rake routes</command>
        anzeigen lassen.<screen>MacBook:movie-app sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
example_test GET    /example/test              {:controller=&gt;"example", :action=&gt;"test"}
MacBook:movie-app sw$</screen></para>

        <para>Diese Klasse wird in der Datei
        <filename>app/controllers/movies_controller.rb</filename> definiert.
        Schauen wir mal rein, was da bei der Methode
        <methodname>show</methodname> steht:<programlisting>  # GET /movies/1
  # GET /movies/1.xml
  def show
    @movie = Movie.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml =&gt; @movie }
    end
  end
</programlisting></para>

        <para>Direkt am Anfang wird die Instance-Variable
        <varname>@movie</varname> mit dem Ergebnis der Suche nach einer ID
        gefüllt (<code>Movie.find(params[:id])</code>). Die :id finden Sie
        oben in den Routen. Der Hash params wird automatisch von Rails gefühlt
        und steht dem Programmierer im Controller zur Verfügung.</para>

        <para>hmmmm... was hat es mit diesem Hash <varname>params[]</varname>
        auf sich? Machen wir mal testweise die Abfrage <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Ich gehe mal davon aus, das Sie mittlerweile den dazu passenden
        Browser-Screenshot vor Ihrem virtuellen Auge haben. Falls nicht =&gt;
        <xref linkend="screenshot_show" /></para>

        <para>Und gleichzeitig schauen wir uns die Log-Ausgabe des Webservers
        an:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-04-05 10:49:59
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (9.6ms)
Completed 200 OK in 30ms (Views: 12.5ms | ActiveRecord: 0.7ms)
</screen></para>

        <para>Da wird in der zweiten Zeile auf den Controller
        <classname>MoviesController</classname> und dort auf die Methode
        <methodname>show</methodname> verwiesen
        (<code>MoviesController#show</code>). Gleichzeitig wird ein Hash mit
        dem Namen <varname>params[]</varname> generiert und dort
        <varname>params[:id]</varname> auf 1 gesetzt.</para>

        <para>Danach wird überprüft, ob es sich um eine
        <filename>.html</filename> oder <filename>.xml</filename> Anfrage
        gehandelt hat. Wurde vom Browser nur <filename>1</filename> und nicht
        <filename>1.html</filename> abgefragt, setzt Rails den Default auf
        <filename>.html</filename>. In der Log-Ausgabe finden Sie den Eintrag
        "<code>as HTML</code>".</para>

        <para>Was passiert als nächstes? Denken wir noch mal über das
        MCV-Model nach. Wir haben schon das Model
        (<methodname>movies</methodname>) und wir haben den Controller
        (<classname>MoviesController</classname>). Was noch fehlt ist der View
        - also die Darstellung der Webseite. Die Views für unser Model finden
        sich alle im Unterverzeichnis
        <filename>app/view/movies</filename><screen>MacBook:movie-app sw$ <command>ls app/views/movies</command>
_form.html.erb edit.html.erb index.html.erb new.html.erb show.html.erb
MacBook:movie-app</screen></para>

        <para>Schauen wir uns mal die Datei <filename>show.html.erb</filename>
        an:<programlisting>&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%= @movie.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Production year:&lt;/b&gt;
  &lt;%= @movie.production_year %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Duration:&lt;/b&gt;
  &lt;%= @movie.duration %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Plot:&lt;/b&gt;
  &lt;%= @movie.plot %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Rating:&lt;/b&gt;
  &lt;%= @movie.rating %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_movie_path(@movie) %&gt; |
&lt;%= link_to 'Back', movies_path %&gt;
</programlisting></para>

        <para>Ist Ihnen aufgefallen, das bei dieser erb-Datei ja wichtige
        HTML-Elemente fehlen? Die sind in der Datei
        <filename>app/views/layouts/movies.html.erb</filename><programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Movies: &lt;%= controller.action_name %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag 'scaffold' %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class="alert"&gt;&lt;%= alert %&gt;&lt;/p&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

        <para>Das ist der Rahmen für alle Views des Models
        <varname>movies</varname>. Da es oft keinen Sinn macht für jedes Model
        ein eigenes Grundlayout zu generieren, kann man diese Datei auch
        löschen und stattdessen eine Datei
        <filename>app/views/layouts/application.html.erb</filename> mit dem
        Grundlayout erstellen. Die gilt dann für die gesamte
        Rails-Application. Die Zeile <code>&lt;%= yield %&gt;</code> wird
        dabei immer von der aufzurufenden View-Datei ersetzt.</para>
      </section>
    </section>

    <section xml:id="dvd-index-html">
      <title>Beispiel /movies (Index aller Datensätze)</title>

      <para>Da der Grundweg im letzten Segment erklärt wurde, gehe ich jetzt
      auf die schnelle durch die Anfrage <uri
      xlink:href="http://localhost:3000/movies">http://0.0.0.0:3000/movies</uri>.
      Hier noch mal den Screenshot dazu:<screenshot>
          <info>
            <title>Index-Ansicht aller Filme</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/movies_index.jpg" format="JPG"></imagedata>
            </imageobject>
          </mediaobject>
        </screenshot></para>

      <para>Im Log erscheint:<screen>Started GET "/movies" for 127.0.0.1 at 2010-04-05 11:02:42
  Processing by MoviesController#index as HTML
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.6ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (28.2ms)
Completed 200 OK in 47ms (Views: 31.2ms | ActiveRecord: 1.1ms)
</screen></para>

      <para>Es geht also zu der Methode <methodname>index</methodname> der
      Klasse <classname>MoviesController</classname>
      (<code>MoviesController#index</code>). Diese Klasse wird in der Datei
      <filename>app/controllers/movies_controller.rb</filename> definiert.
      Schauen wir mal rein, was da bei der Methode
      <methodname>index</methodname> steht:<programlisting>  # GET /movies
  # GET /movies.xml
  def index
    @movies = Movie.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @movies }
    end
  end
</programlisting></para>

      <para>In der Instance-Variable <varname>@movies</varname> wird diesmal
      ein Array aus allen Datensätze die mit <code>Movie.all</code> angezeigt
      werden gespeichert. Da es sich um eine html-Anfrage handelt wird als
      nächstes der View <filename>app/views/movies/index.html.erb</filename>
      gerendert. Ein Blick in diese erb-Datei:<programlisting>&lt;h1&gt;Listing movies&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Production year&lt;/th&gt;
    &lt;th&gt;Duration&lt;/th&gt;
    &lt;th&gt;Plot&lt;/th&gt;
    &lt;th&gt;Rating&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @movies.each do |movie| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= movie.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.production_year %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.duration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.plot %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.rating %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', movie %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_movie_path(movie) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', movie, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Movie', new_movie_path %&gt;
</programlisting></para>

      <para>In der Zeile "<code>&lt;% @movies.each do |movie| %&gt;</code>"
      wird mit der Iternator-Methode <methodname>each</methodname> das Array
      <varname>@movies</varname> Eintrag für Eintrag angezeigt. Jeder Eintrag
      wird dann für den Block in der lokalen Variable <varname>movie</varname>
      gespeichert und die wird dann im Block der mit "<code>&lt;% end
      %&gt;</code>" endet dazu benutzt den Inhalt des Eintrages
      darzustellen.</para>
    </section>
  </section>
</chapter>
