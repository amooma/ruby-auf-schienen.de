<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_named_scope"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_named_scope.title">Named Scopes</title>

  <para>Manchmal ist es beim Programmieren von Rails Applikationen
  übersichtlicher und einfacher, häufig auftauchende Suchen als eigene Methode
  zu definieren. Diese heißen in Rails-Sprech NamedScope.</para>

  <section xml:id="named_scopes_vorbereitung">
    <title xml:id="named_scopes_vorbereitung.title">Vorbereitung</title>

    <para>Falls Sie noch die Rails-Applikation von <xref
    linkend="activerecord_has_many" /> greifbereit haben, können Sie diese
    benutzen. Ansonsten bauen wir sie kurz neu auf:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new phonebook</command>
      create  
      [...]
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd phonebook</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
[...]
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Jetzt legen wir die Personen Datenbank an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model person firstname:string lastname:string</command>
      invoke  active_record
      [...]
      create      test/fixtures/people.yml
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>

    <para>Und zum Schluss legen wir noch die Datenbank für die Telefonnummern
    an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model phonenumber person_id:integer name:string number:string</command>
      invoke  active_record
      [...]
      create      test/fixtures/phonenumbers.yml
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>

    <para>Danach ein <command>rake db:migrate</command> ausführen, damit die
    Datenbanken auch angelegt werden:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0013s
[...]
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>

    <para>Die 1:n Verknüpfung in der <filename>app/models/person.rb</filename>
    eintragen:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
end</programlisting></para>

    <para>Füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit
    folgendem Inhalt:<programlisting>Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
[...]
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>
  </section>

  <section xml:id="einfache_named_scopes">
    <title xml:id="einfache_named_scopes.title">Einfache NamedScopes</title>

    <para>Mit der folgenden Abfrage können wir uns alle Personen mit einer
    eingetragenen Handynummer ausgeben lassen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'}).uniq</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Legen wir für diese Anfrage doch mal einen NamedScope in der
    <filename>app/models/person.rb</filename> an:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
  
<emphasis>  scope :has_mobile_phone, includes(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})
</emphasis>end</programlisting></para>

    <para>Jetzt können wir aus der Console mit der Methode
    <methodname>has_mobile_phone</methodname> auf diese Abfrage
    zugreifen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.has_mobile_phone</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
</screen></para>

    <para>Schauen wir uns noch kurz mit der Methode to_sql den erzeugten
    SQL-Code an:<screen>ruby-1.9.2-p0 &gt; <command>Person.has_mobile_phone.to_sql</command>
 =&gt; "SELECT     \"people\".* FROM       \"people\"  INNER JOIN \"phonenumbers\" ON \"phonenumbers\".\"person_id\" = \"people\".\"id\" WHERE     (\"phonenumbers\".\"name\" = 'Mobile')" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>
  </section>

  <section>
    <title>Parameter übergeben</title>

    <para>Wenn Sie einen NamedScope brauchen, der auch Parameter verarbeiten
    kann, so ist das auch kein Problem. Das folgende Beispiel gibt
    Phonenumbers nach Ihren Vorwahlbereichen aus. Die
    <filename>app/models/phonenumber.rb</filename> sieht so
    aus:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  scope :area_code, lambda {|area_code| where('number LIKE ?', "#{area_code}-%")}
end</programlisting></para>

    <para>Hier ein zwei Beispiele in der Console:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Phonenumber.area_code('030')</command>
 =&gt; [#&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.area_code('040')</command>
 =&gt; [#&lt;Phonenumber id: 7, person_id: 5, name: "Home", number: "040-8888222", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>
  </section>

  <section xml:id="namedscope_verkettung">
    <title xml:id="namedscope_verkettung.title">Verkettung von
    NamedScopes</title>

    <para>Sie können NamedScopes recht intiutiv mit einander verketten. Für
    das reine Beispiel legen wir noch einen NamedScope für alle Personen mit
    dem Nachnamen "Meier" in der <filename>app/models/person.rb</filename>
    an:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
  
  scope :has_mobile_phone, joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})
  scope :is_a_meier, where(:lastname =&gt; 'Meier')
end</programlisting></para>

    <para>Jetzt können wir uns alle Meiers anschauen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.is_a_meier</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.is_a_meier.count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Wenn wir jetzt alle Meiers mit dem Vornamen "Fritz" suchen, dann
    können wir noch ein where hinterherschieben:<screen>ruby-1.9.2-p0 &gt; <command>Person.is_a_meier.where(:firstname =&gt; 'Fritz')</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.is_a_meier.where(:firstname =&gt; 'Fritz').count</command>
 =&gt; 1 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Natürlich können wir in der gleichen Art und Weise auch zwei
    NamedScopes hinter einanderschalten und damit alle Meiers mit einer
    eingetragenen Handynummer rausfiltern:<screen>ruby-1.9.2-p0 &gt; <command>Person.is_a_meier.has_mobile_phone</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.is_a_meier.has_mobile_phone.count</command>
 =&gt; 1 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>

    <section xml:id="named_scope_moegliche_fehler">
      <title xml:id="named_scope_moegliche_fehler.title">Mögliche
      Fehler</title>

      <para>Beim Verketten von NameScopes muss man immer bedenken, welche
      Abfrage dahinter steckt und wie diese mit der Verkettung reagiert.
      Tragen wir in der <filename>app/models/person.rb</filename> noch eine
      NamedScope <methodname>berliner</methodname> ein. Damit filtern wir alle
      Personen mit einer privaten Telefonnummer mit Berliner (030)
      Vorwahl:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
  
  scope :has_mobile_phone, joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})
  scope :is_a_meier, where(:lastname =&gt; 'Meier')
  
<emphasis>  scope :berliner, joins(:phonenumbers).where('phonenumbers.name = ? AND phonenumbers.number LIKE ?', 'Home', '030-%')
</emphasis>end</programlisting></para>

      <para>Das funktioniert auch gut:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.berliner</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.berliner.count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Aber, wenn wir diesen NamedScope mit dem
      <methodname>has_mobile_phone</methodname> NamedScope verbinden, dann
      passiert etwas merkwürdiges:<screen>ruby-1.9.2-p0 &gt; <command>Person.berliner.has_mobile_phone</command>
 =&gt; [] 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Obwohl Herr Fritz Meier sowohl als Ergebnis bei
      <methodname>berliner</methodname> wie auch bei
      <methodname>has_mobile_phone</methodname> rauskommt:<screen>ruby-1.9.2-p0 &gt; <command>Person.berliner.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.has_mobile_phone.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt; 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Woran kann das liegen und wie bekommen wir raus woran es liegt?
      Schauen wir uns mal die SQL-Abfragen an:<screen>ruby-1.9.2-p0 &gt; <command>Person.has_mobile_phone.to_sql</command>
 =&gt; "SELECT     \"people\".* FROM       \"people\"  INNER JOIN \"phonenumbers\" ON \"phonenumbers\".\"person_id\" = \"people\".\"id\" WHERE     (\"phonenumbers\".\"name\" = 'Mobile')" 
ruby-1.9.2-p0 &gt; <command>Person.berliner.to_sql</command>
 =&gt; "SELECT     \"people\".* FROM       \"people\"  INNER JOIN \"phonenumbers\" ON \"phonenumbers\".\"person_id\" = \"people\".\"id\" WHERE     (phonenumbers.name = 'Home' AND phonenumbers.number LIKE '030-%')" 
ruby-1.9.2-p0 &gt; <command>Person.berliner.has_mobile_phone.to_sql</command>
 =&gt; "SELECT     \"people\".* FROM       \"people\"  INNER JOIN \"phonenumbers\" ON \"phonenumbers\".\"person_id\" = \"people\".\"id\" WHERE     (phonenumbers.name = 'Home' AND phonenumbers.number LIKE '030-%') AND (\"phonenumbers\".\"name\" = 'Mobile')" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>

      <para>ActiveRecord benutzt auch hier Lazy Loading (siehe <xref
      linkend="lazy_loading" />). Als Ergebnis der Verknüpfung kommt
      entsprechend eine SQL-Abfrage raus, die niemals einen Treffer haben
      kann. Es wird zeitgleich ein <classname>Phonenumber</classname>
      Datensatz gesucht, der als <varname>name</varname> "Home" und "Mobile"
      hat. Das gibt es natürlich nicht.</para>

      <warning>
        <para>Beim Verknüpfen von NamedScopes immer an Lazy Loading (siehe
        <xref linkend="lazy_loading" />) denken!</para>
      </warning>
    </section>
  </section>

  <section xml:id="named_scope_create">
    <title xml:id="named_scope_create.title">Neue Datensätze mit NamedScopes
    anlegen</title>

    <para>Nehmen wir folgende
    <filename>app/models/person.rb</filename>:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
  
  scope :has_mobile_phone, joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})
  <emphasis>scope :is_a_meier, where(:lastname =&gt; 'Meier')</emphasis>
end</programlisting></para>

    <para>Mit diesem NamedScope können wir dann nicht nur alle Personen mit
    dem Nachnamen "Meier" raussuchen, sondern auch einen neuen Datensatz
    anlegen, der im Feld <varname>lastname</varname> den Wert "Meier"
    enthält:<screen>ruby-1.9.2-p0 &gt; <command>Person.is_a_meier</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-12 12:20:22", updated_at: "2010-10-12 12:20:22"&gt;] 
ruby-1.9.2-p0 &gt; <command>neuer_meier = Person.is_a_meier.build</command>
 =&gt; #&lt;Person id: nil, firstname: nil, lastname: "Meier", created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$</screen></para>

    <para>Das funktioniert bei der Methode <methodname>build</methodname>
    (siehe <xref linkend="activerecord_hinzufuegen_build" />) und
    <methodname>create</methodname> (siehe <xref
    linkend="activerecord_hinzufuegen_create" />).</para>
  </section>
</section>
