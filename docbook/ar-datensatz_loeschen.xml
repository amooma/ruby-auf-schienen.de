<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="datensatz-loeschen"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Einen Datensatz löschen</title>

  <para>Es gibt die Methoden <methodname>destroy</methodname> und
  <methodname>delete</methodname>, um Datensätze zu löschen. Diese Wortwahl
  empfinde ich als reichlich schwierig. Ich muss oft selber nachschlagen, um
  sicher zu sein, welche Methode was macht.</para>

  <section xml:id="activerecord_destroy">
    <title xml:id="activerecord_destroy.title">destroy</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>destroy()</tertiary>
    </indexterm>

    <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
    löschen und dabei werden auch vorhandene Abhängigkeiten beachtet (siehe z.
    B. <code>:dependent =&gt; :destroy</code> in <xref
    linkend="activerecord_1n_optionen" />). Vereinfacht kann man sagen: Lieber
    <methodname>destroy</methodname> nehmen; das ist sicherer, weil das
    Rails-System dann mehr mitdenkt.<important>
        <para>Die Instanz wird nach dem Löschen des Datenbankfeldes
        <foreignphrase xml:lang="en">frozen</foreignphrase> (eingefroren). Sie
        ist also noch da, kann aber nicht verändert werden.</para>
      </important></para>

    <para>Für die Beispiele brauchen wir wieder definierte Daten. Deshalb
    füllen Sie die Datei <filename>db/seeds.rb</filename> mit folgendem
    Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

    <para>Die Datei <filename>app/models/person.rb</filename> ändern Sie
    danach wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
end</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Als Erstes löschen wir Herrn Fritz Meier inklusive all seiner
    Telefonnummern:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz_meier = Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_meier.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' )</command>
  =&gt; [] 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Das war einfach. Was ist aber mit der Variablen
    <varname>fritz_meier</varname>? Die existiert noch mit den Daten im
    sogenannten <foreignphrase xml:lang="en">frozen state</foreignphrase>
    (eingefrorener Zustand). Zum Überprüfen gibt es die Methode <indexterm>
        <primary>frozen?()</primary>
      </indexterm><methodname>frozen?</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>fritz_meier</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_meier.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>fritz_meier.frozen?</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Der Datensatz ist also in der Datenbank gelöscht, aber das Objekt
    mit allen Daten ist noch im laufenden Ruby-Programm vorhanden. Könnten wir
    damit den gesamten Datensatz wiederbeleben? Ja, allerdings ist das dann
    ein neuer Datensatz (er hat also nicht mehr die ID 1):<screen>ruby-1.9.2-p0 &gt; <command>Person.create( fritz_meier.attributes )</command>
 =&gt; #&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' )</command>
 =&gt; [#&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Jetzt fehlen aber noch die Telefonnummern. Die können Sie jedoch
    separat abspeichern (da sie ja noch im <foreignphrase
    xml:lang="en">frozen</foreignphrase>-Objekt vorhanden sind).</para>
  </section>

  <section xml:id="activerecord_delete">
    <title xml:id="activerecord_delete.title">delete</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>delete()</tertiary>
    </indexterm>

    <para>Mit <methodname>delete</methodname> können Sie einen Datensatz
    direkt in der Datenbank löschen. Dabei werden keine Abhängigkeiten zu
    anderen Datensätzen im <foreignphrase xml:lang="en">Model</foreignphrase>
    beachtet. Die Methode <methodname>delete</methodname> löscht also nur die
    eine Zeile in der Datenbank und sonst nichts.</para>

    <para>Löschen wir mal den Datensatz von Frau Meier:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.delete</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where( :person_id =&gt; 2 )</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Es wird zwar der Datensatz von Frau Meier gelöscht, aber die
    Telefonnummern in der zu <classname>Phonenumber</classname> gehörenden
    Datenbank-Tabelle bleiben als Karteileichen im System.</para>

    <para>Wie bei <methodname>destroy</methodname>, geht auch bei
    <methodname>delete</methodname> ein Objekt nach dem
    <methodname>delete</methodname> in den <foreignphrase
    xml:lang="en">frozen</foreignphrase>-Status (siehe <xref
    linkend="activerecord_destroy" />). Der Datensatz ist also in der
    Datenbank bereits gelöscht, aber das Objekt an sich existiert noch.</para>
  </section>
</section>
