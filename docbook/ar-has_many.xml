<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_has_many"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_has_many.title">has_many –
  1:n-Verknüpfung</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Relationen</secondary>

    <tertiary>has_many()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Relationen</secondary>

    <tertiary>belongs_to()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Assoziationen</secondary>

    <see>ActiveRecord, Relationen</see>
  </indexterm>

  <para>Um <methodname>has_many</methodname> zu erklären erstellen wir uns ein
  Mini-Telefonbuch. In diesem Telefonbuch gibt es ein <foreignphrase
  xml:lang="en">Model</foreignphrase> mit Personen und ein <foreignphrase
  xml:lang="en">Model</foreignphrase> mit Telefonnummern. Da jede Person
  mehrere Telefonnummern haben kann (z.B. Handy, Arbeit und Zuhause) benötigen
  wir zum Abbilden eine 1:n-Verknüpfung (<foreignphrase
  xml:lang="en">one-to-many association</foreignphrase>). Mal schauen wie
  einfach das ganze mit ActiveRecord ist.</para>

  <note>
    <para>Verknüpfungen nennt man übrigens auch Beziehung, Relationen
    (<foreignphrase xml:lang="en">Relations</foreignphrase> / <foreignphrase
    xml:lang="en">Relationships</foreignphrase>) oder Assoziationen
    (<foreignphrase xml:lang="en">Associations</foreignphrase>).</para>
  </note>

  <para>Erstellen wir als erstes die Rails-Applikation:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new phonebook</command>
      create  
      create  README
      <replaceable>[...]</replaceable>
      create  vendor/plugins/.gitkeep

stefan@swmbp 0 1.9.2-p0 ~$ <command>cd phonebook</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
<replaceable>[...]</replaceable>
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <para>Jetzt legen wir die Personen-Datenbank-Tabelle an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model person firstname:string lastname:string</command>
      invoke  active_record
      create    db/migrate/20101008205425_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/unit/person_test.rb
      create      test/fixtures/people.yml

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <important>
    <para>Haben Sie gesehen wie Rails automatisch den Plural von
    <literal>person</literal> (nämlich <literal>people</literal>) genommen
    hat?</para>
  </important>

  <para>Und zum Schluss legen wir noch die Datenbank-Tabelle für die
  Telefonnummern an. In dieser benötigen wir ein Zuordnungsfeld zur
  Personen-Tabelle. Dieser Fremdschlüssel (<foreignphrase
  xml:lang="en">Foreign key</foreignphrase>) wird per Default immer als Name
  des referenzierten Objekts (hier: <literal>person</literal>) mit angehängtem
  <literal>_id</literal> gesetzt:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model phonenumber person_id:integer name:string number:string</command>
      invoke  active_record
      create    db/migrate/20101008205906_create_phonenumbers.rb
      create    app/models/phonenumber.rb
      invoke    test_unit
      create      test/unit/phonenumber_test.rb
      create      test/fixtures/phonenumbers.yml

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <para>Danach ein <command>rake db:migrate</command> ausführen, damit die
  Datenbank-Tabellen auch angelegt werden:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0013s
==  CreatePeople: migrated (0.0014s) ==========================================

==  CreatePhonenumbers: migrating =============================================
-- create_table(:phonenumbers)
   -&gt; 0.0018s
==  CreatePhonenumbers: migrated (0.0020s) ====================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <para>Schauen wir uns das mal auf der <foreignphrase
  xml:lang="en">Console</foreignphrase> an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; <command>Phonenumber</command>
 =&gt; Phonenumber(id: integer, person_id: integer, name: string, number: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

  <para>Die zwei Datenbank-Tabellen sind eingerichtet und können mit
  ActiveRecord benutzt werden. Allerdings weiß ActiveRecord noch nichts von
  der 1:n-Beziehung der beiden. Das ist aber recht einfach in zwei Schritten
  realisierbar:<itemizedlist>
      <listitem>
        <para>Wir fügen in der <foreignphrase
        xml:lang="en">Model</foreignphrase>-Datei
        <filename>app/models/person.rb</filename> die Option
        <methodname>has_many</methodname> ein:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
end</programlisting></para>
      </listitem>

      <listitem>
        <para>Und wir fügen in der <foreignphrase
        xml:lang="en">Model</foreignphrase>-Datei
        <filename>app/models/phonenumber.rb</filename> die Option
        <methodname>belongs_to</methodname> ein:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
end</programlisting></para>
      </listitem>
    </itemizedlist></para>

  <para>Diese zwei einfachen Definitionen sorgen für eine ganze Menge
  Rails-Magie.</para>

  <section xml:id="activerecord_1n_erstellen">
    <title xml:id="activerecord_1n_erstellen.title">Datensätze
    erstellen</title>

    <para>Wir wollen in diesem Beispiel für Fritz Meier seine Handy-Nummer
    (0171-12345678), seine Büro-Nummer (030-7777777) und seine
    Privat-Festnetznummer (030-8888888) abspeichern.</para>

    <section xml:id="activerecord_hinzufuegen_manuell">
      <title xml:id="activerecord_hinzufuegen_manuell.title">Manuell</title>

      <para>Wir löschen die Datenbank und erstellen zuerst ein Objekt mit den
      Person-Daten. Dann merken wir uns die ID für diesen Datensatz und
      erstellen danach die drei Telefonnummern-Datensätze mit dieser ID im
      Feld <literal>person_id</literal>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0039s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0033s
-- initialize_schema_migrations_table()
   -&gt; 0.0060s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0043s

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' )</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy  = Phonenumber.create( :person_id =&gt; 1, :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_office = Phonenumber.create( :person_id =&gt; 1, :name =&gt; 'Office', :number =&gt; '030-7777777' )</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_home   = Phonenumber.create( :person_id =&gt; 1, :name =&gt; 'Home',   :number =&gt; '030-8888888' )</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>id()</tertiary>
      </indexterm>

      <para>Die <literal>person_id</literal> von Hand einzutragen ist
      natürlich sehr fehleranfällig. Das gleiche Ergebnis könnten wir auch
      einen Tick schöner mit <code>fritz.id</code> (also mit der Methode
      <methodname>id</methodname>) realisieren:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy  = Phonenumber.create( :person_id =&gt; fritz.id, :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_office = Phonenumber.create( :person_id =&gt; fritz.id, :name =&gt; 'Office', :number =&gt; '030-7777777' )</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_home   = Phonenumber.create( :person_id =&gt; fritz.id, :name =&gt; 'Home',   :number =&gt; '030-8888888' )</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Immer noch nicht super praktisch, oder? Nur Geduld! :-)</para>
    </section>

    <section xml:id="activerecord_hinzufuegen_create">
      <title xml:id="activerecord_hinzufuegen_create.title">create</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>create()</tertiary>
      </indexterm>

      <para>Jetzt versuchen wir das gleiche wie in <xref
      linkend="activerecord_hinzufuegen_manuell" />, aber benutzen diesmal ein
      wenige ActiveRecord-Magie. Wir können mit der Methode
      <methodname>create</methodname> von <literal>phonenumbers</literal>
      (<literal>phonenumbers</literal> im Plural, weil ja 1 zu <foreignphrase
      xml:lang="en">many</foreignphrase> = viele/mehrere) zu jedem
      <classname>Person</classname>-Objekt neue Telefonnummern hinzufügen.
      Diese werden automatisch korrekt mit der <literal>person_id</literal>
      bestückt:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:54:12", updated_at: "2010-10-09 10:54:12"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy  = fritz.phonenumbers.create( :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:54:58", updated_at: "2010-10-09 10:54:58"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_office = fritz.phonenumbers.create( :name =&gt; 'Office', :number =&gt; '030-7777777' )</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:56:35", updated_at: "2010-10-09 10:56:35"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_home   = fritz.phonenumbers.create( :name =&gt; 'Home',   :number =&gt; '030-8888888' )</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:57:21", updated_at: "2010-10-09 10:57:21"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:54:12", updated_at: "2010-10-09 10:54:12"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:54:58", updated_at: "2010-10-09 10:54:58"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:56:35", updated_at: "2010-10-09 10:56:35"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:57:21", updated_at: "2010-10-09 10:57:21"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Es geht sogar noch kürzer, da <methodname>create</methodname>
      statt nur einem <foreignphrase xml:lang="en">Hash</foreignphrase>
      alternativ auch ein <foreignphrase xml:lang="en">Array</foreignphrase>
      von <foreignphrase xml:lang="en">Hashes</foreignphrase> aktzeptiert. Wir
      können also alle Telefonnummer mit einer Zeile eintragen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' )</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:04:39", updated_at: "2010-10-09 11:04:39"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.create([ { :name =&gt; 'Mobile', :number =&gt; '0171-12345678' }, { :name =&gt; 'Office', :number =&gt; '030-7777777' }, { :name =&gt; 'Home', :number =&gt; '030-8888888' } ])</command><remark>FIXME: Die Zeile besser mit Zeilenumbrüchen schreiben.</remark>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:04:39", updated_at: "2010-10-09 11:04:39"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Ich ahne was Sie sich jetzt fragen: <quote>Geht es noch
      kürzer?</quote> Klar: Wir können ja auch alles direkt in einer Zeile
      schreiben:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' ).phonenumbers.create([ { :name =&gt; 'Mobile', :number =&gt; '0171-12345678' }, { :name =&gt; 'Office', :number =&gt; '030-7777777' }, { :name =&gt; 'Home', :number =&gt; '030-8888888' } ])</command><remark>FIXME: Die Zeile besser mit Zeilenumbrüchen schreiben.</remark>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Allerdings ist das in der Praxis nur dann sinnvoll wenn die
      Text-Zeile dadurch nicht sehr lang und unübersichtlich wird.</para>
    </section>

    <section xml:id="activerecord_hinzufuegen_build">
      <title xml:id="activerecord_hinzufuegen_build.title">build</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>build()</tertiary>
      </indexterm>

      <para>Die Methode <methodname>build</methodname> ähnelt
      <methodname>create</methodname>. Allerdings wird der Datensatz nicht
      abgespeichert. Dies erfolgt erst nach einem
      <methodname>save</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' )</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 14:40:38", updated_at: "2010-10-09 14:40:38"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy = fritz.phonenumbers.build( :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: nil, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: nil, updated_at: nil&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy.new_record?</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>fritz_handy.save</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>fritz_handy.new_record?</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <warning>
        <para>Bei der Benutzung von <methodname>create</methodname> und
        <methodname>build</methodname> müssen natürlich logische
        Abhängigkeiten beachtet werden. An sonsten gibt es einen Fehler. So
        kann man nicht zwei <methodname>build</methodname> Methoden mit
        einander verketten. Beispiel:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.build( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' ).phonenumbers.build([ { :name =&gt; 'Mobile', :number =&gt; '0171-12345678' }, { :name =&gt; 'Office', :number =&gt; '030-7777777' }, { :name =&gt; 'Home', :number =&gt; '030-8888888' } ])</command>
 NoMethodError: undefined method `build' for #&lt;Class:0x00000102c06018&gt;
 from <replaceable>[...]</replaceable>/gems/activerecord-3.0.0/lib/active_record/base.rb:1016:in `method_missing'
 from (irb):2
 from <replaceable>[...]</replaceable>/gems/railties-3.0.0/lib/rails/commands/console.rb:44:in `start'
 from <replaceable>[...]</replaceable>/gems/railties-3.0.0/lib/rails/commands/console.rb:8:in `start'
 from <replaceable>[...]</replaceable>/gems/railties-3.0.0/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
      </warning>
    </section>
  </section>

  <section xml:id="activerecord_1n_zugreifen">
    <title xml:id="activerecord_1n_zugreifen.title">Auf Datensätze
    zugreifen</title>

    <para>Dafür brauchen wir Beispieldaten. Deshalb füllen Sie bitte die Datei
    <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' ).phonenumbers.create([
  { :name =&gt; 'Mobile' , :number =&gt; '0171-12345678' }, 
  { :name =&gt; 'Office' , :number =&gt; '030-7777777'   }, 
  { :name =&gt; 'Home'   , :number =&gt; '030-8888888'   }  ])

Person.create( :firstname =&gt; 'Ute', :lastname =&gt; 'Meier' ).phonenumbers.create([
  { :name =&gt; 'Home'   , :number =&gt; '030-8888888'   }  ])

Person.create( :firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus' ).phonenumbers.create([
  { :name =&gt; 'Mobile' , :number =&gt; '0171-1188811'  }  ])

Person.create( :lastname =&gt; 'Udelhoven')

Person.create( :firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf' ).phonenumbers.create([
  { :name =&gt; 'Mobile' , :number =&gt; '0172-22225678' }, 
  { :name =&gt; 'Home'   , :number =&gt; '040-8888222'   }  ])
</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Das praktische an der 1:n-Zuordnung in ActiveRecord ist der
    super-einfache Zugang zu den n-Instanzen. Schauen wir uns das mal für den
    ersten Datensatz an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers.class</command>
 =&gt; Array 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Ist das cool?! Daran erfreue ich mich jedesmal wieder aufs Neue. Man
    kann einfach durch die Pluralform des n-<foreignphrase
    xml:lang="en">Model</foreignphrase> auf die Datensätze zugreifen. Die
    Ergebnismenge wird als <foreignphrase xml:lang="en">Array</foreignphrase>
    zurückgegeben. Ob es auch andersrum geht? Schauen wir uns mal die erste
    Telefonnummer an:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.person</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.person.class</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Bingo! Auch der Zugriff zur zugeordneten
    <classname>Person</classname>-Klasse ganz einfach. Und da es sich nur um
    einen einzigen Datensatz handelt (<methodname>belongs_to</methodname>),
    wird hier die Singularform genommen.</para>

    <para>Und wenn ein Datensatz keine Telefonnummern hat? Schauen wir doch
    mal bei Herrn Udelhoven rein:<screen>ruby-1.9.2-p0 &gt; <command>udelhoven = Person.where( :lastname =&gt; 'Udelhoven' ).first</command>
 =&gt; #&lt;Person id: 4, firstname: nil, lastname: "Udelhoven", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>udelhoven.phonenumbers</command>
 =&gt; [] 

ruby-1.9.2-p0 &gt; <command>udelhoven.phonenumbers.count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Da zu diesem Datensatz keine Telefonnummern zugeordnet sind, gibt
    <methodname>phonenumbers</methodname> ein leeres Array zurück.</para>

    <para>Der Vollständigkeit halber müssten wir jetzt auch schauen was
    passiert, wenn zu einer Telefonnummer keine Person zugeordnet ist:<screen>ruby-1.9.2-p0 &gt; <command>karteileiche = Phonenumber.create( :name =&gt; 'Auskunft', :number =&gt; '11833' )</command>
 =&gt; #&lt;Phonenumber id: 8, person_id: nil, name: "Auskunft", number: "11833", created_at: "2010-10-09 20:29:38", updated_at: "2010-10-09 20:29:38"&gt; 

ruby-1.9.2-p0 &gt; <command>karteileiche.person</command>
 =&gt; nil 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Dieser neue Datensatz hatte keinen Eintrag (also
    <literal>nil</literal>) in der Spalte <literal>person_id</literal> und
    konnte deshalb keiner Person zugeordnet werden. Entsprechend ist das
    Ergebnis von <methodname>person</methodname> auch
    <literal>nil</literal>.</para>
  </section>

  <section>
    <title>Datensätze suchen</title>

    <para>Zum Suchen brauchen wir wieder definierte Beispieldaten. Deshalb
    füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit folgendem
    Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Legen wir mal los. Als erstes schauen wir uns mal an, wie viele
    Personen in der Datenbank sind:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.count</command>
 =&gt; 5 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Und wie viele Telefonnummern?<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.count</command>
 =&gt; 7 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Die normalen Suchen kennen Sie bereits aus <xref
    linkend="queries" />. So können Sie mit <methodname>where</methodname>
    z.B. alle <quote>Meier</quote>-Einträge suchen:<screen>ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier' )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 14:59:14", updated_at: "2010-10-09 14:59:14"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 14:59:14", updated_at: "2010-10-09 14:59:14"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <warning>
      <para>Bitte beachten Sie, dass <methodname>where</methodname> als
      Ergebnis immer ein Array zurpckgibt. Wenn Sie den ersten Datensatz aus
      der Ergebnisliste benötigen, müssen Sie noch ein
      <methodname>first</methodname> anfügen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier' ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier' ).first.class</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
    </warning>

    <para>Aber in dem 1:n-Kontext ist es natürlich interessanter,
    verschachtelt zu suchen. Dazu gibt es verschiedene Möglichkeiten.</para>

    <section xml:id="activerecord_1n_joins">
      <title xml:id="activerecord_1n_joins.title">joins</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>joins()</tertiary>
      </indexterm>

      <para>Wie können wir alle Personen rausfinden, die in unserer Datenbank
      eine Handynummer abgespeichert haben? Das geht mit einem <foreignphrase
      xml:lang="en">Join</foreignphrase>.<footnote>
          <para>Falls Sie sich für den theoretischen Hintergrund zu
          <foreignphrase xml:lang="en">Joins</foreignphrase> interessieren
          finden Sie weitere Informationen unter: <uri
          xlink:href="http://de.wikipedia.org/wiki/SQL#Abfrage_mit_verkn.C3.BCpften_Tabellen">http://de.wikipedia.org/wiki/SQL#Abfrage_mit_verkn.C3.BCpften_Tabellen</uri>,
          <uri
          xlink:href="http://en.wikipedia.org/wiki/Join_%28SQL%29">http://en.wikipedia.org/wiki/Join_(SQL)</uri>,
          <uri
          xlink:href="http://de.wikipedia.org/wiki/Relationale_Algebra#Join">http://de.wikipedia.org/wiki/Relationale_Algebra#Join</uri></para>
        </footnote> Damit können wir die beiden <foreignphrase
      xml:lang="en">Models</foreignphrase> auch in der Suche
      verknüpfen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Drei Personen haben eine Handynummer. Und das konnten wir mit
      einer Zeile Ruby-Code rausbekommen. Bonus-Punkt: Man kann diese Zeile
      auch sehr leicht lesen! Schauen wir uns zu dieser Abfrage noch gerade
      die <filename>log/development.log</filename> an:<programlisting>  Person Load (0.3ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')</programlisting></para>

      <para>Die Methode <methodname>joins</methodname> führt also in SQL zu
      einem <literal>INNER JOIN</literal>.</para>

      <para>Aber wir haben noch einen kleinen Denkfehler gemacht. Was ist wenn
      jemand zwei Handynummern in der Datenbank gespeichert hat? Wird diese
      Person dann doppelt gezählt? Probieren wir mal eine Suche nach allen
      Personen die eine Handynummer und eine private Festnetznummer
      gespeichert haben:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; { :name =&gt; ['Mobile', 'Home'] } )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; { :name =&gt; ['Mobile', 'Home'] } ).count</command>
 =&gt; 6 

ruby-1.9.2-p0 &gt; <command>Person.count</command>
 =&gt; 5 

ruby-1.9.2-p0 &gt;</screen></para>

      <para>Tatsächlich! Obwohl wir nur 5 Personen in der Datenbank haben,
      enthält die Ergebnismenge 6 Einträge. Aber kein Problem! Das Ergebnis
      unserer Abfrage ist ein Array, und in einem Array können wir mit der
      Methode <methodname>uniq</methodname> alle doppelten Einträge
      löschen:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).uniq</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).uniq.count</command>
 =&gt; 4 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Tatsächlich haben also nur 4 Personen in unserer Datenbank eine
      Handynummer oder eine Privatnummer gespeichert.</para>

      <para>Über den gleichen Mechanismus <methodname>joins</methodname>
      können wir auch alle Personen die mit Nachnamen <quote>Meier</quote>
      heißen und eine Handynummer haben abfragen:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).count</command>
 =&gt; 1 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Es gibt nur eine Person, auf die diese Suchkriterien
      zutreffen.</para>

      <para>Als letztes suchen wir jetzt mal alle Personen mit einer Berliner
      Rufnummer (Vorwahl <literal>030</literal>) raus:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( "phonenumbers.number LIKE ?", '030%' ).uniq.count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Natürlich können wir das ganze auch umdrehen. Lassen Sie uns mal
      alle Telefonnummern aus Berlin (Vorwahl <literal>030</literal>)
      raussuchen, deren zugeordnete Person mit Nachnamen <quote>Meier</quote>
      heißt:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where( "number LIKE ?", '030%' ).where( :people =&gt; {:lastname =&gt; 'Meier'} )</command>
 =&gt; [#&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where( "number LIKE ?", '030%' ).where( :people =&gt; {:lastname =&gt; 'Meier'} ).count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Der Trick mit <methodname>uniq</methodname> klappt hier übrigens
      nicht:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where( "number LIKE ?", '030%' ).where(:people =&gt; {:lastname =&gt; 'Meier'} ).uniq.count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Bei der Personensuche konnten wir <methodname>uniq</methodname>
      auf das Ergebnis-Array sinnvoll anwenden, weil die einzelnen Personen
      doppelt im Array waren. Hier haben wir zwar bei den
      <literal>Phonenumber</literal>-Datensätzen 3 und 4 die gleiche
      Telefonnummer <quote>030-8888888</quote>, aber es sind eben verschiedene
      Datensätze. Man muss halt immer auch noch mitdenken. ;-)</para>
    </section>

    <section xml:id="activerecord_1n_includes">
      <title xml:id="activerecord_1n_includes.title">includes</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>includes()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>joins()</tertiary>
      </indexterm>

      <para><methodname>includes</methodname> ähnelt sehr der Methode
      <methodname>joins</methodname> (siehe <xref
      linkend="activerecord_1n_joins" />). Auch damit kann man innerhalb einer
      1:n-Verknüpfung suchen. Schauen wir uns mal das Beispiel <quote>Wir
      suchen alle Personen mit einer Handynummer</quote> mit
      <methodname>includes</methodname> und mit <methodname>joins</methodname>
      an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Die Ergebnisse sind identisch, oder?<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).all == Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).all</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Ja, die Ergebnisse sind identisch. Aber vielleicht haben Sie
      gemerkt, dass ich bei beiden Anfragen ein <methodname>all</methodname>
      eingeschmuggelt habe. Schauen wir uns einmal den Vergleich
      (<code>==</code>) der beiden
      <classname>ActiveRecord::Relation</classname> an:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ) == Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Es handelt sich also um zwei verschiedene Abfragen, die das
      gleiche Ergebnis liefern. Da hilft nur ein Blick in
      <filename>log/development.log</filename>. Als erstes die Ausgabe von
      <methodname>joins</methodname>:<programlisting>  Person Load (0.2ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')</programlisting></para>

      <para>Und jetzt die Ausgabe des
      <methodname>includes</methodname>:<programlisting>  Person Load (0.3ms)  SELECT "people"."id" AS t0_r0, "people"."firstname" AS t0_r1, "people"."lastname" AS t0_r2, "people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "phonenumbers"."id" AS t1_r0, "phonenumbers"."person_id" AS t1_r1, "phonenumbers"."name" AS t1_r2, "phonenumbers"."number" AS t1_r3, "phonenumbers"."created_at" AS t1_r4, "phonenumbers"."updated_at" AS t1_r5 FROM "people" LEFT OUTER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')</programlisting></para>

      <para>Ich erspare Ihnen das Rätselraten: <methodname>joins</methodname>
      liest nur die <literal>people</literal>-Datensätze ein und
      <methodname>includes</methodname> liest auch noch die dazu gehörigen
      <literal>phonenumbers</literal>. Schon bei unserem kleinen Beispiel
      sieht man, dass dies natürlich länger dauert.</para>

      <para>Warum kann der Einsatz von <methodname>includes</methodname> dann
      überhaupt Sinn machen? Wenn Sie schon bei dieser Abfrage wissen, dass
      Sie alle Telefonnummern ebenfalls benötigen, dann macht ein
      <methodname>includes</methodname> Sinn, da dann nur eine
      Datenbankanfrage gestellt wird. ActiveRecord <quote><foreignphrase
      xml:lang="en">cach</foreignphrase>'t</quote> nämlich die Antwort.</para>

      <para>Ich zeige Ihnen das mal an einem Beispiel. Wir werden wieder alle
      Meiers mit einem Handy raussuchen und dann alle Handynummern ausgeben.
      Zur besseren Analyse der SQL-Abfragen, werden wir mit
      <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command> alle
      Ausgabe die normalerweise nur in
      <filename>log/development.log</filename> landen direkt auf der
      <foreignphrase xml:lang="en">Console</foreignphrase> ausgeben. Als
      erstes die Variante mit <methodname>joins</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000102d3a308 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000102d3a2e0 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x00000102d3a290 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x00000102d3a268 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000102d3a218&gt;&gt;&gt;&gt; 

ruby-1.9.2-p0 &gt; <command>handybesitzer = Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
<emphasis>  Person Load (0.2ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</emphasis> =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>handybesitzer.each do |einzelperson|</command>

ruby-1.9.2-p0 &gt;     <command>puts einzelperson.phonenumbers.first.number</command>

ruby-1.9.2-p0 ?&gt;  <command>end</command>
<emphasis>  Phonenumber Load (0.3ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
</emphasis>0171-12345678
<emphasis>  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 3) LIMIT 1
</emphasis>0171-1188811
<emphasis>  Phonenumber Load (0.1ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 5) LIMIT 1
</emphasis>0172-22225678
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Wir haben für die Ausgabe aller Handynummern insgesamt 4
      SQL-Abfragen gemacht, und die brauchten in der Summe 0,8 ms. Jetzt
      machen wir das gleiche Beispiel mal mit
      <methodname>includes</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>handybesitzer = Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
<emphasis>  Person Load (0.3ms)  SELECT "people"."id" AS t0_r0, "people"."firstname" AS t0_r1, "people"."lastname" AS t0_r2, "people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "phonenumbers"."id" AS t1_r0, "phonenumbers"."person_id" AS t1_r1, "phonenumbers"."name" AS t1_r2, "phonenumbers"."number" AS t1_r3, "phonenumbers"."created_at" AS t1_r4, "phonenumbers"."updated_at" AS t1_r5 FROM "people" LEFT OUTER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</emphasis> =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>handybesitzer.each do |einzelperson|</command>
ruby-1.9.2-p0 &gt;     <command>puts einzelperson.phonenumbers.first.number</command>                 
ruby-1.9.2-p0 ?&gt;  <command>end</command>                                                           
0171-12345678
0171-1188811
0172-22225678
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Hier haben wir nur eine SQL-Abfrage die 0,3 ms gedauert hat. Die
      erste SQL-Abfrage dauert also länger, dafür spart man sich aber
      nachfolgende.</para>

      <para>Wäre es dann nicht besser immer mit
      <methodname>includes</methodname> zu arbeiten? Nein, es kommt immer auf
      den konkreten Fall an. Denn bei der Benutzung von
      <methodname>includes</methodname> werden ja initial viel mehr Daten
      transportiert. Die müssen von Ruby gecached und verarbeitet werden. Bei
      unserer kleinen Datenbank ist das egal. Aber stellen Sie sich das ganze
      mal mit allen Handynummern Deutschlands vor. Das ist eine Datenmenge,
      die man nicht unbedingt cachen will.</para>
    </section>
  </section>

  <section xml:id="has_many_delete" xml:lang="">
    <title xml:id="has_many_delete.title">delete und destroy</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>delete()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>delete_all()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>destroy()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>destroy_all()</tertiary>
    </indexterm>

    <para>Mit den Methoden <methodname>destroy</methodname>,
    <methodname>destroy_all</methodname>, <methodname>delete</methodname> und
    <methodname>delete_all</methodname> kann man wie in <xref
    linkend="datensatz-loeschen" /> beschrieben Datensätze löschen. Im Kontext
    von <methodname>has_many</methodname> bedeutet das, dass man die zu einer
    <classname>Person</classname> gehörigen
    <classname>Phonenumber</classname>-Datensätze in einem Streich löschen
    kann:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers.destroy_all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
  </section>

  <section xml:id="activerecord_1n_optionen">
    <title xml:id="activerecord_1n_optionen.title">Optionen</title>

    <para>Ich will an dieser Stelle nicht auf alle möglichen Optionen
    eingehen. Aber ein paar sind so praktisch und werden von mir in jedem
    Projekt benutzt, dass ich sie hier vorstellen möchte. Für alle anderen
    verweise ich auf die Ruby-on-Rails-Doku, die Sie im Internet unter <uri
    xlink:href="http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
    bzw. auf Ihrem System auf der Shell mit <command>ri
    ActiveRecord::Associations::ClassMethods</command> aufrufen können.</para>

    <section>
      <title>has_many</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Relationen</secondary>

        <tertiary>has_many()</tertiary>
      </indexterm>

      <para>Die meiner Meinung nach wichtigsten Optionen für
      <code>has_many</code>:<itemizedlist>
          <listitem>
            <para><emphasis role="bold"><code>:order</code></emphasis><code>
            =&gt; :apfelmus</code></para>

            <para>Wer die Telefonnummern nach den Namen sortieren will, kann
            dies mit folgender <filename>app/models/person.rb</filename>
            erreichen:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, <emphasis role="bold">:order =&gt; :name</emphasis>
end</programlisting></para>

            <para>Das Ergebnis in der <foreignphrase
            xml:lang="en">Console</foreignphrase> sieht dann so aus:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;, #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

            <para>Und falls mal umgekehrt sortiert werden
            soll:<programlisting>has_many :phonenumbers, <emphasis role="bold">:order =&gt; 'name DESC'</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><emphasis
            role="bold"><code>:dependent</code></emphasis><code> =&gt;
            :destroy</code></para>

            <para>Wird eine Person gelöscht, dann ist es ja oft sinnvoll, dass
            auch alle von dieser Person abhängigen (<foreignphrase
            xml:lang="en">dependent</foreignphrase>) Telefonnummern
            automatisch mitgelöscht werden. Das kann mit <code>:dependent
            =&gt; :destroy</code> in der
            <filename>app/models/person.rb</filename> realisiert
            werden:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, <emphasis role="bold">:dependent =&gt; :destroy</emphasis>
end</programlisting></para>

            <para>Im folgenden Beispiel löschen wir die erste Person in der
            Datenbank-Tabelle. Dabei werden automatisch alle Telefonnummern
            dieser Person ebenfalls gelöscht:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 22:27:36", updated_at: "2010-10-09 22:27:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 1).count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; <command>Person.first.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 22:27:36", updated_at: "2010-10-09 22:27:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 1).count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

            <important>
              <indexterm>
                <primary>ActiveRecord</primary>

                <secondary>Methoden</secondary>

                <tertiary>destroy()</tertiary>
              </indexterm>

              <indexterm>
                <primary>ActiveRecord</primary>

                <secondary>Methoden</secondary>

                <tertiary>delete()</tertiary>
              </indexterm>

              <para>Bitte denken Sie immer an den Unterschied zwischen den
              Methoden <methodname>destroy</methodname> (siehe <xref
              linkend="activerecord_destroy" />) und
              <methodname>delete</methodname> (siehe <xref
              linkend="activerecord_delete" />). Diese Abhängigkeit
              funktioniert nur mit der Methode
              <methodname>destroy</methodname>.</para>
            </important>
          </listitem>
        </itemizedlist></para>

      <para>Es gibt natürlich noch eine Menge anderer Optionen. Diese können
      Sie sich mit <command>ri
      ActiveRecord::Associations::ClassMethods#has_many</command> auf der
      Shell ausgeben lassen.</para>
    </section>

    <section>
      <title>belongs_to</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Relationen</secondary>

        <tertiary>belongs_to()</tertiary>
      </indexterm>

      <para>Die meiner Meinung nach wichtigste Option für
      <methodname>belongs_to</methodname> ist:<itemizedlist>
          <listitem>
            <para><emphasis role="bold"><code>:touch</code></emphasis><code>
            =&gt; :true</code></para>

            <para>Damit wird bei einer Veränderung einer
            <classname>Phonenumber</classname> automatisch das Feld
            <literal>updated_at</literal> des Eintrags in der Tabelle
            <classname>People</classname> auf die aktuelle Uhrzeit gesetzt.
            Das sähe in der <filename>app/models/phonenumber.rb</filename> so
            aus:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person, <emphasis role="bold">:touch =&gt; :true</emphasis>
end</programlisting></para>
          </listitem>
        </itemizedlist></para>

      <para>Auch hier sollten Sie einmal auf die Liste aller möglichen
      Optionen einen kurzen Blick werfen. Dazu in der Shell <command>ri
      ActiveRecord::Associations::ClassMethods#belongs_to</command>
      aufrufen.</para>
    </section>
  </section>

  <section xml:id="activerecord_has_many_through">
    <title xml:id="activerecord_has_many_through.title">has_many
    :through</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Relationen</secondary>

      <tertiary>has_many()</tertiary>
    </indexterm>

    <para>Um <code>has_many <replaceable>…</replaceable>, :through =&gt;
    <replaceable>…</replaceable></code> zu erklären müssen wir unser
    Datenbank-<foreignphrase xml:lang="en">Model</foreignphrase> erweitern.
    Nehmen wir einmal an, dass wir jeden Anruf mit Start- und Endzeit
    protokollieren. Das wäre dann eine 1:n-Verknüpfung von
    <classname>Phonenumber</classname> zu <classname>CallRecord</classname>.
    Erstellen wir erst mal ein entsprechendes <foreignphrase
    xml:lang="en">Model</foreignphrase>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model CallRecord phonenumber_id:integer start:datetime end:datetime</command>
      invoke  active_record
      create    db/migrate/20101011071702_create_call_records.rb
      create    app/models/call_record.rb
      invoke    test_unit
      create      test/unit/call_record_test.rb
      create      test/fixtures/call_records.yml

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Die Datenbank-Migration ausführen und damit die Tabelle
    anlegen:<screen>stefan@swmbp 1 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateCallRecords: migrating ==============================================
-- create_table(:call_records)
   -&gt; 0.0013s
==  CreateCallRecords: migrated (0.0013s) =====================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Die <filename>app/models/phonenumber.rb</filename> muss noch
    angepasst werden:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  <emphasis role="bold">has_many :call_records</emphasis>
end</programlisting></para>

    <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
    brauchbaren Testdaten an:<programlisting>Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
             
Phonenumber.all.each do |phonenumber|
  (1..(Phonenumber.count - phonenumber.id)).each do |zaehler|
    phonenumber.call_records.create(:start =&gt; Time.now, :end =&gt; Time.now + zaehler.minutes)
  end
end</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 1 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("call_records", {:force=&gt;true})
   -&gt; 0.0075s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0079s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0074s
-- initialize_schema_migrations_table()
   -&gt; 0.0003s
-- assume_migrated_upto_version(20101011071702, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>So, dann schauen wir uns jetzt mal an, wie oft Herr Fritz Meier die
    erste Nummer in seinem Telefonbuch angerufen hat:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first.call_records</command>
 =&gt; [#&lt;CallRecord id: 1, phonenumber_id: 1, start: "2010-10-11 07:36:12", end: "2010-10-11 07:37:12", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt;, #&lt;CallRecord id: 2, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:38:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 3, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:39:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 4, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:40:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 5, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:41:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 6, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:42:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;] 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first.call_records.count</command>
 =&gt; 6 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Im <filename>log/development.log</filename> schauen wir uns die
    letzten zwei Anfragen noch mal genau an:<programlisting>  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
  CallRecord Load (0.2ms)  SELECT "call_records".* FROM "call_records" WHERE ("call_records".phonenumber_id = 1)

  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
  SQL (0.1ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "call_records" WHERE ("call_records".phonenumber_id = 1)) AS subquery</programlisting></para>

    <para>Um jetzt eine Aufstellung von allen Telefonaten von Herrn Fritz
    Meier zu erhalten, müssten wir umständlich alle seine eingetragenen
    Rufnummern in einer Schleife abarbeiten. Das geht aber mit ActiveRecord
    auch einfacher. Bitte ändern Sie Ihre
    <filename>app/models/person.rb</filename> wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
  has_many :call_records, <emphasis role="bold">:through =&gt; :phonenumbers</emphasis>
end</programlisting></para>

    <para>Das schauen wir uns jetzt mal in der <foreignphrase
    xml:lang="en">Console</foreignphrase> an. Es liegt die Vermutung nahe,
    dass wir jetzt auch einen
    <methodname>call_records</methodname>-Zugriff<remark>FIXME: Hä?</remark>
    von der Klasse <classname>Person</classname> haben:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first.call_records.limit(5)</command>
 =&gt; [#&lt;CallRecord id: 1, phonenumber_id: 1, start: "2010-10-11 07:36:12", end: "2010-10-11 07:37:12", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt;, #&lt;CallRecord id: 2, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:38:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 3, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:39:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 4, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:40:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 5, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:41:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.call_records.count</command>
 =&gt; 15 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Bingo! ActiveRecord übernimmt wieder die Schwerstarbeit und liefert
    uns das SQL (siehe
    <filename>log/development.log</filename>):<programlisting>  Person Load (0.2ms)  SELECT "people".* FROM "people" LIMIT 1
  CallRecord Load (0.3ms)  SELECT "call_records".* FROM "call_records" INNER JOIN "phonenumbers" ON "call_records".phonenumber_id = "phonenumbers".id WHERE (("phonenumbers".person_id = 1)) LIMIT 5

  Person Load (0.3ms)  SELECT "people".* FROM "people" LIMIT 1
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "call_records" INNER JOIN "phonenumbers" ON "call_records".phonenumber_id = "phonenumbers".id WHERE (("phonenumbers".person_id = 1))</programlisting></para>

    <para>Praktisch? Praktisch!</para>

    <note>
      <para>Mehr Informationen und Beispiele zu <code>has_many
      <replaceable>…</replaceable>, :through =&gt;
      <replaceable>…</replaceable></code> finden Sie auf <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri></para>
    </note>
  </section>

  <section xml:id="activerecord_polymorphic">
    <title xml:id="activerecord_polymorphic.title">Polymorphe Assoziationen
    (polymorphic associations)</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Polymorphic Associations</secondary>
    </indexterm>

    <para>Schon das Wort "polymorph" lässt einen angespannt werden. Was mag
    damit gemeint sein? Auf <uri
    xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
    steht dazu: <quote>Polymorphic associations on models are not restricted
    on what types of models they can be associated with.</quote> Na, das ist
    ja jetzt klar wir Kloßbrühe! ;-)</para>

    <para>Ein Beispiel! Nehmen wir an, dass wir zu den Personen und den
    Telefonnummern in unserer Applikation Kommentare einbauen wollen. Und zwar
    beliebig viele Kommentare. Mit dem Wissen aus <xref
    linkend="activerecord_has_many_through" /> könnten wir uns zwei Modelle
    anlegen und jeweils eine <methodname>has_many</methodname>-Verbindung zu
    <classname>Person</classname> oder zu <classname>Phonenumber</classname>
    aufbauen. Bei zweien würde das sogar noch halbwegs praktikabel sein. Aber
    stellen Sie sich mal vor, Sie hätten gerne bei mehr Daten solche
    Kommentare. Dafür jedesmal ein eigenes <foreignphrase
    xml:lang="en">Model</foreignphrase> bauen? Genau da kommt die
    <foreignphrase xml:lang="en">Polymorphic Association</foreignphrase> zum
    Tragen. Damit können Sie ein <foreignphrase
    xml:lang="en">Model</foreignphrase> <classname>Comment</classname> mit
    beliebig vielen anderen Modellen verknüpfen.</para>

    <para>Erstellen wir erst mal das <foreignphrase
    xml:lang="en">Model</foreignphrase>
    <classname>Comment</classname>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model Comment commentable_type:string commentable_id:integer comment:string</command>
      invoke  active_record
      create    db/migrate/20101011084411_create_comments.rb
      create    app/models/comment.rb
      invoke    test_unit
      create      test/unit/comment_test.rb
      create      test/fixtures/comments.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0013s
==  CreateComments: migrated (0.0013s) ========================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Das Suffix <quote><foreignphrase
    xml:lang="en">able</foreignphrase></quote>
    (<replaceable>…</replaceable>bar) beim Namen <quote><foreignphrase
    xml:lang="en">commentable</foreignphrase></quote> (kommentierbar) ist
    Rails-üblich, muss aber nicht sein. Wir brauchen ja zum Verknüpfen jetzt
    nicht nur die ID des Eintrags, sondern müssen auch noch wissen, um welches
    <foreignphrase xml:lang="en">Model</foreignphrase> es sich eigentlich
    handelt. Da macht der Begriff <quote><foreignphrase
    xml:lang="en">commentable_type</foreignphrase></quote> halbwegs
    Sinn.</para>

    <para>Jetzt müssen wir in <filename>app/models/comment.rb</filename>
    folgenden Eintrag machen:<programlisting>class Comment &lt; ActiveRecord::Base
  belongs_to :commentable, :polymorphic =&gt; true
end</programlisting></para>

    <para>Jetzt den Eintrag in
    <filename>app/models/person.rb</filename><programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

    <para>Und noch den Eintrag in
    <filename>app/models/phonenumber.rb</filename><programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

    <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
    brauchbaren Testdaten an:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

    <para>Die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("comments", {:force=&gt;true})
   -&gt; 0.0053s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0058s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0067s
-- initialize_schema_migrations_table()
   -&gt; 0.0004s
-- assume_migrated_upto_version(20101011084411, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Gehen wir mal in die <foreignphrase
    xml:lang="en">Console</foreignphrase> und versuchen mal zwei Kommentare zu
    Herrn Fritz Meier anzulegen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 09:00:51", updated_at: "2010-10-11 09:00:51"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; <command>fritz.comments.create( :comment =&gt; 'Ein Beispiel' )</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.create( :comment =&gt; 'Noch ein Beispiel' )</command>
 =&gt; #&lt;Comment id: 2, commentable_type: "Person", commentable_id: 1, comment: "Noch ein Beispiel", created_at: "2010-10-11 09:07:44", updated_at: "2010-10-11 09:07:44"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 2 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Das funktioniert also. Schauen wir uns mal den ersten Kommentar
    an:<screen>ruby-1.9.2-p0 &gt; <command>Comment.first</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Alles logisch. Alles gut. Aber so wie ich Sie einschätze wollen Sie
    jetzt auch sehen wie das mit Telefonnummern geht. Kein Problem:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create( :comment =&gt; 'Und wieder ein Beispiel.' )</command>
 =&gt; #&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create( :comment =&gt; 'xyz Beispiel' )</command>
 =&gt; #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments</command>
 =&gt; [#&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt;, #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

    <note>
      <para><foreignphrase xml:lang="en">Polymorphic
      Associations</foreignphrase> sind sehr praktisch. Man sollte aber auch
      immer daran denken, dass sie mehr Last auf der Datenbank erzeugen als
      eine normale 1:n-Verknüpfung. Normalerweise macht das den Bock nicht
      fett, aber man sollte es bei der Planung im Hinterkopf haben.</para>
    </note>
  </section>
</section>
