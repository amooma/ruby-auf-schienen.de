<?xml version="1.0" encoding="UTF-8"?>
<section version="5.0" xml:id="activerecord_has_many"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_has_many.title">has_many –
  1:n-Verknüpfung</title>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Relationen</secondary>

    <tertiary>has_many()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Relationen</secondary>

    <tertiary>belongs_to()</tertiary>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <secondary>Assoziationen</secondary>

    <see>ActiveRecord, Relationen</see>
  </indexterm>

  <para>Um <methodname>has_many</methodname> zu erklären, erstellen wir eine
  Buch-Datenbank. In dieser Datenbank gibt es ein <foreignphrase
  xml:lang="en">Model</foreignphrase> mit Büchern (books) und ein
  <foreignphrase xml:lang="en">Model</foreignphrase> mit Autoren (authors). Da
  ein Buch mehrere Autoren haben kann, benötigen wir zum Abbilden eine
  1:n-Verknüpfung (<foreignphrase xml:lang="en">one-to-many
  association</foreignphrase>). Sie werden sehen, wie einfach das Ganze mit
  ActiveRecord ist.</para>

  <note>
    <para>Verknüpfungen nennt man übrigens auch Beziehung, Relationen
    (<foreignphrase xml:lang="en">Relations</foreignphrase> / <foreignphrase
    xml:lang="en">Relationships</foreignphrase>) oder Assoziationen
    (<foreignphrase xml:lang="en">Associations</foreignphrase>).</para>
  </note>

  <para>Wir erstellen als Erstes die Rails-Applikation:<screen>MacBook:~ xyz$ <command>rails new bookshelf</command>
[...]
MacBook:~ xyz$ <command>cd bookshelf</command> 
MacBook:bookshelf xyz$ </screen></para>

  <para>Jetzt legen wir das Model für die Bücher an:<screen>MacBook:bookshelf xyz$ <command>rails generate model book title</command>
      invoke  active_record
      create    db/migrate/20120506132424_create_books.rb
      create    app/models/book.rb
      invoke    test_unit
      create      test/unit/book_test.rb
      create      test/fixtures/books.yml
MacBook:bookshelf xyz$ </screen></para>

  <para>Und zum Schluss legen wir noch die Datenbank-Tabelle für die Autoren
  an. In dieser benötigen wir ein Zuordnungsfeld zur Bücher-Tabelle. Dieser
  Fremdschlüssel (<foreignphrase xml:lang="en">Foreign key</foreignphrase>)
  wird per Default immer als Name des referenzierten Objekts (hier:
  <literal>book</literal>) mit angehängtem <literal>_id</literal>
  gesetzt:<screen>MacBook:bookshelf xyz$ <command>rails generate model author book_id:integer first_name last_name</command>
      invoke  active_record
      create    db/migrate/20120506132619_create_authors.rb
      create    app/models/author.rb
      invoke    test_unit
      create      test/unit/author_test.rb
      create      test/fixtures/authors.yml
MacBook:bookshelf xyz$</screen></para>

  <para>Danach ein <command>rake db:migrate</command> ausführen, damit die
  Datenbank-Tabellen auch angelegt werden:<screen>MacBook:bookshelf xyz$ <command>rake db:migrate</command>
==  CreateBooks: migrating ====================================================
-- create_table(:books)
   -&gt; 0.0014s
==  CreateBooks: migrated (0.0015s) ===========================================

==  CreateAuthors: migrating ==================================================
-- create_table(:authors)
   -&gt; 0.0015s
==  CreateAuthors: migrated (0.0015s) =========================================

MacBook:bookshelf xyz$ </screen></para>

  <para>Schauen wir uns das mal auf der <foreignphrase
  xml:lang="en">Console</foreignphrase> an:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book</command>
 =&gt; Book(id: integer, title: string, created_at: datetime, updated_at: datetime) 
1.9.3p194 :002 &gt; <command>Author</command>
 =&gt; Author(id: integer, book_id: integer, first_name: string, last_name: string, created_at: datetime, updated_at: datetime) 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:bookshelf xyz$ </screen></para>

  <para>Die zwei Datenbank-Tabellen sind eingerichtet und können mit
  ActiveRecord benutzt werden. Allerdings weiß ActiveRecord noch nichts von
  der 1:n-Beziehung der beiden. Das ist aber recht einfach in zwei Schritten
  realisierbar:<itemizedlist>
      <listitem>
        <para>Wir fügen in der <foreignphrase
        xml:lang="en">Model</foreignphrase>-Datei
        <filename>app/models/book.rb</filename> die Option
        <methodname>has_many</methodname> ein:<programlisting>class Book &lt; ActiveRecord::Base
  attr_accessible :title

  <emphasis>has_many :authors</emphasis>
end</programlisting></para>
      </listitem>

      <listitem>
        <para>Und wir fügen in der <foreignphrase
        xml:lang="en">Model</foreignphrase>-Datei
        <filename>app/models/author.rb</filename> die Option
        <methodname>belongs_to</methodname> ein:<programlisting>class Author &lt; ActiveRecord::Base
  attr_accessible :book_id, :first_name, :last_name

  <emphasis>belongs_to :book</emphasis>
end</programlisting></para>
      </listitem>
    </itemizedlist></para>

  <para>Diese zwei einfachen Definitionen sorgen für eine ganze Menge
  Rails-Magie.</para>

  <section xml:id="activerecord_1n_erstellen">
    <title xml:id="activerecord_1n_erstellen.title">Datensätze
    erstellen</title>

    <para>Wir wollen in diesem Beispiel das Buch "Homo faber" von Max Frisch
    abspeichern.</para>

    <section xml:id="activerecord_hinzufuegen_manuell">
      <title xml:id="activerecord_hinzufuegen_manuell.title">Manuell</title>

      <para>Wir löschen die Datenbank mit <command>rake
      db:reset</command><screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
-- create_table("authors", {:force=&gt;true})
   -&gt; 0.0151s
-- create_table("books", {:force=&gt;true})
   -&gt; 0.0024s
-- initialize_schema_migrations_table()
   -&gt; 0.0033s
-- assume_migrated_upto_version(20120506132619, ["/Users/xyz/bookshelf/db/migrate"])
   -&gt; 0.0033s
MacBook:bookshelf xyz$ </screen></para>

      <para>Und erstellen zuerst ein Objekt mit den Buch-Daten. Dann merken
      wir uns die ID für diesen Datensatz und erstellen danach die
      Autoren-Datensatz mit dieser ID im Feld
      <literal>book_id</literal>:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>book = Book.create(:title =&gt; 'Homo faber')</command>
   (0.1ms)  begin transaction
  SQL (5.0ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 06 May 2012 13:47:45 UTC +00:00], ["title", "Homo faber"], ["updated_at", Sun, 06 May 2012 13:47:45 UTC +00:00]]
   (1.2ms)  commit transaction
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 13:47:45", updated_at: "2012-05-06 13:47:45"&gt; 
1.9.3p194 :002 &gt; <command>author = Author.create(:book_id =&gt; 1, :first_name =&gt; 'Max', :last_name =&gt; 'Frisch')</command>
   (0.1ms)  begin transaction
  SQL (0.7ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 13:48:17 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Sun, 06 May 2012 13:48:17 UTC +00:00]]
   (3.1ms)  commit transaction
 =&gt; #&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 13:48:17", updated_at: "2012-05-06 13:48:17"&gt; 
1.9.3p194 :003 &gt; <command>Book.all</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" 
 =&gt; [#&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 13:47:45", updated_at: "2012-05-06 13:47:45"&gt;] 
1.9.3p194 :004 &gt; <command>Author.all</command>
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" 
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 13:48:17", updated_at: "2012-05-06 13:48:17"&gt;] 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>id()</tertiary>
      </indexterm>

      <para>Die <literal>book_id</literal> quasi manuell einzutragen, ist
      natürlich sehr unpraktisch und fehleranfällig. Deshalb gibt es die
      Methode <xref linkend="activerecord_has_many_create"/>.</para>
    </section>

    <section xml:id="activerecord_has_many_create">
      <title xml:id="activerecord_has_many_create.title">create</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>create()</tertiary>
      </indexterm>

      <para>Jetzt versuchen wir das Gleiche wie in <xref
      linkend="activerecord_hinzufuegen_manuell"/>, aber benutzen diesmal ein
      wenig ActiveRecord-Magie. Wir können mit der Methode
      <methodname>create</methodname> von <literal>authors</literal> zu jedem
      <classname>Book</classname>-Objekt neue Autoren hinzufügen. Diese werden
      automatisch korrekt mit der <literal>book_id</literal> bestückt:<screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
[...]
MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>book = Book.create(:title =&gt; 'Homo faber')</command>
   (0.1ms)  begin transaction
  SQL (4.9ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 06 May 2012 13:52:28 UTC +00:00], ["title", "Homo faber"], ["updated_at", Sun, 06 May 2012 13:52:28 UTC +00:00]]
   (2.6ms)  commit transaction
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 13:52:28", updated_at: "2012-05-06 13:52:28"&gt; 
1.9.3p194 :002 &gt; <command>author = book.authors.create(:first_name =&gt; 'Max', :last_name =&gt; 'Frisch')</command>
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 13:52:52 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Sun, 06 May 2012 13:52:52 UTC +00:00]]
   (0.8ms)  commit transaction
 =&gt; #&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 13:52:52", updated_at: "2012-05-06 13:52:52"&gt; 
1.9.3p194 :003 &gt; <command>Book.all</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" 
 =&gt; [#&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 13:52:28", updated_at: "2012-05-06 13:52:28"&gt;] 
1.9.3p194 :004 &gt; <command>Author.all</command>
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" 
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 13:52:52", updated_at: "2012-05-06 13:52:52"&gt;] 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <para>Sie können auch direkt das
      <methodname>authors.create()</methodname> hinter das
      <methodname>Book.create()</methodname> setzen:<screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
[...]
MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.create(:title =&gt; 'Homo faber').authors.create(:first_name =&gt; 'Max', :last_name =&gt; 'Frisch')</command>
   (0.1ms)  begin transaction
  SQL (5.2ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 06 May 2012 13:56:38 UTC +00:00], ["title", "Homo faber"], ["updated_at", Sun, 06 May 2012 13:56:38 UTC +00:00]]
   (3.6ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 13:56:38 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Sun, 06 May 2012 13:56:38 UTC +00:00]]
   (1.1ms)  commit transaction
 =&gt; #&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 13:56:38", updated_at: "2012-05-06 13:56:38"&gt; 
1.9.3p194 :002 &gt; <command>Book.all</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" 
 =&gt; [#&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 13:56:38", updated_at: "2012-05-06 13:56:38"&gt;] 
1.9.3p194 :003 &gt; <command>Author.all</command>
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" 
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 13:56:38", updated_at: "2012-05-06 13:56:38"&gt;] 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <para>Da <methodname>create</methodname> statt nur einem <foreignphrase
      xml:lang="en">Hash</foreignphrase> alternativ auch ein <foreignphrase
      xml:lang="en">Array</foreignphrase> von <foreignphrase
      xml:lang="en">Hashes</foreignphrase> akzeptiert, können Sie auch mehrere
      Autoren für ein Buch auf einmal anlegen:<screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
[...]
MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.create(:title =&gt; 'Beispiel').authors.create([{:last_name =&gt; 'A'}, {:last_name =&gt; 'B'}, {:last_name =&gt; 'C'}])</command>
   (0.1ms)  begin transaction
  SQL (5.0ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 06 May 2012 14:03:27 UTC +00:00], ["title", "Beispiel"], ["updated_at", Sun, 06 May 2012 14:03:27 UTC +00:00]]
   (2.7ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.6ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 14:03:27 UTC +00:00], ["first_name", nil], ["last_name", "A"], ["updated_at", Sun, 06 May 2012 14:03:27 UTC +00:00]]
   (0.9ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 14:03:27 UTC +00:00], ["first_name", nil], ["last_name", "B"], ["updated_at", Sun, 06 May 2012 14:03:27 UTC +00:00]]
   (0.8ms)  commit transaction
   (0.0ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 14:03:27 UTC +00:00], ["first_name", nil], ["last_name", "C"], ["updated_at", Sun, 06 May 2012 14:03:27 UTC +00:00]]
   (1.0ms)  commit transaction
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: nil, last_name: "A", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;, #&lt;Author id: 2, book_id: 1, first_name: nil, last_name: "B", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;, #&lt;Author id: 3, book_id: 1, first_name: nil, last_name: "C", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;] 
1.9.3p194 :002 &gt; <command>Book.all</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" 
 =&gt; [#&lt;Book id: 1, title: "Beispiel", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;] 
1.9.3p194 :003 &gt; <command>Author.all</command>
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" 
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: nil, last_name: "A", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;, #&lt;Author id: 2, book_id: 1, first_name: nil, last_name: "B", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;, #&lt;Author id: 3, book_id: 1, first_name: nil, last_name: "C", created_at: "2012-05-06 14:03:27", updated_at: "2012-05-06 14:03:27"&gt;] 
1.9.3p194 :004 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <para>Allerdings ist das in der Praxis nur dann sinnvoll, wenn die
      Text-Zeile dadurch nicht zu lang und unübersichtlich wird.</para>
    </section>

    <section xml:id="activerecord_hinzufuegen_build">
      <title xml:id="activerecord_hinzufuegen_build.title">build</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>build()</tertiary>
      </indexterm>

      <para>Die Methode <methodname>build</methodname> ähnelt
      <methodname>create</methodname>. Allerdings wird der Datensatz nicht
      abgespeichert. Dies erfolgt erst nach einem
      <methodname>save</methodname>:<screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
[...]
MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>book = Book.create(:title =&gt; 'Homo faber')</command>
   (0.1ms)  begin transaction
  SQL (4.9ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Sun, 06 May 2012 14:05:40 UTC +00:00], ["title", "Homo faber"], ["updated_at", Sun, 06 May 2012 14:05:40 UTC +00:00]]
   (3.9ms)  commit transaction
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 14:05:40", updated_at: "2012-05-06 14:05:40"&gt; 
1.9.3p194 :002 &gt; <command>author = book.authors.build(:first_name =&gt; 'Max', :last_name =&gt; 'Frisch')</command>
 =&gt; #&lt;Author id: nil, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: nil, updated_at: nil&gt; 
1.9.3p194 :003 &gt; <command>author.new_record?</command>
 =&gt; true 
1.9.3p194 :004 &gt; <command>author.save</command>
   (0.1ms)  begin transaction
  SQL (1.7ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 1], ["created_at", Sun, 06 May 2012 14:06:29 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Sun, 06 May 2012 14:06:29 UTC +00:00]]
   (3.3ms)  commit transaction
 =&gt; true 
1.9.3p194 :005 &gt; <command>author.new_record?</command>
 =&gt; false 
1.9.3p194 :006 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <warning>
        <para>Bei der Benutzung von <methodname>create</methodname> und
        <methodname>build</methodname> müssen natürlich logische
        Abhängigkeiten beachtet werden, sonst gibt es einen Fehler. So kann
        man nicht zwei <methodname>build</methodname>-Methoden miteinander
        verketten. Beispiel:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.build(:title =&gt; 'Beispiel').authors.build(:last_name =&gt; 'A')</command>
NoMethodError: undefined method `build' for #&lt;Class:0x007ff8c52d2330&gt;
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/activerecord-3.2.3/lib/active_record/dynamic_matchers.rb:50:in `method_missing'
 from (irb):1
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.3/lib/rails/commands/console.rb:47:in `start'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.3/lib/rails/commands/console.rb:8:in `start'
 from /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/railties-3.2.3/lib/rails/commands.rb:41:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:bookshelf xyz$ </screen></para>
      </warning>
    </section>
  </section>

  <section xml:id="activerecord_1n_zugreifen">
    <title xml:id="activerecord_1n_zugreifen.title">Auf Datensätze
    zugreifen</title>

    <para>Dafür brauchen wir Beispieldaten. Deshalb füllen Sie bitte die Datei
    <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting># ruby encoding: utf-8

Book.create(:title =&gt; 'Homo faber').authors.create(:first_name =&gt; 'Max', :last_name =&gt; 'Frisch')
Book.create(:title =&gt; 'Der Besuch der alten Dame').authors.create(:first_name =&gt; 'Friedrich', :last_name =&gt; 'Dürrenmatt')
Book.create(:title =&gt; 'Julius Shulman: The Last Decade').authors.create([
  {:first_name =&gt; 'Thomas', :last_name =&gt; 'Schirmbock'},
  {:first_name =&gt; 'Julius', :last_name =&gt; 'Shulman'},
  {:first_name =&gt; 'Jürgen', :last_name =&gt; 'Nogai'}
  ])
Book.create(:title =&gt; 'Julius Shulman: Palm Springs').authors.create([
  {:first_name =&gt; 'Michael', :last_name =&gt; 'Stern'},
  {:first_name =&gt; 'Alan', :last_name =&gt; 'Hess'}
  ])
Book.create(:title =&gt; 'Photographing Architecture and Interiors').authors.create([
  {:first_name =&gt; 'Julius', :last_name =&gt; 'Shulman'},
  {:first_name =&gt; 'Richard', :last_name =&gt; 'Neutra'}
  ])
Book.create(:title =&gt; 'Der Zauberberg').authors.create(:first_name =&gt; 'Thomas', :last_name =&gt; 'Mann')
Book.create(:title =&gt; 'In einer Familie').authors.create(:first_name =&gt; 'Heinrich', :last_name =&gt; 'Mann')</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
[...]
MacBook:bookshelf xyz$</screen></para>

    <para>Das Praktische an der 1:n-Zuordnung in ActiveRecord ist der
    besonders einfache Zugang zu den n-Instanzen. Schauen wir uns das für den
    ersten Datensatz an:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.first</command>
  Book Load (0.1ms)  SELECT "books".* FROM "books" LIMIT 1
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 14:23:43", updated_at: "2012-05-06 14:23:43"&gt; 
1.9.3p194 :002 &gt; <command>Book.first.authors</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" LIMIT 1
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 1
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 14:23:43", updated_at: "2012-05-06 14:23:43"&gt;] 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

    <para>Ist das cool?! Man kann einfach durch die Pluralform des
    n-<foreignphrase xml:lang="en">Model</foreignphrase> auf die Datensätze
    zugreifen. Die Ergebnismenge wird als <foreignphrase
    xml:lang="en">Array</foreignphrase> zurückgegeben. Ob es auch andersherum
    geht?<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Author.first</command>
  Author Load (0.1ms)  SELECT "authors".* FROM "authors" LIMIT 1
 =&gt; #&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-06 14:23:43", updated_at: "2012-05-06 14:23:43"&gt; 
1.9.3p194 :002 &gt; <command>Author.first.book</command>
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" LIMIT 1
  Book Load (0.2ms)  SELECT "books".* FROM "books" WHERE "books"."id" = 1 LIMIT 1
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-06 14:23:43", updated_at: "2012-05-06 14:23:43"&gt; 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

    <para>Bingo! Auch der Zugriff zur zugeordneten
    <classname>Book</classname>-Klasse ist ganz einfach. Und da es sich nur um
    einen einzigen Datensatz handelt (<methodname>belongs_to</methodname>),
    wird hier die Singularform genommen.</para>

    <note>
      <para>Wenn es zu einem Buch keinen Autor geben würde, so wäre das
      Ergebnis ein leeres Array. Wenn zu einem Author kein Buch zugeordnet
      ist, dann gibt ActiveRecord als <classname>Book</classname> den Wert
      <code>nil</code> aus.</para>
    </note>
  </section>

  <section>
    <title>Datensätze suchen</title>

    <para>Zum Suchen brauchen wir wieder definierte Beispieldaten. Deshalb
    füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit folgendem
    Inhalt:<programlisting># ruby encoding: utf-8

Book.create(:title =&gt; 'Homo faber').authors.create(:first_name =&gt; 'Max', :last_name =&gt; 'Frisch')
Book.create(:title =&gt; 'Der Besuch der alten Dame').authors.create(:first_name =&gt; 'Friedrich', :last_name =&gt; 'Dürrenmatt')
Book.create(:title =&gt; 'Julius Shulman: The Last Decade').authors.create([
  {:first_name =&gt; 'Thomas', :last_name =&gt; 'Schirmbock'},
  {:first_name =&gt; 'Julius', :last_name =&gt; 'Shulman'},
  {:first_name =&gt; 'Jürgen', :last_name =&gt; 'Nogai'}
  ])
Book.create(:title =&gt; 'Julius Shulman: Palm Springs').authors.create([
  {:first_name =&gt; 'Michael', :last_name =&gt; 'Stern'},
  {:first_name =&gt; 'Alan', :last_name =&gt; 'Hess'}
  ])
Book.create(:title =&gt; 'Photographing Architecture and Interiors').authors.create([
  {:first_name =&gt; 'Julius', :last_name =&gt; 'Shulman'},
  {:first_name =&gt; 'Richard', :last_name =&gt; 'Neutra'}
  ])
Book.create(:title =&gt; 'Der Zauberberg').authors.create(:first_name =&gt; 'Thomas', :last_name =&gt; 'Mann')
Book.create(:title =&gt; 'In einer Familie').authors.create(:first_name =&gt; 'Heinrich', :last_name =&gt; 'Mann')</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>MacBook:bookshelf xyz$ <command>rake db:reset</command>
[...]
MacBook:bookshelf xyz$</screen></para>

    <para>Dann legen wir mal los. Als Erstes schauen wir uns an, wie viele
    Bücher in der Datenbank sind:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.count</command>
   (0.1ms)  SELECT COUNT(*) FROM "books" 
 =&gt; 7 
1.9.3p194 :002 &gt;</screen></para>

    <para>Und wie viele Autoren?<screen>1.9.3p194 :002 &gt; <command>Author.count</command>
   (0.2ms)  SELECT COUNT(*) FROM "authors" 
 =&gt; 11 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

    <section xml:id="activerecord_1n_joins">
      <title xml:id="activerecord_1n_joins.title">joins</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>joins()</tertiary>
      </indexterm>

      <para>Wie können wir alle Bücher herausfinden, die mindestens einen
      Authoren mit dem Nachnamen 'Mann' haben? Das geht mit einem
      <foreignphrase xml:lang="en">Join</foreignphrase>.<footnote>
          <para>Falls Sie sich für den theoretischen Hintergrund zu
          <foreignphrase xml:lang="en">Joins</foreignphrase> interessieren,
          finden Sie weitere Informationen unter: <uri
          xlink:href="http://de.wikipedia.org/wiki/SQL#Abfrage_mit_verkn.C3.BCpften_Tabellen">http://de.wikipedia.org/wiki/SQL#Abfrage_mit_verkn.C3.BCpften_Tabellen</uri>,
          <uri
          xlink:href="http://en.wikipedia.org/wiki/Join_%28SQL%29">http://en.wikipedia.org/wiki/Join_(SQL)</uri>,
          <uri
          xlink:href="http://de.wikipedia.org/wiki/Relationale_Algebra#Join">http://de.wikipedia.org/wiki/Relationale_Algebra#Join.</uri></para>
        </footnote> Damit können wir die beiden <foreignphrase
      xml:lang="en">Models</foreignphrase> auch in der Suche
      verknüpfen:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.joins(:authors).where(:authors =&gt; {:last_name =&gt; 'Mann'})</command>
  Book Load (0.2ms)  SELECT "books".* FROM "books" INNER JOIN "authors" ON "authors"."book_id" = "books"."id" WHERE "authors"."last_name" = 'Mann'
 =&gt; [#&lt;Book id: 6, title: "Der Zauberberg", created_at: "2012-05-07 07:14:08", updated_at: "2012-05-07 07:14:08"&gt;, #&lt;Book id: 7, title: "In einer Familie", created_at: "2012-05-07 07:14:08", updated_at: "2012-05-07 07:14:08"&gt;] 
1.9.3p194 :002 &gt; <command>Book.joins(:authors).where(:authors =&gt; {:last_name =&gt; 'Mann'}).count</command>
   (0.4ms)  SELECT COUNT(*) FROM "books" INNER JOIN "authors" ON "authors"."book_id" = "books"."id" WHERE "authors"."last_name" = 'Mann'
 =&gt; 2 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <para>Zwei Bücher mit einem Autoren 'Mann' sind in der Datenbank. Im SQL
      sehen Sie, das die Methode <methodname>joins</methodname> ein
      <literal>INNER JOIN</literal> ausführt.</para>

      <para>Selbstverständlich können wir das Ganze auch umdrehen. Wir suchen
      uns den Autor des Buches 'Homo faber':<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Author.joins(:book).where(:books =&gt; {:title =&gt; 'Homo faber'})</command>
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" INNER JOIN "books" ON "books"."id" = "authors"."book_id" WHERE "books"."title" = 'Homo faber'
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-07 07:14:08", updated_at: "2012-05-07 07:14:08"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>
    </section>

    <section xml:id="activerecord_1n_includes">
      <title xml:id="activerecord_1n_includes.title">includes</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>includes()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>joins()</tertiary>
      </indexterm>

      <para><methodname>includes</methodname> ähnelt sehr der Methode
      <methodname>joins</methodname> (siehe <xref
      linkend="activerecord_1n_joins"/>). Auch damit kann man innerhalb einer
      1:n-Verknüpfung suchen. Suchen wir noch mal alle Bücher mit einem Autor,
      der als Nachnamen 'Mann' hat:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.includes(:authors).where(:authors =&gt; {:last_name =&gt; 'Mann'})</command>
  SQL (0.4ms)  SELECT "books"."id" AS t0_r0, "books"."title" AS t0_r1, "books"."created_at" AS t0_r2, "books"."updated_at" AS t0_r3, "authors"."id" AS t1_r0, "authors"."book_id" AS t1_r1, "authors"."first_name" AS t1_r2, "authors"."last_name" AS t1_r3, "authors"."created_at" AS t1_r4, "authors"."updated_at" AS t1_r5 FROM "books" LEFT OUTER JOIN "authors" ON "authors"."book_id" = "books"."id" WHERE "authors"."last_name" = 'Mann'
 =&gt; [#&lt;Book id: 6, title: "Der Zauberberg", created_at: "2012-05-07 07:14:08", updated_at: "2012-05-07 07:14:08"&gt;, #&lt;Book id: 7, title: "In einer Familie", created_at: "2012-05-07 07:14:08", updated_at: "2012-05-07 07:14:08"&gt;] 
1.9.3p194 :002 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

      <para>Sie sehen in der Console-Ausgabe, das der SQL-Code sich von der
      <methodname>joins</methodname>-Abfrage unterscheidet.</para>

      <para><methodname>joins</methodname> liest nur die
      <literal>Book</literal>-Datensätze ein und
      <methodname>includes</methodname> liest auch noch die dazugehörigen
      <literal>Authors</literal>. Schon bei unserem kleinen Beispiel sieht
      man, dass dies natürlich länger dauert (0.2 ms vs. 0.4 ms).</para>

      <para>Warum kann der Einsatz von <methodname>includes</methodname> dann
      überhaupt Sinn machen? Wenn Sie schon bei der Abfrage wissen, dass Sie
      später alle Autorendaten benötigen, dann ist ein
      <methodname>includes</methodname> sinnvoll, weil dann nur eine
      Datenbankanfrage gestellt wird. ActiveRecord <quote><foreignphrase
      xml:lang="en">cach</foreignphrase>'t</quote> nämlich die Antwort.</para>

      <para>Wäre es dann nicht besser, immer mit
      <methodname>includes</methodname> zu arbeiten? Nein, es kommt immer auf
      den konkreten Fall an. Denn bei der Benutzung von
      <methodname>includes</methodname> werden ja initial viel mehr Daten
      transportiert. Diese müssen von Ruby gecached und verarbeitet werden.
      Die Verarbeitung dauert also länger und verbraucht mehr
      Resourcen.</para>
    </section>
  </section>

  <section xml:id="has_many_delete" xml:lang="">
    <title xml:id="has_many_delete.title">delete und destroy</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>delete()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>delete_all()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>destroy()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>destroy_all()</tertiary>
    </indexterm>

    <para>Mit den Methoden <methodname>destroy</methodname>,
    <methodname>destroy_all</methodname>, <methodname>delete</methodname> und
    <methodname>delete_all</methodname> kann man, wie in <xref
    linkend="datensatz-loeschen"/> beschrieben, Datensätze löschen. Im Kontext
    von <methodname>has_many</methodname> bedeutet das, dass man die zu einem
    <classname>Book</classname> gehörigen
    <classname>Author</classname>-Datensätze in einem Streich löschen
    kann:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>book = Book.find_by_title('Julius Shulman: The Last Decade')</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" WHERE "books"."title" = 'Julius Shulman: The Last Decade' LIMIT 1
 =&gt; #&lt;Book id: 3, title: "Julius Shulman: The Last Decade", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt; 
1.9.3p194 :002 &gt; <command>book.authors</command>
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 3
 =&gt; [#&lt;Author id: 3, book_id: 3, first_name: "Thomas", last_name: "Schirmbock", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt;, #&lt;Author id: 4, book_id: 3, first_name: "Julius", last_name: "Shulman", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt;, #&lt;Author id: 5, book_id: 3, first_name: "Jürgen", last_name: "Nogai", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt;] 
1.9.3p194 :003 &gt; <command>book.authors.destroy_all</command>
   (0.1ms)  begin transaction
  SQL (5.5ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 3]]
  SQL (0.0ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 4]]
  SQL (0.0ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 5]]
   (3.2ms)  commit transaction
 =&gt; [#&lt;Author id: 3, book_id: 3, first_name: "Thomas", last_name: "Schirmbock", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt;, #&lt;Author id: 4, book_id: 3, first_name: "Julius", last_name: "Shulman", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt;, #&lt;Author id: 5, book_id: 3, first_name: "Jürgen", last_name: "Nogai", created_at: "2012-05-07 07:36:41", updated_at: "2012-05-07 07:36:41"&gt;] 
1.9.3p194 :004 &gt; <command>book.authors</command>
 =&gt; [] 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>
  </section>

  <section xml:id="activerecord_1n_optionen">
    <title xml:id="activerecord_1n_optionen.title">Optionen</title>

    <para>Ich will an dieser Stelle nicht auf alle möglichen Optionen
    eingehen. Aber ein paar sind so praktisch und werden von mir in jedem
    Projekt benutzt, dass ich sie hier vorstellen möchte. Für alle anderen
    verweise ich auf die Ruby-on-Rails-Doku, die Sie im Internet unter <uri
    xlink:href="http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
    bzw. auf Ihrem System auf der Shell mit <command>ri
    ActiveRecord::Associations::ClassMethods</command> aufrufen können.</para>

    <section>
      <title>belongs_to</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Relationen</secondary>

        <tertiary>belongs_to()</tertiary>
      </indexterm>

      <para>Die meiner Meinung nach wichtigste Option für
      <methodname>belongs_to</methodname> ist:<itemizedlist>
          <listitem>
            <para><emphasis role="bold"><code>:touch</code></emphasis><code>
            =&gt; :true</code></para>

            <para>Damit wird bei einer Veränderung eines
            <classname>Author</classname> automatisch das Feld
            <literal>updated_at</literal> des Eintrags in der Tabelle
            <classname>Book</classname> auf die aktuelle Uhrzeit gesetzt. Das
            sähe in der <filename>app/models/author.rb</filename>
            folgendermaßen aus:<programlisting>class Author &lt; ActiveRecord::Base
  attr_accessible :book_id, :first_name, :last_name

  <emphasis>belongs_to :book, :touch =&gt; true</emphasis>
end</programlisting></para>
          </listitem>
        </itemizedlist></para>

      <para>Auch hier sollten Sie einmal auf die Liste aller möglichen
      Optionen einen kurzen Blick werfen. Dazu in der Shell <command>ri
      ActiveRecord::Associations::ClassMethods#belongs_to</command>
      aufrufen.</para>
    </section>

    <section>
      <title>has_many</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Relationen</secondary>

        <tertiary>has_many()</tertiary>
      </indexterm>

      <para>Die meiner Meinung nach wichtigsten Optionen für
      <code>has_many</code>:<itemizedlist>
          <listitem>
            <para><emphasis role="bold"><code>:order</code></emphasis><code>
            =&gt; :last_name</code></para>

            <para>Wer die Autoren nach den Nachnamen sortieren will, kann dies
            mit folgender <filename>app/models/book.rb</filename>
            erreichen:<programlisting>class Book &lt; ActiveRecord::Base
  attr_accessible :title

  <emphasis>has_many :authors, :order =&gt; :last_name</emphasis>
end</programlisting></para>

            <para>Erstellen wir als Beispiel mal ein neues Buch mit neuen
            Autoren und schauen uns an, wie ActiveRecord diese dann
            sortiert:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.create(:title =&gt; 'Test').authors.create([{:last_name =&gt; 'Z'}, {:last_name =&gt; 'A'}])</command>
   (0.1ms)  begin transaction
  SQL (5.9ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Mon, 07 May 2012 07:45:34 UTC +00:00], ["title", "Test"], ["updated_at", Mon, 07 May 2012 07:45:34 UTC +00:00]]
   (3.6ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.7ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 8], ["created_at", Mon, 07 May 2012 07:45:34 UTC +00:00], ["first_name", nil], ["last_name", "Z"], ["updated_at", Mon, 07 May 2012 07:45:34 UTC +00:00]]
   (1.1ms)  commit transaction
   (0.1ms)  begin transaction
  SQL (0.4ms)  INSERT INTO "authors" ("book_id", "created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?, ?)  [["book_id", 8], ["created_at", Mon, 07 May 2012 07:45:34 UTC +00:00], ["first_name", nil], ["last_name", "A"], ["updated_at", Mon, 07 May 2012 07:45:34 UTC +00:00]]
   (0.9ms)  commit transaction
 =&gt; [#&lt;Author id: 12, book_id: 8, first_name: nil, last_name: "Z", created_at: "2012-05-07 07:45:34", updated_at: "2012-05-07 07:45:34"&gt;, #&lt;Author id: 13, book_id: 8, first_name: nil, last_name: "A", created_at: "2012-05-07 07:45:34", updated_at: "2012-05-07 07:45:34"&gt;] 
1.9.3p194 :002 &gt; <command>Book.last.authors</command>                                                Book Load (0.4ms)  SELECT "books".* FROM "books" ORDER BY "books"."id" DESC LIMIT 1
  Author Load (0.4ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 8 ORDER BY last_name
 =&gt; [#&lt;Author id: 13, book_id: 8, first_name: nil, last_name: "A", created_at: "2012-05-07 07:45:34", updated_at: "2012-05-07 07:45:34"&gt;, #&lt;Author id: 12, book_id: 8, first_name: nil, last_name: "Z", created_at: "2012-05-07 07:45:34", updated_at: "2012-05-07 07:45:34"&gt;] 
1.9.3p194 :003 &gt; <command>exit</command>
MacBook:bookshelf xyz$ </screen></para>

            <para>Und falls mal umgekehrt sortiert werden
            soll:<programlisting>has_many :authors, <emphasis role="bold">:order =&gt; 'title DESC'</emphasis></programlisting></para>
          </listitem>

          <listitem>
            <para><emphasis
            role="bold"><code>:dependent</code></emphasis><code> =&gt;
            :destroy</code></para>

            <para>Wird ein Buch gelöscht, dann ist es oft sinnvoll, dass auch
            alle von diesem Buch abhängigen (<foreignphrase
            xml:lang="en">dependent</foreignphrase>) Autoren automatisch
            mitgelöscht werden. Das kann mit <code>:dependent =&gt;
            :destroy</code> in der <filename>app/models/book.rb</filename>
            realisiert werden:<programlisting>class Book &lt; ActiveRecord::Base
  attr_accessible :title

  <emphasis>has_many :authors, :dependent =&gt; :destroy</emphasis>
end</programlisting></para>

            <para>Im folgenden Beispiel löschen wir das erste Buch in der
            Datenbank-Tabelle. Dabei werden automatisch alle Autoren dieses
            Buches ebenfalls gelöscht:<screen>MacBook:bookshelf xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>Book.first</command>
  Book Load (0.2ms)  SELECT "books".* FROM "books" LIMIT 1
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-07 07:44:53", updated_at: "2012-05-07 07:44:53"&gt; 
1.9.3p194 :002 &gt; <command>Book.first.authors</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" LIMIT 1
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 1
 =&gt; [#&lt;Author id: 1, book_id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-07 07:44:53", updated_at: "2012-05-07 07:44:53"&gt;] 
1.9.3p194 :003 &gt; <command>Book.first.destroy</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" LIMIT 1
   (0.1ms)  begin transaction
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" WHERE "authors"."book_id" = 1
  SQL (4.6ms)  DELETE FROM "authors" WHERE "authors"."id" = ?  [["id", 1]]
  SQL (0.2ms)  DELETE FROM "books" WHERE "books"."id" = ?  [["id", 1]]
   (3.8ms)  commit transaction
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-07 07:44:53", updated_at: "2012-05-07 07:44:53"&gt; 
1.9.3p194 :004 &gt; <command>Author.exists?(1)</command>
  Author Exists (0.2ms)  SELECT 1 FROM "authors" WHERE "authors"."id" = 1 LIMIT 1
 =&gt; false 
1.9.3p194 :005 &gt; <command>exit</command>
MacBook:bookshelf xyz$</screen></para>

            <important>
              <indexterm>
                <primary>ActiveRecord</primary>

                <secondary>Methoden</secondary>

                <tertiary>destroy()</tertiary>
              </indexterm>

              <indexterm>
                <primary>ActiveRecord</primary>

                <secondary>Methoden</secondary>

                <tertiary>delete()</tertiary>
              </indexterm>

              <para>Bitte denken Sie immer an den Unterschied zwischen den
              Methoden <methodname>destroy</methodname> (siehe <xref
              linkend="activerecord_destroy"/>) und
              <methodname>delete</methodname> (siehe <xref
              linkend="activerecord_delete"/>). Diese Abhängigkeit
              funktioniert nur mit der Methode
              <methodname>destroy</methodname>.</para>
            </important>
          </listitem>

          <listitem xml:id="activerecord_has_many_through">
            <para xml:id="activerecord_has_many_through.title"><emphasis
            role="bold"><code>:has_many .. :through</code></emphasis></para>

            <indexterm>
              <primary>ActiveRecord</primary>

              <secondary>Relationen</secondary>

              <tertiary>has_many()</tertiary>
            </indexterm>

            <para>Hier muss ich etwas weiter ausholen: Bei unserem
            Buch-Autoren-Beispiel wird Ihnen aufgefallen sein, das wir Autoren
            im Zweifelsfall mehrfach in der <varname>authors</varname> Tabelle
            eintragen. Im Sinne einer guten Normalisierung ist das nicht. Es
            wäre schöner, jeden Autor nur einmal in der authors Tabelle
            einzutragen und die Verknüpfung mit den Büchern über eine
            Zwischentabelle zu regeln. Genau dafür gibt es <code>has_many
            <replaceable>…</replaceable>, :through =&gt;
            <replaceable>…</replaceable></code>.</para>

            <para>Fangen wir bei null mit einer neuen Rails Applikation
            an:<screen>MacBook:~ xyz$ <command>rails new bookshelf2</command>
[...]
MacBook:~ xyz$ <command>cd bookshelf2</command>
MacBook:bookshelf2 xyz$</screen></para>

            <para>Jetzt legen wir wieder die Modelle für
            <classname>Book</classname> und <classname>Author</classname> an.
            Beim Author lassen wir aber die <varname>book_id</varname>
            weg:<screen>MacBook:bookshelf2 xyz$ <command>rails generate model book title</command>
      invoke  active_record
      create    db/migrate/20120507085137_create_books.rb
      create    app/models/book.rb
      invoke    test_unit
      create      test/unit/book_test.rb
      create      test/fixtures/books.yml
MacBook:bookshelf2 xyz$ <command>rails generate model author first_name last_name</command>
      invoke  active_record
      create    db/migrate/20120507085158_create_authors.rb
      create    app/models/author.rb
      invoke    test_unit
      create      test/unit/author_test.rb
      create      test/fixtures/authors.yml
MacBook:bookshelf2 xyz$</screen></para>

            <para>Zum Schluss erstellen wir ein Model
            <classname>Authorship</classname>, das ein Feld
            <varname>book_id</varname> und ein Feld
            <varname>author_id</varname> enthält:<screen>MacBook:bookshelf2 xyz$ <command>rails generate model authorship book_id:integer author_id:integer</command>
      invoke  active_record
      create    db/migrate/20120507085358_create_authorships.rb
      create    app/models/authorship.rb
      invoke    test_unit
      create      test/unit/authorship_test.rb
      create      test/fixtures/authorships.yml
MacBook:bookshelf2 xyz$</screen></para>

            <para>Danach ein <command>rake db:migrate</command><screen>MacBook:bookshelf2 xyz$ <command>rake db:migrate</command>
[...]
MacBook:bookshelf2 xyz$ </screen></para>

            <para><classname>Authorship</classname> verknüpfen wir per
            <methodname>belongs_to</methodname> mit
            <classname>Book</classname> und <classname>Author</classname> in
            der Datei
            <filename>app/models/authorship.rb</filename><programlisting>class Authorship &lt; ActiveRecord::Base
  attr_accessible :author_id, :book_id

<emphasis>  belongs_to :author
  belongs_to :book</emphasis>
end</programlisting></para>

            <para>In der <filename>app/models/book.rb</filename> verknüpfen
            wir jetzt mit has_many die <varname>books</varname> mit den
            <varname>authorships</varname> und danach mit <code>has_many
            :authors, :through =&gt; :authorships</code> die
            <varname>authors</varname> über die <varname>authoships</varname>
            mit den <varname>books</varname>:<programlisting>class Book &lt; ActiveRecord::Base
  attr_accessible :title

  has_many :authorships
  <emphasis>has_many :authors, :through =&gt; :authorships</emphasis>
end</programlisting></para>

            <para>Um den umgekehrten Weg auch gehen zu können, fügen wir in
            der <filename>app/models/author.rb</filename> das gleiche
            Konstrukt ein:<programlisting>class Author &lt; ActiveRecord::Base
  attr_accessible :first_name, :last_name

  has_many :authorships
  <emphasis>has_many :books, :through =&gt; :authorships</emphasis>
end
</programlisting></para>

            <para>Jetzt legen wir ein Buch an:<screen>MacBook:bookshelf2 xyz$ <command>rails console</command>
Loading development environment (Rails 3.2.3)
1.9.3p194 :001 &gt; <command>book = Book.create(:title =&gt; 'Homo faber')</command>
   (0.1ms)  begin transaction
  SQL (4.8ms)  INSERT INTO "books" ("created_at", "title", "updated_at") VALUES (?, ?, ?)  [["created_at", Mon, 07 May 2012 09:34:34 UTC +00:00], ["title", "Homo faber"], ["updated_at", Mon, 07 May 2012 09:34:34 UTC +00:00]]
   (3.8ms)  commit transaction
 =&gt; #&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-07 09:34:34", updated_at: "2012-05-07 09:34:34"&gt; 
1.9.3p194 :002 &gt; </screen></para>

            <para>Dieses Buch hat noch keinen Autor:<screen>1.9.3p194 :002 &gt; <command>book.authors</command>
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" INNER JOIN "authorships" ON "authors"."id" = "authorships"."author_id" WHERE "authorships"."book_id" = 1
 =&gt; [] 
1.9.3p194 :003 &gt; </screen></para>

            <para>Mit den Methoden <methodname>build</methodname> oder
            <methodname>create</methodname> kann ich einen Autor für dieses
            Buch anlegen:<screen>1.9.3p194 :003 &gt; <command>book.authors.create(:first_name =&gt; 'Max', :last_name =&gt; 'Frisch')</command>
   (0.1ms)  begin transaction
  SQL (0.7ms)  INSERT INTO "authors" ("created_at", "first_name", "last_name", "updated_at") VALUES (?, ?, ?, ?)  [["created_at", Mon, 07 May 2012 09:36:33 UTC +00:00], ["first_name", "Max"], ["last_name", "Frisch"], ["updated_at", Mon, 07 May 2012 09:36:33 UTC +00:00]]
  SQL (0.4ms)  INSERT INTO "authorships" ("author_id", "book_id", "created_at", "updated_at") VALUES (?, ?, ?, ?)  [["author_id", 1], ["book_id", 1], ["created_at", Mon, 07 May 2012 09:36:33 UTC +00:00], ["updated_at", Mon, 07 May 2012 09:36:33 UTC +00:00]]
   (2.6ms)  commit transaction
 =&gt; #&lt;Author id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-07 09:36:33", updated_at: "2012-05-07 09:36:33"&gt; 
1.9.3p194 :004 &gt; </screen></para>

            <para>Jetzt haben wir folgende Einträge in den verschiedenen
            Datenbanktabellen:<screen>1.9.3p194 :004 &gt; <command>Book.all</command>
  Book Load (0.3ms)  SELECT "books".* FROM "books" 
 =&gt; [#&lt;Book id: 1, title: "Homo faber", created_at: "2012-05-07 09:34:34", updated_at: "2012-05-07 09:34:34"&gt;] 
1.9.3p194 :005 &gt; <command>Author.all</command>
  Author Load (0.3ms)  SELECT "authors".* FROM "authors" 
 =&gt; [#&lt;Author id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-07 09:36:33", updated_at: "2012-05-07 09:36:33"&gt;] 
1.9.3p194 :006 &gt; <command>Authorship.all</command>
  Authorship Load (0.3ms)  SELECT "authorships".* FROM "authorships" 
 =&gt; [#&lt;Authorship id: 1, book_id: 1, author_id: 1, created_at: "2012-05-07 09:36:33", updated_at: "2012-05-07 09:36:33"&gt;] 
1.9.3p194 :007 &gt;</screen></para>

            <para>ActiveRecord hat automatisch die Tabelle
            <varname>authorships</varname> mit den Verknüpfungen vom
            <classname>Book</classname> zum <classname>Author</classname>
            gefüllt.</para>

            <para>Wir können uns mit
            <methodname>Book.first.authors</methodname> alle Autoren des
            ersten Buches anzeigen lassen:<screen>1.9.3p194 :007 &gt; <command>Book.first.authors</command>
  Book Load (0.2ms)  SELECT "books".* FROM "books" LIMIT 1
  Author Load (0.2ms)  SELECT "authors".* FROM "authors" INNER JOIN "authorships" ON "authors"."id" = "authorships"."author_id" WHERE "authorships"."book_id" = 1
 =&gt; [#&lt;Author id: 1, first_name: "Max", last_name: "Frisch", created_at: "2012-05-07 09:36:33", updated_at: "2012-05-07 09:36:33"&gt;] 
1.9.3p194 :008 &gt;</screen></para>

            <para>Manchmal ist das create und build Konstrukt etwas
            umständlich. Für diesen Fall können Sie auch einzelne Objekte oder
            ein Array von Objekten mit der Methode
            <methodname>&lt;&lt;</methodname> verknüpfen. Wenn wir z.B. die in
            diesem Kapitel benutzte <filename>db/seeds.rb</filename> auf die
            von uns jetzt erstellte has_many ... through Verknüpfung umstellen
            wollen, so sähe die Datei so aus:<programlisting># ruby encoding: utf-8

Book.create(:title =&gt; 'Homo faber').authors &lt;&lt; Author.find_or_create_by_first_name_and_last_name('Max', 'Frisch')
Book.create(:title =&gt; 'Der Besuch der alten Dame').authors &lt;&lt; Author.find_or_create_by_first_name_and_last_name('Friedrich', 'Dürrenmatt')
Book.create(:title =&gt; 'Julius Shulman: The Last Decade').authors  &lt;&lt; [
  Author.find_or_create_by_first_name_and_last_name('Thomas', 'Schirmbock'),
  Author.find_or_create_by_first_name_and_last_name('Julius', 'Shulman'),
  Author.find_or_create_by_first_name_and_last_name('Jürgen', 'Nogai')
  ]
Book.create(:title =&gt; 'Julius Shulman: Palm Springs').authors &lt;&lt; [
  Author.find_or_create_by_first_name_and_last_name('Michael', 'Stern'),
  Author.find_or_create_by_first_name_and_last_name('Alan', 'Hess')
  ]
Book.create(:title =&gt; 'Photographing Architecture and Interiors').authors &lt;&lt; [
  Author.find_or_create_by_first_name_and_last_name('Julius', 'Shulman'),
  Author.find_or_create_by_first_name_and_last_name('Richard', 'Neutra')
  ]
Book.create(:title =&gt; 'Der Zauberberg').authors &lt;&lt; Author.find_or_create_by_first_name_and_last_name('Thomas', 'Mann')
Book.create(:title =&gt; 'In einer Familie').authors &lt;&lt; Author.find_or_create_by_first_name_and_last_name('Heinrich', 'Mann')</programlisting></para>

            <para>Durch die Benutzung von
            <methodname>find_or_create</methodname> können wir hier sicher
            stellen, das ein Autor nicht zwei mal angelegt wird.</para>

            <para>has_many ... through ist ein sehr kraftvolles Tool in der
            Hand eines guten Programmierers. Ein weiteres Beispiel zur
            Benutzung von has_many ... through finden Sie in <xref
            linkend="ar-many_to_many"/>.</para>
          </listitem>
        </itemizedlist></para>

      <para>Es gibt natürlich noch eine Menge anderer Optionen. Diese können
      Sie sich mit <command>ri
      ActiveRecord::Associations::ClassMethods#has_many</command> auf der
      Shell ausgeben lassen.</para>
    </section>
  </section>
</section>
