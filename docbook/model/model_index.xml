<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="model" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Model - Das M in MVC.</title>

  <section xml:id="model_was_bisher_geschah">
    <title xml:id="model_was_bisher_geschah.title">Was bisher geschah</title>

    <para>Um sicher zu stellen, das wir alle vom gleichen reden (für den Fall
    das Sie gezielt dieses Kapitel aufschlagen), erstellen wir gerade mal im
    Schnelldurchgang eine frische Applikation. Für alle die gerade erst <xref
    linkend="erste_schritte_mit_rails" /> durchgearbeitet haben: Das haben Sie
    schon alles. Für alle anderen: Einfach das Kochrezept abtippen.</para>

    <section>
      <title>Unser Beispielprojekt: Eine Filmdatenbank</title>

      <para>Wir legen das Rails-Projekt <code>movie-app</code> an:<screen>stefan@swmbp 0 head- test$ <command>rails new movie-app</command>
      create  
      create  README
      create  .gitignore
      create  Rakefile
      create  config.ru
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  app/models
      create  app/views/layouts
      create  config
      create  config/routes.rb
      create  config/application.rb

      [...]

      create  test/functional
      create  test/integration
      create  test/unit
      create  tmp
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 head- test$</screen></para>

      <para>Um sicher zu gehen, das alle gems korrekt installiert sind führen
      wir jetzt im neu erstellen Rails-Projekt ein <command>bundle
      install</command> aus:<screen>stefan@swmbp 0 head- test$ <command>cd movie-app</command>
stefan@swmbp 0 head- test$ <command>bundle install</command>
Updating git://github.com/rails/rails.git
Checking out files: 100% (1891/1891), done.
Fetching source index from http://rubygems.org/
Updating git://github.com/rails/rails.git
Using rake (0.8.7) from bundler gems 
Using abstract (1.0.0) from bundler gems 
Using builder (2.1.2) from bundler gems 
Installing i18n (0.4.0.beta1) from .gem files at /Users/rails30/.rvm/gems/ruby-1.9.1-p378/cache 
Using memcache-client (1.8.3) from bundler gems 
Using tzinfo (0.3.20) from bundler gems 
Using activesupport (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using activemodel (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using erubis (2.6.5) from bundler gems 
Using rack (1.1.0) from bundler gems 
Using rack-mount (0.6.3) from bundler gems 
Using rack-test (0.5.3) from bundler gems 
Using actionpack (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using mime-types (1.16) from bundler gems 
Using polyglot (0.3.1) from bundler gems 
Using treetop (1.4.5) from bundler gems 
Using mail (2.2.1) from bundler gems 
Using text-hyphen (1.0.0) from bundler gems 
Using text-format (1.0.0) from bundler gems 
Using actionmailer (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using arel (0.3.3) from bundler gems 
Using activerecord (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using activeresource (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using bundler (0.9.25) from bundler gems 
Using thor (0.13.6) from bundler gems 
Using railties (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using rails (3.0.0.beta3) from git://github.com/rails/rails.git (at master) 
Using sqlite3-ruby (1.2.5) from bundler gems Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
stefan@swmbp 0 head- test$ 
</screen></para>

      <para>Jetzt noch mit Scaffold das Grundgerüst für dieses Kapitel
      erstellen:<screen>stefan@swmbp 0 head- movie-app$ <command>rails generate scaffold movie title:string production_year:integer duration:integer plot:text rating:integer</command>
      invoke  active_record
      create    db/migrate/20100423081205_create_movies.rb
      create    app/models/movie.rb
      invoke    test_unit
      create      test/unit/movie_test.rb
      create      test/fixtures/movies.yml
       route  resources :movies
      invoke  scaffold_controller
      create    app/controllers/movies_controller.rb
      invoke    erb
      create      app/views/movies
      create      app/views/movies/index.html.erb
      create      app/views/movies/edit.html.erb
      create      app/views/movies/show.html.erb
      create      app/views/movies/new.html.erb
      create      app/views/movies/_form.html.erb
      create      app/views/layouts/movies.html.erb
      invoke    test_unit
      create      test/functional/movies_controller_test.rb
      invoke    helper
      create      app/helpers/movies_helper.rb
      invoke      test_unit
      create        test/unit/helpers/movies_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
stefan@swmbp 0 head- movie-app$</screen></para>

      <para>Zum Schluss legen wir die Datenbank im Entwicklungssystem
      an:<screen>stefan@swmbp 0 head- movie-app$ <command>rake db:migrate</command>
(in /Users/stefan/Development/test/movie-app)
==  CreateMovies: migrating ===================================================
-- create_table(:movies)
   -&gt; 0.0013s
==  CreateMovies: migrated (0.0014s) ==========================================

stefan@swmbp 0 head- movie-app$</screen></para>
    </section>

    <section xml:id="model_seed_rb">
      <title xml:id="model_seed_rb.title">Beispieldaten mit seed.rb
      einspielen</title>

      <para>Um gleich mit der Arbeit anfangen zu können, betanken wir unsere
      Filmdatenbank mit ein paar Beispielfilmen.</para>

      <para>Bitte schreiben Sie mit dem Editor Ihrer Wahl den folgenden Inhalt
      in die <filename>db/seeds.rb</filename> Datei:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#   
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Major.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Movie.create({ :title =&gt; 'The Terminator', :production_year =&gt; 1984 })
Movie.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })
Movie.create({ :title =&gt; 'Terminator Salvation', :production_year =&gt; 2009 })
Movie.create({ :title =&gt; 'Rain Man', :production_year =&gt; 1988, :rating =&gt; 5 })
Movie.create({ :title =&gt; 'War of the Worlds', :production_year =&gt; 2005, :rating =&gt; 4 })
Movie.create({ :title =&gt; 'Collateral', :production_year =&gt; 2004, :rating =&gt; 5})
Movie.create({ :title =&gt; 'Miami Vice', :production_year =&gt; 2006, :rating =&gt; 5})
Movie.create({ :title =&gt; 'Hancock', :production_year =&gt; 2008, :rating =&gt; 4})
Movie.create({ :title =&gt; 'The Aviator', :production_year =&gt; 2004, :rating =&gt; 4})
Movie.create({ :title =&gt; 'Some Like It Hot', :production_year =&gt; 1959, :rating =&gt; 5})
Movie.create({ :title =&gt; 'W.', :production_year =&gt; 2008, :rating =&gt; 4})
Movie.create({ :title =&gt; 'Iron Man', :production_year =&gt; 2008, :rating =&gt; 5})
Movie.create({ :title =&gt; 'The Dark Knight', :production_year =&gt; 2008, :rating =&gt; 5})
</programlisting></para>

      <para>Danach befühlen wir unser Entwicklungssystem mit diesen
      Daten:<screen>stefan@swmbp 0 head- movie-app$ <command>rake db:seed</command>
(in /Users/stefan/Development/test/movie-app)
stefan@swmbp 0 head- movie-app$</screen></para>

      <para>Fertig. Jetzt haben wir ein gutes Grundgerüst für dieses
      Kapitel.</para>
    </section>
  </section>

  <section xml:id="model_orientierung">
    <title xml:id="model_orientierung.title">Orientierung</title>

    <para>Ein Hauptvorteil von Rails ist die klare Struktur des
    Rails-Projektes. Wenn Sie neu in ein Team eintretten oder von einem
    befreundeten Rails-Entwickler ein Projekt übernehmen, dann können Sie sich
    sehr schnell einen Überblick verschaffen. Die Definition der Models finden
    Sie immer im Verzeichnis <filename>app/models</filename><screen>stefan@swmbp 0 head- movie-app$ <command>ls app/models</command>
movie.rb
stefan@swmbp 0 head- movie-app$</screen></para>

    <para>Aktuell haben wir nur ein Model (movie). Bei grösseren
    Rails-Projekten sind entsprechend mehr Modelle enthalten. Die die
    <filename>app/models/movie.rb</filename> Datei sieht nach dem Scaffolding
    so aus:<programlisting>class Movie &lt; ActiveRecord::Base
end</programlisting></para>

    <para>An Movie &lt; ActiveRecord::Base erkennen wir, das es sich bei
    diesem Model um eine Klasse handelt, die auf die Klasse ActiveRecord
    aufbaut. Wir bekommen also alles was ActiveRecord von Haus enthält erst
    mal kostenlos mitgeliefert. Alle von uns gewünschten Erweiterungen werden
    On-Top auf diese Klasse gesetzt. Falls Ihnen dieses Prinzip nicht mehr
    ganz geläufig ist, sollten Sie noch mal in <xref linkend="ruby-class" />
    nachschlagen. Das Verständnis für diesen Mechanismus ist ziemlich
    essentiell für den erfolgreichen Einsatz von Rails.</para>
  </section>

  <section xml:id="model_validierungen">
    <title xml:id="model_validierungen.title">Validierungen</title>

    <para>Unser aller Albtraum sind User die Daten eingeben, mit denen wir als
    Programmierer nicht gerechnet haben. Und wem ist das noch nicht passiert!?
    In Rails haben wir ein ausgeklügeltes und einfach zu programmierendes
    Validierungssystem, mit dem wir solche Eingabefehler abfangen
    können.</para>

    <para>In unserer Filmdatenbank haben wir ein Feld, das auf jeden Fall
    ausgefüllt werden soll: Der Titel (<code>title</code>) des Films. Die
    Validierungsregel dafür gehört in die
    <filename>app/models/movie.rb</filename> Datei:<programlisting>class Movie &lt; ActiveRecord::Base
  validates_presence_of :title
end</programlisting></para>

    <para>Probieren wir das mal aus und starten dafür den
    Rails-Server:<screen>stefan@swmbp 0 head- movie-app$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0.beta2 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-04-23 10:56:16] INFO  WEBrick 1.3.1
[2010-04-23 10:56:16] INFO  ruby 1.9.2 (2010-04-11) [x86_64-darwin10.3.0]
[2010-04-23 10:56:16] INFO  WEBrick::HTTPServer#start: pid=20907 port=3000
</screen></para>

    <para>Jetzt gehen wir mit dem Browser auf die URI <uri
    xlink:href="http://0.0.0.0:3000/movies/new">http://0.0.0.0:3000/movies/new</uri>
    und tragen die Daten zu einem Film ohne Titel ein:<screenshot>
        <info>
          <title>Neuen Film ohne Titel eingeben.</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/movies_new_validation_1.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Nach dem klicken auf "Create Movie" gekommen wir folgende
    Fehlermeldung angezeigt:<screenshot>
        <info>
          <title>Validierungsfehlermeldung bei fehlendem Titel</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/movies_new_validation_2.jpg"></imagedata>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Was ist hier passiert? Schauen wir uns im Controller
    <filename>app/controllers/movies_controller.rb</filename> die
    <methodname>create</methodname> Methode an:<programlisting>  # POST /movies
  # POST /movies.xml
  def create
    @movie = Movie.new(params[:movie])

    respond_to do |format|
      if @movie.save
        format.html { redirect_to(@movie, :notice =&gt; 'Movie was successfully created.') }
        format.xml  { render :xml =&gt; @movie, :status =&gt; :created, :location =&gt; @movie }
      else
        format.html { render :action =&gt; "new" }
        format.xml  { render :xml =&gt; @movie.errors, :status =&gt; :unprocessable_entity }
      end
    end
  end
</programlisting></para>

    <para>Es wurde ein neues Movie Objekt erstellt (<code>@movie</code>). Beim
    Abspeichern (<methodname>@movie.save</methodname>) kam es dann zu einem
    Fehler und deshalb kam als Ergebnis <code>false</code> und die
    if-else-Kondition sprang auf <code>else</code>. Deshalb wurde mittels
    <code>redirect_to</code> die <methodname>new</methodname> Methode
    aufgerufen (siehe <xref linkend="redirects" />). So weit klar, aber es
    stellt sich die Frage, wo die Fehlermeldung "Title can't be blank"
    herkommt.</para>

    <para>Rein View-technisch ist die Antwort einfach. Im von
    <filename>app/views/movies/edit.html.erb</filename> und
    <filename>app/views/movies/new.html.erb</filename> benutzen Partial (siehe
    <xref linkend="partials" />)
    <filename>app/views/movies/_form.html.erb</filename> steht in der zweiten
    Zeile<programlisting>&lt;%= f.error_messages %&gt;
</programlisting></para>

    <para>Das sind die Fehler die bei der Erzeugung eines neuen ActiveRecord
    Objektes entstanden sind.</para>

    <para>Wir machen am besten mal auf der Console (siehe <xref
    linkend="die_console" />) weiter:<screen>stefan@swmbp 0 head- movie-app$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta2)
ruby-head &gt;</screen></para>

    <para>Jetzt gernerien wir ein eines Movie-Objekt und befüllen es mit
    einigen Werten:<screen>ruby-head &gt; <command>pulp_fiction = Movie.new</command>
 =&gt; #&lt;Movie id: nil, title: nil, production_year: nil, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt; 
ruby-head &gt; <command>pulp_fiction.production_year = 1994</command>
 =&gt; 1994 
ruby-head &gt; <command>pulp_fiction.duration = 154</command>
 =&gt; 154 
ruby-head &gt; </screen></para>

    <para>Wenn wir das Movie-Objekt mit der Methode
    <methodname>save</methodname> abspeichern wollen, dann bekommen wir eine
    Fehlermeldung:<screen>ruby-head &gt; <command>pulp_fiction.save</command>
 =&gt; false 
ruby-head &gt;</screen></para>

    <para>Die Fehlermeldungen werden mit der Methode
    <methodname>errors</methodname> ausgegeben:<screen>ruby-1.9.2-p-1 &gt; <command>pulp_fiction.errors</command>
 =&gt; {:title=&gt;["can't be blank"]} 
ruby-1.9.2-p-1 &gt;</screen>Aus purer Neugierde schauen wir uns noch die
    Klasse dieser Ausgabe an:<screen>ruby-1.9.2-p-1 &gt; <command>pulp_fiction.errors.class</command>
 =&gt; ActiveModel::Errors 
ruby-1.9.2-p-1 &gt;</screen></para>

    <para>Ist also kein Array oder Hash. Aber wir können mit den normalen
    Iterator-Methoden drauf zugreifen:<screen>ruby-1.9.2-p-1 &gt; <command>pulp_fiction.errors.first</command>
 =&gt; [:title, "can't be blank"] 
ruby-1.9.2-p-1 &gt; <command>pulp_fiction.errors.first.class</command>
 =&gt; Array 
ruby-1.9.2-p-1 &gt;</screen></para>

    <para>Aber zurück zum eigentlichen Thema. Da wir in
    <filename>app/models/movie.rb</filename> die folgende Validierungsregel
    eingebaut haben, bekommen wir die obige Fehlermeldung und können das
    Objekt nicht abspeichern.<programlisting>class Movie &lt; ActiveRecord::Base
  validates_presence_of :title
end</programlisting></para>

    <para>Das coole daran ist, das wir uns in der gesamten Rails-Applikation
    darauf verlassen können. Es gibt keinen Weg die Validierung zu umgehen.
    hmmm... OK, das war jetzt eine kleine Lüge. Wir können die Validierung mit
    der Methode <methodname>save_without_validation</methodname>
    umgehen:<screen>ruby-1.9.2-p-1 &gt; <command>pulp_fiction.save_without_validation</command>
 =&gt; true 
ruby-1.9.2-p-1 &gt;</screen></para>

    <para>Aber bitte vergessen Sie das mit dem
    <methodname>save_without_validation</methodname> ganz schnell wieder!
    Validierung ist nicht nur zum Schutz vor Falscheingaben durch den User
    praktisch, sondern auch zum Schutz vor Fehler in der
    Programmierung.</para>

    <para>Führen wir unser Beispiel noch zu Ende und fügen den Titel
    hinzu:<screen>ruby-1.9.2-p-1 &gt; <command>pulp_fiction.save</command>
 =&gt; false 
ruby-1.9.2-p-1 &gt; <command>pulp_fiction.title = 'Pulp Fiction'</command>
 =&gt; "Pulp Fiction" 
ruby-1.9.2-p-1 &gt; <command>pulp_fiction.save</command>
 =&gt; true 
ruby-1.9.2-p-1 &gt;</screen></para>

    <para>Schauen wir uns noch gerade die Ausgabe der
    <methodname>errors</methodname> Methode an:<screen>ruby-1.9.2-p-1 &gt; <command>pulp_fiction.errors</command>
 =&gt; {} 
ruby-1.9.2-p-1 &gt;</screen></para>

    <section xml:id="eingebaute_validierungs_methoden">
      <title xml:id="eingebaute_validierungs_methoden.title">Eingebaute
      Validierungs-Methoden</title>

      <para>ActiveRecord kommt mit einem Satz von fertigen
      Validierungs-Methoden, die man immer wieder braucht. Die wichtigsten
      gehen wir hier Methode für Methode durch. Diesen Abschnitt können Sie
      auch schnell überfliegen und im Fall des Falles noch mal hier
      nachschlagen.</para>

      <section>
        <title
        xml:id="validates_presence_of.title">validates_presence_of</title>

        <para>Mit <methodname>validates_presence_of</methodname> können Sie
        festlegen, das ein bestimmtes Feld präsent also ausgefüllt sein muss.
        Das Filmdatenbank-Beispiel dazu:<programlisting>class Movie &lt; ActiveRecord::Base
  <emphasis>validates_presence_of :title</emphasis>
end</programlisting></para>

        <para>Denn ohne einen Titel macht ein Filmeintrag keinen Sinn.</para>

        <section>
          <title>Wichtige Optionen</title>

          <para><itemizedlist>
              <listitem>
                <para><code>:message</code></para>

                <para>Gibt eine eigene Fehlermeldung aus. Default ist "can't
                be blank".</para>

                <para><example>
                    <title>Anwendung der :message Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_presence_of :title, <emphasis>:message =&gt; "darf nicht leer sein"</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:on</code></para>

                <para>Spezifiziert, wann die Validierung ausgeführt werden
                soll. Default ist <code>:save</code>.</para>

                <para>Mögliche Optionen:<itemizedlist>
                    <listitem>
                      <para><code>:update</code></para>

                      <para>Nur bei einem Update des Datensatzes wird
                      validiert.</para>
                    </listitem>

                    <listitem>
                      <para><code>:create</code></para>

                      <para>Nur beim ersten Abspeichern, also beim initialen
                      Erstellen des Datensatzes, wird validiert.</para>
                    </listitem>

                    <listitem>
                      <para><code>:save</code></para>

                      <para><code>:save</code> ist die Kombination zwischen
                      <code>:update</code> und <code>:create</code>. Es wird
                      also immer validiert.</para>
                    </listitem>
                  </itemizedlist></para>

                <para><example>
                    <title>Anwendung der :on Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_presence_of :title, <emphasis>:on =&gt; :create</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>

      <section xml:id="validates_uniqueness_of">
        <title
        xml:id="validates_uniqueness_of.title">validates_uniqueness_of</title>

        <para>Mit <methodname>validates_uniqueness_of</methodname> können Sie
        festlegen, das ein bestimmtes Feld in der gesamten Datenbank nur
        einmal einen einzelnen Wert enthalten darf. Er muss also immer unique
        (einzigartig) sein. Wenn wir in unserer Filmdatenbank jeden Filmtitel
        nur einmal aufnehmen wollen, dann wäre die entsprechende
        Validierung:<programlisting>class Movie &lt; ActiveRecord::Base
  validates_presence_of :title
  <emphasis>validates_uniqueness_of :title</emphasis>
end
</programlisting></para>

        <para>Ich würde aber auf Nummer sicher gehen und die
        <code>:case_sensitive =&gt; false</code> Option
        benutzen:<programlisting>class Movie &lt; ActiveRecord::Base
  validates_presence_of :title
  validates_uniqueness_of :title<emphasis>, :case_sensitive =&gt; false</emphasis>
end
</programlisting></para>

        <para>Per default ist <code>:case_sensitive</code> immer auf
        <code>true</code> gesetzt, deshalb müssen wir es hier auf
        <code>false</code> setzen, um sicher zu stellen, das auch Filmtitel,
        die nur unterschiedlich Gross und Klein geschrieben wurden trotzdem
        unique sind.</para>

        <section>
          <title>Wichtige Optionen</title>

          <para><itemizedlist>
              <listitem>
                <para><code>:message</code></para>

                <para>Gibt eine eigene Fehlermeldung aus. Default ist "has
                already been taken".<example>
                    <title>Anwendung der :message Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_uniqueness_of :title, <emphasis>:message =&gt; "muss in der Datenbank einmalig sein"</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:case_sensitive</code></para>

                <para>Definiert, ob die Einzigartigkeit (uniqueness) des
                Feldes inklusive Gross- und Kleinschreibung definiert ist.
                Default ist <code>true</code>.<example>
                    <title>Anwendung der :case_sensitive Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_uniqueness_of :title, <emphasis>:case_sensitive =&gt; false</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:allow_nil</code></para>

                <para>Definiert, ob ein Eintrag auch nil sein darf. Ein
                solcher Eintrag wäre dann genau einmal möglich. Default ist
                <code>false</code>.<example>
                    <title>Anwendung der :allow_nil Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_uniqueness_of :title, <emphasis>:allow_nil =&gt; true</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:allow_blank</code></para>

                <para>Definiert, ob ein Eintrag auch leer sein darf. Ein
                solcher Eintrag wäre dann genau einmal möglich. Default ist
                <code>false</code>.<example>
                    <title>Anwendung der :allow_blank Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_uniqueness_of :title, <emphasis>:allow_blank =&gt; true</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>

      <section xml:id="validates_numericality_of">
        <title
        xml:id="validates_numericality_of.title">validates_numericality_of</title>

        <para>Mit <code>validates_numericality_of</code> wird überprüft, ob
        der Eintrag eine Zahl ist. In unserer Filmdatenbank würde das auf das
        Feld <code>production_year</code> passen:<programlisting>class Movie &lt; ActiveRecord::Base
  <emphasis>validates_numericality_of :production_year</emphasis>
end
</programlisting></para>

        <para>Allerdings wäre das nur die halbe Miete. Denn
        <code>validates_numericality_of</code> überprüft per Default nur, ob
        es sich um eine Zahl handelt. Wir möchten aber eine ganze Zahl (also
        Integer). Entsprechend müssten wir folgende Validierung
        benutzen:<programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:only_integer =&gt; true</emphasis>
end
</programlisting></para>

        <para>Aber es geht noch weiter, denn eigentlich sind nur die Jahre
        1895 (erster Stummfilm) bis heute interessant. Das können wir
        ebenfalls in die Validierung mit aufnehmen:<programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, 
                            :only_integer =&gt; true,
                            :greater_than =&gt; 1894,
                            :less_than =&gt; Date.today.year + 1
end
</programlisting></para>

        <para>Analyse:<itemizedlist>
            <listitem>
              <para><code>:only_integer =&gt; true</code></para>

              <para>Nur ganze Zahlen werden aktzeptiert (Integer).</para>
            </listitem>

            <listitem>
              <para><code>:greater_than =&gt; 1894</code></para>

              <para>Die Zahl muss grösser als 1894 sein, weil der erste
              Stummfilm im Jahr 1895 veröffentlicht wurde.</para>
            </listitem>

            <listitem>
              <para><code>:less_than =&gt; Date.today.year + 1</code></para>

              <para>Jetzt wird es wirklich cool! ;-) Da ein Film in unserer
              Datenbank schlecht aus der Zukunft sein kann, nehmen wir das
              aktuelle Jahr mit <code>Date.today.year</code> und addieren 1.
              Damit definieren wir dann, das das <code>production_year</code>
              niedriger sein muss.</para>
            </listitem>
          </itemizedlist></para>

        <section>
          <title>Wichtige Optionen</title>

          <para><itemizedlist>
              <listitem>
                <para><code>:message</code></para>

                <para>Gibt eine eigene Fehlermeldung aus. Default ist "is not
                a number".<example>
                    <title>Anwendung der :message Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :title, <emphasis>:message =&gt; "muss eine Zahl sein"</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:on</code></para>

                <para>Spezifiziert, wann die Validierung ausgeführt werden
                soll. Default ist <code>:save.</code></para>

                <para>Mögliche Optionen:<itemizedlist>
                    <listitem>
                      <para><code>:update</code></para>

                      <para>Nur bei einem Update des Datensatzes wird
                      validiert.</para>
                    </listitem>

                    <listitem>
                      <para><code>:create</code></para>

                      <para>Nur beim ersten Abspeichern, also beim initialen
                      Erstellen des Datensatzes, wird validiert.</para>
                    </listitem>

                    <listitem>
                      <para><code>:save</code></para>

                      <para><code>:save</code> ist die Kombination zwischen
                      <code>:update</code> und <code>:create</code>. Es wird
                      also immer validiert.</para>
                    </listitem>
                  </itemizedlist></para>

                <para><example>
                    <title>Anwendung der :on Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :title, <emphasis>:on =&gt; :create</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:only_integer</code></para>

                <para>Lässt nur ganze Zahlen zu. Default ist
                <code>false</code> (das heißt es dürfen auch Real
                abgespeichert werden).</para>
              </listitem>

              <listitem>
                <para><code>:greater_than</code></para>

                <para>Stellt sicher, das die Zahl grösser als der hier
                angegebene Wert ist.<example>
                    <title>Anwendung der :greater_than Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:greater_than =&gt; 1894</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:greater_than_or_equal_to</code></para>

                <para>Stellt sicher, das die Zahl grösser oder gleich des
                angegebene Wertes ist.<example>
                    <title>Anwendung der :greater_than_or_equal_to
                    Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:greater_than_or_equal_to =&gt; 1895</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:less_than</code></para>

                <para>Stellt sicher, das die Zahl kleiner als der hier
                angegebene Wert ist.<example>
                    <title>Anwendung der :less_than Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:less_than =&gt; 2011</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:less_than_or_equal_to</code></para>

                <para>Stellt sicher, das die Zahl kleiner oder gleich des
                angegebenen Wertes ist.<example>
                    <title>Anwendung der :less_than_or_equal_to Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:less_than_or_equal_to =&gt; 2010</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:equal_to</code></para>

                <para>Stellt sicher, das die Zahl gleich der angegebenen Zahl
                ist.<example>
                    <title>Anwendung der :equal_to Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:equal_to =&gt; 2000</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:odd</code></para>

                <para>Stellt sicher, das die Zahl immer ungerade ist. Default
                ist <code>false</code>.<example>
                    <title>Anwendung der :odd Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:odd =&gt; true</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>

              <listitem>
                <para><code>:even</code></para>

                <para>Stellt sicher, das die Zahl immer gerade ist. Default
                ist <code>false</code>.<example>
                    <title>Anwendung der :even Option</title>

                    <para><programlisting>class Movie &lt; ActiveRecord::Base
  validates_numericality_of :production_year, <emphasis>:even =&gt; true</emphasis>
end
</programlisting></para>
                  </example></para>
              </listitem>
            </itemizedlist></para>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Dieses Kapitel ist noch nicht fertig gestellt</title>

    <para>Ich veröffentlich nicht jeden frisch geschriebenen Satz, aber jeden
    in sich selbst schon logischen Teil. Das heißt aber nicht, das dieser Teil
    auch schon abgeschlossen oder gar final ist. Oft schaue ich mir ein
    Kapitel ein paar Tage später an und sage mir "das geht besser" oder "das
    ist so nicht richtig rund". Entweder werfe ich den Text dann ganz raus
    oder ändere ihn ab.</para>

    <para><emphasis>Deshalb: Bitte regelmässig auf der Webseite nach Updates
    schauen. Zu diesem Kapitel wird es noch einiges geben.</emphasis></para>
  </section>
</chapter>
