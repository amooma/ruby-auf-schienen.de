<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="activerecord_chapter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_chapter.title">ActiveRecord</title>

  <para>ActiveRecord ist eine Abstaktionsschicht, die es uns leichten Zugang
  zu einer SQL-Datenbank gibt. Einer der Erfolgsrezepte von Rails ist
  sicherlich die Benutzung von ActiveRecord. Die Programmierung und Benutzung
  "fühlt sich gut an" und es ist viel weniger fehleranfällig als pures SQL.
  Bei der Arbeit mit diesem Kapitel hilft SQL-Wissen, aber es wird nicht
  vorrausgesetzt und es ist auch für die Arbeit mit ActiveRecord nicht
  notwendig.</para>

  <section>
    <title>Howto zum Kapitel</title>

    <para>Dieses Kapitel ist in sich selbst geschlossen. Allerdings wird die
    vorherige Lektüre von <xref linkend="ruby-grundlagen" /> und <xref
    linkend="erste_schritte_mit_rails" /> vorausgesetzt. Ohne wird es nicht
    gehen.</para>

    <para>Der Rails-Anfänger sollte das Kapitel einmal von oben bis unten
    durcharbeiten. Das heißt konkret: Alle Schritte in der eigenen Console mit
    ausprobieren und ruhig selber links und recht mal ein wenig
    experimentieren. Einfach hin und wieder zwei mal auf die Tab-Taste drücken
    und sich eine Liste der jeweils verfügbaren Methoden anzeigen
    lassen.</para>

    <para>Am Anfang eines Themas werde ich Ihnen in der Rails Console (siehe
    <xref linkend="die_console" />) zeigen wie die Grundlagen funktionieren.
    Am Ende des entsprechenden Themas werden wir dann das erlernte Wissen in
    das Webinterface der Rails-Applikations übertragen.<warning>
        <para>Es geht in diesem Kapitel um ActiveRecord. Deshalb: Um die
        Beispiele so übersichtlich wie möglich zu halten, werde ich deshalb
        keine Validierung (siehe <xref linkend="model_validierungen" />) und
        auch keine Tests (siehe <xref linkend="tests" />) einbauen. Ebenso
        verzichte ich in diesem Beispiel auf ein Rechtemodel.</para>
      </warning></para>

    <section>
      <title>Keine Lust auf SQL?</title>

      <para>Hin und wieder werde ich den durch eine ActiveRecord Methode
      erzeugten SQL-Code im Logfile nachschlagen. Wenn Sie sich nicht für SQL
      interessieren: Einfach überlesen. Das schöne an ActiveRecord ist ja das
      man sich darum keinen Kopf machen muss. Für alle anderen dient es zum
      besseren Verständnis der im Hintergrund laufenden Optimierungen.</para>

      <tip>
        <para>Wenn Sie sich für diese Optimierung interessieren, so empfehle
        ich Ihnen bei diesen Übungen und auch später bei der Entwicklung immer
        noch ein zweites Terminal mit einem <command>tail -f
        log/development.log</command> laufen zu lassen. Dort sehen Sie dann
        immer, was gerade auf Datenbank-Ebene abläuft.</para>
      </tip>
    </section>
  </section>

  <section>
    <title>Datenbank/Model anlegen</title>

    <para>Auch wenn ich mich nicht für Musik interessiere, sind Musikalben für
    ein Datenbankbeispiel sehr gut geeignet. Die benutzen Daten entnehme ich
    dabei der Wikipedia-Seite <uri
    xlink:href="http://en.wikipedia.org/wiki/The_500_Greatest_Albums_of_All_Time">http://en.wikipedia.org/wiki/The_500_Greatest_Albums_of_All_Time</uri></para>

    <para>Legen wir erst mal ein neues Rails-Projekt an:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new jukebox</command>
      create  
      create  README
      create  Rakefile
      [...]
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd jukebox</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
Using abstract (1.0.0) 
[...]
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Schauen wir uns mal die Hilfeseite von <command>rails generate
    model</command> an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails generate model</command>
Usage:
  rails generate model NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME  # Orm to be invoked
                  # Default: active_record

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Create rails files for model generator.
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Das kling alles halbwegs logisch. Leben wir also das Model
    <classname>album</classname> an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails generate model album position:integer name:string release_year:integer</command>
      invoke  active_record
      create    db/migrate/20100902194019_create_albums.rb
      create    app/models/album.rb
      invoke    test_unit
      create      test/unit/album_test.rb
      create      test/fixtures/albums.yml
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Rails hat ein Datenbank-Migrations-File mit dem Namen
    <filename>db/migrate/20100902194019_create_albums.rb</filename> angelegt.
    In dieser Datei wird eine Klasse <classname>CreateAlbums</classname> als
    Tochter von <classname>ActiveRecord::Migration</classname> definiert. Die
    Methoden <methodname>self.up</methodname> und
    <methodname>self.down</methodname> werden benutzt, um eine Migration oder
    den dazu gehörigen Roll-Back zu definieren.<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>cat db/migrate/20100902194019_create_albums.rb</command>
class CreateAlbums &lt; ActiveRecord::Migration
  def self.up
    create_table :albums do |t|
      t.integer :position
      t.string :name
      t.integer :release_year

      t.timestamps
    end
  end

  def self.down
    drop_table :albums
  end
end
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Mit <command>rake db:migrate</command> können wir die entsprechende
    Datenbank anlegen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake db:migrate</command>
(in /Users/stefan/jukebox)
==  CreateAlbums: migrating ===================================================
-- create_table(:albums)
   -&gt; 0.0015s
==  CreateAlbums: migrated (0.0016s) ==========================================

stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Schauen wir mal in die Datei
    <filename>app/models/album.rb</filename>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>cat app/models/album.rb</command> 
class Album &lt; ActiveRecord::Base
end
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>hmmm... die Klasse Album ist also eine Tochter von
    ActiveRecord::Base. Logisch, da wir ja in diesem Kapitel ActiveRecord
    besprechen. ;-)</para>

    <para>Die eingebaute Hilfeseite zu
    <classname>ActiveRecord::Base</classname> ist etwas länger:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>ri -T ActiveRecord::Base | wc -l</command>
     454
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Deshalb werde ich sie hier nicht abbilden und überlasse es Ihrer
    Neugierde einmal <command>ri ActiveRecord</command> aufzurufen.</para>

    <section>
      <title>Datensätze hinzufügen</title>

      <para>Neue Datensätze können mit verschiedenen Methoden erstellt werden.
      Schauen wir uns als erstes mal die <methodname>create</methodname>
      Methode an. Wie immer gibt es dazu eine eigene kleine Hilfeseite im
      System:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>ri -T ActiveRecord::Base.create</command>
ActiveRecord::Base.create

(from gem activerecord-3.0.0)
------------------------------------------------------------------------------
  create(attributes = nil) { |object| ... }

------------------------------------------------------------------------------

Creates an object (or multiple objects) and saves it to the database, if
validations pass. The resulting object is returned whether the object was
saved successfully to the database or not.

The attributes parameter can be either be a Hash or an Array of Hashes.
 These Hashes describe the attributes on the objects that are to be created.

Examples
  # Create a single new object
  User.create(:first_name =&gt; 'Jamie')

  # Create an Array of new objects
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])

  # Create a single object and pass it into a block to set other attributes.
  User.create(:first_name =&gt; 'Jamie') do |u|
    u.is_admin = false
  end

  # Creating an Array of new objects using a block, where the block is executed for each object:
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
    u.is_admin = false
  end


stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Super, direkt mit Beispielen! Was will man mehr? Versuchen wir mal
      so in der Console die ersten 3 Alben einzutragen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.create(:position =&gt; 1, :name =&gt; "Sgt. Pepper's Lonely Hearts Club Band", :release_year =&gt; 1967)</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:position =&gt; 2, :name =&gt; "Pet Sounds", :release_year =&gt; 1966)</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:position =&gt; 3, :name =&gt; "Revolver", :release_year =&gt; 1966)</command>
 =&gt; #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Sieht ja ganz gut aus, aber wo sind die Daten gespeichert worden?
      Schauen wir mal in die Konfigurationsdatei für die Datenbank
      (<filename>config/database.yml</filename>):<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>cat config/database.yml</command> 
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Da wir im development Modus arbeiten hat Rails beim <command>rake
      db:migrate</command> eine neue SQLite3 Datenbank
      <filename>db/development.sqlite3</filename> angelegt und dort alle Daten
      gespeichert.</para>

      <para>Schauen wir mal mit dem Kommandozeilen-Client
      <command>sqlite3</command> rein:</para>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>sqlite3 db/development.sqlite3 </command>
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
albums             schema_migrations
sqlite&gt; <command>.schema albums</command>
CREATE TABLE "albums" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "position" integer, "name" varchar(255), "release_year" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; <command>SELECT * FROM albums;</command>
1|1|Sgt. Pepper's Lonely Hearts Club Band|1967|2010-09-02 19:48:42.744962|2010-09-02 19:48:42.744962
2|2|Pet Sounds|1966|2010-09-02 19:49:07.513328|2010-09-02 19:49:07.513328
3|3|Revolver|1966|2010-09-02 19:49:27.511745|2010-09-02 19:49:27.511745
sqlite&gt; <command>.exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Tatsächlich, da ist eine Datenbank mit dem Namen
      <varname>albums</varname> und in der sind die von uns eben erstellten
      Einträge.</para>

      <para>Neben <methodname>create</methodname> gibt es auch
      <methodname>new</methodname>. Allerdings muss ein mit
      <methodname>new</methodname> erzeugtes Objekt extra mit
      <methodname>save</methodname> gespeichert werden (hat Vor- und
      Nachteile):<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>highway61 = Album.new</command>
 =&gt; #&lt;Album id: nil, position: nil, name: nil, release_year: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>highway61.position = 4</command>
 =&gt; 4 
ruby-1.9.2-p0 &gt; <command>highway61.name = 'Highway 61 Revisited'</command>
 =&gt; "Highway 61 Revisited" 
ruby-1.9.2-p0 &gt; <command>highway61.release_year = 1965</command>
 =&gt; 1965 
ruby-1.9.2-p0 &gt; <command>highway61</command>
 =&gt; #&lt;Album id: nil, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>highway61.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>highway61</command>
 =&gt; #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Was passiert im Hintergrund? ActiveRecord übernimmt alle Arbeit
      für uns. Bei jedem <methodname>create</methodname> oder beim initialen
      <methodname>save</methodname> wird mit <code>INSERT</code> ein neuer
      Datensatz in der SQL-Datenbank angelegt. Im Log können wir dies
      überprüfen:<programlisting>  SQL (0.9ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-09-02 20:30:34.872261', 'Highway 61 Revisited', 4, 1965, '2010-09-02 20:30:34.872261')
</programlisting></para>
    </section>

    <section>
      <title>first, last und all</title>

      <para>Aus irgend einem magischen Grund braucht man ja immer mal den
      ersten oder den letzten oder auch alle Datensätze. Wahrscheinlich
      deshalb gibt es für alle drei Fälle eine fertige Methode. Fangen wir mit
      den einfachsten <methodname>first</methodname> und
      <methodname>last</methodname> an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Ein kurzer Blick in <filename>log/development.log</filename> zeigt
      uns wie ActiveRecord das gemacht hat:<programlisting>  Album Load (0.4ms)  SELECT "albums".* FROM "albums" LIMIT 1
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" ORDER BY albums.id DESC LIMIT 1
</programlisting></para>

      <para>Und jetzt mal alle auf einemal mit
      <methodname>all</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.all</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Der dazu gehörige SQL-Code ist nicht überraschen:<programlisting>  Album Load (0.2ms)  SELECT "albums".* FROM "albums"
</programlisting></para>

      <para>Die von <methodname>first</methodname>,
      <methodname>last</methodname> und <methodname>all</methodname> erzeugten
      Objekte sind aber unterschiedlich. Bei <methodname>first</methodname>
      und <methodname>all</methodname> wird ein <classname>Album</classname>
      ausgegeben und bei <methodname>all</methodname> ein Array:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.first.class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.all</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.all.class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Wenn <methodname>Album.all</methodname> ein Array ist, dann müsste
      man doch auch Iteratoren (siehe <xref linkend="iterator" /> und <xref
      linkend="array_iterator" />) benutzen können, oder? Ja, natürlich! Das
      ist ja das schöne daran. Kleiner Versuch mit
      <methodname>each</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.all.each do |album|</command>
ruby-1.9.2-p0 &gt;     <command>puts album.name</command>
ruby-1.9.2-p0 ?&gt;  <command>end</command>
Sgt. Pepper's Lonely Hearts Club Band
Pet Sounds
Revolver
Highway 61 Revisited
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Kann man dann auch <methodname>Album.all.first</methodname> als
      Alternative zu <methodname>first</methodname> benutzen? Ja, aber es
      macht keinen Sinn. Schauen wir mal:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.all.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <para>Sicherlich, das Ergebnis ist das gleiche, aber werfen wir mal
      einen Blick ins
      <filename>log/development.log</filename>:<programlisting>  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 1
  Album Load (0.3ms)  SELECT "albums".* FROM "albums"
</programlisting></para>

      <para>Selbst bei unserer Mini-Datenbank sehen wir schon einen
      Geschwindigkeitsunterschied. Bei der Methode first wird ein <code>SELECT
      *</code> mit einem <code>LIMIT 1</code> abgerufen (erste Zeile). Beim
      <methodname>Album.all.first</methodname> wird ein die ganze Tabelle mit
      <code>SELECT *</code> eingelesen und dann innerhalb von Ruby das erste
      Element dieses Arrays rausgezogen. Bei dieser kleinen Applikation kann
      man sich das noch leisten, aber stellen Sie sich mal vor, es würde sich
      um eine Datenbank mit zig Millionen Einträgen handeln.</para>

      <tip>
        <para>Auch wenn ActiveRecord dem Programmierer schon sehr viel
        Denkarbeit abnimmt, sollte man immer überlegen, ob das gleiche
        Ergebnis nicht auch mit einem optimaleren Weg realisiert werden
        kann.</para>
      </tip>
    </section>

    <section>
      <title>Queries</title>

      <para>Die Methoden <methodname>first</methodname> und
      <methodname>all</methodname> sind ja schon ganz nett, aber meistens will
      man ja doch nach etwas ganz bestimmten suchen.</para>

      <para>Füllen wir aber als erstes unsere Datenbank mit mehr Alben. Dann
      macht das Suchen auch mehr Spass.<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.create(:name =&gt; "Rubber Soul", :release_year =&gt; 1965, :position =&gt; 5)</command>
 =&gt; #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:name =&gt; "What's Going On", :release_year =&gt; 1971, :position =&gt; 6)</command>
 =&gt; #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-09-03 09:05:09", updated_at: "2010-09-03 09:05:09"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:name =&gt; "Exile on Main St.", :release_year =&gt; 1972, :position =&gt; 7)</command>
 =&gt; #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-09-03 09:05:28", updated_at: "2010-09-03 09:05:28"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:name =&gt; "London Calling", :release_year =&gt; 1979, :position =&gt; 8)</command>
 =&gt; #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-09-03 09:05:46", updated_at: "2010-09-03 09:05:46"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:name =&gt; "Blonde on Blonde", :release_year =&gt; 1966, :position =&gt; 9)</command>
 =&gt; #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:name =&gt; "The Beatles", :release_year =&gt; 1968, :position =&gt; 10)</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

      <section>
        <title>where</title>

        <para>Mit <methodname>where</methodname> kann man nach bestimmten
        Werten in der Datenbank suchen. Suchen wir mal alle Alben aus dem Jahr
        1966:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Sie können mir where auch nach Ranges suchen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966).count</command>
 =&gt; 5 
ruby-1.9.2-p0 &gt; exit
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>Und Sie können auch mehrere Suchfaktoren gleichzeitig
        angeben:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966, :position =&gt; 1..5)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966, :position =&gt; 1..5).count</command>
 =&gt; 4 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Oder noch cooler ein Array von Parametern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; [1966,1968])</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <important>
          <para>Das Ergegebnis von where is immer ein Array. Auch wenn nur ein
          Treffer drin ist oder auch wenn gar kein Treffer ausgegeben
          wird.</para>
        </important>
      </section>

      <section>
        <title>Attribute-based find_by, find_last_by und find_all_by</title>

        <para>Das Attribute-based <methodname>find_by</methodname> ist eine
        "magische" Methode. Aber eine Consolenbeispiel sagt mehr als tausend
        Worte. Ich verwende erst <methodname>where</methodname> und dann
        <methodname>find_by</methodname> für die gleiche Abfage:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).first</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(1966)</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).last</command>
 =&gt; #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_last_by_release_year(1966)</command>
 =&gt; #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Im Gegensatz zu <methodname>where</methodname> gibt
        <methodname>find_by</methodname> entweder ein Objekt der gesuchten
        Klasse (hier <classname>Album</classname>) oder
        <classname>nil</classname> aus (where gibt <emphasis>immer</emphasis>
        ein Array aus):<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(1972)</command>
 =&gt; #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-09-03 09:05:28", updated_at: "2010-09-03 09:05:28"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(1972).class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(2010)</command>
 =&gt; nil 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(2010).class</command>
 =&gt; NilClass 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Die Methode <methodname>find_all_by</methodname> gibt wie
        <methodname>where</methodname> immer ein Array aus:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(2020).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>
      </section>

      <section>
        <title>exists?</title>

        <para>Hin und wieder will man wissen, ob es einen bestimmten Datensatz
        gibt und genau dafür gibt es die Methode
        <methodname>exists?</methodname>. Sie gibt als Ergebnis
        <varname>true</varname> oder <varname>false</varname> aus:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.exists?(10)</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.exists?(11)</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>Album.exists?(:name =&gt; 'The Beatles')</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.exists?(['name LIKE ?', '%Beatles%'])</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>Die komplette Hilfe zur Methode <methodname>exists?</methodname>
        können Sie sich mit <command>ri
        ActiveRecord::FinderMethods.exists?</command> anzeigen lassen.</para>
      </section>

      <section>
        <title>find</title>

        <para>Die Methode <methodname>find</methodname> ist - sagen wir mal -
        komplex in den Möglichkeiten.</para>

        <tip>
          <para>Die komplette Hilfe zur Methode <methodname>find</methodname>
          können Sie sich mit <command>ri
          ActiveRecord::FinderMethods.find</command> anzeigen lassen. Dort
          gibt es auch viele Beispiele.</para>
        </tip>

        <section>
          <title>Abfragemethoden</title>

          <para>Es gibt prinzipiel folgende Abfragemethoden mit find. Sie
          können alle mit den Parametern kombiniert werden.</para>

          <section>
            <title>Nach/Mit IDs suchen</title>

            <para>Wenn ich die ID eines Objektes kenne, kann ich das einzelne
            Objekt oder mehrere Objekte gleichzeitig anhand der ID
            suchen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find(2)</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find(2).class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.find([1,3,7])</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-09-03 09:05:28", updated_at: "2010-09-03 09:05:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.find([1,3,7]).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

            <para>Wenn man immer ein Array als Ergebnis haben will muss man
            nur nur einfach immer auch ein Array als Parameter
            übergeben:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find(5).class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.find([5]).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

            <para>Wenn man nach einer ID sucht, sollte man sich allerdings
            ganz sicher sein, das es diese Idee auch gibt. Im Zweifelsfall
            kann/muss man das mit der Methode <methodname>exists?</methodname>
            vorher machen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find(50)</command>
ActiveRecord::RecordNotFound: Couldn't find Album with ID=50
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/relation/finder_methods.rb:296:in `find_one'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/relation/finder_methods.rb:281:in `find_with_ids'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/relation/finder_methods.rb:107:in `find'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/base.rb:439:in `find'
 from (irb):2
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands/console.rb:44:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.2-p0 &gt; <command>Album.exists?(50)</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>
          </section>

          <section>
            <title>first und last</title>

            <para>Mit der Methode <methodname>find</methodname> kann man
            sowohl den ersten wie auch den letzten Datensatz ausgeben:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find(:first)</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find(:first) == Album.first</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.find(:last)</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find(:last) == Album.last</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>
          </section>

          <section>
            <title>all</title>

            <para>Mit <methodname>find(:all)</methodname> kann man sich alle
            Datensätze als Array ausgeben lassen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find(:all)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-09-03 09:05:09", updated_at: "2010-09-03 09:05:09"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-09-03 09:05:28", updated_at: "2010-09-03 09:05:28"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-09-03 09:05:46", updated_at: "2010-09-03 09:09:20"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.find(:all) == Album.all</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>
          </section>
        </section>

        <section>
          <title>Parameter</title>

          <para>Die Anzahl und die daraus resultierenden Suchmöglichkeiten von
          find übersteigen den Rahmen dieses Buches. Ich werden an dieser
          Stelle einige wichtige aufzeigen und später jeweils bei bestimmten
          Themen weitere Parameter einführen.</para>

          <section>
            <title>:conditions</title>

            <para>Mit dem Parameter <parameter>:conditions</parameter> können
            SQL-Abfragen mit der <methodname>find</methodname>-Methode
            realisiert werden. Beispiele:</para>
          </section>
        </section>
      </section>

      <section>
        <title>find_or_create</title>

        <para></para>
      </section>

      <section>
        <title>select</title>

        <para></para>
      </section>

      <section>
        <title>limit und offset</title>

        <para></para>
      </section>

      <section>
        <title>batch</title>

        <para></para>
      </section>

      <section xml:id="lazy_loading">
        <title xml:id="lazy_loading.title">Lazy Loading</title>

        <para>Seit Rails 3.0 wird bei ActiveRecords <emphasis>Lazy
        Loading</emphasis> verwendet. Dies ist ein Mechanismus, der eine
        Datenbankabfrage erst dann stellt, wenn der weitere Programmablauf
        nicht ohne das Ergebnis dieser realisiert werden kann. Vorher wird die
        Anfrage als <classname>ActiveRecord::Relation</classname> gespeichert.
        Lazy Loading funktioniert nicht mit allen Suchmethoden!<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" = 1966)" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Wenn aber <code>Album.where(:release_year =&gt; 1966)</code> ein
        <classname>ActiveRecord::Relation</classname> ist, warum bekommen wir
        dann in der Console ein Array ausgegeben? Die Console will uns das
        Entwicklerleben etwas einfacher machen und zeigt uns quasi automatisch
        das Ergebnis der <methodname>all</methodname> Methode an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).all.class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Noch nicht ganz klar? Dann machen wir einen anderen Versuch.
        Hier schauen wir uns die Klassen von einem
        <methodname>find</methodname> und einem <methodname>where</methodname>
        an. Beide sind unterschiedlich (<methodname>where</methodname> liefert
        ein <classname>ActiveRecord::Relation</classname>). Wenn wir aber
        beide mit einem <code>==</code> vergleichen, dann ist das Ergebnis
        true. Wenn Rails das <code>==</code> sieht, denkt es sich "so, jetzt
        geht es nicht mehr anders, ich muss die Abfrage durchführen":<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class == Album.find_all_by_release_year(1966).class</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966) == Album.where(:release_year =&gt; 1966)</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

        <para>Prinzipiel klar, aber der Sinn noch nicht ganz? Dann bauen wir
        uns mal eine Abfrage zusammen, in der wir mehrere Methoden
        verschachteln. In dem folgenden Beispiel wird <varname>a</varname>
        immer weiter definiert und erst ganz zum Schluss (beim Aufruf der
        Methode <methodname>all</methodname>) wird die Datenbankabfrage
        wirklich getätigt. Mit der Methode <methodname>to_sql</methodname>
        kann man sich immer die aktuelle SQL-Query ausgeben lassen.<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>a = Album.where(:release_year =&gt; 1965..1968)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-05 21:29:19"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>a.to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" BETWEEN 1965 AND 1968)" 
ruby-1.9.2-p0 &gt; <command>a = a.order(:release_year)</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-05 21:29:19"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>a.to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" BETWEEN 1965 AND 1968) ORDER BY  release_year" 
ruby-1.9.2-p0 &gt; <command>a = a.limit(3)</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;] 
ruby-1.9.2-p0 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>a.to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" BETWEEN 1965 AND 1968) ORDER BY  release_year LIMIT 3" 
ruby-1.9.2-p0 &gt; <command>a.all</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>
      </section>

      <section>
        <title>scope</title>

        <para></para>
      </section>

      <section>
        <title>Debugging in der Console</title>

        <para>Manchmal ist es nervig ständig zwischen einem Terminal mit der
        Rails Console und einem anderen Terminal mit dem Logfile zu wechseln,
        um zu sehen, was gerade von ActiveRecord mit der Datenbank gemacht
        wurde. Es gibt mit <command>ActiveRecord::Base.logger =
        Logger.new(STDOUT)</command> einen einfachen Weg diese Meldungen auch
        in der Console anzuzeigen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000100a6e6d0 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000100a6e6a8 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x00000100a6e658 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x00000100a6e630 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000100a6e5e0&gt;&gt;&gt;&gt; 
ruby-1.9.2-p0 &gt; <command>Album.first</command>
  SQL (0.4ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 1
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="has_many">
    <title xml:id="has_many.title">has_many - 1:n Verknüpfung</title>

    <warning>
      <para>Dieser Abschnitt wird gerade überarbeitet und passt so nicht zum
      Rest des Buches. Bitte in ein paar Tagen noch mal reinschauen.
      TODO</para>
    </warning>

    <para>In unserer Album-Datenbank haben wir alle Top-Alben gelistet.
    Allerdings fehlen uns die Songs auf den einzelnen Alben. Die sauberste
    Lösung dafür ist eine weitere Tabelle die einen Foreign-Key (foreign_key)
    mit der ID des Albums. Dann können wir über eine 1:n Verknüpfung zu jedem
    Album alle Songs ausgeben. Der Name des Foreign-Keys wird per Default
    immer aus dem Namen der Primary Datenbank (in unserem Fall
    <classname>Album</classname>) und einem "<code>_id</code>"
    zusammengefügt.</para>

    <para>Legen wir die zweite Tabelle für die Songs an: <screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails generate model Track album_id:integer title:string length:integer</command>
      invoke  active_record
      create    db/migrate/20100905215323_create_tracks.rb
      create    app/models/track.rb
      invoke    test_unit
      create      test/unit/track_test.rb
      create      test/fixtures/tracks.yml
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Danach wieder <command>rake db:migrate</command> ausführen, damit
    die Datenbank auch angelegt wird:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake db:migrate</command>
(in /Users/stefan/jukebox)
==  CreateTracks: migrating ===================================================
-- create_table(:tracks)
   -&gt; 0.0012s
==  CreateTracks: migrated (0.0013s) ==========================================

stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Schauen wir uns das mal auf der Console an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Track</command>
 =&gt; Track(id: integer, album_id: integer, title: string, length: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.all.count</command>
 =&gt; 10 
ruby-1.9.2-p0 &gt; <command>Track.all.count</command>
 =&gt; 0 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$</screen></para>

    <para>Es fehlen Einträge in der <varname>flight_schedules</varname>
    Datenbank. Tragen wir mal drei Beispielflüge ein:<screen>ruby-1.9.1-p378 &gt; <command>FlightSchedule.create(:flight_id =&gt; 1, :departure =&gt; DateTime.parse('01.01.2012 10:00'), :arrival =&gt; DateTime.parse('01.01.2012 11:05'))</command>
 =&gt; #&lt;FlightSchedule id: 1, flight_id: 1, departure: "2012-01-01 10:00:00", arrival: "2012-01-01 11:05:00", created_at: "2010-06-18 21:22:19", updated_at: "2010-06-18 21:22:19"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.create(:flight_id =&gt; 1, :departure =&gt; DateTime.parse('03.01.2012 10:00'), :arrival =&gt; DateTime.parse('03.01.2012 11:05'))</command>
 =&gt; #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2012-01-03 10:00:00", arrival: "2012-01-03 11:05:00", created_at: "2010-06-18 21:23:27", updated_at: "2010-06-18 21:23:27"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.create(:flight_id =&gt; 1, :departure =&gt; DateTime.parse('02.01.2012 10:00'), :arrival =&gt; DateTime.parse('02.01.2012 11:05'))</command>
 =&gt; #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2012-01-02 10:00:00", arrival: "2012-01-02 11:05:00", created_at: "2010-06-18 21:23:37", updated_at: "2010-06-18 21:23:37"&gt; 
ruby-1.9.1-p378 &gt; <command>pp FlightSchedule.all</command>
[#&lt;FlightSchedule id: 1, flight_id: 1, departure: "2012-01-01 10:00:00", arrival: "2012-01-01 11:05:00", created_at: "2010-06-18 21:22:19", updated_at: "2010-06-18 21:22:19"&gt;,
 #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2012-01-03 10:00:00", arrival: "2012-01-03 11:05:00", created_at: "2010-06-18 21:23:27", updated_at: "2010-06-18 21:23:27"&gt;,
 #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2012-01-02 10:00:00", arrival: "2012-01-02 11:05:00", created_at: "2010-06-18 21:23:37", updated_at: "2010-06-18 21:23:37"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>exit</command>
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>

    <para>Die zwei Datenbanken sind eingerichtet und können mit ActiveRecord
    benutzt werden. Allerdings weiß ActiveRecord noch nichts von der 1:n
    Beziehung der beiden. Das ist aber recht einfach in zwei
    Schritten:<orderedlist>
        <listitem>
          <para>Wir fügen die <code>has_many</code> Option in die Model-Datei
          <filename>app/models/flight.rb</filename> ein:<programlisting>class Flight &lt; ActiveRecord::Base
  has_many :flight_schedules
end</programlisting></para>

          <para>Mit diesem Eintrag bekommen wir automagisch ein paar neue
          Methoden für die Flight Klasse. So können wir jetzt mit der Methode
          <methodname>flight_schedules</methodname> alle
          <classname>FlightSchedule</classname> Einträge für den aktuellen
          <classname>Flight</classname> abrufen:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; <command>pp Flight.find(1).flight_schedules</command>
[#&lt;FlightSchedule id: 1, flight_id: 1, departure: "2012-01-01 10:00:00", arrival: "2012-01-01 11:05:00", created_at: "2010-06-18 21:22:19", updated_at: "2010-06-18 21:22:19"&gt;,
 #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2012-01-03 10:00:00", arrival: "2012-01-03 11:05:00", created_at: "2010-06-18 21:23:27", updated_at: "2010-06-18 21:23:27"&gt;,
 #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2012-01-02 10:00:00", arrival: "2012-01-02 11:05:00", created_at: "2010-06-18 21:23:37", updated_at: "2010-06-18 21:23:37"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>Flight.find(1).flight_schedules.count</command>
 =&gt; 3 
ruby-1.9.1-p378 &gt;</screen></para>

          <para>Da wir für den zweiten Flug noch keine
          <classname>FlightSchedule</classname> Einträge haben bekommen wir
          hier als Ergebnis ein leeres Array:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(2).flight_schedules</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt; <command>Flight.find(2).flight_schedules.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt; </screen></para>

          <para>Ebenfalls funktioniert der umgekehrte Weg auch noch nicht. Wir
          haben noch keine Zuordnung eines Flight zu einem FlightSchedule. Die
          entsprechende Methode ist noch nicht existent:<screen>ruby-1.9.1-p378 &gt; <command>FlightSchedule.first.flight</command>
NoMethodError: undefined method `flight' for #&lt;FlightSchedule:0x00000105016870&gt;
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activemodel-3.0.0.beta4/lib/active_model/attribute_methods.rb:358:in `method_missing'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/attribute_methods.rb:45:in `method_missing'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/attribute_methods.rb:43:in `method_missing'
 from (irb):9
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:47:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.1-p378 &gt; <command>exit</command></screen></para>
        </listitem>

        <listitem>
          <para>Im zweiten Schritt fügen wir in der Model-Datei
          <filename>app/models/flight_schedule.rb</filename> die
          <code>belongs_to</code> Option ein:<programlisting>class FlightSchedule &lt; ActiveRecord::Base
  belongs_to :flight
end</programlisting></para>

          <para>Damit bekommen wir automagisch die Methode
          <methodname>flight</methodname> in der Klasse
          <classname>FlightSchedule</classname> angeboten und können zu einem
          <classname>FlightSchedule</classname> den
          <classname>Flight</classname> anzeigen:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; <command>FlightSchedule.first</command>
 =&gt; #&lt;FlightSchedule id: 1, flight_id: 1, departure: "2012-01-01 10:00:00", arrival: "2012-01-01 11:05:00", created_at: "2010-06-18 21:22:19", updated_at: "2010-06-18 21:22:19"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.first.flight</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-18 21:17:30", updated_at: "2010-06-18 21:17:30"&gt; 
ruby-1.9.1-p378 &gt; <command>exit</command></screen></para>
        </listitem>
      </orderedlist></para>

    <para>So einfach ist es eine 1:n Verknüpfung zu erstellen? Ja! Ist
    ActiveRecord nicht toll?! :-)</para>

    <para>Sie müssen natürlich nicht immer ein <code>has_many</code> mit einem
    <code>belongs_to</code> verknüpfen. Wenn Sie nur eine Seite benötigen, so
    können Sie auf die jeweils andere verzichten. In der Regel ist es aber
    meistens praktisch in beide Richtungen agieren zu können.</para>

    <section>
      <title>Optionen</title>

      <para>Ich will an dieser Stelle nicht auf alle möglichen Optionen
      eingehen. Aber ein paar sind so praktisch und werden von mir in jedem
      Projekt benutzt, das ich sie hier vorstellen möchte. Für alle anderen
      verweise ich auf die Ruby on Rails Doku die Sie im Internet unter <uri
      xlink:href="http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
      bzw. auf Ihrem System mit <command>ri
      ActiveRecord::Associations::ClassMethods</command> auf der Shell abrufen
      können.</para>

      <section>
        <title>has_many</title>

        <para>Die meiner Meinung nach wichtigsten Optionen für
        <code>has_many</code>:<itemizedlist>
            <listitem>
              <para><code>:order =&gt; ''</code></para>

              <para>In unserem Flugplan wäre es schon sehr praktisch, wenn die
              Flüge nach den Flugzeiten sortiert wären. Dies geht mit
              folgender Einstellung:<programlisting>has_many :flight_schedules, :order =&gt; 'departure'
</programlisting></para>

              <para>In unserem Fall sähe dann das Ergebnis in der Console so
              aus. Sie sehen, das die IDs 2 und 3 vertauscht sind.<screen>ruby-1.9.1-p378 &gt; <command>pp Flight.first.flight_schedules</command>
[#&lt;FlightSchedule id: 1, flight_id: 1, departure: "2012-01-01 10:00:00", arrival: "2012-01-01 11:05:00", created_at: "2010-06-18 21:22:19", updated_at: "2010-06-18 21:22:19"&gt;,
 #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2012-01-02 10:00:00", arrival: "2012-01-02 11:05:00", created_at: "2010-06-18 21:23:37", updated_at: "2010-06-18 21:23:37"&gt;,
 #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2012-01-03 10:00:00", arrival: "2012-01-03 11:05:00", created_at: "2010-06-18 21:23:27", updated_at: "2010-06-18 21:23:27"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt;</screen></para>

              <para>Und falls es einmal umgekehrt sortiert werden
              sollte:<programlisting>has_many :flight_schedules, :order =&gt; 'departure DESC'
</programlisting></para>
            </listitem>

            <listitem>
              <para><code>:dependent =&gt; :destroy</code></para>

              <para>Wird ein Eintrag in der Flight Tabelle gelöscht, dann ist
              es ja nur sinnvoll, das auch alle dazu gehörigen
              Flugplan-Einträge in FlightSchedule gelöscht werden. Das kann
              mit <code>:dependent =&gt; :destroy</code> realisiert
              werden:<programlisting>has_many :flight_schedules, :dependent =&gt; :destroy
</programlisting></para>

              <para>Im folgenden Beispiel löschen wir einen
              <classname>Flight</classname> und dadurch werden alle 1:n
              <classname>FlightSchedule</classname> Einträge ebenfalls
              gelöscht:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 16:24:07", updated_at: "2010-06-17 16:24:07"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first.flight_schedules.first</command>
 =&gt; #&lt;FlightSchedule id: 1, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:03", updated_at: "2010-06-17 16:41:03"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first.destroy</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 16:24:07", updated_at: "2010-06-17 16:24:07"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.exists?(1)</command>
 =&gt; false 
ruby-1.9.1-p378 &gt;</screen></para>

              <important>
                <para>Bitte denken Sie immer an den Unterschied zwischen den
                Methoden <methodname>destroy</methodname> (siehe <xref
                linkend="activerecord_destroy" />) und
                <methodname>delete</methodname> (siehe <xref
                linkend="activerecord_delete" />). Diese Abhängigkeit
                funktioniert nur mit der <methodname>destroy</methodname>
                Methode.</para>
              </important>
            </listitem>

            <listitem>
              <para><code>:readonly =&gt; :true</code></para>

              <para>Manchmal braucht man keinen Schreibzugriff auf die
              Verknüpfung. Dann kann man auch direkt mit
              <code>:readonly</code> arbeiten.<programlisting>has_many :flight_schedules, :readonly =&gt; :true</programlisting></para>
            </listitem>
          </itemizedlist></para>

        <para>Es gibt natürlich noch eine Menge anderer Optionen. Diese können
        Sie sich mit <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command> auf der
        Shell ausgeben lassen.</para>
      </section>

      <section>
        <title>belongs_to</title>

        <para>Die meiner Meinung nach wichtigeste Option für
        <methodname>belongs_to</methodname> ist:<itemizedlist>
            <listitem>
              <para><code>:touch =&gt; :true</code></para>

              <para>Damit wird bei einer Veränderung des
              <classname>FlightSchedules</classname> automatisch das Feld
              <varname>updated_at</varname> der Primary Datenbank
              <classname>Flight</classname> auf die aktuelle Uhrzeit
              gesetzt.</para>
            </listitem>
          </itemizedlist></para>

        <para>Auch hier sollten Sie einmal auf die Liste aller möglichen
        Optionen einen kurzen Blick werfen. Dazu in der Shell <command>ri
        ActiveRecord::Associations::ClassMethods#belongs_to</command>
        aufrufen.</para>
      </section>
    </section>

    <section>
      <title>Methoden</title>

      <section xml:id="has_many_build">
        <title xml:id="has_many_build.title">build</title>

        <para>Die Methode <methodname>build</methodname> erstellt eine neue
        Kind-Instanz die automatisch die Eltern-ID enthält:<screen>ruby-1.9.1-p378 &gt; <command>Flight.last</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_txl = Flight.last</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>neuer_flugplan = fra_txl.flight_schedules.build(:departure =&gt; Time.now + 1.year, :arrival =&gt; Time.now + 1.year + 1.hour)</command>
 =&gt; #&lt;FlightSchedule id: nil, flight_id: 5, departure: "2011-06-17 21:05:43", arrival: "2011-06-17 22:05:43", created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt;
</screen></para>

        <para>Jetzt muss <varname>neuer_flugplan</varname> nur noch mit
        <methodname>save</methodname> abgespeichert werden:<screen>ruby-1.9.1-p378 &gt; <command>neuer_flugplan.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Der Vorteil liegt in der Sicherheit keine falsche ID zu nehmen
        und oft im übersichtlicheren Code.</para>
      </section>

      <section xml:id="has_many_create">
        <title xml:id="has_many_create.title">create</title>

        <para>Die Methode create arbeitet wie <methodname>build</methodname>,
        nur das danach quasi automatisch direkt ein
        <methodname>save</methodname> aufgerufen wird. Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(5)</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 1 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.create(:departure =&gt; Time.now + 1.month, :arrival =&gt; Time.now + 1.month + 1.hour)</command>
 =&gt; #&lt;FlightSchedule id: 5, flight_id: 5, departure: "2010-07-17 21:14:08", arrival: "2010-07-17 22:14:08", created_at: "2010-06-17 19:14:08", updated_at: "2010-06-17 19:14:08"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 2 
ruby-1.9.1-p378 &gt;</screen></para>

        <important>
          <para>Bitte achten Sie bei der Verwendung von
          <methodname>create</methodname> immer auch auf die von Ihnen
          verwendeten Validierungs-Regeln (siehe <xref
          linkend="model_validierungen" />). Denn falls die Validierung einen
          Fehler ausgibt, dann der der neue Datensatz natürlich nicht
          gespeichert. Da ist manchmal der kleine Umweg über build
          einfacher.</para>
        </important>
      </section>

      <section xml:id="has_many_delete" xml:lang="">
        <title xml:id="has_many_delete.title">delete und destroy</title>

        <para>Mit den Methoden <methodname>destroy</methodname>,
        <methodname>destroy_all</methodname>, <methodname>delete</methodname>
        und <methodname>delete_all</methodname> kann man wie in <xref
        linkend="datensatz-loeschen" /> beschrieben Datensätze löschen. Im
        Kontext von <methodname>has_many</methodname> bedeutet das, das man
        die zu einem <classname>Flight</classname> gelisteten
        <classname>FlightSchedule</classname>-Datensätze in einem Streich
        löschen kann:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(5)</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 4 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.destroy_all</command>
 =&gt; {} 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 0 
ruby-1.9.1-p378 &gt; <command>Flight.find(5)</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>
    </section>

    <section xml:id="has_many_webinterface_umsetzung">
      <title xml:id="has_many_webinterface_umsetzung.title">Umsetzung im
      Webinterface</title>

      <para>Ziel soll es sein, dem User des Webinterfaces nicht nur die beiden
      bestehenden <uri
      xlink:href="http://0.0.0.0:3000/flights">http://0.0.0.0:3000/flights</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/flight_schedules">http://0.0.0.0:3000/flight_schedules</uri>
      Übersichten zu geben, sondern bei der Index-Übersicht von
      <varname>flights</varname> zu jeder Flugnummer auch die nächsten drei
      Flugtermine anzuzeigen. Bei der Einzelansicht zu einem
      <classname>Flight</classname> (show-View) sollen alle Flugtermine zu
      einer Flugnummer angezeigt werden.</para>

      <section>
        <title>IST-Zustand (Vorher)</title>

        <para>Erst schauen wir uns die Default Ansichten an, die vom
        Scaffolding generiert wurden.</para>

        <para><screenshot>
            <info>
              <title>Index-Ansicht der Flights</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/has_many_vorher_flights_index.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot><screenshot>
            <info>
              <title>Show-Ansicht des Flight mit der ID 1</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/has_many_vorher_flights_show_1.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot><screenshot>
            <info>
              <title>Index-Ansicht der FlightSchedules</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/has_many_vorher_flight_schedules_index.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>
      </section>

      <section>
        <title>SOLL-Zustand (Nachher)</title>

        <para>Jetzt zeige ich Ihnen wie die gleichen Seiten in Zukunft
        aussehen sollen.</para>

        <para>Bei der Flight Index-Ansicht sollen nicht nur die Flights
        aufgelistet werden, sondern auch noch die dazu gehörigen
        FlightSchedule-Einträge.</para>

        <para><screenshot>
            <info>
              <title>Index-Ansicht der Flights</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/has_many_nachher_flights_index.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>Bei der Einzelansicht eines Flights sollen ebenfalls
        die dazu gehörigen FlightSchedule-Einträge angezeigt
        werden.<screenshot>
            <info>
              <title>Show-Ansicht des Flight mit der ID 1</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/has_many_nachher_flights_show_1.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Bei er Index-Ansicht der FlightSchedule-Einträge soll die
        Flugnummer mit einem Link zum entsprechenden Flug plus die Strecke
        angezeigt werden.<screenshot>
            <info>
              <title>Index-Ansicht der FlightSchedules</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/has_many_nachher_flight_schedules_index.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>
      </section>

      <section>
        <title>Die Routen</title>

        <para>Die Datei <filename>config/routes.rb</filename> ist so eine Art
        Landkarte für eine Rails-Application. Ich gehe in näher auf dieses
        Thema ein. Aktuell reicht es den Inhalt dieser Datei wie folgt zu
        füllen:<programlisting>Railsair::Application.routes.draw do |map|
  resources :flight_schedules

  resources :flights do
    resources :flight_schedules
  end
end </programlisting></para>

        <para>Die daraus resultierenden Routen können Sie übrigens auf der
        Shell mit <command>rake routes</command> anzeigen (da lohnt es sich
        auch mal das Terminal-Fenster etwas in die Breite zu ziehen):<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake routes</command>
(in /Users/stefan/book/railsair)
                            GET    /flight_schedules(.:format)                             {:action=&gt;"index", :controller=&gt;"flight_schedules"}
           flight_schedules POST   /flight_schedules(.:format)                             {:action=&gt;"create", :controller=&gt;"flight_schedules"}
        new_flight_schedule GET    /flight_schedules/new(.:format)                         {:action=&gt;"new", :controller=&gt;"flight_schedules"}
                            GET    /flight_schedules/:id(.:format)                         {:action=&gt;"show", :controller=&gt;"flight_schedules"}
                            PUT    /flight_schedules/:id(.:format)                         {:action=&gt;"update", :controller=&gt;"flight_schedules"}
            flight_schedule DELETE /flight_schedules/:id(.:format)                         {:action=&gt;"destroy", :controller=&gt;"flight_schedules"}
       edit_flight_schedule GET    /flight_schedules/:id/edit(.:format)                    {:action=&gt;"edit", :controller=&gt;"flight_schedules"}
                            GET    /flights/:flight_id/flight_schedules(.:format)          {:action=&gt;"index", :controller=&gt;"flight_schedules"}
    flight_flight_schedules POST   /flights/:flight_id/flight_schedules(.:format)          {:action=&gt;"create", :controller=&gt;"flight_schedules"}
 new_flight_flight_schedule GET    /flights/:flight_id/flight_schedules/new(.:format)      {:action=&gt;"new", :controller=&gt;"flight_schedules"}
                            GET    /flights/:flight_id/flight_schedules/:id(.:format)      {:action=&gt;"show", :controller=&gt;"flight_schedules"}
                            PUT    /flights/:flight_id/flight_schedules/:id(.:format)      {:action=&gt;"update", :controller=&gt;"flight_schedules"}
     flight_flight_schedule DELETE /flights/:flight_id/flight_schedules/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"flight_schedules"}
edit_flight_flight_schedule GET    /flights/:flight_id/flight_schedules/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"flight_schedules"}
                            GET    /flights(.:format)                                      {:action=&gt;"index", :controller=&gt;"flights"}
                    flights POST   /flights(.:format)                                      {:action=&gt;"create", :controller=&gt;"flights"}
                 new_flight GET    /flights/new(.:format)                                  {:action=&gt;"new", :controller=&gt;"flights"}
                            GET    /flights/:id(.:format)                                  {:action=&gt;"show", :controller=&gt;"flights"}
                            PUT    /flights/:id(.:format)                                  {:action=&gt;"update", :controller=&gt;"flights"}
                     flight DELETE /flights/:id(.:format)                                  {:action=&gt;"destroy", :controller=&gt;"flights"}
                edit_flight GET    /flights/:id/edit(.:format)                             {:action=&gt;"edit", :controller=&gt;"flights"}
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
      </section>

      <section>
        <title>Die Models</title>

        <para>Sollte eigentlich schon klar sein, aber sicher ist
        sicher.</para>

        <para>Die Datei
        <filename>app/models/flight.rb</filename><programlisting>class Flight &lt; ActiveRecord::Base
  has_many :flight_schedules, :order =&gt; :departure, :dependent =&gt; :destroy
end</programlisting></para>

        <para>Die Datei
        <filename>app/models/flight_schedule.rb</filename><programlisting>class FlightSchedule &lt; ActiveRecord::Base
  belongs_to :flight
end</programlisting></para>
      </section>

      <section>
        <title>Die Controller</title>

        <para>Im der Controller-Datei
        <filename>app/controllers/flights_controller.rb</filename> ändern wir
        die Methode <methodname>index</methodname> wie folgt
        ab:<programlisting>  def index
    <emphasis>@flights = Flight.order(:departure_airport,:destination_airport)</emphasis>

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @flights }
    end
  end
</programlisting></para>

        <para>Damit bekommen wir in der Instance-Variablen
        <varname>@flights</varname> alle verfügbaren
        <classname>Flights</classname> nach Ab- und Zielflughafen sortiert
        gespeichert.</para>

        <para>In der Controller-Datei
        <filename>app/controllers/flight_schedules_controller.rb</filename>
        ändern wir ebenfalls die Methode <methodname>index</methodname>
        ab:<programlisting>  def index
    @flight_schedules = FlightSchedule.order(:departure)

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @flight_schedules }
    end
  end
</programlisting></para>
      </section>

      <section>
        <title>Die Views</title>

        <para>Nachdem wir im Model und im Controller die Vorarbeit geleistet
        haben, können wir in den Views die gewünschten Seiten rendern.</para>

        <para>Fangen wir mit der Index-Seite von <classname>Flight</classname>
        an. Die Datei <filename>app/views/flights/index.html.erb</filename>
        muss wie folgt abgeändert werden:<programlisting>&lt;h1&gt;Alle RailsAir-Flüge&lt;/h1&gt;

&lt;p&gt;&lt;%= link_to 'Neue Flug-Nr.', new_flight_path %&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Flug-Nr.&lt;/th&gt;
    &lt;th&gt;Abflughafen&lt;/th&gt;
    &lt;th&gt;Zielflughafen&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @flights.each do |flight| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= link_to flight.flight_number, flight_path(flight) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= flight.departure_airport %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= flight.destination_airport %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;&lt;/td&gt;
   &lt;td colspan = "3"&gt;
    &lt;%= render :partial =&gt; 'flight_schedules_index', :locals =&gt; { :flight =&gt; flight } %&gt;
   &lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</programlisting></para>

        <para>Zusätzlich muss die Partial-Datei
        <filename>app/views/flights/_flight_schedules_index.html.erb</filename>
        mit folgendem Inhalt neu angelegt werden:<programlisting>&lt;ul&gt;
  &lt;% if flight.flight_schedules.count &gt; 0 %&gt;
    &lt;% flight.flight_schedules.each do |flight_schedule| %&gt;
    &lt;li&gt;
     &lt;%= flight_schedule.departure.strftime("%d.%m.%y %H:%M") %&gt;
     -
     &lt;%= flight_schedule.arrival.strftime("%H:%M") %&gt;
    &lt;/li&gt;
    &lt;% end %&gt;
  &lt;% end %&gt;
  &lt;li&gt;&lt;%= link_to 'Neue Flugzeit', new_flight_flight_schedule_path(flight) %&gt;&lt;/li&gt;
&lt;/ul&gt;
</programlisting></para>

        <para>Warum dafür ein extra Partial? Dieser Programmteil wird nicht
        nur in der index Action, sondern auch in der der
        <methodname>show</methodname> Action und damit in der Datei
        <filename>app/views/flights/show.html.erb</filename>
        verwendet:<programlisting>&lt;p id="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;

&lt;h1&gt;&lt;%= @flight.flight_number %&gt;&lt;/h1&gt;

&lt;p&gt;
  &lt;%= @flight.departure_airport %&gt; - 
  &lt;%= @flight.destination_airport %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Flugzeiten:&lt;/b&gt;
&lt;/p&gt;
&lt;%= render :partial =&gt; 'flight_schedules_index', :locals =&gt; { :flight =&gt; @flight } %&gt;


&lt;%= link_to 'Edit', edit_flight_path(@flight) %&gt; |
&lt;%= link_to 'Destroy', @flight, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt; | 
&lt;%= link_to 'Back', flights_path %&gt;
</programlisting></para>

        <para>Als nächstes müssen wir noch die Datei
        <filename>app/views/flight_schedules/index.html.erb</filename>
        anpassen:<programlisting>&lt;h1&gt;Flugplan&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Flight&lt;/th&gt;
    &lt;th&gt;Strecke&lt;/th&gt;
    &lt;th&gt;Departure&lt;/th&gt;
    &lt;th&gt;Arrival&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @flight_schedules.each do |flight_schedule| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= link_to flight_schedule.flight.flight_number, flight_path(flight_schedule.flight) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= "#{flight_schedule.flight.departure_airport} - #{flight_schedule.flight.destination_airport}" %&gt;
    &lt;td&gt;&lt;%= flight_schedule.departure.strftime("%d.%m.%y %H:%M") %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= flight_schedule.arrival.strftime("%H:%M") %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', flight_schedule %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_flight_schedule_path(flight_schedule) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', flight_schedule, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</programlisting></para>

        <para>Hier geht es weiter nach der nächsten Maus.</para>
      </section>
    </section>
  </section>

  <section xml:id="railsair">
    <title xml:id="railsair.title">Die Fluggesellschaft RailsAir</title>

    <para>Damit das Kapitel in sich selbst abschlossen ist, erstellen wir ein
    neues Rails-Projekt, in dem wir dann alle Beispiele einbauen. Dabei habe
    ich etwas aus dem "täglichen Leben" genommen und schlage vor, das wir
    gemeinsam eine neue regionale Fluggesellschaft gründen. Die RailsAir!
    Fangen wir mal an:<screen>stefan@swmbp 0 1.9.1-p378 book$ <command>rails new railsair</command>
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb

      [...]

      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.1-p378 book$</screen></para>

    <para>So jetzt noch in das neue Verzeichnis wechseln und <command>bundle
    install</command> ausführen:<screen>stefan@swmbp 0 1.9.1-p378 book$ <command>cd railsair</command>
stefan@swmbp 0 1.9.1-p378 railsair$ <command>bundle install</command>
Fetching source index from http://rubygems.org/
Using rake (0.8.7) from bundler gems 
Using abstract (1.0.0) from bundler gems 
Using activesupport (3.0.0.beta4) from bundler gems 

[...]

Using rails (3.0.0.beta4) from bundler gems 
Using sqlite3-ruby (1.3.0) from bundler gems 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
  </section>

  <section xml:id="railsair_flight_scaffold">
    <title xml:id="railsair_flight_scaffold.title">Welche Flugnummern werden
    mit welchen Routen geflogen?</title>

    <para>Als Basis für dieses Kapitel erstellen wir jetzt eine Flugdatenbank.
    Der Einfachheit halber mit Scaffolding:</para>

    <para><screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails generate scaffold flight flight_number:string departure_airport:string destination_airport:string</command>
      invoke  active_record
      create    db/migrate/20100617123001_create_flights.rb
      create    app/models/flight.rb

      [...]

      create        test/unit/helpers/flights_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>

    <para>Die Datenbank anlegen:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:migrate</command>
(in /Users/stefan/book/railsair)
==  CreateFlights: migrating ==================================================
-- create_table(:flights)
   -&gt; 0.0017s
==  CreateFlights: migrated (0.0018s) =========================================

stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
  </section>

  <section xml:id="anlegen_und_anzeigen_von_datensaetzen">
    <title xml:id="anlegen_und_anzeigen_von_datensaetzen.title">Anlegen und
    Anzeigen von Datensätzen</title>

    <para>Wir arbeiten mit der Rails Console (siehe <xref
    linkend="die_console" />):<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; </screen></para>

    <section>
      <title>Neuen Datensatz anlegen</title>

      <para>ActiveRecord stellt uns automagisch eine Klasse aus der Datenbank
      <parameter>flights</parameter> mit dem Namen
      <classname>Flight</classname> zur Verfügung. Diese Klasse hat eine
      Methode <methodname>new</methodname> und mit der können wir ein neues
      Objekt erstellen. <screen>ruby-1.9.1-p378 &gt; <command>apfelmus = Flight.new</command>
 =&gt; #&lt;Flight id: nil, flight_number: nil, departure_airport: nil, destination_airport: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Wir können uns sicherheitshalber noch mal die Klasse der Instance
      <varname>apfelmus</varname> ausgeben lassen.<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Das neue Objekt <varname>apfelmus</varname> hat automatsch
      Accessors (siehe <xref linkend="getter_und_setter_methoden" />) zu den
      einzelnen Datenfeldern. Diese benutzen wir zum Füllen des ersten
      Datensatzes:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.flight_number = 'RA 001'</command>
 =&gt; "RA 001" 
ruby-1.9.1-p378 &gt; <command>apfelmus.departure_airport = 'FRA'</command>
 =&gt; "FRA" 
ruby-1.9.1-p378 &gt; <command>apfelmus.destination_airport = 'MUC'</command>
 =&gt; "MUC" 
ruby-1.9.1-p378 &gt; <command>apfelmus</command>
 =&gt; #&lt;Flight id: nil, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Objekt ist allerdings noch nicht in der Datenbank gespeichert.
      Das erfolgt erst durch Aufruf der Methode
      <methodname>save</methodname>.<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>

      <section>
        <title>Datensatz mit create anlegen</title>

        <para>Sie können nicht nur mit der Methode
        <methodname>new</methodname> ein neues Objekt der Klasse
        <classname>Flight</classname> anlegen, um dieses später mit
        <methodname>save</methodname> in der Datenbank zu speichern. Sie
        können auch direkt mit der Methode <methodname>create</methodname>
        einen Datensatz in der Datenbank anlegen:</para>

        <para>Alternative können wir einen zweiten Datensatz auch direkt mit
        der Methode <methodname>create</methodname> anlegen.<screen>ruby-1.9.1-p378 &gt; <command>Flight.create(:flight_number =&gt; 'RA 002', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'HAM')</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:02:03", updated_at: "2010-06-17 13:02:03"&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Sie können einen so neu erstellten Datensatz auch direkt in
        einer Variable speichern:<screen>ruby-1.9.1-p378 &gt; <command>pflaumenmus = Flight.create(:flight_number =&gt; 'RA 003', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'HAM')</command>
 =&gt; #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:03:46", updated_at: "2010-06-17 13:03:46"&gt; 
ruby-1.9.1-p378 &gt; <command>pflaumenmus.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Die Methode <methodname>create</methodname> nimmt übrigens auch
        ein Array (siehe <xref linkend="ruby_array" />) von neuen Objekten an.
        So können Sie auch mehr als einen <varname>Flight</varname> auf einmal
        erzeugen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.create([{:flight_number =&gt; 'RA 004', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'DUS'},{:flight_number =&gt; 'RA 005', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'TXL'}])</command>
 =&gt; [#&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:06:28", updated_at: "2010-06-17 13:06:28"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:06:28", updated_at: "2010-06-17 13:06:28"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

        <section>
          <title>Hilfe zu create</title>

          <para>Die Methode <methodname>create</methodname> gehört zu
          <classname>ActiveRecord::Base</classname>. Die online Hilfe dazu
          kann mit <command>ri ActiveRecord::Base.create</command> abgerufen
          werden. Wenn Sie das jetzt ausprobieren wollen, müssen Sie natürlich
          erst mit <command>exit</command> aus der Console raus.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>ri ActiveRecord::Base.create</command>
ActiveRecord::Base.create

(from gem activerecord-3.0.0.beta4)
------------------------------------------------------------------------------
  create(attributes = nil) { |object| ... }

------------------------------------------------------------------------------

Creates an object (or multiple objects) and saves it to the database, if
validations pass. The resulting object is returned whether the object was
saved successfully to the database or not.

The attributes parameter can be either be a Hash or an Array of Hashes.
 These Hashes describe the attributes on the objects that are to be created.

Examples
  # Create a single new object
  User.create(:first_name =&gt; 'Jamie')

  # Create an Array of new objects
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])

  # Create a single object and pass it into a block to set other attributes.
  User.create(:first_name =&gt; 'Jamie') do |u|
    u.is_admin = false
  end

  # Creating an Array of new objects using a block, where the block is executed for each object:
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
    u.is_admin = false
  end


stefan@swmbp 0 1.9.1-p378 railsair$
</screen></para>
        </section>
      </section>
    </section>

    <section xml:id="seed_rb">
      <title xml:id="seed_rb.title">Mit seed.rb die Entwicklungsdatenbank
      betanken</title>

      <para>In der Entwicklung von neuen Rails Projekten kommt es immer mal
      wieder vor, das man den Inhalt der Datenbank löschen und mit neuen
      Werten befüllen will. In Rails gibt es dafür den praktischen Mechanismus
      der Datei <filename>db/seeds.rb</filename></para>

      <para>Die <filename>db/seeds.rb</filename> ist ein normales
      Ruby-Programm, das man mit <command>rake db:seed</command> ausführen
      kann. Dies geht natürlich nicht nur mit der Entwicklungsdatenbank,
      sondern kann später auch in der Produktion geschehen. Das ist z.B.
      praktisch, wenn man initial eine Länderliste in eine Länderdatenbank
      eintragen will.</para>

      <para>Für unsere Flight-Datenbank habe ich folgende
      <filename>db/seeds.rb</filename> vorbereitet:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Flight.create(:flight_number =&gt; 'RA 001', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'MUC')
Flight.create(:flight_number =&gt; 'RA 002', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'HAM')
Flight.create(:flight_number =&gt; 'RA 003', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'HAM')
Flight.create(:flight_number =&gt; 'RA 004', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'DUS')
Flight.create(:flight_number =&gt; 'RA 005', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'TXL')</programlisting></para>

      <section>
        <title>Betankung</title>

        <para>Die Datenbank können wir <command>rake db:reset</command>
        resetten.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:reset</command>
(in /Users/stefan/book/railsair)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("flights", {:force=&gt;true})
   -&gt; 0.0142s
-- initialize_schema_migrations_table()
   -&gt; 0.0057s
-- assume_migrated_upto_version(20100617123001, "db/migrate")
   -&gt; 0.0026s
rake aborted!
undefined method `&lt;=&gt;' for class `ActiveSupport::Multibyte::Chars'

(See full trace by running task with --trace)
stefan@swmbp 1 1.9.1-p378 railsair$</screen></para>

        <para>Um sie dann mit <command>rake db:seed</command> zu
        betanken.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:seed</command>
(in /Users/stefan/book/test/railsair)
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="einfache_queries">
    <title xml:id="einfache_queries.title">Query</title>

    <para>So, das wird jetzt ein wenig komplexer. Muss man sich nicht beim
    ersten mal ganz durchlesen, aber schaden kann es auch nicht.</para>

    <note>
      <para>In diesem Kapitel werden absichtlich keine Methoden benutzt, die
      in Rails 3.0 deprecated sind.</para>
    </note>

    <section>
      <title>first und last</title>

      <para>Mit den Methoden <methodname>first</methodname> und
      <methodname>last</methodname> können wir uns den ersten und den letzten
      Datensatz aus einer Datenbank-Tabelle ausgeben lassen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.last</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Ergebnis von <methodname>Flight.first</methodname> ist
      natürlich eine <classname>Flight</classname> Klasse:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>all</title>

      <para>Der einfachste Weg alle Datensätze aus der Datenbank
      <varname>flights</varname> anzuzeigen ist die Methode
      <methodname>all</methodname>:<screen>ruby-1.9.1-p378 &gt; <command>Flight.all</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <tip>
        <para>Sie können sich mit dem Programm <command>pp</command> die
        Ausgabe von <methodname>Flight.all</methodname> etwas übersichtlicher
        darstellen lassen:<screen>ruby-1.9.1-p378 &gt; <command>pp Flight.all</command>
[#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;,
 #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;,
 #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;,
 #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;,
 #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; </screen></para>
      </tip>

      <para>Was für eine Klasse ist das Ergebnis von
      <classname>Flight.all</classname>? Schauen wir mal mit der Methode
      <methodname>class</methodname> nach:<screen>ruby-1.9.1-p378 &gt; <command>Flight.all.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Dann können wir ja die Iterator-Methode
      <methodname>each</methodname> anwenden (siehe <xref
      linkend="array_iterator" />), um durch die einzelnen Elemente des Arrays
      zu gehen. Damit können Sie sich als Beispiel alle Flugnummern ausgeben
      lassen.<screen>ruby-1.9.1-p378 &gt; <command>Flight.all.each { |flight| puts flight.flight_number }</command>
RA 001
RA 002
RA 003
RA 004
RA 005
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>Nach ID suchen</title>

      <para>Einen Flight nach der Datenbank-ID zu suchen geht mit der Methode
      <methodname>find</methodname>(ID):<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(1)</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Ergebnis von <methodname>Flight.find(1)</methodname> ist
      natürlich eine <classname>Flight</classname> Klasse:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(1).class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Wir können aber auch mehrere IDs auf einmal suchen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(2,4,5)</command>
 =&gt; [#&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Ergebnis ist dann logischerweise dann wiederum ein Array
      (siehe <xref linkend="ruby_array" />):<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(2,4,5).class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Mit diesem Array können Sie dann wieder die Iterator-Methoden
      benutzen (siehe <xref linkend="array_iterator" />).</para>

      <section>
        <title>Verhalten bei "nicht gefunden"</title>

        <para>Wer mit <methodname>find(ID)</methodname> einen bestimmten
        Datensatz abrufen will, sollte sicher sein, das es diesen Datensatz
        auch gibt. Sonst kommt es zu einem Fehler, den man extra abfangen
        müsste:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(100)</command>
ActiveRecord::RecordNotFound: Couldn't find Flight with ID=100
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/relation/finder_methods.rb:287:in `find_one'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/relation/finder_methods.rb:274:in `find_with_ids'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/relation/finder_methods.rb:102:in `find'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/base.rb:403:in `find'
 from (irb):27
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:47:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Man kann übrigens mit der Methode
        <methodname>exists?(ID)</methodname> vor einem
        <methodname>find(ID)</methodname> überprüfen, ob der entsprechende
        Datensatz in der Datenbank existiert. Das Ergebnis von
        <methodname>exists?(ID)</methodname> ist ein Boolean.<screen>ruby-1.9.1-p378 &gt; <command>Flight.exists?(100)</command>
 =&gt; false 
ruby-1.9.1-p378 &gt; <command>Flight.exists?(2)</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>

        <para><warning>
            <para>Mehr der Form halber möchte ich hier erwähnen, das es bei
            einem <methodname>exists(ID)</methodname> gefolgt von einem
            <methodname>find(ID)</methodname> durchaus zu einer Race-Condition
            kommen kann. Unwahrscheinlich, aber nicht unmöglich. Es kann ja
            sein, das in der minimalen Zeit zwischen den beiden Befehlen ein
            anderes Programm genau diese Tabellen-ID löscht.</para>
          </warning></para>
      </section>
    </section>

    <section>
      <title>find_by_x und find_all_by_x</title>

      <para>Bei der Benutzung von find_by kommt ein wenig Ruby-Magie ins
      Spiel. Die Methode <methodname>find</methodname> kann dynamisch mit
      <methodname>_by_</methodname> und dem Feldnamen erweitert werden und
      gibt dann den ersten Treffer der Suche aus. Am einfachsten zeigt sich
      das mit ein paar Beispielen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport('FRA')</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find_by_destination_airport('TXL')</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Man kann <methodname>find_by_x</methodname> Methoden weiterhin
      beliebig mit <methodname>_and_</methodname> um weitere Feldnamen
      verlängern:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport_and_destination_airport('MUC','DUS')</command>
 =&gt; #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Während <methodname>find_by_x</methodname> immer nur den ersten
      gefundenen Datensatz ausgibt, kann man mit
      <methodname>find_all_by_x</methodname> alle Treffer für diese Anfrage
      als Array bekommen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('FRA')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('FRA').class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <section>
        <title>Verhalten bei "nicht gefunden"</title>

        <para>Wenn ein <methodname>find_by</methodname> keinen Treffer findet,
        dann ist das Ergebnis nil:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport('LAX')</command>
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport('LAX').class</command>
 =&gt; NilClass 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Kein Treffer bei einem <methodname>find_all_by</methodname>
        Aufruf ist ein leeres Array:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('LAX')</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('LAX').class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt; </screen></para>
      </section>
    </section>

    <section>
      <title>where</title>

      <para>Eine sehr mächtige Alternative zu
      <methodname>find_all_by</methodname> die Methode
      <methodname>where</methodname>:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Einer der Vorteile von <methodname>where</methodname> im Vergleich
      zu <methodname>find_all_by</methodname> ist die Möglichkeit es
      hintereinander zu schalten:<screen>ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').where(:production_year =&gt; 2007)</command>
 =&gt; [#&lt;Airplane id: 5, name: "Orlando", model: "Boing 747", production_year: 2007, seats: 467, created_at: "2010-06-14 11:51:10", updated_at: "2010-06-14 11:51:10"&gt;] 
ruby-head &gt;</screen></para>

      <section>
        <title>count</title>

        <para>Mit der Methode <methodname>count</methodname> kann man sich
        dann die Anzahl der gefundenen Flights ausrechnen lassen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').count</command>
 =&gt; 3 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Jetzt mal eine kleine Quizfrage: "Zählt Rails die Anzahl der
        Objekte im Array, das von <command>Flight.where(:departure_airport
        =&gt; 'FRA').count</command> ausgegeben wird oder geht es
        intelligenter vor?". Die Antwort liegt im Logfile
        <filename>log/development.log</filename><screen>  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "flights" WHERE ("flights"."departure_airport" = 'FRA')
</screen></para>

        <para>ActiveRecord überlässt also nicht Ruby on Rails das Zählen des
        Ergebnis-Arrays von <command>Flight.where(:departure_airport =&gt;
        'FRA')</command> sondern fügt das <code>COUNT</code> der SQL Anweisung
        hinzu und lässt die Datenbank diese Berechnung vollziehen (was viel
        schneller und Resourcen-schonender ist).</para>
      </section>

      <section>
        <title>Verhalten bei "nicht gefunden"</title>

        <para>Die Methode <methodname>where</methodname> gibt als Ergebnis
        einer nicht erfolgreichen Suche ein leeres Array aus:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX')</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt;</screen></para>

        <note>
          <para>Man kann natürlich argumentieren, das das Ergebnis einer
          erfolglosen Suche ein ActiveRecord::Relation ist, das erst bei einem
          weiteren Vergleich wirklich aufgelöst wird. Stimmt. Da sich aber
          ActiveRecord darum automatisch kümmert, kann man diese Genauigkeit
          in der Praxis getrost vernachlässigen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX')</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX').class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX') == Array.new</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>
        </note>
      </section>
    </section>

    <section>
      <title>Sortieren</title>

      <para>Mit der Methode <methodname>order()</methodname> können Sie die
      Ergebnisse einer Abfrage sortieren. Dabei können Sie als Parameter ein
      Symbol (siehe <xref linkend="ruby_symbol" />) oder den entsprechenden
      SQL-Befehl (<code>asc</code> = aufsteigend und <code>desc</code> =
      absteigend) übergeben.<screen>ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport)</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;] 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').order('flight_number desc')</command>
 =&gt; [#&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Wenn Sie erst nach Abflug- und dann nach Zielflughafen sortieren
      wollen, so können Sie dies wie folgt machen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport, :destination_airport)</command>
 =&gt; [#&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-18 14:29:01", updated_at: "2010-06-18 14:29:01"&gt;, #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-18 14:28:54", updated_at: "2010-06-18 14:28:54"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-18 14:29:01", updated_at: "2010-06-18 14:29:01"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-18 14:29:01", updated_at: "2010-06-18 14:29:01"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-18 14:29:01", updated_at: "2010-06-18 14:29:01"&gt;] 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Auch hier sorgt Lazy Loading (siehe <xref
      linkend="lazy_loading" />) im Hintergrund für performantere
      Programme:<screen>ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport).to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" ORDER BY  departure_airport" 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').order('flight_number desc').class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').order('flight_number desc').to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA') ORDER BY  flight_number desc" 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>Limit</title>

      <para>Zum Schluss zeige ich Ihnen noch die
      <methodname>limit</methodname> Methode, mit der Sie die Anzahl der
      Ergebnisse limitieren können:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').limit(2)</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;] 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Ja, auch dies ist wieder ein Fall für Lazy Loading (siehe <xref
      linkend="lazy_loading" />):<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').limit(2).to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA') LIMIT 2" 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>Berechnungen</title>

      <para>ActiveRecord gibt uns direkten Zugriff auf eine Hand voll
      Berechnungsmethoden die von einer SQL-Datenbank durchgeführt werden
      können. Auch hier gilt der Grundsatz: Im Zweifel kann die Datenbank eine
      dieser Berechnungen schneller, als wir im Programm.<note>
          <para>Dummerweise habe ich ihm Beispiel keine Zahlen in den Tabellen
          eingebaut. Das hat man davon, wenn man möglichst einfache Beispiele
          wählt. Aus diesem Grund greife ich bei den folgenden Methoden
          teilweise auf eine imaginäre <classname>Airplane</classname>
          Datenbank zurück, die die Fehler <varname>:production_year</varname>
          und <varname>:seats</varname> hat.</para>
        </note></para>

      <section>
        <title>count</title>

        <para>Mit <methodname>count</methodname> kann man die Anzahl der
        Datensätze berechnen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').count</command>
 =&gt; 3 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>average</title>

        <para>Mit <methodname>average</methodname> kann man den
        Durchschnittswert eines Tabellenfeldes berechnen:<screen>ruby-head &gt; <command>Airplane.average(:seats)</command>
 =&gt; #&lt;BigDecimal:101377858,'0.4941667E3',18(18)&gt; 
ruby-head &gt; <command>Airplane.average(:seats).to_i</command>
 =&gt; 494 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').average(:production_year)</command>
 =&gt; #&lt;BigDecimal:1013321e0,'0.20056667E4',18(18)&gt; 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').average(:production_year).to_i</command> 
 =&gt; 2005 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').average(:production_year).to_f</command> 
 =&gt; 2005.6667 
ruby-head &gt;</screen></para>
      </section>

      <section>
        <title>minimum und maximum</title>

        <para>Mit den Methoden <methodname>minimum</methodname> und
        <methodname>maximum</methodname> kann man das jeweilige Minimum oder
        Maximum eines Feldes berechnen:<screen>ruby-head &gt; <command>Airplane.minimum(:seats)</command>
 =&gt; 300 
ruby-head &gt; <command>Airplane.maximum(:seats)</command>
 =&gt; 852 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').minimum(:production_year)</command>
 =&gt; 2005 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').maximum(:production_year)</command>
 =&gt; 2007 
ruby-head &gt; </screen></para>
      </section>

      <section>
        <title>sum</title>

        <para>Mit der Methode <methodname>sum</methodname> kann man die Summe
        eines bestimmten Feldes in Einträgen berechnen: <screen>ruby-head &gt; <command>Airplane.sum(:seats)</command>
 =&gt; 2965 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').sum(:seats)</command>
 =&gt; 1401 
ruby-head &gt; </screen></para>
      </section>
    </section>
  </section>

  <section xml:id="datensatz-editieren">
    <title>Einen Datensatz editieren</title>

    <para>Das Verändern eines Datensatzes erfolgt in zwei
    Schritten:<orderedlist>
        <listitem>
          <para>Suche des Datensatzes und erstellen einer entsprechenden
          Instanz.</para>
        </listitem>

        <listitem>
          <para>Verändern der Werte.</para>
        </listitem>

        <listitem>
          <para>Abspeichern des Datensatzes mit der Methode
          <methodname>save</methodname>.</para>
        </listitem>
      </orderedlist></para>

    <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus = Flight.find_by_destination_airport('TXL')</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt; 
ruby-1.9.1-p378 &gt; <command>apfelmus.destination_airport = 'CDG'</command>
 =&gt; "CDG" 
ruby-1.9.1-p378 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; <command>Flight.find_by_destination_airport('CDG')</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "CDG", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 15:13:29"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

    <section xml:id="activerecord_locking">
      <title xml:id="activerecord_locking.title">Locking</title>

      <para>Per Default benutzt Rails Optimistisches Locking der Datensätze.
      Dies kann aber umgeschaltet werden. Da für die meisten User
      Optimistisches Locking optimal ist und viele vor diesem Absatz nicht mal
      über das Problem nachgedacht haben, werde ich nicht weiter drauf
      eingehen, sondern auf die ri Hilfe verweisen. Wer pessimistisches
      Locking benötigt, der findet dort die notwendigen Schalter.</para>

      <para><screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>ri ActiveRecord::Locking::Optimistic</command>
ActiveRecord::Locking::Optimistic

(from gem activerecord-3.0.0.beta4)
------------------------------------------------------------------------------
What is Optimistic Locking

Optimistic locking allows multiple users to access the same record for edits,
and assumes a minimum of conflicts with the data.  It does this by checking
whether another process has made changes to a record since it was opened, an
ActiveRecord::StaleObjectError is thrown if that has occurred and the update
is ignored.

Check out ActiveRecord::Locking::Pessimistic for an alternative.

Usage

Active Records support optimistic locking if the field lock_version is
present.  Each update to the record increments the lock_version column and the
locking facilities ensure that records instantiated twice will let the last
one saved raise a StaleObjectError if the first was also updated. Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.first_name = "should fail"
  p2.save # Raises a ActiveRecord::StaleObjectError

Optimistic locking will also check for stale data when objects are destroyed. 
Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.destroy # Raises a ActiveRecord::StaleObjectError

You're then responsible for dealing with the conflict by rescuing the
exception and either rolling back, merging, or otherwise apply the business
logic needed to resolve the conflict.

You must ensure that your database schema defaults the lock_version column to
0.

This behavior can be turned off by setting
ActiveRecord::Base.lock_optimistically = false. To override the name of
the lock_version column, invoke the set_locking_column method. This
method uses the same syntax as set_table_name

------------------------------------------------------------------------------
Instance methods:

  attributes_from_column_definition


stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
    </section>
  </section>

  <section xml:id="activerecord_transaction">
    <title xml:id="activerecord_transaction.title">Transaction</title>

    <para>Es gibt immer mal wieder Anwendungsgebiete, bei denen man eine
    Datenbank-Transaktion durchführen muss. Das klassische Beispiel dafür ist
    eine Geldbewegung von einem zu einem anderen Konto. Die macht nur Sinn,
    wenn beide Aktionen ausgeführt werden.</para>

    <para>Eine Transaktion wird nach folgendem Bauplan
    durchgeführt:<programlisting>ActiveRecord::Base.transaction do
    was_immer_der_erste_schritt_ist
    was_immer_der_zweite_schritt_ist
    was_immer_der_dritte_schritt_ist
end</programlisting></para>

    <para>Wenn wir in unserem Flugplan die Flugnummern des ersten und des
    zweiten Datensatzes austauschen wollen, dann wäre das auch ein klassischer
    Fall für eine Transaktion. An sonsten hätten wir bei einem Fehler zwei mal
    die gleiche Flugnummer in der Datenbank. Versuchen wir es einmal:<screen>ruby-1.9.1-p378 &gt; <command>erster_flug = Flight.find(1)</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>zweiter_flug = Flight.find(2)</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt; 
ruby-1.9.1-p378 &gt; <command>ActiveRecord::Base.transaction do</command>
ruby-1.9.1-p378 &gt;   <command>erster_flug.flight_number = 'RA 002'</command>
ruby-1.9.1-p378 ?&gt;  <command>erster_flug.save</command>
ruby-1.9.1-p378 ?&gt;  <command>zweiter_flug.flight_number = 'RA 001'</command>
ruby-1.9.1-p378 ?&gt;  <command>zweiter_flug.save</command>
ruby-1.9.1-p378 ?&gt;  <command>end</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>

    <para>Die Transaktion wurde erfolgreich durchgeführt:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(1)</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(2)</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

    <para>Tansaktionen sind ein komplexes Thema. Wenn Sie mehr Informationen
    dazu suchen, können Sie die ri Hilfe dafür mit <command>ri
    ActiveRecord::Transactions::ClassMethods</command> auf der Shell
    abrufen.<important>
        <para>Die Methoden <methodname>save</methodname> und
        <methodname>destroy</methodname> werden automatisch in
        Transaktions-Wrapper ausgeführt. So stellt Rails sicher, das bei
        diesen Methoden kein undefinierter Zustand entsteht.</para>
      </important></para>
  </section>

  <section xml:id="datensatz-loeschen">
    <title>Einen Datensatz löschen</title>

    <para>Es gibt die Methoden <methodname>destroy</methodname> und
    <methodname>delete</methodname>, um Datensätze zu löschen.</para>

    <section xml:id="activerecord_destroy">
      <title xml:id="activerecord_destroy.title">destroy</title>

      <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
      löschen und dabei werden auch vorhandene Abhängigkeiten beachtet.
      Vereinfacht kann man sagen: "Lieber destroy nehmen, das ist sicherer,
      weil das Rails-System dann mehr mitdenkt."<important>
          <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
          (eingefroren). Sie ist also noch da, kann aber nicht verändert
          werden.</para>
        </important></para>

      <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc = Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc.destroy</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Der Datensatz ist also in der Datenbank gelöscht worden.
      Allerdings enthält das Object <varname>fra_muc</varname> noch die Daten
      und ist im frozen-State:<screen>ruby-1.9.1-p378 &gt; <command>fra_muc</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc.frozen?</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Wozu das gut ist? Erst mal ist es wichtig für das Verständnis von
      der Arbeit mit ActiveRecords. Man muss immer im Hinterkopf behalten, was
      im eigenen Objekt und was in der Datenbank ist.</para>

      <para>Aber ganz praktisch gesprochen kann man ein frozen-Objekt und die
      Methode <methodname>attributes</methodname> dazu benutzen einen
      versehentlich gelöschten Datensatz in einen neuen Datensatz zu
      speichern:<screen>ruby-1.9.1-p378 &gt; <command>fra_muc</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc.attributes</command>
 =&gt; {"created_at"=&gt;2010-06-17 13:41:06 UTC, "departure_airport"=&gt;"FRA", "destination_airport"=&gt;"MUC", "flight_number"=&gt;"RA 002", "id"=&gt;1, "updated_at"=&gt;2010-06-17 15:44:56 UTC} 
ruby-1.9.1-p378 &gt; <command>Flight.create(fra_muc.attributes)</command>
 =&gt; #&lt;Flight id: 6, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.last</command>
 =&gt; #&lt;Flight id: 6, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section xml:id="activerecord_delete">
      <title xml:id="activerecord_delete.title">delete</title>

      <para>Mit <methodname>delete</methodname> können Sie einen Datensatz
      direkt in der Datenbank löschen. Dabei werden keine Abhängigkeiten zu
      anderen Datensätzen im Model beachtet. Die Methode
      <methodname>delete</methodname> löscht also nur die eine Zeile in der
      Datenbank und sonst nichts.<note>
          <para>Für unseren jetzigen Kenntnisstand sind solche Abhänigkeiten
          noch egal, aber in späteren Kapiteln werden wir verschiedene
          Tabellen mit einander verknüpfen und dann wird es entsprechende
          Abhängigkeiten geben.</para>
        </note></para>

      <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>fra_ham = Flight.first</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_ham.delete</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Wie bei <methodname>destroy</methodname> geht das Objekt auch hier
      nach dem <methodname>delete</methodname> in den frozen-Status
      über:<screen>ruby-1.9.1-p378 &gt; <command>fra_ham.frozen?</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>
    </section>
  </section>
</chapter>
