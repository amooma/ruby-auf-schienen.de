<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="activerecord_chapter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_chapter.title">ActiveRecord</title>

  <info>
    <collab>
      <person>
        <personname><firstname>Philipp</firstname><surname>Kempgen</surname></personname>
      </person>
    </collab>
  </info>

  <indexterm>
    <primary>ActiveRecord</primary>
  </indexterm>

  <indexterm>
    <primary>Active Record (Muster)</primary>

    <see>ActiveRecord</see>
  </indexterm>

  <indexterm>
    <primary>Datenbank</primary>

    <seealso>ActiveRecord</seealso>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <seealso>Datenbank</seealso>
  </indexterm>

  <indexterm>
    <primary>ORM</primary>

    <seealso>Datenbank</seealso>
  </indexterm>

  <para><literal>ActiveRecord</literal> ist eine Abstaktionsschicht, die es
  uns einen sehr leichten Zugang zu einer <indexterm>
      <primary>SQL-Datenbank</primary>

      <see>Datenbank</see>
    </indexterm><indexterm>
      <primary>Datenbank</primary>

      <secondary>relational (SQL)</secondary>
    </indexterm><indexterm>
      <primary>relationale Datenbank</primary>

      <see>Datenbank</see>
    </indexterm>SQL-Datenbank zur Verfügung stellt.
  <literal>ActiveRecord</literal> implementiert das Architektur-Muster
  <foreignphrase xml:lang="en">Active Record</foreignphrase> <footnote>
      <para>siehe <uri
      xlink:href="http://en.wikipedia.org/wiki/Active_record_pattern">http://en.wikipedia.org/wiki/Active_record_pattern</uri></para>
    </footnote>.</para>

  <note>
    <para>Das nennt sich dann <indexterm>
        <primary>Objektrelationale Abbildung</primary>

        <see>ORM</see>
      </indexterm>objektrelationale Abbildung (<indexterm>
        <primary>Object-relational mapping</primary>

        <see>ORM</see>
      </indexterm><foreignphrase xml:lang="en">Object-relational
    mapping</foreignphrase>, <indexterm>
        <primary>ORM (Object-relational mapping)</primary>
      </indexterm><foreignphrase xml:lang="en">ORM</foreignphrase>). Ich
    empfinde das als zu trocken und langweilig, aber falls Sie heute Abend
    nicht einschlafen können, werfen Sie doch mal einen Blick auf <uri
    xlink:href="http://de.wikipedia.org/wiki/Objektrelationale_Abbildung">http://de.wikipedia.org/wiki/Objektrelationale_Abbildung</uri>.</para>
  </note>

  <para>Einer der Erfolgsrezepte von Rails ist sicherlich die Benutzung von
  <literal>ActiveRecord</literal>. Die Programmierung und Benutzung
  <quote>fühlt sich gut an</quote> und es ist viel weniger fehleranfällig als
  pures SQL. Bei der Arbeit mit diesem Kapitel hilft SQL-Wissen, aber es wird
  nicht vorausgesetzt, und es ist auch für die Arbeit mit
  <literal>ActiveRecord</literal> nicht notwendig.</para>

  <para>Nur am Rande sei hier erwähnt, das Sie bei der Arbeit mit Rails nicht
  zum Arbeiten mit ActiveRecord verpflichtet sind. Sie können auch andere ORMs
  benutzen. ActiveRecord ist der Default und wird auch von der Mehrheit aller
  Rails-Entwickler benutzt.</para>

  <section xml:id="activerecord-howto-zum-kapitel">
    <title>Howto zum Kapitel</title>

    <para>Dieses Kapitel ist in sich selbst geschlossen. Allerdings wird das
    Wissen aus <xref linkend="ruby-grundlagen" /> und <xref
    linkend="erste_schritte_mit_rails" /> vorausgesetzt. Ohne dieses
    Grundwissen werden Sie keinen Spaß an diesem Kapitel haben!</para>

    <para>Der Rails-Anfänger sollte das Kapitel einmal von oben bis unten
    durcharbeiten. Das heißt konkret: Alle Schritte in der eigenen
    <foreignphrase xml:lang="en">Console</foreignphrase> (siehe <xref
    linkend="die_console" />) mit ausprobieren und ruhig selber links und
    rechts mal ein wenig experimentieren. Bitte nehmen Sie sich Zeit. Es ist
    ein wichtiges Kapitel!</para>

    <para><note>
        <para>Es geht in diesem Kapitel um ActiveRecord. Deshalb: Um die
        Beispiele so übersichtlich wie möglich zu halten werde ich deshalb
        keine Tests (siehe <xref linkend="tests" />) einbauen.</para>
      </note></para>

    <section xml:id="activerecord-keine-lust-auf-sql">
      <title>Keine Lust auf SQL?</title>

      <para>Hin und wieder werde ich den durch eine ActiveRecord-Methode
      erzeugten SQL-Code in der Log-Datei nachschlagen. Wenn Sie sich nicht
      für SQL interessieren: Einfach überlesen. Das Schöne an ActiveRecord ist
      ja dass man sich darum keinen Kopf machen muss. Für alle anderen dient
      es zum besseren Verständnis der im Hintergrund laufenden
      Optimierungen.</para>

      <tip>
        <para>Wenn Sie sich für diese Optimierungen interessieren, so empfehle
        ich Ihnen bei diesen Übungen und auch später bei der Entwicklung immer
        noch ein zweites Terminal mit einem <command>tail -f
        log/development.log</command> laufen zu lassen. Dort sehen Sie dann
        immer, was gerade auf der Datenbank-Ebene abläuft.</para>
      </tip>
    </section>

    <section xml:id="activerecord_blut_lecken">
      <title xml:id="activerecord_blut_lecken.title">Blut lecken</title>

      <para>Dieses Buch ist ein Einsteigerbuch. Entsprechend werden hier die
      Grundlagen für die Benutzung von ActiveRecord besprochen. Es wäre ein
      leichtes ein doppelt so dickes Buch nur über ActiveRecord zu schreiben.
      Lassen Sie sich von diesem Kapitel anfixen und forschen Sie in den
      Dokumentationen zu Rails weiter (siehe <xref
      linkend="weiterfuehrende_doku" />).</para>

      <tip>
        <para>Einer meiner besten Freunde bei der Entwicklung von
        Rails-Applikationen ist die Tabulator-Taste. Wann immer Sie eine
        Methode für ein bestimmte Problem suchen, dann stellen Sie es in der
        Rails-Console nach, und drücken Sie zweimal auf die Tabulatortaste um
        alle verfügbaren Methoden für die entsprechende Klasse aufzulisten.
        Die Namen der Methoden sind meistens selbsterklärend.</para>
      </tip>
    </section>
  </section>

  <xi:include href="ar-datenbank_anlegen.xml" />

  <xi:include href="ar-datensaetze_hinzufuegen.xml" />

  <xi:include href="ar-first_last_all.xml" />

  <xi:include href="ar-seeds.xml" />

  <xi:include href="ar-queries.xml" />

  <section xml:id="activerecord_datensatz_veraendern">
    <title xml:id="activerecord_datensatz_veraendern.title">Einen Datensatz
    verändern</title>

    <para>Daten hinzufügen ist ja schon ganz nett, aber hin und wieder will
    man ja auch einen Datensatz editieren. Wir benutzen zur Beschreibung die
    Album-Datenbank aus <xref linkend="queries" />.</para>

    <section xml:id="activerecord_einfaches_editieren">
      <title xml:id="activerecord_einfaches_editieren.title">Einfaches
      Editieren</title>

      <para>Das einfache Editieren eines Datensatzes erfolgt in folgenden
      Schritten:<orderedlist>
          <listitem>
            <para>Suche des Datensatzes und erstellen einer entsprechenden
            Instanz</para>
          </listitem>

          <listitem>
            <para>Verändern der Werte</para>
          </listitem>

          <listitem>
            <para>Abspeichern des Datensatzes mit der Methode <indexterm>
                <primary>ActiveRecord</primary>

                <secondary>Methoden</secondary>

                <tertiary>save()</tertiary>
              </indexterm><methodname>save</methodname></para>
          </listitem>
        </orderedlist></para>

      <para>Wir suchen uns jetzt das Album mit dem Namen <quote>The
      Beatles</quote> und verändern den Namen in <quote>Ein
      Test</quote>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>apfelmus = Album.where( :name =&gt; 'The Beatles' ).first</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:53:00"&gt; 

ruby-1.9.2-p0 &gt; <command>apfelmus.name = 'Ein Test'</command>
 =&gt; "Ein Test" 

ruby-1.9.2-p0 &gt; <command>apfelmus</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:53:00"&gt; 

ruby-1.9.2-p0 &gt; <command>apfelmus.save</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:56:49"&gt; 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>

    <section xml:id="activerecord_changed">
      <title xml:id="activerecord_changed.title">changed?</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>changed?()</tertiary>
      </indexterm>

      <para>Wenn man sich nicht sicher ist, ob ein Datensatz verändert und
      noch nicht abgespeichert wurde, dann kann man dies mit der
      <methodname>changed?</methodname> Methode rausfinden:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>apfelmus = Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:56:49"&gt; 

ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; <command>apfelmus.name = 'The Beatles'</command>
 =&gt; "The Beatles" 

ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>apfelmus.save</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>

    <section xml:id="activerecord_update_attributes">
      <title
      xml:id="activerecord_update_attributes.title">update_attributes</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>update_attributes()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>update_attributes</methodname> kann
      man verschiedene Attribute eines Objektes auf einmal ändern und danach
      automatisch direkt speichern.</para>

      <para>Setzen wir damit das Beispiel von <xref
      linkend="activerecord_einfaches_editieren" /> um:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>apfelmus = Album.where( :name =&gt; 'The Beatles' ).first</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:22:17"&gt; 

ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; <command>apfelmus.update_attributes( :name =&gt; 'Ein Test' )</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:22:38"&gt; 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Ein solches Update lässt sich auch direkt an eine
      <methodname>where</methodname>-Methode anknüpfen <remark>FIXME: Ist aber
      so nicht unbedingt empfehlenswert oder? .first() könnte ja auch nil
      zurückgeben.</remark> und ist dann fast atomar:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Album.where( :name =&gt; 'Ein Test' ).first</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:22:38"&gt; 

ruby-1.9.2-p0 &gt; <command>Album.where( :name =&gt; 'Ein Test' ).first.update_attributes( :name =&gt; 'The Beatles' )</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>Album.where( :name =&gt; 'Ein Test' ).first</command> 
 =&gt; nil 

ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:24:41"&gt; 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Dass es aber doch noch zwei SQL-Befehle sind zeigt sich in der
      <filename>log/development.log</filename>:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."name" = 'Ein Test') LIMIT 1
  SQL (0.3ms)  UPDATE "albums" SET "name" = 'The Beatles', "updated_at" = '2010-10-08 20:24:41.644808' WHERE ("albums"."id" = 10)</programlisting></para>

      <remark>FIXME: Mal .first und .first.update... separat ausprobieren. Ist
      ja klar daß schon .first eine Abfrage erzeugt.</remark>
    </section>

    <section xml:id="activerecord_locking">
      <title xml:id="activerecord_locking.title">Locking</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Locking</secondary>
      </indexterm>

      <para>Per Default benutzt Rails sogenanntes <quote>optimistisches
      Locking</quote> (<foreignphrase xml:lang="en">optimistic
      Locking</foreignphrase>) der Datensätze. Dies kann aber umgeschaltet
      werden. Da für die meisten Anwender optimistisches Locking optimal ist
      und viele vor diesem Absatz nicht mal über das Problem nachgedacht
      haben, werde ich nicht weiter drauf eingehen, sondern auf die
      <literal>ri</literal>-Hilfe verweisen. Wer pessimistisches Locking
      benötigt, der findet dort die notwendigen Parameter.</para>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>ri -T ActiveRecord::Locking::Optimistic</command></screen><screen>ActiveRecord::Locking::Optimistic

(from gem activerecord-3.0.0)
------------------------------------------------------------------------------
What is Optimistic Locking

Optimistic locking allows multiple users to access the same record for edits,
and assumes a minimum of conflicts with the data.  It does this by checking
whether another process has made changes to a record since it was opened, an
ActiveRecord::StaleObjectError is thrown if that has occurred and the update
is ignored.

Check out ActiveRecord::Locking::Pessimistic for an alternative.

Usage

Active Records support optimistic locking if the field lock_version is
present.  Each update to the record increments the lock_version column and the
locking facilities ensure that records instantiated twice will let the last
one saved raise a StaleObjectError if the first was also updated. Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.first_name = "should fail"
  p2.save # Raises a ActiveRecord::StaleObjectError

Optimistic locking will also check for stale data when objects are destroyed. 
Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.destroy # Raises a ActiveRecord::StaleObjectError

You're then responsible for dealing with the conflict by rescuing the
exception and either rolling back, merging, or otherwise apply the business
logic needed to resolve the conflict.

You must ensure that your database schema defaults the lock_version column to
0.

This behavior can be turned off by setting
ActiveRecord::Base.lock_optimistically = false. To override the name of
the lock_version column, invoke the set_locking_column method. This
method uses the same syntax as set_table_name

------------------------------------------------------------------------------
Instance methods:

  attributes_from_column_definition</screen></para>
    </section>
  </section>

  <section xml:id="activerecord_has_many">
    <title xml:id="activerecord_has_many.title">has_many –
    1:n-Verknüpfung</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Relationen</secondary>

      <tertiary>has_many()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Relationen</secondary>

      <tertiary>belongs_to()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Assoziationen</secondary>

      <see>ActiveRecord, Relationen</see>
    </indexterm>

    <para>Um <methodname>has_many</methodname> zu erklären erstellen wir uns
    ein Mini-Telefonbuch. In diesem Telefonbuch gibt es ein <foreignphrase
    xml:lang="en">Model</foreignphrase> mit Personen und ein <foreignphrase
    xml:lang="en">Model</foreignphrase> mit Telefonnummern. Da jede Person
    mehrere Telefonnummern haben kann (z.B. Handy, Arbeit und Zuhause)
    benötigen wir zum Abbilden eine 1:n-Verknüpfung (<foreignphrase
    xml:lang="en">one-to-many association</foreignphrase>). Mal schauen wie
    einfach das ganze mit ActiveRecord ist.</para>

    <note>
      <para>Verknüpfungen nennt man übrigens auch Beziehung, Relationen
      (<foreignphrase xml:lang="en">Relations</foreignphrase> / <foreignphrase
      xml:lang="en">Relationships</foreignphrase>) oder Assoziationen
      (<foreignphrase xml:lang="en">Associations</foreignphrase>).</para>
    </note>

    <para>Erstellen wir als erstes die Rails-Applikation:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new phonebook</command>
      create  
      create  README
      <replaceable>[...]</replaceable>
      create  vendor/plugins/.gitkeep

stefan@swmbp 0 1.9.2-p0 ~$ <command>cd phonebook</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
<replaceable>[...]</replaceable>
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Jetzt legen wir die Personen-Datenbank-Tabelle an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model person firstname:string lastname:string</command>
      invoke  active_record
      create    db/migrate/20101008205425_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/unit/person_test.rb
      create      test/fixtures/people.yml

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <important>
      <para>Haben Sie gesehen wie Rails automatisch den Plural von
      <literal>person</literal> (nämlich <literal>people</literal>) genommen
      hat?</para>
    </important>

    <para>Und zum Schluss legen wir noch die Datenbank-Tabelle für die
    Telefonnummern an. In dieser benötigen wir ein Zuordnungsfeld zur
    Personen-Tabelle. Dieser Fremdschlüssel (<foreignphrase
    xml:lang="en">Foreign key</foreignphrase>) <remark>Wird auch auf dem DBMS
    ein Foreign Key angelegt?</remark> wird per Default immer als Name des
    referenzierten Objekts (hier: <literal>person</literal>) mit angehängtem
    <literal>_id</literal> gesetzt:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model phonenumber person_id:integer name:string number:string</command>
      invoke  active_record
      create    db/migrate/20101008205906_create_phonenumbers.rb
      create    app/models/phonenumber.rb
      invoke    test_unit
      create      test/unit/phonenumber_test.rb
      create      test/fixtures/phonenumbers.yml

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Danach ein <command>rake db:migrate</command> ausführen, damit die
    Datenbank-Tabellen auch angelegt werden:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0013s
==  CreatePeople: migrated (0.0014s) ==========================================

==  CreatePhonenumbers: migrating =============================================
-- create_table(:phonenumbers)
   -&gt; 0.0018s
==  CreatePhonenumbers: migrated (0.0020s) ====================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Schauen wir uns das mal auf der <foreignphrase
    xml:lang="en">Console</foreignphrase> an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; <command>Phonenumber</command>
 =&gt; Phonenumber(id: integer, person_id: integer, name: string, number: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Die zwei Datenbank-Tabellen sind eingerichtet und können mit
    ActiveRecord benutzt werden. Allerdings weiß ActiveRecord noch nichts von
    der 1:n-Beziehung der beiden. Das ist aber recht einfach in zwei Schritten
    realisierbar:<itemizedlist>
        <listitem>
          <para>Wir fügen in der <foreignphrase
          xml:lang="en">Model</foreignphrase>-Datei
          <filename>app/models/person.rb</filename> die Option
          <methodname>has_many</methodname> ein:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
end</programlisting></para>
        </listitem>

        <listitem>
          <para>Und wir fügen in der <foreignphrase
          xml:lang="en">Model</foreignphrase>-Datei
          <filename>app/models/phonenumber.rb</filename> die Option
          <methodname>belongs_to</methodname> ein:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
end</programlisting></para>
        </listitem>
      </itemizedlist></para>

    <para>Diese zwei einfachen Definitionen sorgen für eine ganze Menge
    Rails-Magie.</para>

    <section xml:id="activerecord_1n_erstellen">
      <title xml:id="activerecord_1n_erstellen.title">Datensätze
      erstellen</title>

      <para>Wir wollen in diesem Beispiel für Fritz Meier seine Handy-Nummer
      (0171-12345678), seine Büro-Nummer (030-7777777) und seine
      Privat-Festnetznummer (030-8888888) abspeichern.</para>

      <section xml:id="activerecord_hinzufuegen_manuell">
        <title xml:id="activerecord_hinzufuegen_manuell.title">Manuell</title>

        <para>Wir löschen die Datenbank und erstellen zuerst ein Objekt mit
        den Person-Daten. Dann merken wir uns die ID für diesen Datensatz und
        erstellen danach die drei Telefonnummern-Datensätze mit dieser ID im
        Feld <literal>person_id</literal>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0039s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0033s
-- initialize_schema_migrations_table()
   -&gt; 0.0060s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0043s

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' )</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy  = Phonenumber.create( :person_id =&gt; 1, :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_office = Phonenumber.create( :person_id =&gt; 1, :name =&gt; 'Office', :number =&gt; '030-7777777' )</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_home   = Phonenumber.create( :person_id =&gt; 1, :name =&gt; 'Home',   :number =&gt; '030-8888888' )</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>id()</tertiary>
        </indexterm>

        <para>Die <literal>person_id</literal> von Hand einzutragen ist
        natürlich sehr fehleranfällig. Das gleiche Ergebnis könnten wir auch
        einen Tick schöner mit <code>fritz.id</code> (also mit der Methode
        <methodname>id</methodname>)<remark>FIXME: Die Methode id() wurde noch
        nicht genannt oder?</remark> realisieren:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy  = Phonenumber.create( :person_id =&gt; fritz.id, :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_office = Phonenumber.create( :person_id =&gt; fritz.id, :name =&gt; 'Office', :number =&gt; '030-7777777' )</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_home   = Phonenumber.create( :person_id =&gt; fritz.id, :name =&gt; 'Home',   :number =&gt; '030-8888888' )</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Immer noch nicht super praktisch, oder? Nur Geduld! :-)</para>
      </section>

      <section xml:id="activerecord_hinzufuegen_create">
        <title xml:id="activerecord_hinzufuegen_create.title">create</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>create()</tertiary>
        </indexterm>

        <para>Jetzt versuchen wir das gleiche wie in <xref
        linkend="activerecord_hinzufuegen_manuell" />, aber benutzen diesmal
        ein wenige ActiveRecord-Magie. Wir können mit der Methode
        <methodname>create</methodname> von <literal>phonenumbers</literal>
        (<literal>phonenumbers</literal> im Plural, weil ja 1 zu
        <foreignphrase xml:lang="en">many</foreignphrase> = viele/mehrere) zu
        jedem <classname>Person</classname>-Objekt neue Telefonnummern
        hinzufügen. Diese werden automatisch korrekt mit der
        <literal>person_id</literal> bestückt:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:54:12", updated_at: "2010-10-09 10:54:12"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy  = fritz.phonenumbers.create( :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:54:58", updated_at: "2010-10-09 10:54:58"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_office = fritz.phonenumbers.create( :name =&gt; 'Office', :number =&gt; '030-7777777' )</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:56:35", updated_at: "2010-10-09 10:56:35"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_home   = fritz.phonenumbers.create( :name =&gt; 'Home',   :number =&gt; '030-8888888' )</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:57:21", updated_at: "2010-10-09 10:57:21"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:54:12", updated_at: "2010-10-09 10:54:12"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:54:58", updated_at: "2010-10-09 10:54:58"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:56:35", updated_at: "2010-10-09 10:56:35"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:57:21", updated_at: "2010-10-09 10:57:21"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Es geht sogar noch kürzer, da <methodname>create</methodname>
        statt nur einem <foreignphrase
        xml:lang="en">Hash</foreignphrase><remark>FIXME: Weiß der Leser daß er
        oben nicht etwa mehrere Parameter sondern implizit einen Hash
        übergeben hat, auch ohne {}?</remark> alternativ auch ein
        <foreignphrase xml:lang="en">Array</foreignphrase> von <foreignphrase
        xml:lang="en">Hashes</foreignphrase> aktzeptiert. Wir können also alle
        Telefonnummer mit einer Zeile eintragen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' )</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:04:39", updated_at: "2010-10-09 11:04:39"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.create([ { :name =&gt; 'Mobile', :number =&gt; '0171-12345678' }, { :name =&gt; 'Office', :number =&gt; '030-7777777' }, { :name =&gt; 'Home', :number =&gt; '030-8888888' } ])</command><remark>FIXME: Die Zeile besser mit Zeilenumbrüchen schreiben.</remark>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:04:39", updated_at: "2010-10-09 11:04:39"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Ich ahne was Sie sich jetzt fragen: <quote>Geht es noch
        kürzer?</quote> Klar: Wir können ja auch alles direkt in einer Zeile
        schreiben:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' ).phonenumbers.create([ { :name =&gt; 'Mobile', :number =&gt; '0171-12345678' }, { :name =&gt; 'Office', :number =&gt; '030-7777777' }, { :name =&gt; 'Home', :number =&gt; '030-8888888' } ])</command><remark>FIXME: Die Zeile besser mit Zeilenumbrüchen schreiben.</remark>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Allerdings ist das in der Praxis nur dann sinnvoll wenn die
        Text-Zeile dadurch nicht sehr lang und unübersichtlich wird.</para>
      </section>

      <section xml:id="activerecord_hinzufuegen_build">
        <title xml:id="activerecord_hinzufuegen_build.title">build</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>build()</tertiary>
        </indexterm>

        <para>Die Methode <methodname>build</methodname> ähnelt
        <methodname>create</methodname>. Allerdings wird der Datensatz nicht
        abgespeichert. Dies erfolgt erst nach einem
        <methodname>save</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>

stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' )</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 14:40:38", updated_at: "2010-10-09 14:40:38"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy = fritz.phonenumbers.build( :name =&gt; 'Mobile', :number =&gt; '0171-12345678' )</command>
 =&gt; #&lt;Phonenumber id: nil, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: nil, updated_at: nil&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_handy.new_record?</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>fritz_handy.save</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>fritz_handy.new_record?</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <warning>
          <para>Im Gegensatz zu <methodname>create</methodname> kann man mit
          <methodname>build</methodname> natürlich nicht eine Mutter und eine
          Elterninstanz mit jeweils einem <methodname>build</methodname>
          aufbauen.<remark>FIXME: Verstehe nicht was DU sagen willst. Eine
          "Mutter" ist doch das gleiche wie eine "Elterninstanz".</remark> Das
          führt zu einem Fehler. Die Elterninstanz muss immer bereits
          existieren bzw. mit <methodname>create</methodname> erstellt werden.
          Beispiel:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.build( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' ).phonenumbers.build([ { :name =&gt; 'Mobile', :number =&gt; '0171-12345678' }, { :name =&gt; 'Office', :number =&gt; '030-7777777' }, { :name =&gt; 'Home', :number =&gt; '030-8888888' } ])</command>
 NoMethodError: undefined method `build' for #&lt;Class:0x00000102c06018&gt;
 from <replaceable>[...]</replaceable>/gems/activerecord-3.0.0/lib/active_record/base.rb:1016:in `method_missing'
 from (irb):2
 from <replaceable>[...]</replaceable>/gems/railties-3.0.0/lib/rails/commands/console.rb:44:in `start'
 from <replaceable>[...]</replaceable>/gems/railties-3.0.0/lib/rails/commands/console.rb:8:in `start'
 from <replaceable>[...]</replaceable>/gems/railties-3.0.0/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
        </warning>
      </section>
    </section>

    <section xml:id="activerecord_1n_zugreifen">
      <title xml:id="activerecord_1n_zugreifen.title">Auf Datensätze
      zugreifen</title>

      <para>Dafür brauchen wir Beispieldaten. Deshalb füllen Sie bitte die
      Datei <filename>db/seeds.rb</filename> mit folgendem
      Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create( :firstname =&gt; 'Fritz', :lastname =&gt; 'Meier' ).phonenumbers.create([
  { :name =&gt; 'Mobile' , :number =&gt; '0171-12345678' }, 
  { :name =&gt; 'Office' , :number =&gt; '030-7777777'   }, 
  { :name =&gt; 'Home'   , :number =&gt; '030-8888888'   }  ])

Person.create( :firstname =&gt; 'Ute', :lastname =&gt; 'Meier' ).phonenumbers.create([
  { :name =&gt; 'Home'   , :number =&gt; '030-8888888'   }  ])

Person.create( :firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus' ).phonenumbers.create([
  { :name =&gt; 'Mobile' , :number =&gt; '0171-1188811'  }  ])

Person.create( :lastname =&gt; 'Udelhoven')

Person.create( :firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf' ).phonenumbers.create([
  { :name =&gt; 'Mobile' , :number =&gt; '0172-22225678' }, 
  { :name =&gt; 'Home'   , :number =&gt; '040-8888222'   }  ])
</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Das praktische an der 1:n-Zuordnung in ActiveRecord ist der
      super-einfache Zugang zu den n-Instanzen. Schauen wir uns das mal für
      den ersten Datensatz an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers.class</command>
 =&gt; Array 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Ist das cool?! Daran erfreue ich mich jedesmal wieder aufs Neue.
      Man kann einfach durch die Pluralform des n-<foreignphrase
      xml:lang="en">Model</foreignphrase> auf die Datensätze zugreifen. Die
      Ergebnismenge wird als <foreignphrase
      xml:lang="en">Array</foreignphrase> zurückgegeben. Ob es auch andersrum
      geht? Schauen wir uns mal die erste Telefonnummer an:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.person</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.person.class</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Bingo! Auch der Zugriff zur zugeordneten
      <classname>Person</classname>-Klasse ganz einfach. Und da es sich nur um
      einen einzigen Datensatz handelt (<methodname>belongs_to</methodname>),
      wird hier die Singularform genommen.</para>

      <para>Und wenn ein Datensatz keine Telefonnummern hat? Schauen wir doch
      mal bei Herrn Udelhoven rein:<screen>ruby-1.9.2-p0 &gt; <command>udelhoven = Person.where( :lastname =&gt; 'Udelhoven' ).first</command>
 =&gt; #&lt;Person id: 4, firstname: nil, lastname: "Udelhoven", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>udelhoven.phonenumbers</command>
 =&gt; [] 

ruby-1.9.2-p0 &gt; <command>udelhoven.phonenumbers.count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Da zu diesem Datensatz keine Telefonnummern zugeordnet sind, gibt
      <methodname>phonenumbers</methodname> ein leeres Array zurück.</para>

      <para>Der Vollständigkeit halber müssten wir jetzt auch schauen was
      passiert, wenn zu einer Telefonnummer keine Person zugeordnet
      ist:<screen>ruby-1.9.2-p0 &gt; <command>karteileiche = Phonenumber.create( :name =&gt; 'Auskunft', :number =&gt; '11833' )</command>
 =&gt; #&lt;Phonenumber id: 8, person_id: nil, name: "Auskunft", number: "11833", created_at: "2010-10-09 20:29:38", updated_at: "2010-10-09 20:29:38"&gt; 

ruby-1.9.2-p0 &gt; <command>karteileiche.person</command>
 =&gt; nil 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Dieser neue Datensatz hatte keinen Eintrag (also
      <literal>nil</literal>) in der Spalte <literal>person_id</literal> und
      konnte deshalb keiner Person zugeordnet werden. Entsprechend ist das
      Ergebnis von <methodname>person</methodname> auch
      <literal>nil</literal>.</para>
    </section>

    <section>
      <title>Datensätze suchen</title>

      <para>Zum Suchen brauchen wir wieder definierte Beispieldaten. Deshalb
      füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit
      folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
      weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
      formatierte Variante von oben übernehmen.</remark></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Legen wir mal los. Als erstes schauen wir uns mal an, wie viele
      Personen in der Datenbank sind:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.count</command>
 =&gt; 5 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Und wie viele Telefonnummern?<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.count</command>
 =&gt; 7 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Die normalen Suchen kennen Sie bereits aus <xref
      linkend="queries" />. So können Sie mit <methodname>where</methodname>
      z.B. alle <quote>Meier</quote>-Einträge suchen:<screen>ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier' )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 14:59:14", updated_at: "2010-10-09 14:59:14"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 14:59:14", updated_at: "2010-10-09 14:59:14"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <warning>
        <para>Bitte beachten Sie, dass <methodname>where</methodname> als
        Ergebnis immer ein Array zurpckgibt. Wenn Sie den ersten Datensatz aus
        der Ergebnisliste benötigen, müssen Sie noch ein
        <methodname>first</methodname> anfügen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier' ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier' ).first.class</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
      </warning>

      <para>Aber in dem 1:n-Kontext ist es natürlich interessanter,
      verschachtelt zu suchen. Dazu gibt es verschiedene Möglichkeiten.</para>

      <section xml:id="activerecord_1n_joins">
        <title xml:id="activerecord_1n_joins.title">joins</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>joins()</tertiary>
        </indexterm>

        <para>Wie können wir alle Personen rausfinden, die in unserer
        Datenbank eine Handynummer abgespeichert haben? Das geht mit einem
        <foreignphrase xml:lang="en">Join</foreignphrase>.<footnote>
            <para>Falls Sie sich für den theoretischen Hintergrund zu
            <foreignphrase xml:lang="en">Joins</foreignphrase> interessieren
            finden Sie weitere Informationen unter: <uri
            xlink:href="http://de.wikipedia.org/wiki/SQL#Abfrage_mit_verkn.C3.BCpften_Tabellen">http://de.wikipedia.org/wiki/SQL#Abfrage_mit_verkn.C3.BCpften_Tabellen</uri>,
            <uri
            xlink:href="http://en.wikipedia.org/wiki/Join_%28SQL%29">http://en.wikipedia.org/wiki/Join_(SQL)</uri>,
            <uri
            xlink:href="http://de.wikipedia.org/wiki/Relationale_Algebra#Join">http://de.wikipedia.org/wiki/Relationale_Algebra#Join</uri></para>
          </footnote> Damit können wir die beiden <foreignphrase
        xml:lang="en">Models</foreignphrase> auch in der Suche
        verknüpfen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Drei Personen haben eine Handynummer. Und das konnten wir mit
        einer Zeile Ruby-Code rausbekommen. Bonus-Punkt: Man kann diese Zeile
        auch sehr leicht lesen! Schauen wir uns zu dieser Abfrage noch gerade
        die <filename>log/development.log</filename> an:<programlisting>  Person Load (0.3ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')</programlisting></para>

        <para>Die Methode <methodname>joins</methodname> führt also in SQL zu
        einem <literal>INNER JOIN</literal>.</para>

        <para>Aber wir haben noch einen kleinen Denkfehler gemacht. Was ist
        wenn jemand zwei Handynummern in der Datenbank gespeichert hat? Wird
        diese Person dann doppelt gezählt? Probieren wir mal eine Suche nach
        allen Personen die eine Handynummer und eine private Festnetznummer
        gespeichert haben:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; { :name =&gt; ['Mobile', 'Home'] } )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; { :name =&gt; ['Mobile', 'Home'] } ).count</command>
 =&gt; 6 

ruby-1.9.2-p0 &gt; <command>Person.count</command>
 =&gt; 5 

ruby-1.9.2-p0 &gt;</screen></para>

        <para>Tatsächlich! Obwohl wir nur 5 Personen in der Datenbank haben,
        enthält die Ergebnismenge 6 Einträge. Aber kein Problem! Das Ergebnis
        unserer Abfrage ist ein Array, und in einem Array können wir mit der
        Methode <methodname>uniq</methodname> alle doppelten Einträge
        löschen:<remark>FIXME: Gibt's da keine schönere
        Lösung?</remark><screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).uniq</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).uniq.count</command>
 =&gt; 4 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Tatsächlich haben also nur 4 Personen in unserer Datenbank eine
        Handynummer oder eine Privatnummer gespeichert.</para>

        <para>Über den gleichen Mechanismus <methodname>joins</methodname>
        können wir auch alle Personen die mit Nachnamen <quote>Meier</quote>
        heißen und eine Handynummer haben abfragen:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).count</command>
 =&gt; 1 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Es gibt nur eine Person, auf die diese Suchkriterien
        zutreffen.</para>

        <para>Als letztes suchen wir jetzt mal alle Personen mit einer
        Berliner Rufnummer (Vorwahl <literal>030</literal>) raus:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( "phonenumbers.number LIKE ?", '030%' ).uniq.count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; </screen><remark>FIXME: (Diese Anmerkung gehört eigentlich
        schon weiter oben hin:) Müßte man nicht in dem String
        "phonenumbers.number LIKE ?" die Spalten-/Felder-Identifiers quoten?
        Zumindest wenn das reservierte SQL-Wörter sind?</remark></para>

        <para>Natürlich können wir das ganze auch umdrehen. Lassen Sie uns mal
        alle Telefonnummern aus Berlin (Vorwahl <literal>030</literal>)
        raussuchen, deren zugeordnete Person mit Nachnamen
        <quote>Meier</quote> heißt:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where( "number LIKE ?", '030%' ).where( :people =&gt; {:lastname =&gt; 'Meier'} )</command>
 =&gt; [#&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where( "number LIKE ?", '030%' ).where( :people =&gt; {:lastname =&gt; 'Meier'} ).count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Der Trick mit <methodname>uniq</methodname> klappt hier übrigens
        nicht:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where( "number LIKE ?", '030%' ).where(:people =&gt; {:lastname =&gt; 'Meier'} ).uniq.count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Bei der Personensuche konnten wir <methodname>uniq</methodname>
        auf das Ergebnis-Array sinnvoll anwenden, weil die einzelnen Personen
        doppelt im Array waren. Hier haben wir zwar bei den
        <literal>Phonenumber</literal>-Datensätzen 3 und 4 die gleiche
        Telefonnummer <quote>030-8888888</quote>, aber es sind eben
        verschiedene Datensätze. Man muss halt immer auch noch mitdenken.
        ;-)</para>
      </section>

      <section xml:id="activerecord_1n_includes">
        <title xml:id="activerecord_1n_includes.title">includes</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>includes()</tertiary>
        </indexterm>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>joins()</tertiary>
        </indexterm>

        <para><methodname>includes</methodname> ähnelt sehr der Methode
        <methodname>joins</methodname> (siehe <xref
        linkend="activerecord_1n_joins" />). Auch damit kann man innerhalb
        einer 1:n-Verknüpfung suchen. Schauen wir uns mal das Beispiel
        <quote>Wir suchen alle Personen mit einer Handynummer</quote> mit
        <methodname>includes</methodname> und mit
        <methodname>joins</methodname> an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Die Ergebnisse sind identisch, oder?<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).all == Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ).all</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Ja, die Ergebnisse sind identisch. Aber vielleicht haben Sie
        gemerkt, dass ich bei beiden Anfragen ein <methodname>all</methodname>
        eingeschmuggelt habe. Schauen wir uns einmal den Vergleich
        (<code>==</code>) der beiden
        <classname>ActiveRecord::Relation</classname> an:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} ) == Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
 =&gt; false 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Es handelt sich also um zwei verschiedene Abfragen, die das
        gleiche Ergebnis liefern. Da hilft nur ein Blick in
        <filename>log/development.log</filename>. Als erstes die Ausgabe von
        <methodname>joins</methodname>:<programlisting>  Person Load (0.2ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')</programlisting></para>

        <para>Und jetzt die Ausgabe des
        <methodname>includes</methodname>:<programlisting>  Person Load (0.3ms)  SELECT "people"."id" AS t0_r0, "people"."firstname" AS t0_r1, "people"."lastname" AS t0_r2, "people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "phonenumbers"."id" AS t1_r0, "phonenumbers"."person_id" AS t1_r1, "phonenumbers"."name" AS t1_r2, "phonenumbers"."number" AS t1_r3, "phonenumbers"."created_at" AS t1_r4, "phonenumbers"."updated_at" AS t1_r5 FROM "people" LEFT OUTER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')</programlisting></para>

        <para>Ich erspare Ihnen das Rätselraten:
        <methodname>joins</methodname> liest nur die
        <literal>people</literal>-Datensätze ein und
        <methodname>includes</methodname> liest auch noch die dazu gehörigen
        <literal>phonenumbers</literal>. Schon bei unserem kleinen Beispiel
        sieht man, dass dies natürlich länger dauert.</para>

        <para>Warum kann der Einsatz von <methodname>includes</methodname>
        dann überhaupt Sinn machen? Wenn Sie schon bei dieser Abfrage wissen,
        dass Sie alle Telefonnummern ebenfalls benötigen, dann macht ein
        <methodname>includes</methodname> Sinn, da dann nur eine
        Datenbankanfrage gestellt wird. ActiveRecord <quote><foreignphrase
        xml:lang="en">cach</foreignphrase>'t</quote><remark>FIXME: Schöner
        ausdrücken.</remark> nämlich die Antwort.</para>

        <para>Ich zeige Ihnen das mal an einem Beispiel. Wir werden wieder
        alle Meiers mit einem Handy raussuchen und dann alle Handynummern
        ausgeben. Zur besseren Analyse der SQL-Abfragen, werden wir mit
        <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command> alle
        Ausgabe die normalerweise nur in
        <filename>log/development.log</filename> landen direkt auf der
        <foreignphrase xml:lang="en">Console</foreignphrase> ausgeben. Als
        erstes die Variante mit <methodname>joins</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000102d3a308 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000102d3a2e0 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x00000102d3a290 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x00000102d3a268 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000102d3a218&gt;&gt;&gt;&gt; 

ruby-1.9.2-p0 &gt; <command>handybesitzer = Person.joins(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
<emphasis>  Person Load (0.2ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</emphasis> =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>handybesitzer.each do |einzelperson|</command>

ruby-1.9.2-p0 &gt;     <command>puts einzelperson.phonenumbers.first.number</command>

ruby-1.9.2-p0 ?&gt;  <command>end</command>
<emphasis>  Phonenumber Load (0.3ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
</emphasis>0171-12345678
<emphasis>  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 3) LIMIT 1
</emphasis>0171-1188811
<emphasis>  Phonenumber Load (0.1ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 5) LIMIT 1
</emphasis>0172-22225678
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

        <para>Wir haben für die Ausgabe aller Handynummern insgesamt 4
        SQL-Abfragen gemacht, und die brauchten in der Summe 0,8 ms. Jetzt
        machen wir das gleiche Beispiel mal mit
        <methodname>includes</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>handybesitzer = Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:name =&gt; 'Mobile'} )</command>
<emphasis>  Person Load (0.3ms)  SELECT "people"."id" AS t0_r0, "people"."firstname" AS t0_r1, "people"."lastname" AS t0_r2, "people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "phonenumbers"."id" AS t1_r0, "phonenumbers"."person_id" AS t1_r1, "phonenumbers"."name" AS t1_r2, "phonenumbers"."number" AS t1_r3, "phonenumbers"."created_at" AS t1_r4, "phonenumbers"."updated_at" AS t1_r5 FROM "people" LEFT OUTER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</emphasis> =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>handybesitzer.each do |einzelperson|</command>
ruby-1.9.2-p0 &gt;     <command>puts einzelperson.phonenumbers.first.number</command>                 
ruby-1.9.2-p0 ?&gt;  <command>end</command>                                                           
0171-12345678
0171-1188811
0172-22225678
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Hier haben wir nur eine SQL-Abfrage die 0,3 ms gedauert hat. Die
        erste SQL-Abfrage dauert also länger, dafür spart man sich aber
        nachfolgende.</para>

        <para>Wäre es dann nicht besser immer mit
        <methodname>includes</methodname> zu arbeiten? Nein, es kommt immer
        auf den konkreten Fall an. Denn bei der Benutzung von
        <methodname>includes</methodname> werden ja initial viel mehr Daten
        transportiert. Die müssen von Ruby gecached<remark>FIXME: Schöner
        ausdrücken.</remark> und verarbeitet werden. Bei unserer kleinen
        Datenbank ist das egal. Aber stellen Sie sich das ganze mal mit allen
        Handynummern Deutschlands vor. Das ist eine Datenmenge, die man nicht
        unbedingt cachen will.</para>
      </section>
    </section>

    <section xml:id="has_many_delete" xml:lang="">
      <title xml:id="has_many_delete.title">delete und destroy</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>delete()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>delete_all()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>destroy()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>destroy_all()</tertiary>
      </indexterm>

      <para>Mit den Methoden <methodname>destroy</methodname>,
      <methodname>destroy_all</methodname>, <methodname>delete</methodname>
      und <methodname>delete_all</methodname> kann man wie in <xref
      linkend="datensatz-loeschen" /> beschrieben Datensätze löschen. Im
      Kontext von <methodname>has_many</methodname> bedeutet das, dass man die
      zu einer <classname>Person</classname> gehörigen
      <classname>Phonenumber</classname>-Datensätze in einem Streich löschen
      kann:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers.destroy_all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
    </section>

    <section xml:id="activerecord_1n_optionen">
      <title xml:id="activerecord_1n_optionen.title">Optionen</title>

      <para>Ich will an dieser Stelle nicht auf alle möglichen Optionen
      eingehen. Aber ein paar sind so praktisch und werden von mir in jedem
      Projekt benutzt, dass ich sie hier vorstellen möchte. Für alle anderen
      verweise ich auf die Ruby-on-Rails-Doku, die Sie im Internet unter <uri
      xlink:href="http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
      bzw. auf Ihrem System auf der Shell mit <command>ri
      ActiveRecord::Associations::ClassMethods</command> aufrufen
      können.</para>

      <section>
        <title>has_many</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Relationen</secondary>

          <tertiary>has_many()</tertiary>
        </indexterm>

        <para>Die meiner Meinung nach wichtigsten Optionen für
        <code>has_many</code>:<itemizedlist>
            <listitem>
              <para><emphasis role="bold"><code>:order</code></emphasis><code>
              =&gt; :apfelmus</code></para>

              <para>Wer die Telefonnummern nach den Namen sortieren will, kann
              dies mit folgender <filename>app/models/person.rb</filename>
              erreichen:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, <emphasis role="bold">:order =&gt; :name</emphasis>
end</programlisting></para>

              <para>Das Ergebnis in der <foreignphrase
              xml:lang="en">Console</foreignphrase> sieht dann so aus:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;, #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

              <para>Und falls mal umgekehrt sortiert werden
              soll:<programlisting>has_many :phonenumbers, <emphasis
                    role="bold">:order =&gt; 'name DESC'</emphasis></programlisting></para>
            </listitem>

            <listitem>
              <para><emphasis
              role="bold"><code>:dependent</code></emphasis><code> =&gt;
              :destroy</code></para>

              <para>Wird eine Person gelöscht, dann ist es ja oft sinnvoll,
              dass auch alle von dieser Person abhängigen (<foreignphrase
              xml:lang="en">dependent</foreignphrase>) Telefonnummern
              automatisch mitgelöscht werden. Das kann mit <code>:dependent
              =&gt; :destroy</code> in der
              <filename>app/models/person.rb</filename> realisiert
              werden:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, <emphasis role="bold">:dependent =&gt; :destroy</emphasis>
end</programlisting></para>

              <para>Im folgenden Beispiel löschen wir die erste Person in der
              Datenbank-Tabelle. Dabei werden automatisch alle Telefonnummern
              dieser Person ebenfalls gelöscht:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 22:27:36", updated_at: "2010-10-09 22:27:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 1).count</command>
 =&gt; 3 

ruby-1.9.2-p0 &gt; <command>Person.first.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 22:27:36", updated_at: "2010-10-09 22:27:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 1).count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

              <important>
                <indexterm>
                  <primary>ActiveRecord</primary>

                  <secondary>Methoden</secondary>

                  <tertiary>destroy()</tertiary>
                </indexterm>

                <indexterm>
                  <primary>ActiveRecord</primary>

                  <secondary>Methoden</secondary>

                  <tertiary>delete()</tertiary>
                </indexterm>

                <para>Bitte denken Sie immer an den Unterschied zwischen den
                Methoden <methodname>destroy</methodname> (siehe <xref
                linkend="activerecord_destroy" />) und
                <methodname>delete</methodname> (siehe <xref
                linkend="activerecord_delete" />). Diese Abhängigkeit
                funktioniert nur mit der Methode
                <methodname>destroy</methodname>.</para>
              </important>
            </listitem>
          </itemizedlist></para>

        <para>Es gibt natürlich noch eine Menge anderer Optionen. Diese können
        Sie sich mit <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command> auf der
        Shell ausgeben lassen.</para>
      </section>

      <section>
        <title>belongs_to</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Relationen</secondary>

          <tertiary>belongs_to()</tertiary>
        </indexterm>

        <para>Die meiner Meinung nach wichtigste Option für
        <methodname>belongs_to</methodname> ist:<itemizedlist>
            <listitem>
              <para><emphasis role="bold"><code>:touch</code></emphasis><code>
              =&gt; :true</code></para>

              <para>Damit wird bei einer Veränderung einer
              <classname>Phonenumber</classname> automatisch das Feld
              <literal>updated_at</literal> des Eintrags in der Tabelle
              <classname>People</classname> auf die aktuelle Uhrzeit gesetzt.
              Das sähe in der <filename>app/models/phonenumber.rb</filename>
              so aus:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person, <emphasis role="bold">:touch =&gt; :true</emphasis>
end</programlisting></para>
            </listitem>
          </itemizedlist></para>

        <para>Auch hier sollten Sie einmal auf die Liste aller möglichen
        Optionen einen kurzen Blick werfen. Dazu in der Shell <command>ri
        ActiveRecord::Associations::ClassMethods#belongs_to</command>
        aufrufen.</para>
      </section>
    </section>

    <section xml:id="activerecord_has_many_through">
      <title xml:id="activerecord_has_many_through.title">has_many
      :through</title>

      <remark>FIXME: Warum steht through nicht als Parameter unter Optionen
      -&gt; has_many?</remark>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Relationen</secondary>

        <tertiary>has_many()</tertiary>
      </indexterm>

      <para>Um <code>has_many <replaceable>…</replaceable>, :through =&gt;
      <replaceable>…</replaceable></code> zu erklären müssen wir unser
      Datenbank-<foreignphrase xml:lang="en">Model</foreignphrase> erweitern.
      Nehmen wir einmal an, dass wir jeden Anruf mit Start- und Endzeit
      protokollieren. Das wäre dann eine 1:n-Verknüpfung von
      <classname>Phonenumber</classname> zu <classname>CallRecord</classname>.
      Erstellen wir erst mal ein entsprechendes <foreignphrase
      xml:lang="en">Model</foreignphrase>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model CallRecord phonenumber_id:integer start:datetime end:datetime</command>
      invoke  active_record
      create    db/migrate/20101011071702_create_call_records.rb
      create    app/models/call_record.rb
      invoke    test_unit
      create      test/unit/call_record_test.rb
      create      test/fixtures/call_records.yml

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Die Datenbank-Migration ausführen und damit die Tabelle
      anlegen:<screen>stefan@swmbp 1 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateCallRecords: migrating ==============================================
-- create_table(:call_records)
   -&gt; 0.0013s
==  CreateCallRecords: migrated (0.0013s) =====================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Die <filename>app/models/phonenumber.rb</filename> muss noch
      angepasst werden:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  <emphasis role="bold">has_many :call_records</emphasis>
end</programlisting></para>

      <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
      brauchbaren Testdaten an:<programlisting>Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
             
Phonenumber.all.each do |phonenumber|
  (1..(Phonenumber.count - phonenumber.id)).each do |zaehler|
    phonenumber.call_records.create(:start =&gt; Time.now, :end =&gt; Time.now + zaehler.minutes)
  end
end</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
      weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
      formatierte Variante von oben übernehmen.</remark></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 1 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("call_records", {:force=&gt;true})
   -&gt; 0.0075s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0079s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0074s
-- initialize_schema_migrations_table()
   -&gt; 0.0003s
-- assume_migrated_upto_version(20101011071702, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>So, dann schauen wir uns jetzt mal an, wie oft Herr Fritz Meier
      die erste Nummer in seinem Telefonbuch<remark>FIXME: Das ist nicht sein
      Telefonbuch sondern seine eigenen Telefonnummern, oder?</remark>
      angerufen hat:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first.call_records</command>
 =&gt; [#&lt;CallRecord id: 1, phonenumber_id: 1, start: "2010-10-11 07:36:12", end: "2010-10-11 07:37:12", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt;, #&lt;CallRecord id: 2, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:38:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 3, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:39:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 4, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:40:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 5, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:41:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 6, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:42:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;] 

ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first.call_records.count</command>
 =&gt; 6 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Im <filename>log/development.log</filename> schauen wir uns die
      letzten zwei Anfragen noch mal genau an:<programlisting>  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
  CallRecord Load (0.2ms)  SELECT "call_records".* FROM "call_records" WHERE ("call_records".phonenumber_id = 1)

  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
  SQL (0.1ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "call_records" WHERE ("call_records".phonenumber_id = 1)) AS subquery</programlisting></para>

      <para>Um jetzt eine Aufstellung von allen Telefonaten von Herrn Fritz
      Meier zu erhalten, müssten wir umständlich alle seine eingetragenen
      Rufnummern in einer Schleife abarbeiten. Das geht aber mit ActiveRecord
      auch einfacher. Bitte ändern Sie Ihre
      <filename>app/models/person.rb</filename> wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
  has_many :call_records, <emphasis role="bold">:through =&gt; :phonenumbers</emphasis>
end</programlisting></para>

      <para>Das schauen wir uns jetzt mal in der <foreignphrase
      xml:lang="en">Console</foreignphrase> an. Es liegt die Vermutung nahe,
      dass wir jetzt auch einen
      <methodname>call_records</methodname>-Zugriff<remark>FIXME: Hä?</remark>
      von der Klasse <classname>Person</classname> haben:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first.call_records.limit(5)</command>
 =&gt; [#&lt;CallRecord id: 1, phonenumber_id: 1, start: "2010-10-11 07:36:12", end: "2010-10-11 07:37:12", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt;, #&lt;CallRecord id: 2, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:38:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 3, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:39:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 4, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:40:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 5, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:41:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.call_records.count</command>
 =&gt; 15 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Bingo! ActiveRecord übernimmt wieder die Schwerstarbeit und
      liefert uns das SQL (siehe
      <filename>log/development.log</filename>):<programlisting>  Person Load (0.2ms)  SELECT "people".* FROM "people" LIMIT 1
  CallRecord Load (0.3ms)  SELECT "call_records".* FROM "call_records" INNER JOIN "phonenumbers" ON "call_records".phonenumber_id = "phonenumbers".id WHERE (("phonenumbers".person_id = 1)) LIMIT 5

  Person Load (0.3ms)  SELECT "people".* FROM "people" LIMIT 1
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "call_records" INNER JOIN "phonenumbers" ON "call_records".phonenumber_id = "phonenumbers".id WHERE (("phonenumbers".person_id = 1))</programlisting></para>

      <para>Praktisch? Praktisch!</para>

      <para>Mehr Informationen und Beispiele zu <code>has_many
      <replaceable>…</replaceable>, :through =&gt;
      <replaceable>…</replaceable></code> finden Sie unter dem Stichwort
      <quote>Many-to-many</quote> auf <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri></para>

      <remark>FIXME: Wir sind hier im 1:n-Abschnitt. Warum wird auf n:n
      verwiesen?</remark>
    </section>

    <section xml:id="activerecord_polymorphic">
      <title xml:id="activerecord_polymorphic.title">Polymorphe Assoziationen
      (polymorphic associations)</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Polymorphic Associations</secondary>
      </indexterm>

      <para>Schon das Wort "polymorph" lässt einen angespannt werden. Was mag
      damit gemeint sein? Auf <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
      steht dazu: <quote>Polymorphic associations on models are not restricted
      on what types of models they can be associated with.</quote> Na, das ist
      ja jetzt klar wir Kloßbrühe! ;-)</para>

      <para>Ein Beispiel! Nehmen wir an, dass wir zu den Personen und den
      Telefonnummern in unserer Applikation Kommentare einbauen wollen. Und
      zwar beliebig viele Kommentare. Mit dem Wissen aus <xref
      linkend="activerecord_has_many_through" /> könnten wir uns zwei Modelle
      anlegen und jeweils eine <methodname>has_many</methodname>-Verbindung zu
      <classname>Person</classname> oder zu <classname>Phonenumber</classname>
      aufbauen. Bei zweien würde das sogar noch halbwegs praktikabel sein.
      Aber stellen Sie sich mal vor, Sie hätten gerne bei mehr Daten solche
      Kommentare. Dafür jedesmal ein eigenes <foreignphrase
      xml:lang="en">Model</foreignphrase> bauen? Genau da kommt die
      <foreignphrase xml:lang="en">Polymorphic Association</foreignphrase> zum
      Tragen. Damit können Sie ein <foreignphrase
      xml:lang="en">Model</foreignphrase> <classname>Comment</classname> mit
      beliebig vielen and<remark>FIXME: "and" oder "anderen"?</remark>
      Modellen verknüpfen.</para>

      <para>Erstellen wir erst mal das <foreignphrase
      xml:lang="en">Model</foreignphrase>
      <classname>Comment</classname>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model Comment commentable_type:string commentable_id:integer comment:string</command>
      invoke  active_record
      create    db/migrate/20101011084411_create_comments.rb
      create    app/models/comment.rb
      invoke    test_unit
      create      test/unit/comment_test.rb
      create      test/fixtures/comments.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0013s
==  CreateComments: migrated (0.0013s) ========================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Das Suffix <quote><foreignphrase
      xml:lang="en">able</foreignphrase></quote>
      (<replaceable>…</replaceable>bar) beim Namen <quote><foreignphrase
      xml:lang="en">commentable</foreignphrase></quote> (kommentierbar) ist
      Rails-üblich, muss aber nicht sein. Wir brauchen ja zum Verknüpfen jetzt
      nicht nur die ID des Eintrags, sondern müssen auch noch wissen, um
      welches <foreignphrase xml:lang="en">Model</foreignphrase> es sich
      eigentlich handelt. Da macht der Begriff <quote><foreignphrase
      xml:lang="en">commentable_type</foreignphrase></quote> halbwegs
      Sinn.</para>

      <para>Jetzt müssen wir in <filename>app/models/comment.rb</filename>
      folgenden Eintrag machen:<programlisting>class Comment &lt; ActiveRecord::Base
  belongs_to :commentable, :polymorphic =&gt; true
end</programlisting></para>

      <para>Jetzt den Eintrag in
      <filename>app/models/person.rb</filename><programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

      <para>Und noch den Eintrag in
      <filename>app/models/phonenumber.rb</filename><programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

      <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
      brauchbaren Testdaten an:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
      weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
      formatierte Variante von oben übernehmen.</remark></para>

      <para>Die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("comments", {:force=&gt;true})
   -&gt; 0.0053s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0058s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0067s
-- initialize_schema_migrations_table()
   -&gt; 0.0004s
-- assume_migrated_upto_version(20101011084411, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Gehen wir mal in die <foreignphrase
      xml:lang="en">Console</foreignphrase> und versuchen mal zwei Kommentare
      zu Herrn Fritz Meier anzulegen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 09:00:51", updated_at: "2010-10-11 09:00:51"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 0 

ruby-1.9.2-p0 &gt; <command>fritz.comments.create( :comment =&gt; 'Ein Beispiel' )</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.create( :comment =&gt; 'Noch ein Beispiel' )</command>
 =&gt; #&lt;Comment id: 2, commentable_type: "Person", commentable_id: 1, comment: "Noch ein Beispiel", created_at: "2010-10-11 09:07:44", updated_at: "2010-10-11 09:07:44"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 2 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Das funktioniert also. Schauen wir uns mal den ersten Kommentar
      an:<screen>ruby-1.9.2-p0 &gt; <command>Comment.first</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Alles logisch. Alles gut. Aber so wie ich Sie einschätze wollen
      Sie jetzt auch sehen wie das mit Telefonnummern geht. Kein
      Problem:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create( :comment =&gt; 'Und wieder ein Beispiel.' )</command>
 =&gt; #&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create( :comment =&gt; 'xyz Beispiel' )</command>
 =&gt; #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments</command>
 =&gt; [#&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt;, #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

      <para><foreignphrase xml:lang="en">Polymorphic
      Associations</foreignphrase> sind sehr praktisch. Man sollte aber auch
      immer daran denken, dass sie mehr Last auf der Datenbank erzeugen als
      eine normale 1:n-Verknüpfung. Normalerweise macht das den Bock nicht
      fett, aber man sollte es bei der Planung im Hinterkopf haben.</para>

      <remark>FIXME: Gibt es außer has_many() und belongs_to() noch andere
      Relationen? 1:1 has_one(), n:n has_and_belongs_to_many()?</remark>
    </section>
  </section>

  <section xml:id="datensatz-loeschen">
    <title>Einen Datensatz löschen</title>

    <para>Es gibt die Methoden <methodname>destroy</methodname> und
    <methodname>delete</methodname>, um Datensätze zu löschen. Diese Wortwahl
    empfinde ich als reichlich schwierig. Ich muss fast immer nachschlagen, um
    selbst sicher zu sein, welche Methode was macht.</para>

    <section xml:id="activerecord_destroy">
      <title xml:id="activerecord_destroy.title">destroy</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>destroy()</tertiary>
      </indexterm>

      <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
      löschen und dabei werden auch vorhandene Abhängigkeiten beachtet (siehe
      z.B. <code>:dependent =&gt; :destroy</code> in <xref
      linkend="activerecord_1n_optionen" />). Vereinfacht kann man sagen:
      Lieber <methodname>destroy</methodname> nehmen; das ist sicherer, weil
      das Rails-System dann mehr mitdenkt.<important>
          <para>Die Instanz wird nach dem Löschen des Datenbankfeldes
          <foreignphrase xml:lang="en">frozen</foreignphrase> (eingefroren).
          Sie ist also noch da, kann aber nicht verändert werden.</para>
        </important></para>

      <para>Für die Beispiele brauchen wir wieder definierte Daten. Deshalb
      füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit
      folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
      weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
      formatierte Variante von oben übernehmen.</remark></para>

      <para>Die Datei <filename>app/models/person.rb</filename> ändern Sie
      bitte wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
end</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Als erstes löschen wir Herrn Fritz Meier inklusive all seiner
      Telefonnummern:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz_meier = Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_meier.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' )</command>
  =&gt; [] 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Das war einfach. Was ist allerdings mit der Variablen
      <varname>fritz_meier</varname>? Die existiert noch mit den Daten im
      sogenannten <foreignphrase xml:lang="en">frozen state</foreignphrase>
      (eingefrorener Zustand). Zum Überprüfen gibt es die Methode <indexterm>
          <primary>frozen?()</primary>
        </indexterm><methodname>frozen?</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>fritz_meier</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_meier.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>fritz_meier.frozen?</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Der Datensatz ist also in der Datenbank gelöscht, aber das Objekt
      mit allen Daten ist noch im laufenden Ruby-Programm vorhanden. Könnten
      wir damit den gesamten Datensatz wiederbeleben? Ja, allerdings ist das
      dann ein neuer Datensatz (er hat also nicht mehr die ID 1):<screen>ruby-1.9.2-p0 &gt; <command>Person.create( fritz_meier.attributes )</command>
 =&gt; #&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' )</command>
 =&gt; [#&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Jetzt fehlen allerdings noch die Telefonnummern. Die können Sie
      aber separat abspeichern (da sie ja noch im <foreignphrase
      xml:lang="en">frozen</foreignphrase> Objekt vorhanden sind).</para>
    </section>

    <section xml:id="activerecord_delete">
      <title xml:id="activerecord_delete.title">delete</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>delete()</tertiary>
      </indexterm>

      <para>Mit <methodname>delete</methodname> können Sie einen Datensatz
      direkt in der Datenbank löschen. Dabei werden keine Abhängigkeiten zu
      anderen Datensätzen im <foreignphrase
      xml:lang="en">Model</foreignphrase> beachtet. Die Methode
      <methodname>delete</methodname> löscht also nur die eine Zeile in der
      Datenbank und sonst nichts.</para>

      <para>Löschen wir mal den Datensatz von Frau Meier:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.delete</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where( :person_id =&gt; 2 )</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Es wird zwar der Datensatz von Frau Meier gelöscht, aber die
      Telefonnummern in der zu <classname>Phonenumber</classname> gehörenden
      Datenbank-Tabelle bleiben als Karteileichen im System.</para>

      <para>Wie bei <methodname>destroy</methodname> geht das Objekt auch bei
      <methodname>delete</methodname> ein Objekt nach dem
      <methodname>delete</methodname> in den <foreignphrase
      xml:lang="en">frozen</foreignphrase>-Status (siehe <xref
      linkend="activerecord_destroy" />).<remark>FIXME: Den Satz verstehe ich
      nicht.</remark></para>
    </section>
  </section>

  <section xml:id="activerecord_transaction">
    <title xml:id="activerecord_transaction.title">Transaktionen
    (Transactions)</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Transaktionen</secondary>
    </indexterm>

    <indexterm>
      <primary>Transaktionen</primary>

      <see>ActiveRecord, Transaktionen</see>
    </indexterm>

    <indexterm>
      <primary>Datenbank</primary>

      <secondary>Transaktionen</secondary>

      <see>ActiveRecord, Transaktionen</see>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>transaction()</tertiary>
    </indexterm>

    <para>Es gibt immer mal wieder Anwendungsgebiete, bei denen man eine
    Datenbank-Transaktion durchführen muss. Das klassische Beispiel dafür ist
    eine Geldbewegung von einem zu einem anderen Konto. Die macht nur Sinn,
    wenn beide Aktionen (von einem Konto abbuchen und auf das Konto des
    Empfängers draufbuchen) ausgeführt werden.</para>

    <para>Zum Demonstrieren einer Transaktion brauchen wir wieder definierte
    Beispieldaten. Deshalb füllen Sie bitte die Datei
    <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
    weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
    formatierte Variante von oben übernehmen.</remark></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Eine Transaktion wird nach folgendem Muster
    durchgeführt:<programlisting><emphasis role="bold">ActiveRecord::Base.transaction do</emphasis>
  <replaceable>was_auch_immer_der_erste_schritt_ist</replaceable>
  <replaceable>was_auch_immer_der_zweite_schritt_ist</replaceable>
  <replaceable>was_auch_immer_der_dritte_schritt_ist</replaceable>
<emphasis role="bold">end</emphasis></programlisting></para>

    <para>Herr und Frau Meier haben beide die gleiche Telefonnummer:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '030-8888888'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Jetzt wollen beide nach Hamburg umziehen und bekommen dort eine neue
    Telefonnummer. Jetzt wollen wir beim Ändern der Nummer sicherstellen, dass
    beide Nummern in einer Transaktion geändert werden.</para>

    <para>Hier ist der Code dazu:<remark>FIXME: Fehlt hier was? Hier steht
    kein Code zu den Telefonnummern. Danach geht es mit Flugnummern
    weiter.</remark></para>

    <para>Wenn wir in unserem Flugplan<remark>FIXME: In welchem Flugplan?
    Davon war bisher noch nicht die Rede oder?</remark> die Flugnummern des
    ersten und des zweiten Datensatzes austauschen wollen, dann wäre das auch
    ein klassischer Fall für eine Transaktion. Ansonsten hätten wir bei einem
    Fehler zweimal die gleiche Flugnummer in der Datenbank-Tabelle. Versuchen
    wir es mal:<remark>FIXME: Hm, hier geht es jetzt wieder mit Phonenumbers
    weiter.</remark><screen>ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '030-8888888'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; <command>die_meiers = Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '030-8888888'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; <command>herr_meier_telefon = die_meiers.first.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt; 

ruby-1.9.2-p0 &gt; <command>frau_meier_telefon = die_meiers.last.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt; 

ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.transaction do</command>
ruby-1.9.2-p0 &gt;     <command>neue_nummer = '040-9999999'</command>
ruby-1.9.2-p0 ?&gt;  <command>  herr_meier_telefon.number = neue_nummer</command>
ruby-1.9.2-p0 ?&gt;    <command>herr_meier_telefon.save</command>
ruby-1.9.2-p0 ?&gt;  <command>  frau_meier_telefon.number = neue_nummer</command>
ruby-1.9.2-p0 ?&gt;  <command>  frau_meier_telefon.save</command>
ruby-1.9.2-p0 ?&gt;  <command>end</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>die_meiers = Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '040-9999999'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Beim Ende der Transaktion sehen wir dann in der
    <filename>log/development.log</filename> die entsprechenden
    Befehle:<programlisting>  SQL (0.3ms)  UPDATE "phonenumbers" SET "number" = '040-9999999', "updated_at" = '2010-10-10 08:28:08.669155' WHERE ("phonenumbers"."id" = 3)
  SQL (0.1ms)  UPDATE "phonenumbers" SET "number" = '040-9999999', "updated_at" = '2010-10-10 08:28:08.678647' WHERE ("phonenumbers"."id" = 4)</programlisting></para>

    <para>Da unsere Entwicklungs-Datenbank SQLite keine Transaktionen
    unterstützt, sehen wir nur zwei normale SQL-Befehle.<remark>FIXME: Laut
    http://de.wikipedia.org/wiki/Sqlite und http://www.sqlite.org/ unterstützt
    SQLite Transaktionen.</remark><remark>FIXME: Es wäre gut die Log-Datei zu
    sehen mit einem DBMS das Transaktionen unterstützt.</remark><remark>FIXME:
    Wenn das DBMS keine Transaktionen unterstützt werden also die SQL-Befehle
    einzeln ausgeführt? Kann man auch sagen daß etwas *nur* als Transaktion
    laufen soll oder abbrechen wenn das DBMS das nicht kann?</remark></para>

    <para>Jetzt werden Sie sagen: <quote>Ja, das hätte ich aber auch einfacher
    mit <methodname>update_attributes</methodname> realisieren können (siehe
    <xref linkend="activerecord_update_attributes" />)!</quote> Meine Antwort
    darauf: Gut aufgepasst! Das hier ist ja nur ein Beispiel. ;-)</para>

    <para>Transaktionen sind ein komplexes Thema. Wenn Sie mehr Informationen
    dazu suchen, können Sie die ri Hilfe dafür mit <command>ri
    ActiveRecord::Transactions::ClassMethods</command><remark>FIXME: Ist
    ...ClassMethods hier wirklich eine Klasse und keine Methode?</remark> auf
    der Shell abrufen.<important>
        <para>Die Methoden <methodname>save</methodname> und
        <methodname>destroy</methodname> werden automatisch im
        Transaktions-<foreignphrase xml:lang="en">Wrapper</foreignphrase>
        ausgeführt. So stellt Rails sicher, dass bei diesen Methoden kein
        undefinierter Zustand entsteht.</para>
      </important><warning>
        <para>Transaktionen werden nicht von jeder Datenbank nativ
        unterstützt. Bei unserem Beispiel oben sehen Sie, dass SQLite es zum
        Beispiel nicht unterstützt<remark>FIXME: Laut
        http://de.wikipedia.org/wiki/Sqlite und http://www.sqlite.org/
        unterstützt SQLite Transaktionen.</remark>. Meiner Meinung nach
        schadet es nicht sie zu benutzen. Es kann ja sein, dass die nächste
        Version Ihrer Lieblingsdatenbank Transaktionen unterstützt.</para>
      </warning></para>
  </section>

  <xi:include href="named_scope.xml" />

  <xi:include href="validation.xml" />

  <xi:include href="migration.xml" />
</chapter>
