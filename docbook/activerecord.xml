<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="activerecord_chapter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_chapter.title">ActiveRecord</title>

  <info>
    <collab>
      <person>
        <personname><firstname>Philipp</firstname><surname>Kempgen</surname></personname>
      </person>
    </collab>
  </info>

  <indexterm>
    <primary>ActiveRecord</primary>
  </indexterm>

  <indexterm>
    <primary>Active Record (Muster)</primary>

    <see>ActiveRecord</see>
  </indexterm>

  <indexterm>
    <primary>Datenbank</primary>

    <seealso>ActiveRecord</seealso>
  </indexterm>

  <indexterm>
    <primary>ActiveRecord</primary>

    <seealso>Datenbank</seealso>
  </indexterm>

  <indexterm>
    <primary>ORM</primary>

    <seealso>Datenbank</seealso>
  </indexterm>

  <para><literal>ActiveRecord</literal> ist eine Abstaktionsschicht, die es
  uns einen sehr leichten Zugang zu einer <indexterm>
      <primary>SQL-Datenbank</primary>

      <see>Datenbank</see>
    </indexterm><indexterm>
      <primary>Datenbank</primary>

      <secondary>relational (SQL)</secondary>
    </indexterm><indexterm>
      <primary>relationale Datenbank</primary>

      <see>Datenbank</see>
    </indexterm>SQL-Datenbank zur Verfügung stellt.
  <literal>ActiveRecord</literal> implementiert das Architektur-Muster
  <foreignphrase xml:lang="en">Active Record</foreignphrase> <footnote>
      <para>siehe <uri
      xlink:href="http://en.wikipedia.org/wiki/Active_record_pattern">http://en.wikipedia.org/wiki/Active_record_pattern</uri></para>
    </footnote>.</para>

  <note>
    <para>Das nennt sich dann <indexterm>
        <primary>Objektrelationale Abbildung</primary>

        <see>ORM</see>
      </indexterm>objektrelationale Abbildung (<indexterm>
        <primary>Object-relational mapping</primary>

        <see>ORM</see>
      </indexterm><foreignphrase xml:lang="en">Object-relational
    mapping</foreignphrase>, <indexterm>
        <primary>ORM (Object-relational mapping)</primary>
      </indexterm><foreignphrase xml:lang="en">ORM</foreignphrase>). Ich
    empfinde das als zu trocken und langweilig, aber falls Sie heute Abend
    nicht einschlafen können, werfen Sie doch mal einen Blick auf <uri
    xlink:href="http://de.wikipedia.org/wiki/Objektrelationale_Abbildung">http://de.wikipedia.org/wiki/Objektrelationale_Abbildung</uri>.</para>
  </note>

  <para>Einer der Erfolgsrezepte von Rails ist sicherlich die Benutzung von
  <literal>ActiveRecord</literal>. Die Programmierung und Benutzung
  <quote>fühlt sich gut an</quote> und es ist viel weniger fehleranfällig als
  pures SQL. Bei der Arbeit mit diesem Kapitel hilft SQL-Wissen, aber es wird
  nicht vorausgesetzt, und es ist auch für die Arbeit mit
  <literal>ActiveRecord</literal> nicht notwendig.</para>

  <para>Nur am Rande sei hier erwähnt, das Sie bei der Arbeit mit Rails nicht
  zum Arbeiten mit ActiveRecord verpflichtet sind. Sie können auch andere ORMs
  benutzen. ActiveRecord ist der Default und wird auch von der Mehrheit aller
  Rails-Entwickler benutzt.</para>

  <section xml:id="activerecord-howto-zum-kapitel">
    <title>Howto zum Kapitel</title>

    <para>Dieses Kapitel ist in sich selbst geschlossen. Allerdings wird das
    Wissen aus <xref linkend="ruby-grundlagen" /> und <xref
    linkend="erste_schritte_mit_rails" /> vorausgesetzt. Ohne dieses
    Grundwissen werden Sie keinen Spaß an diesem Kapitel haben!</para>

    <para>Der Rails-Anfänger sollte das Kapitel einmal von oben bis unten
    durcharbeiten. Das heißt konkret: Alle Schritte in der eigenen
    <foreignphrase xml:lang="en">Console</foreignphrase> (siehe <xref
    linkend="die_console" />) mit ausprobieren und ruhig selber links und
    rechts mal ein wenig experimentieren. Bitte nehmen Sie sich Zeit. Es ist
    ein wichtiges Kapitel!</para>

    <para><note>
        <para>Es geht in diesem Kapitel um ActiveRecord. Deshalb: Um die
        Beispiele so übersichtlich wie möglich zu halten werde ich deshalb
        keine Tests (siehe <xref linkend="tests" />) einbauen.</para>
      </note></para>

    <section xml:id="activerecord-keine-lust-auf-sql">
      <title>Keine Lust auf SQL?</title>

      <para>Hin und wieder werde ich den durch eine ActiveRecord-Methode
      erzeugten SQL-Code in der Log-Datei nachschlagen. Wenn Sie sich nicht
      für SQL interessieren: Einfach überlesen. Das Schöne an ActiveRecord ist
      ja dass man sich darum keinen Kopf machen muss. Für alle anderen dient
      es zum besseren Verständnis der im Hintergrund laufenden
      Optimierungen.</para>

      <tip>
        <para>Wenn Sie sich für diese Optimierungen interessieren, so empfehle
        ich Ihnen bei diesen Übungen und auch später bei der Entwicklung immer
        noch ein zweites Terminal mit einem <command>tail -f
        log/development.log</command> laufen zu lassen. Dort sehen Sie dann
        immer, was gerade auf der Datenbank-Ebene abläuft.</para>
      </tip>
    </section>

    <section xml:id="activerecord_blut_lecken">
      <title xml:id="activerecord_blut_lecken.title">Blut lecken</title>

      <para>Dieses Buch ist ein Einsteigerbuch. Entsprechend werden hier die
      Grundlagen für die Benutzung von ActiveRecord besprochen. Es wäre ein
      leichtes ein doppelt so dickes Buch nur über ActiveRecord zu schreiben.
      Lassen Sie sich von diesem Kapitel anfixen und forschen Sie in den
      Dokumentationen zu Rails weiter (siehe <xref
      linkend="weiterfuehrende_doku" />).</para>

      <tip>
        <para>Einer meiner besten Freunde bei der Entwicklung von
        Rails-Applikationen ist die Tabulator-Taste. Wann immer Sie eine
        Methode für ein bestimmte Problem suchen, dann stellen Sie es in der
        Rails-Console nach, und drücken Sie zweimal auf die Tabulatortaste um
        alle verfügbaren Methoden für die entsprechende Klasse aufzulisten.
        Die Namen der Methoden sind meistens selbsterklärend.</para>
      </tip>
    </section>
  </section>

  <xi:include href="ar-datenbank_anlegen.xml" />

  <xi:include href="ar-datensaetze_hinzufuegen.xml" />

  <xi:include href="ar-first_last_all.xml" />

  <xi:include href="ar-seeds.xml" />

  <xi:include href="ar-queries.xml" />

  <xi:include href="ar-datensatz_veraendern.xml" />

  <xi:include href="ar-has_many.xml" />

  <section xml:id="datensatz-loeschen">
    <title>Einen Datensatz löschen</title>

    <para>Es gibt die Methoden <methodname>destroy</methodname> und
    <methodname>delete</methodname>, um Datensätze zu löschen. Diese Wortwahl
    empfinde ich als reichlich schwierig. Ich muss fast immer nachschlagen, um
    selbst sicher zu sein, welche Methode was macht.</para>

    <section xml:id="activerecord_destroy">
      <title xml:id="activerecord_destroy.title">destroy</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>destroy()</tertiary>
      </indexterm>

      <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
      löschen und dabei werden auch vorhandene Abhängigkeiten beachtet (siehe
      z.B. <code>:dependent =&gt; :destroy</code> in <xref
      linkend="activerecord_1n_optionen" />). Vereinfacht kann man sagen:
      Lieber <methodname>destroy</methodname> nehmen; das ist sicherer, weil
      das Rails-System dann mehr mitdenkt.<important>
          <para>Die Instanz wird nach dem Löschen des Datenbankfeldes
          <foreignphrase xml:lang="en">frozen</foreignphrase> (eingefroren).
          Sie ist also noch da, kann aber nicht verändert werden.</para>
        </important></para>

      <para>Für die Beispiele brauchen wir wieder definierte Daten. Deshalb
      füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit
      folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
      weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
      formatierte Variante von oben übernehmen.</remark></para>

      <para>Die Datei <filename>app/models/person.rb</filename> ändern Sie
      bitte wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
end</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Als erstes löschen wir Herrn Fritz Meier inklusive all seiner
      Telefonnummern:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>fritz_meier = Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' ).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_meier.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' )</command>
  =&gt; [] 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Das war einfach. Was ist allerdings mit der Variablen
      <varname>fritz_meier</varname>? Die existiert noch mit den Daten im
      sogenannten <foreignphrase xml:lang="en">frozen state</foreignphrase>
      (eingefrorener Zustand). Zum Überprüfen gibt es die Methode <indexterm>
          <primary>frozen?()</primary>
        </indexterm><methodname>frozen?</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>fritz_meier</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>fritz_meier.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>fritz_meier.frozen?</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; </screen></para>

      <para>Der Datensatz ist also in der Datenbank gelöscht, aber das Objekt
      mit allen Daten ist noch im laufenden Ruby-Programm vorhanden. Könnten
      wir damit den gesamten Datensatz wiederbeleben? Ja, allerdings ist das
      dann ein neuer Datensatz (er hat also nicht mehr die ID 1):<screen>ruby-1.9.2-p0 &gt; <command>Person.create( fritz_meier.attributes )</command>
 =&gt; #&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.where( :lastname =&gt; 'Meier', :firstname =&gt; 'Fritz' )</command>
 =&gt; [#&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Jetzt fehlen allerdings noch die Telefonnummern. Die können Sie
      aber separat abspeichern (da sie ja noch im <foreignphrase
      xml:lang="en">frozen</foreignphrase> Objekt vorhanden sind).</para>
    </section>

    <section xml:id="activerecord_delete">
      <title xml:id="activerecord_delete.title">delete</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>delete()</tertiary>
      </indexterm>

      <para>Mit <methodname>delete</methodname> können Sie einen Datensatz
      direkt in der Datenbank löschen. Dabei werden keine Abhängigkeiten zu
      anderen Datensätzen im <foreignphrase
      xml:lang="en">Model</foreignphrase> beachtet. Die Methode
      <methodname>delete</methodname> löscht also nur die eine Zeile in der
      Datenbank und sonst nichts.</para>

      <para>Löschen wir mal den Datensatz von Frau Meier:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>Person.first.delete</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 

ruby-1.9.2-p0 &gt; <command>Phonenumber.where( :person_id =&gt; 2 )</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Es wird zwar der Datensatz von Frau Meier gelöscht, aber die
      Telefonnummern in der zu <classname>Phonenumber</classname> gehörenden
      Datenbank-Tabelle bleiben als Karteileichen im System.</para>

      <para>Wie bei <methodname>destroy</methodname> geht das Objekt auch bei
      <methodname>delete</methodname> ein Objekt nach dem
      <methodname>delete</methodname> in den <foreignphrase
      xml:lang="en">frozen</foreignphrase>-Status (siehe <xref
      linkend="activerecord_destroy" />).<remark>FIXME: Den Satz verstehe ich
      nicht.</remark></para>
    </section>
  </section>

  <section xml:id="activerecord_transaction">
    <title xml:id="activerecord_transaction.title">Transaktionen
    (Transactions)</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Transaktionen</secondary>
    </indexterm>

    <indexterm>
      <primary>Transaktionen</primary>

      <see>ActiveRecord, Transaktionen</see>
    </indexterm>

    <indexterm>
      <primary>Datenbank</primary>

      <secondary>Transaktionen</secondary>

      <see>ActiveRecord, Transaktionen</see>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>transaction()</tertiary>
    </indexterm>

    <para>Es gibt immer mal wieder Anwendungsgebiete, bei denen man eine
    Datenbank-Transaktion durchführen muss. Das klassische Beispiel dafür ist
    eine Geldbewegung von einem zu einem anderen Konto. Die macht nur Sinn,
    wenn beide Aktionen (von einem Konto abbuchen und auf das Konto des
    Empfängers draufbuchen) ausgeführt werden.</para>

    <para>Zum Demonstrieren einer Transaktion brauchen wir wieder definierte
    Beispieldaten. Deshalb füllen Sie bitte die Datei
    <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting><remark>FIXME: Ist das der gleiche Inhalt der seeds.rb wie
    weiter oben (activerecord_1n_zugreifen)? Wenn ja, dann die schöner
    formatierte Variante von oben übernehmen.</remark></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Eine Transaktion wird nach folgendem Muster
    durchgeführt:<programlisting><emphasis role="bold">ActiveRecord::Base.transaction do</emphasis>
  <replaceable>was_auch_immer_der_erste_schritt_ist</replaceable>
  <replaceable>was_auch_immer_der_zweite_schritt_ist</replaceable>
  <replaceable>was_auch_immer_der_dritte_schritt_ist</replaceable>
<emphasis role="bold">end</emphasis></programlisting></para>

    <para>Herr und Frau Meier haben beide die gleiche Telefonnummer:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)

ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '030-8888888'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; </screen></para>

    <para>Jetzt wollen beide nach Hamburg umziehen und bekommen dort eine neue
    Telefonnummer. Jetzt wollen wir beim Ändern der Nummer sicherstellen, dass
    beide Nummern in einer Transaktion geändert werden.</para>

    <para>Hier ist der Code dazu:<remark>FIXME: Fehlt hier was? Hier steht
    kein Code zu den Telefonnummern. Danach geht es mit Flugnummern
    weiter.</remark></para>

    <para>Wenn wir in unserem Flugplan<remark>FIXME: In welchem Flugplan?
    Davon war bisher noch nicht die Rede oder?</remark> die Flugnummern des
    ersten und des zweiten Datensatzes austauschen wollen, dann wäre das auch
    ein klassischer Fall für eine Transaktion. Ansonsten hätten wir bei einem
    Fehler zweimal die gleiche Flugnummer in der Datenbank-Tabelle. Versuchen
    wir es mal:<remark>FIXME: Hm, hier geht es jetzt wieder mit Phonenumbers
    weiter.</remark><screen>ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '030-8888888'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; <command>die_meiers = Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '030-8888888'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; <command>herr_meier_telefon = die_meiers.first.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt; 

ruby-1.9.2-p0 &gt; <command>frau_meier_telefon = die_meiers.last.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt; 

ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.transaction do</command>
ruby-1.9.2-p0 &gt;     <command>neue_nummer = '040-9999999'</command>
ruby-1.9.2-p0 ?&gt;  <command>  herr_meier_telefon.number = neue_nummer</command>
ruby-1.9.2-p0 ?&gt;    <command>herr_meier_telefon.save</command>
ruby-1.9.2-p0 ?&gt;  <command>  frau_meier_telefon.number = neue_nummer</command>
ruby-1.9.2-p0 ?&gt;  <command>  frau_meier_telefon.save</command>
ruby-1.9.2-p0 ?&gt;  <command>end</command>
 =&gt; true 

ruby-1.9.2-p0 &gt; <command>die_meiers = Person.includes(:phonenumbers).where( :phonenumbers =&gt; {:number =&gt; '040-9999999'} )</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 

ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Beim Ende der Transaktion sehen wir dann in der
    <filename>log/development.log</filename> die entsprechenden
    Befehle:<programlisting>  SQL (0.3ms)  UPDATE "phonenumbers" SET "number" = '040-9999999', "updated_at" = '2010-10-10 08:28:08.669155' WHERE ("phonenumbers"."id" = 3)
  SQL (0.1ms)  UPDATE "phonenumbers" SET "number" = '040-9999999', "updated_at" = '2010-10-10 08:28:08.678647' WHERE ("phonenumbers"."id" = 4)</programlisting></para>

    <para>Da unsere Entwicklungs-Datenbank SQLite keine Transaktionen
    unterstützt, sehen wir nur zwei normale SQL-Befehle.<remark>FIXME: Laut
    http://de.wikipedia.org/wiki/Sqlite und http://www.sqlite.org/ unterstützt
    SQLite Transaktionen.</remark><remark>FIXME: Es wäre gut die Log-Datei zu
    sehen mit einem DBMS das Transaktionen unterstützt.</remark><remark>FIXME:
    Wenn das DBMS keine Transaktionen unterstützt werden also die SQL-Befehle
    einzeln ausgeführt? Kann man auch sagen daß etwas *nur* als Transaktion
    laufen soll oder abbrechen wenn das DBMS das nicht kann?</remark></para>

    <para>Jetzt werden Sie sagen: <quote>Ja, das hätte ich aber auch einfacher
    mit <methodname>update_attributes</methodname> realisieren können (siehe
    <xref linkend="activerecord_update_attributes" />)!</quote> Meine Antwort
    darauf: Gut aufgepasst! Das hier ist ja nur ein Beispiel. ;-)</para>

    <para>Transaktionen sind ein komplexes Thema. Wenn Sie mehr Informationen
    dazu suchen, können Sie die ri Hilfe dafür mit <command>ri
    ActiveRecord::Transactions::ClassMethods</command><remark>FIXME: Ist
    ...ClassMethods hier wirklich eine Klasse und keine Methode?</remark> auf
    der Shell abrufen.<important>
        <para>Die Methoden <methodname>save</methodname> und
        <methodname>destroy</methodname> werden automatisch im
        Transaktions-<foreignphrase xml:lang="en">Wrapper</foreignphrase>
        ausgeführt. So stellt Rails sicher, dass bei diesen Methoden kein
        undefinierter Zustand entsteht.</para>
      </important><warning>
        <para>Transaktionen werden nicht von jeder Datenbank nativ
        unterstützt. Bei unserem Beispiel oben sehen Sie, dass SQLite es zum
        Beispiel nicht unterstützt<remark>FIXME: Laut
        http://de.wikipedia.org/wiki/Sqlite und http://www.sqlite.org/
        unterstützt SQLite Transaktionen.</remark>. Meiner Meinung nach
        schadet es nicht sie zu benutzen. Es kann ja sein, dass die nächste
        Version Ihrer Lieblingsdatenbank Transaktionen unterstützt.</para>
      </warning></para>
  </section>

  <xi:include href="named_scope.xml" />

  <xi:include href="validation.xml" />

  <xi:include href="migration.xml" />
</chapter>
