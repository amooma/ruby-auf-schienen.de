<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="activerecord_chapter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_chapter.title">ActiveRecord</title>

  <para>ActiveRecord ist eine Abstaktionsschicht, die es uns leichten Zugang
  zu einer SQL-Datenbank gibt. Einer der Erfolgsrezepte von Rails ist
  sicherlich die Benutzung von ActiveRecord. Die Programmierung und Benutzung
  "fühlt sich gut an" und es ist viel weniger fehleranfällig als pures SQL.
  Bei der Arbeit mit diesem Kapitel hilft SQL-Wissen, aber es wird nicht
  vorrausgesetzt und es ist auch für die Arbeit mit ActiveRecord nicht
  notwendig.</para>

  <section>
    <title>Howto zum Kapitel</title>

    <para>Dieses Kapitel ist in sich selbst geschlossen. Allerdings wird die
    vorherige Lektüre von <xref linkend="ruby-grundlagen" /> und <xref
    linkend="erste_schritte_mit_rails" /> vorausgesetzt. Ohne wird es nicht
    gehen.</para>

    <para>Der Rails-Anfänger sollte das Kapitel einmal von oben bis unten
    durcharbeiten. Das heißt konkret: Alle Schritte in der eigenen Console mit
    ausprobieren und ruhig selber links und recht mal ein wenig
    experimentieren. Einfach hin und wieder zwei mal auf die Tab-Taste drücken
    und sich eine Liste der jeweils verfügbaren Methoden anzeigen
    lassen.</para>

    <para>Am Anfang eines Themas werde ich Ihnen in der Rails Console (siehe
    <xref linkend="die_console" />) zeigen wie die Grundlagen funktionieren.
    Am Ende des entsprechenden Themas werden wir dann das erlernte Wissen in
    das Webinterface der Rails-Applikations übertragen.<warning>
        <para>Es geht in diesem Kapitel um ActiveRecord. Deshalb: Um die
        Beispiele so übersichtlich wie möglich zu halten, werde ich deshalb
        keine Validierung (siehe <xref linkend="model_validierungen" />) und
        auch keine Tests (siehe <xref linkend="tests" />) einbauen. Ebenso
        verzichte ich in diesem Beispiel auf ein Rechtemodel. </para>
      </warning></para>
  </section>

  <section xml:id="railsair">
    <title xml:id="railsair.title">Die Fluggesellschaft RailsAir</title>

    <para>Damit das Kapitel in sich selbst abschlossen ist, erstellen wir ein
    neues Rails-Projekt, in dem wir dann alle Beispiele einbauen. Dabei habe
    ich etwas aus dem "täglichen Leben" genommen und schlage vor, das wir
    gemeinsam eine neue regionale Fluggesellschaft gründen. Die RailsAir!
    Fangen wir mal an:<screen>stefan@swmbp 0 1.9.1-p378 book$ <command>rails new railsair</command>
      create  
      create  README
      create  Rakefile
      create  config.ru
      create  .gitignore
      create  Gemfile
      create  app
      create  app/controllers/application_controller.rb

      [...]

      create  tmp/pids
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.1-p378 book$</screen></para>

    <para>So jetzt noch in das neue Verzeichnis wechseln und <command>bundle
    install</command> ausführen:<screen>stefan@swmbp 0 1.9.1-p378 book$ <command>cd railsair</command>
stefan@swmbp 0 1.9.1-p378 railsair$ <command>bundle install</command>
Fetching source index from http://rubygems.org/
Using rake (0.8.7) from bundler gems 
Using abstract (1.0.0) from bundler gems 
Using activesupport (3.0.0.beta4) from bundler gems 

[...]

Using rails (3.0.0.beta4) from bundler gems 
Using sqlite3-ruby (1.3.0) from bundler gems 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
  </section>

  <section xml:id="railsair_flight_scaffold">
    <title xml:id="railsair_flight_scaffold.title">Welche Flugnummern werden
    mit welchen Routen geflogen?</title>

    <para>Als Basis für dieses Kapitel erstellen wir jetzt eine Flugdatenbank.
    Der Einfachheit halber mit Scaffolding:</para>

    <para><screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails generate scaffold flight flight_number:string departure_airport:string destination_airport:string</command>
      invoke  active_record
      create    db/migrate/20100617123001_create_flights.rb
      create    app/models/flight.rb

      [...]

      create        test/unit/helpers/flights_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>

    <para>Die Datenbank anlegen:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:migrate</command>
(in /Users/stefan/book/railsair)
==  CreateFlights: migrating ==================================================
-- create_table(:flights)
   -&gt; 0.0017s
==  CreateFlights: migrated (0.0018s) =========================================

stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
  </section>

  <section xml:id="anlegen_und_anzeigen_von_datensaetzen">
    <title xml:id="anlegen_und_anzeigen_von_datensaetzen.title">Anlegen und
    Anzeigen von Datensätzen</title>

    <para>Wir arbeiten mit der Rails Console (siehe <xref
    linkend="die_console" />):<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; </screen></para>

    <section>
      <title>Neuen Datensatz anlegen</title>

      <para>ActiveRecord stellt uns automagisch eine Klasse aus der Datenbank
      <parameter>flights</parameter> mit dem Namen
      <classname>Flight</classname> zur Verfügung. Diese Klasse hat eine
      Methode <methodname>new</methodname> und mit der können wir ein neues
      Objekt erstellen. <screen>ruby-1.9.1-p378 &gt; <command>apfelmus = Flight.new</command>
 =&gt; #&lt;Flight id: nil, flight_number: nil, departure_airport: nil, destination_airport: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Wir können uns sicherheitshalber noch mal die Klasse der Instance
      <varname>apfelmus</varname> ausgeben lassen.<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Das neue Objekt <varname>apfelmus</varname> hat automatsch
      Accessors (siehe <xref linkend="getter_und_setter_methoden" />) zu den
      einzelnen Datenfeldern. Diese benutzen wir zum Füllen des ersten
      Datensatzes:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.flight_number = 'RA 001'</command>
 =&gt; "RA 001" 
ruby-1.9.1-p378 &gt; <command>apfelmus.departure_airport = 'FRA'</command>
 =&gt; "FRA" 
ruby-1.9.1-p378 &gt; <command>apfelmus.destination_airport = 'MUC'</command>
 =&gt; "MUC" 
ruby-1.9.1-p378 &gt; <command>apfelmus</command>
 =&gt; #&lt;Flight id: nil, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Objekt ist allerdings noch nicht in der Datenbank gespeichert.
      Das erfolgt erst durch Aufruf der Methode
      <methodname>save</methodname>.<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>

      <section>
        <title>Datensatz mit create anlegen</title>

        <para>Sie können nicht nur mit der Methode
        <methodname>new</methodname> ein neues Objekt der Klasse
        <classname>Flight</classname> anlegen, um dieses später mit
        <methodname>save</methodname> in der Datenbank zu speichern. Sie
        können auch direkt mit der Methode <methodname>create</methodname>
        einen Datensatz in der Datenbank anlegen:</para>

        <para>Alternative können wir einen zweiten Datensatz auch direkt mit
        der Methode <methodname>create</methodname> anlegen.<screen>ruby-1.9.1-p378 &gt; <command>Flight.create(:flight_number =&gt; 'RA 002', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'HAM')</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:02:03", updated_at: "2010-06-17 13:02:03"&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Sie können einen so neu erstellten Datensatz auch direkt in
        einer Variable speichern:<screen>ruby-1.9.1-p378 &gt; <command>pflaumenmus = Flight.create(:flight_number =&gt; 'RA 003', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'HAM')</command>
 =&gt; #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:03:46", updated_at: "2010-06-17 13:03:46"&gt; 
ruby-1.9.1-p378 &gt; <command>pflaumenmus.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Die Methode <methodname>create</methodname> nimmt übrigens auch
        ein Array (siehe <xref linkend="ruby_array" />) von neuen Objekten an.
        So können Sie auch mehr als einen <varname>Flight</varname> auf einmal
        erzeugen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.create([{:flight_number =&gt; 'RA 004', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'DUS'},{:flight_number =&gt; 'RA 005', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'TXL'}])</command>
 =&gt; [#&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:06:28", updated_at: "2010-06-17 13:06:28"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:06:28", updated_at: "2010-06-17 13:06:28"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

        <section>
          <title>Hilfe zu create</title>

          <para>Die Methode <methodname>create</methodname> gehört zu
          <classname>ActiveRecord::Base</classname>. Die online Hilfe dazu
          kann mit <command>ri ActiveRecord::Base.create</command> abgerufen
          werden. Wenn Sie das jetzt ausprobieren wollen, müssen Sie natürlich
          erst mit <command>exit</command> aus der Console raus.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>ri ActiveRecord::Base.create</command>
ActiveRecord::Base.create

(from gem activerecord-3.0.0.beta4)
------------------------------------------------------------------------------
  create(attributes = nil) { |object| ... }

------------------------------------------------------------------------------

Creates an object (or multiple objects) and saves it to the database, if
validations pass. The resulting object is returned whether the object was
saved successfully to the database or not.

The attributes parameter can be either be a Hash or an Array of Hashes.
 These Hashes describe the attributes on the objects that are to be created.

Examples
  # Create a single new object
  User.create(:first_name =&gt; 'Jamie')

  # Create an Array of new objects
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])

  # Create a single object and pass it into a block to set other attributes.
  User.create(:first_name =&gt; 'Jamie') do |u|
    u.is_admin = false
  end

  # Creating an Array of new objects using a block, where the block is executed for each object:
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
    u.is_admin = false
  end


stefan@swmbp 0 1.9.1-p378 railsair$
</screen></para>
        </section>
      </section>
    </section>

    <section xml:id="seed_rb">
      <title xml:id="seed_rb.title">Mit seed.rb die Entwicklungsdatenbank
      betanken</title>

      <para>In der Entwicklung von neuen Rails Projekten kommt es immer mal
      wieder vor, das man den Inhalt der Datenbank löschen und mit neuen
      Werten befüllen will. In Rails gibt es dafür den praktischen Mechanismus
      der Datei <filename>db/seeds.rb</filename></para>

      <para>Die <filename>db/seeds.rb</filename> ist ein normales
      Ruby-Programm, das man mit <command>rake db:seed</command> ausführen
      kann. Dies geht natürlich nicht nur mit der Entwicklungsdatenbank,
      sondern kann später auch in der Produktion geschehen. Das ist z.B.
      praktisch, wenn man initial eine Länderliste in eine Länderdatenbank
      eintragen will.</para>

      <para>Für unsere Flight-Datenbank habe ich folgende
      <filename>db/seeds.rb</filename> vorbereitet:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Flight.create(:flight_number =&gt; 'RA 001', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'MUC')
Flight.create(:flight_number =&gt; 'RA 002', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'HAM')
Flight.create(:flight_number =&gt; 'RA 003', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'HAM')
Flight.create(:flight_number =&gt; 'RA 004', :departure_airport =&gt; 'MUC', :destination_airport =&gt; 'DUS')
Flight.create(:flight_number =&gt; 'RA 005', :departure_airport =&gt; 'FRA', :destination_airport =&gt; 'TXL')</programlisting></para>

      <section>
        <title>Betankung</title>

        <para>Die Datenbank können wir <command>rake db:reset</command>
        resetten.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:reset</command>
(in /Users/stefan/book/railsair)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("flights", {:force=&gt;true})
   -&gt; 0.0142s
-- initialize_schema_migrations_table()
   -&gt; 0.0057s
-- assume_migrated_upto_version(20100617123001, "db/migrate")
   -&gt; 0.0026s
rake aborted!
undefined method `&lt;=&gt;' for class `ActiveSupport::Multibyte::Chars'

(See full trace by running task with --trace)
stefan@swmbp 1 1.9.1-p378 railsair$</screen></para>

        <para>Um sie dann mit <command>rake db:seed</command> zu
        betanken.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:seed</command>
(in /Users/stefan/book/test/railsair)
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="einfache_queries">
    <title xml:id="einfache_queries.title">Query</title>

    <para>So, das wird jetzt ein wenig komplexer. Muss man sich nicht beim
    ersten mal ganz durchlesen, aber schaden kann es auch nicht.</para>

    <note>
      <para>In diesem Kapitel werden absichtlich keine Methoden benutzt, die
      in Rails 3.0 deprecated sind.</para>
    </note>

    <section>
      <title>first und last</title>

      <para>Mit den Methoden <methodname>first</methodname> und
      <methodname>last</methodname> können wir uns den ersten und den letzten
      Datensatz aus einer Datenbank-Tabelle ausgeben lassen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.last</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Ergebnis von <methodname>Flight.first</methodname> ist
      natürlich eine <classname>Flight</classname> Klasse:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>all</title>

      <para>Der einfachste Weg alle Datensätze aus der Datenbank
      <varname>flights</varname> anzuzeigen ist die Methode
      <methodname>all</methodname>:<screen>ruby-1.9.1-p378 &gt; <command>Flight.all</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <tip>
        <para>Sie können sich mit dem Programm <command>pp</command> die
        Ausgabe von <methodname>Flight.all</methodname> etwas übersichtlicher
        darstellen lassen:<screen>ruby-1.9.1-p378 &gt; <command>pp Flight.all</command>
[#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;,
 #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;,
 #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;,
 #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;,
 #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; </screen></para>
      </tip>

      <para>Was für eine Klasse ist das Ergebnis von
      <classname>Flight.all</classname>? Schauen wir mal mit der Methode
      <methodname>class</methodname> nach:<screen>ruby-1.9.1-p378 &gt; <command>Flight.all.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Dann können wir ja die Iterator-Methode
      <methodname>each</methodname> anwenden (siehe <xref
      linkend="array_iterator" />), um durch die einzelnen Elemente des Arrays
      zu gehen. Damit können Sie sich als Beispiel alle Flugnummern ausgeben
      lassen.<screen>ruby-1.9.1-p378 &gt; <command>Flight.all.each { |flight| puts flight.flight_number }</command>
RA 001
RA 002
RA 003
RA 004
RA 005
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>Nach ID suchen</title>

      <para>Einen Flight nach der Datenbank-ID zu suchen geht mit der Methode
      <methodname>find</methodname>(ID):<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(1)</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Ergebnis von <methodname>Flight.find(1)</methodname> ist
      natürlich eine <classname>Flight</classname> Klasse:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(1).class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Wir können aber auch mehrere IDs auf einmal suchen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(2,4,5)</command>
 =&gt; [#&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Das Ergebnis ist dann logischerweise dann wiederum ein Array
      (siehe <xref linkend="ruby_array" />):<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(2,4,5).class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Mit diesem Array können Sie dann wieder die Iterator-Methoden
      benutzen (siehe <xref linkend="array_iterator" />).</para>

      <section>
        <title>Verhalten bei "nicht gefunden"</title>

        <para>Wer mit <methodname>find(ID)</methodname> einen bestimmten
        Datensatz abrufen will, sollte sicher sein, das es diesen Datensatz
        auch gibt. Sonst kommt es zu einem Fehler, den man extra abfangen
        müsste:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(100)</command>
ActiveRecord::RecordNotFound: Couldn't find Flight with ID=100
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/relation/finder_methods.rb:287:in `find_one'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/relation/finder_methods.rb:274:in `find_with_ids'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/relation/finder_methods.rb:102:in `find'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/base.rb:403:in `find'
 from (irb):27
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:47:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Man kann übrigens mit der Methode
        <methodname>exists?(ID)</methodname> vor einem
        <methodname>find(ID)</methodname> überprüfen, ob der entsprechende
        Datensatz in der Datenbank existiert. Das Ergebnis von
        <methodname>exists?(ID)</methodname> ist ein Boolean.<screen>ruby-1.9.1-p378 &gt; <command>Flight.exists?(100)</command>
 =&gt; false 
ruby-1.9.1-p378 &gt; <command>Flight.exists?(2)</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>

        <para><warning>
            <para>Mehr der Form halber möchte ich hier erwähnen, das es bei
            einem <methodname>exists(ID)</methodname> gefolgt von einem
            <methodname>find(ID)</methodname> durchaus zu einer Race-Condition
            kommen kann. Unwahrscheinlich, aber nicht unmöglich. Es kann ja
            sein, das in der minimalen Zeit zwischen den beiden Befehlen ein
            anderes Programm genau diese Tabellen-ID löscht.</para>
          </warning></para>
      </section>
    </section>

    <section>
      <title>find_by_x und find_all_by_x</title>

      <para>Bei der Benutzung von find_by kommt ein wenig Ruby-Magie ins
      Spiel. Die Methode <methodname>find</methodname> kann dynamisch mit
      <methodname>_by_</methodname> und dem Feldnamen erweitert werden und
      gibt dann den ersten Treffer der Suche aus. Am einfachsten zeigt sich
      das mit ein paar Beispielen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport('FRA')</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find_by_destination_airport('TXL')</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Man kann <methodname>find_by_x</methodname> Methoden weiterhin
      beliebig mit <methodname>_and_</methodname> um weitere Feldnamen
      verlängern:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport_and_destination_airport('MUC','DUS')</command>
 =&gt; #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt; 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Während <methodname>find_by_x</methodname> immer nur den ersten
      gefundenen Datensatz ausgibt, kann man mit
      <methodname>find_all_by_x</methodname> alle Treffer für diese Anfrage
      als Array bekommen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('FRA')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('FRA').class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

      <section>
        <title>Verhalten bei "nicht gefunden"</title>

        <para>Wenn ein <methodname>find_by</methodname> keinen Treffer findet,
        dann ist das Ergebnis nil:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport('LAX')</command>
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>Flight.find_by_departure_airport('LAX').class</command>
 =&gt; NilClass 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Kein Treffer bei einem <methodname>find_all_by</methodname>
        Aufruf ist ein leeres Array:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('LAX')</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt; <command>Flight.find_all_by_departure_airport('LAX').class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt; </screen></para>
      </section>
    </section>

    <section>
      <title>where</title>

      <para>Eine sehr mächtige Alternative zu
      <methodname>find_all_by</methodname> die Methode
      <methodname>where</methodname>:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Einer der Vorteile von <methodname>where</methodname> im Vergleich
      zu <methodname>find_all_by</methodname> ist die Möglichkeit es
      hintereinander zu schalten:<screen>ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').where(:production_year =&gt; 2007)</command>
 =&gt; [#&lt;Airplane id: 5, name: "Orlando", model: "Boing 747", production_year: 2007, seats: 467, created_at: "2010-06-14 11:51:10", updated_at: "2010-06-14 11:51:10"&gt;] 
ruby-head &gt;</screen></para>

      <section>
        <title>count</title>

        <para>Mit der Methode <methodname>count</methodname> kann man sich
        dann die Anzahl der gefundenen Flights ausrechnen lassen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').count</command>
 =&gt; 3 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Jetzt mal eine kleine Quizfrage: "Zählt Rails die Anzahl der
        Objekte im Array, das von <command>Flight.where(:departure_airport
        =&gt; 'FRA').count</command> ausgegeben wird oder geht es
        intelligenter vor?". Die Antwort liegt im Logfile
        <filename>log/development.log</filename><screen>  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "flights" WHERE ("flights"."departure_airport" = 'FRA')
</screen></para>

        <para>ActiveRecord überlässt also nicht Ruby on Rails das Zählen des
        Ergebnis-Arrays von <command>Flight.where(:departure_airport =&gt;
        'FRA')</command> sondern fügt das <code>COUNT</code> der SQL Anweisung
        hinzu und lässt die Datenbank diese Berechnung vollziehen (was viel
        schneller und Resourcen-schonender ist).</para>
      </section>

      <section xml:id="lazy_loading">
        <title xml:id="lazy_loading.title">Lazy Loading</title>

        <para>Seit Rails 3.0 wird bei ActiveRecords <emphasis>Lazy
        Loading</emphasis> verwendet. Das heißt, das eine Datenbankabfrage
        erst dann gestellt wird, wenn es gar nicht mehr anders geht. Vorher
        wird die Anfrage als <classname>ActiveRecord::Relation</classname>
        gespeichert. Dummerweise sieht man das in der Console nicht
        automatisch (da das potentielle Ergebnis der Abfrage immer ausgegeben
        wird). Schauen wir uns das mal an einem Code-Beispiel an:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus = Flight.where(:departure_airport =&gt; 'FRA')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Die <methodname>where</methodname> Abfrage wäre also im
        Produktivbetrieb an dieser Stelle noch nicht gemacht worden. Erweitern
        wir mal die Suche:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus = apfelmus.where(:destination_airport =&gt; 'MUC')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;] 
ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; </screen></para>

        <para>Das Ergebnis ist immer noch ein ActiveRecord::Relation. Die
        Datenbank wurde also im Produktivbetrieb noch nicht befragt. Das
        geschieht erst, wenn wir die <methodname>all</methodname> Methode
        aufrufen:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus = apfelmus.all</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;] 
ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Da das Ergebnis-Array nur einen Eintrag hat, können wir es mit
        der Methode <methodname>first</methodname> leicht auslesen:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>apfelmus.first.class</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Warum wird die Datenbank-Abfrage erst beim Aufruf der Methode
        <methodname>all</methodname> vollzogen? Das ist der Zeitpunkt, an dem
        ActiveRecord::Relation nicht drum rum kommt. Vorher reichte es die
        gewünschten Suchen als Relation abzuspeichern. Es geht dabei wieder
        einmal um die Optimierung der SQL-Abfrage. Schauen wir uns die obigen
        Schritte noch einmal unter diesem Gesichtspunkt an:</para>

        <para><screen>ruby-1.9.1-p378 &gt; <command>apfelmus = Flight.where(:departure_airport =&gt; 'FRA')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;] 
ruby-1.9.1-p378 &gt; <command>apfelmus.to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA')" 
ruby-1.9.1-p378 &gt; <command>apfelmus = apfelmus.where(:destination_airport =&gt; 'MUC')</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;] 
ruby-1.9.1-p378 &gt; <command>apfelmus.to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA') AND (\"flights\".\"destination_airport\" = 'MUC')" 
ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>ActiveRecord nimmt uns als Entwickler bei der Benutzung von
        <methodname>where</methodname> im Vergleich zu
        <methodname>find_all_by</methodname> viel Optimierungs-Arbeit ab. Mit
        der Methode <methodname>to_sql</methodname> kann man sich dabei immer
        den aktuellen SQL-Aufruf anzeigen lassen. Das geht aber nur, so lange
        die Klasse ein ActiveRecord::Relation ist. Wurde die Abfrage mit
        <methodname>all</methodname>, <methodname>first</methodname> oder
        <methodname>last</methodname> durchgeführt, ergibt
        <methodname>to_sql</methodname> logischerweise einen Fehler:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>apfelmus.all.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt; <command>apfelmus.to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA') AND (\"flights\".\"destination_airport\" = 'MUC')" 
ruby-1.9.1-p378 &gt; <command>apfelmus.all.to_sql</command>
NoMethodError: undefined method `scalar' for nil:NilClass
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activesupport-3.0.0.beta4/lib/active_support/whiny_nil.rb:48:in `method_missing'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/arel-0.4.0/lib/arel/engines/sql/core_extensions/object.rb:5:in `to_sql'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/arel-0.4.0/lib/arel/engines/sql/core_extensions/array.rb:6:in `block in to_sql'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/arel-0.4.0/lib/arel/engines/sql/core_extensions/array.rb:6:in `collect'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/arel-0.4.0/lib/arel/engines/sql/core_extensions/array.rb:6:in `to_sql'
 from (irb):70
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:47:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>Verhalten bei "nicht gefunden"</title>

        <para>Die Methode <methodname>where</methodname> gibt als Ergebnis
        einer nicht erfolgreichen Suche ein leeres Array aus:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX')</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt;</screen></para>

        <note>
          <para>Man kann natürlich argumentieren, das das Ergebnis einer
          erfolglosen Suche ein ActiveRecord::Relation ist, das erst bei einem
          weiteren Vergleich wirklich aufgelöst wird. Stimmt. Da sich aber
          ActiveRecord darum automatisch kümmert, kann man diese Genauigkeit
          in der Praxis getrost vernachlässigen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX')</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX').class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'LAX') == Array.new</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>
        </note>
      </section>
    </section>

    <section>
      <title>Sortieren</title>

      <para>Mit der Methode <methodname>order()</methodname> können Sie die
      Ergebnisse einer Abfrage sortieren. Dabei können Sie als Parameter ein
      Symbol (siehe <xref linkend="ruby_symbol" />) oder den entsprechenden
      SQL-Befehl (<code>asc</code> = aufsteigend und <code>desc</code> =
      absteigend) übergeben.<screen>ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport)</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;, #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;] 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').order('flight_number desc')</command>
 =&gt; [#&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;, #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;] 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Auch hier sorgt Lazy Loading (siehe <xref
      linkend="lazy_loading" />) im Hintergrund für performantere
      Programme:<screen>ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>Flight.order(:departure_airport).to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" ORDER BY  departure_airport" 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').order('flight_number desc').class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').order('flight_number desc').to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA') ORDER BY  flight_number desc" 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>Limit</title>

      <para>Zum Schluss zeige ich Ihnen noch die
      <methodname>limit</methodname> Methode, mit der Sie die Anzahl der
      Ergebnisse limitieren können:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').limit(2)</command>
 =&gt; [#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt;, #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt;] 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Ja, auch dies ist wieder ein Fall für Lazy Loading (siehe <xref
      linkend="lazy_loading" />):<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').limit(2).to_sql</command>
 =&gt; "SELECT     \"flights\".* FROM       \"flights\" WHERE     (\"flights\".\"departure_airport\" = 'FRA') LIMIT 2" 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section>
      <title>Berechnungen</title>

      <para>ActiveRecord gibt uns direkten Zugriff auf eine Hand voll
      Berechnungsmethoden die von einer SQL-Datenbank durchgeführt werden
      können. Auch hier gilt der Grundsatz: Im Zweifel kann die Datenbank eine
      dieser Berechnungen schneller, als wir im Programm.<note>
          <para>Dummerweise habe ich ihm Beispiel keine Zahlen in den Tabellen
          eingebaut. Das hat man davon, wenn man möglichst einfache Beispiele
          wählt. Aus diesem Grund greife ich bei den folgenden Methoden
          teilweise auf eine imaginäre <classname>Airplane</classname>
          Datenbank zurück, die die Fehler <varname>:production_year</varname>
          und <varname>:seats</varname> hat.</para>
        </note></para>

      <section>
        <title>count</title>

        <para>Mit <methodname>count</methodname> kann man die Anzahl der
        Datensätze berechnen:<screen>ruby-1.9.1-p378 &gt; <command>Flight.where(:departure_airport =&gt; 'FRA').count</command>
 =&gt; 3 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>

      <section>
        <title>average</title>

        <para>Mit <methodname>average</methodname> kann man den
        Durchschnittswert eines Tabellenfeldes berechnen:<screen>ruby-head &gt; <command>Airplane.average(:seats)</command>
 =&gt; #&lt;BigDecimal:101377858,'0.4941667E3',18(18)&gt; 
ruby-head &gt; <command>Airplane.average(:seats).to_i</command>
 =&gt; 494 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').average(:production_year)</command>
 =&gt; #&lt;BigDecimal:1013321e0,'0.20056667E4',18(18)&gt; 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').average(:production_year).to_i</command> 
 =&gt; 2005 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').average(:production_year).to_f</command> 
 =&gt; 2005.6667 
ruby-head &gt;</screen></para>
      </section>

      <section>
        <title>minimum und maximum</title>

        <para>Mit den Methoden <methodname>minimum</methodname> und
        <methodname>maximum</methodname> kann man das jeweilige Minimum oder
        Maximum eines Feldes berechnen:<screen>ruby-head &gt; <command>Airplane.minimum(:seats)</command>
 =&gt; 300 
ruby-head &gt; <command>Airplane.maximum(:seats)</command>
 =&gt; 852 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').minimum(:production_year)</command>
 =&gt; 2005 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').maximum(:production_year)</command>
 =&gt; 2007 
ruby-head &gt; </screen></para>
      </section>

      <section>
        <title>sum</title>

        <para>Mit der Methode <methodname>sum</methodname> kann man die Summe
        eines bestimmten Feldes in Einträgen berechnen: <screen>ruby-head &gt; <command>Airplane.sum(:seats)</command>
 =&gt; 2965 
ruby-head &gt; <command>Airplane.where(:model =&gt; 'Boing 747').sum(:seats)</command>
 =&gt; 1401 
ruby-head &gt; </screen></para>
      </section>
    </section>
  </section>

  <section xml:id="datensatz-editieren">
    <title>Einen Datensatz editieren</title>

    <para>Das Verändern eines Datensatzes erfolgt in zwei
    Schritten:<orderedlist>
        <listitem>
          <para>Suche des Datensatzes und erstellen einer entsprechenden
          Instanz.</para>
        </listitem>

        <listitem>
          <para>Verändern der Werte.</para>
        </listitem>

        <listitem>
          <para>Abspeichern des Datensatzes mit der Methode
          <methodname>save</methodname>.</para>
        </listitem>
      </orderedlist></para>

    <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>apfelmus = Flight.find_by_destination_airport('TXL')</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 13:41:16"&gt; 
ruby-1.9.1-p378 &gt; <command>apfelmus.destination_airport = 'CDG'</command>
 =&gt; "CDG" 
ruby-1.9.1-p378 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; <command>Flight.find_by_destination_airport('CDG')</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "CDG", created_at: "2010-06-17 13:41:16", updated_at: "2010-06-17 15:13:29"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

    <section xml:id="activerecord_locking">
      <title xml:id="activerecord_locking.title">Locking</title>

      <para>Per Default benutzt Rails Optimistisches Locking der Datensätze.
      Dies kann aber umgeschaltet werden. Da für die meisten User
      Optimistisches Locking optimal ist und viele vor diesem Absatz nicht mal
      über das Problem nachgedacht haben, werde ich nicht weiter drauf
      eingehen, sondern auf die ri Hilfe verweisen. Wer pessimistisches
      Locking benötigt, der findet dort die notwendigen Schalter.</para>

      <para><screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>ri ActiveRecord::Locking::Optimistic</command>
ActiveRecord::Locking::Optimistic

(from gem activerecord-3.0.0.beta4)
------------------------------------------------------------------------------
What is Optimistic Locking

Optimistic locking allows multiple users to access the same record for edits,
and assumes a minimum of conflicts with the data.  It does this by checking
whether another process has made changes to a record since it was opened, an
ActiveRecord::StaleObjectError is thrown if that has occurred and the update
is ignored.

Check out ActiveRecord::Locking::Pessimistic for an alternative.

Usage

Active Records support optimistic locking if the field lock_version is
present.  Each update to the record increments the lock_version column and the
locking facilities ensure that records instantiated twice will let the last
one saved raise a StaleObjectError if the first was also updated. Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.first_name = "should fail"
  p2.save # Raises a ActiveRecord::StaleObjectError

Optimistic locking will also check for stale data when objects are destroyed. 
Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.destroy # Raises a ActiveRecord::StaleObjectError

You're then responsible for dealing with the conflict by rescuing the
exception and either rolling back, merging, or otherwise apply the business
logic needed to resolve the conflict.

You must ensure that your database schema defaults the lock_version column to
0.

This behavior can be turned off by setting
ActiveRecord::Base.lock_optimistically = false. To override the name of
the lock_version column, invoke the set_locking_column method. This
method uses the same syntax as set_table_name

------------------------------------------------------------------------------
Instance methods:

  attributes_from_column_definition


stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>
    </section>
  </section>

  <section xml:id="activerecord_transaction">
    <title xml:id="activerecord_transaction.title">Transaction</title>

    <para>Es gibt immer mal wieder Anwendungsgebiete, bei denen man eine
    Datenbank-Transaktion durchführen muss. Das klassische Beispiel dafür ist
    eine Geldbewegung von einem zu einem anderen Konto. Die macht nur Sinn,
    wenn beide Aktionen ausgeführt werden.</para>

    <para>Eine Transaktion wird nach folgendem Bauplan
    durchgeführt:<programlisting>ActiveRecord::Base.transaction do
    was_immer_der_erste_schritt_ist
    was_immer_der_zweite_schritt_ist
    was_immer_der_dritte_schritt_ist
end</programlisting></para>

    <para>Wenn wir in unserem Flugplan die Flugnummern des ersten und des
    zweiten Datensatzes austauschen wollen, dann wäre das auch ein klassischer
    Fall für eine Transaktion. An sonsten hätten wir bei einem Fehler zwei mal
    die gleiche Flugnummer in der Datenbank. Versuchen wir es einmal:<screen>ruby-1.9.1-p378 &gt; <command>erster_flug = Flight.find(1)</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 13:41:06"&gt; 
ruby-1.9.1-p378 &gt; <command>zweiter_flug = Flight.find(2)</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt; 
ruby-1.9.1-p378 &gt; <command>ActiveRecord::Base.transaction do</command>
ruby-1.9.1-p378 &gt;   <command>erster_flug.flight_number = 'RA 002'</command>
ruby-1.9.1-p378 ?&gt;  <command>erster_flug.save</command>
ruby-1.9.1-p378 ?&gt;  <command>zweiter_flug.flight_number = 'RA 001'</command>
ruby-1.9.1-p378 ?&gt;  <command>zweiter_flug.save</command>
ruby-1.9.1-p378 ?&gt;  <command>end</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>

    <para>Die Transaktion wurde erfolgreich durchgeführt:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(1)</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(2)</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

    <para>Tansaktionen sind ein komplexes Thema. Wenn Sie mehr Informationen
    dazu suchen, können Sie die ri Hilfe dafür mit <command>ri
    ActiveRecord::Transactions::ClassMethods</command> auf der Shell
    abrufen.<important>
        <para>Die Methoden <methodname>save</methodname> und
        <methodname>destroy</methodname> werden automatisch in
        Transaktions-Wrapper ausgeführt. So stellt Rails sicher, das bei
        diesen Methoden kein undefinierter Zustand entsteht.</para>
      </important></para>
  </section>

  <section xml:id="datensatz-loeschen">
    <title>Einen Datensatz löschen</title>

    <para>Es gibt die Methoden <methodname>destroy</methodname> und
    <methodname>delete</methodname>, um Datensätze zu löschen.</para>

    <section xml:id="activerecord_destroy">
      <title xml:id="activerecord_destroy.title">destroy</title>

      <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
      löschen und dabei werden auch vorhandene Abhängigkeiten beachtet.
      Vereinfacht kann man sagen: "Lieber destroy nehmen, das ist sicherer,
      weil das Rails-System dann mehr mitdenkt."<important>
          <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
          (eingefroren). Sie ist also noch da, kann aber nicht verändert
          werden.</para>
        </important></para>

      <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc = Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc.destroy</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Der Datensatz ist also in der Datenbank gelöscht worden.
      Allerdings enthält das Object <varname>fra_muc</varname> noch die Daten
      und ist im frozen-State:<screen>ruby-1.9.1-p378 &gt; <command>fra_muc</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc.frozen?</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>

      <para>Wozu das gut ist? Erst mal ist es wichtig für das Verständnis von
      der Arbeit mit ActiveRecords. Man muss immer im Hinterkopf behalten, was
      im eigenen Objekt und was in der Datenbank ist.</para>

      <para>Aber ganz praktisch gesprochen kann man ein frozen-Objekt und die
      Methode <methodname>attributes</methodname> dazu benutzen einen
      versehentlich gelöschten Datensatz in einen neuen Datensatz zu
      speichern:<screen>ruby-1.9.1-p378 &gt; <command>fra_muc</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_muc.attributes</command>
 =&gt; {"created_at"=&gt;2010-06-17 13:41:06 UTC, "departure_airport"=&gt;"FRA", "destination_airport"=&gt;"MUC", "flight_number"=&gt;"RA 002", "id"=&gt;1, "updated_at"=&gt;2010-06-17 15:44:56 UTC} 
ruby-1.9.1-p378 &gt; <command>Flight.create(fra_muc.attributes)</command>
 =&gt; #&lt;Flight id: 6, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.last</command>
 =&gt; #&lt;Flight id: 6, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 13:41:06", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>
    </section>

    <section xml:id="activerecord_delete">
      <title xml:id="activerecord_delete.title">delete</title>

      <para>Mit <methodname>delete</methodname> können Sie einen Datensatz
      direkt in der Datenbank löschen. Dabei werden keine Abhängigkeiten zu
      anderen Datensätzen im Model beachtet. Die Methode
      <methodname>delete</methodname> löscht also nur die eine Zeile in der
      Datenbank und sonst nichts.<note>
          <para>Für unseren jetzigen Kenntnisstand sind solche Abhänigkeiten
          noch egal, aber in späteren Kapiteln werden wir verschiedene
          Tabellen mit einander verknüpfen und dann wird es entsprechende
          Abhängigkeiten geben.</para>
        </note></para>

      <para>Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>fra_ham = Flight.first</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_ham.delete</command>
 =&gt; #&lt;Flight id: 2, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 15:44:56"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 13:41:15", updated_at: "2010-06-17 13:41:15"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>

      <para>Wie bei <methodname>destroy</methodname> geht das Objekt auch hier
      nach dem <methodname>delete</methodname> in den frozen-Status
      über:<screen>ruby-1.9.1-p378 &gt; <command>fra_ham.frozen?</command>
 =&gt; true 
ruby-1.9.1-p378 &gt; </screen></para>
    </section>
  </section>

  <section xml:id="has_many">
    <title xml:id="has_many.title">has_many - 1:n Verknüpfung</title>

    <para>Mit dem im <xref linkend="railsair_flight_scaffold" /> erstellen
    Datenbankmodel haben wir eine Auflistung der Flugstrecken. Es fehlen aber
    die Flugzeiten. Die sauberste Lösung dafür ist eine weitere Tabelle die
    einen Foreign-Key (foreign_key) mit der ID des Flight-Eintrages enthält
    und für jeden Flug die Flugzeiten abspeichert. Dann können wir über eine
    1:n Verknüpfung zu jeder Flugnummer alle Flüge ausgeben. Der Name des
    Foreign-Keys wird per Default immer aus dem Namen der Primary Datenbank
    (in unserem Fall <classname>Flight</classname>) und einem
    "<code>_id</code>" zusammengefügt. </para>

    <para>Um nach dem letzten Kapitel einen gleichen Datenstand zu haben
    reseten wir erst mal unsere Entwicklungsdatenbank und spielen die
    <filename>db/seed.rb</filename> Datei (siehe <xref linkend="seed_rb" />)
    ein:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:reset</command>
(in /Users/stefan/book/railsair)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("flights", {:force=&gt;true})
   -&gt; 0.0151s
-- initialize_schema_migrations_table()
   -&gt; 0.0061s
-- assume_migrated_upto_version(20100617123001, "db/migrate")
   -&gt; 0.0022s
stefan@swmbp 1 1.9.1-p378 railsair$ <command>rake db:seed</command>
(in /Users/stefan/book/railsair)
stefan@swmbp 1 1.9.1-p378 railsair$</screen></para>

    <para>Kurze Überprüfung, ob alles geklappt hat:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; <command>pp Flight.all</command>
[#&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 16:24:07", updated_at: "2010-06-17 16:24:07"&gt;,
 #&lt;Flight id: 2, flight_number: "RA 002", departure_airport: "FRA", destination_airport: "HAM", created_at: "2010-06-17 16:24:14", updated_at: "2010-06-17 16:24:14"&gt;,
 #&lt;Flight id: 3, flight_number: "RA 003", departure_airport: "MUC", destination_airport: "HAM", created_at: "2010-06-17 16:24:14", updated_at: "2010-06-17 16:24:14"&gt;,
 #&lt;Flight id: 4, flight_number: "RA 004", departure_airport: "MUC", destination_airport: "DUS", created_at: "2010-06-17 16:24:14", updated_at: "2010-06-17 16:24:14"&gt;,
 #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>exit</command></screen></para>

    <para>Jetzt legen wir die zweite Tabelle mit den Abflug- und
    Ankunftszeiten an. Das Feld <varname>flight_id</varname> wird dabei das
    Verbindungsstück zwischen den beiden Tabellen. Dabei wird immer das Muster
    klassenname_id benutzt.<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails generate scaffold flight_schedule flight_id:integer departure:time arrival:time</command>
      invoke  active_record
      create    db/migrate/20100617162714_create_flight_schedules.rb
      create    app/models/flight_schedule.rb
      invoke    test_unit
      create      test/unit/flight_schedule_test.rb
      create      test/fixtures/flight_schedules.yml
       route  resources :flight_schedules
      invoke  scaffold_controller
      create    app/controllers/flight_schedules_controller.rb
      invoke    erb
      create      app/views/flight_schedules
      create      app/views/flight_schedules/index.html.erb
      create      app/views/flight_schedules/edit.html.erb
      create      app/views/flight_schedules/show.html.erb
      create      app/views/flight_schedules/new.html.erb
      create      app/views/flight_schedules/_form.html.erb
      invoke    test_unit
      create      test/functional/flight_schedules_controller_test.rb
      invoke    helper
      create      app/helpers/flight_schedules_helper.rb
      invoke      test_unit
      create        test/unit/helpers/flight_schedules_helper_test.rb
      invoke  stylesheets
   identical    public/stylesheets/scaffold.css
stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>

    <para>Danach wieder <command>rake db:migrate</command> ausführen, damit
    die Datenbank auch angelegt wird:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rake db:migrate</command>
(in /Users/stefan/book/railsair)
==  CreateFlightSchedules: migrating ==========================================
-- create_table(:flight_schedules)
   -&gt; 0.0014s
==  CreateFlightSchedules: migrated (0.0015s) =================================

stefan@swmbp 0 1.9.1-p378 railsair$</screen></para>

    <para>Schauen wir uns das mal auf der Console an:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; <command>Flight</command>
 =&gt; Flight(id: integer, flight_number: string, departure_airport: string, destination_airport: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; <command>FlightSchedule</command>
 =&gt; FlightSchedule(id: integer, flight_id: integer, departure: time, arrival: time, created_at: datetime, updated_at: datetime) 
ruby-1.9.1-p378 &gt; <command>Flight.all.count</command>
 =&gt; 5 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.all.count</command>
 =&gt; 0 
ruby-1.9.1-p378 &gt; </screen></para>

    <para>Es fehlen Einträge in der <varname>flight_schedules</varname>
    Datenbank. Tragen wir mal drei Beispielflüge ein:<screen>ruby-1.9.1-p378 &gt; <command>FlightSchedule.create(:flight_id =&gt; 1, :departure =&gt; Time.parse('01.01.2012 10:00'), :arrival =&gt; Time.parse('01.01.2012 11:05'))</command>
 =&gt; #&lt;FlightSchedule id: 1, flight_id: 1, departure: "2012-01-01 10:00:00", arrival: "2012-01-01 11:05:00", created_at: "2010-06-17 16:41:03", updated_at: "2010-06-17 16:41:03"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.create(:flight_id =&gt; 1, :departure =&gt; Time.parse('02.01.2012 10:00'), :arrival =&gt; Time.parse('02.01.2012 11:05'))</command>
 =&gt; #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2012-01-02 10:00:00", arrival: "2012-01-02 11:05:00", created_at: "2010-06-17 16:41:18", updated_at: "2010-06-17 16:41:18"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.create(:flight_id =&gt; 1, :departure =&gt; Time.parse('03.01.2012 10:00'), :arrival =&gt; Time.parse('03.01.2012 11:05'))</command>
 =&gt; #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2012-01-03 10:00:00", arrival: "2012-01-03 11:05:00", created_at: "2010-06-17 16:41:27", updated_at: "2010-06-17 16:41:27"&gt; 
ruby-1.9.1-p378 &gt; <command>pp FlightSchedule.all</command>
[#&lt;FlightSchedule id: 1, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:03", updated_at: "2010-06-17 16:41:03"&gt;,
 #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:18", updated_at: "2010-06-17 16:41:18"&gt;,
 #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:27", updated_at: "2010-06-17 16:41:27"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>exit</command></screen></para>

    <para>Die zwei Datenbanken sind eingerichtet und können mit ActiveRecord
    benutzt werden. Allerdings weiß ActiveRecord noch nichts von der 1:n
    Beziehung der beiden. Das ist aber recht einfach in zwei
    Schritten:<orderedlist>
        <listitem>
          <para>Wir fügen die <code>has_many</code> Option in die Model-Datei
          <filename>app/models/flights.rb</filename> ein:<programlisting>class Flight &lt; ActiveRecord::Base
  has_many :flight_schedules
end</programlisting></para>

          <para>Mit diesem Eintrag bekommen wir automagisch ein paar neue
          Methoden für die Flight Klasse. So können wir jetzt mit der Methode
          <methodname>flight_schedules</methodname> alle
          <classname>FlightSchedule</classname> Einträge für den aktuellen
          <classname>Flight</classname> abrufen:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; <command>pp Flight.find(1).flight_schedules</command>
[#&lt;FlightSchedule id: 1, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:03", updated_at: "2010-06-17 16:41:03"&gt;,
 #&lt;FlightSchedule id: 2, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:18", updated_at: "2010-06-17 16:41:18"&gt;,
 #&lt;FlightSchedule id: 3, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:27", updated_at: "2010-06-17 16:41:27"&gt;]
 =&gt; nil 
ruby-1.9.1-p378 &gt; <command>Flight.find(1).flight_schedules.count</command>
 =&gt; 3 
ruby-1.9.1-p378 &gt;</screen></para>

          <para>Da wir für den zweiten Flug noch keine
          <classname>FlightSchedule</classname> Einträge haben bekommen wir
          hier als Ergebnis ein leeres Array:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(2).flight_schedules</command>
 =&gt; [] 
ruby-1.9.1-p378 &gt; <command>Flight.find(2).flight_schedules.class</command>
 =&gt; Array 
ruby-1.9.1-p378 &gt; </screen></para>

          <para>Ebenfalls funktioniert der umgekehrte Weg auch noch nicht. Wir
          haben noch keine Zuordnung eines Flight zu einem FlightSchedule. Die
          entsprechende Methode ist noch nicht existent:<screen>ruby-1.9.1-p378 &gt; <command>FlightSchedule.first.flight</command>
NoMethodError: undefined method `flight' for #&lt;FlightSchedule:0x00000105016870&gt;
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activemodel-3.0.0.beta4/lib/active_model/attribute_methods.rb:358:in `method_missing'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/attribute_methods.rb:45:in `method_missing'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/activerecord-3.0.0.beta4/lib/active_record/attribute_methods.rb:43:in `method_missing'
 from (irb):9
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:47:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.1-p378/gems/railties-3.0.0.beta4/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.1-p378 &gt; <command>exit</command></screen></para>
        </listitem>

        <listitem>
          <para>Im zweiten Schritt fügen wir in der Model-Datei
          <filename>app/models/flight_schedule.rb</filename> die
          <code>belongs_to</code> Option ein:<programlisting>class FlightSchedule &lt; ActiveRecord::Base
  belongs_to :flight
end</programlisting></para>

          <para>Damit bekommen wir automagisch die Methode
          <methodname>flight</methodname> in der Klasse
          <classname>FlightSchedule</classname> angeboten und können zu einem
          <classname>FlightSchedule</classname> den
          <classname>Flight</classname> anzeigen:<screen>stefan@swmbp 0 1.9.1-p378 railsair$ <command>rails console</command>
Loading development environment (Rails 3.0.0.beta4)
ruby-1.9.1-p378 &gt; <command>FlightSchedule.first</command>
 =&gt; #&lt;FlightSchedule id: 1, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:03", updated_at: "2010-06-17 16:41:03"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.first.flight</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 16:24:07", updated_at: "2010-06-17 16:24:07"&gt; 
ruby-1.9.1-p378 &gt; <command>exit</command></screen></para>
        </listitem>
      </orderedlist> </para>

    <para>So einfach ist es eine 1:n Verknüpfung zu erstellen? Ja! Ist
    ActiveRecord nicht toll?! :-)</para>

    <para>Sie müssen natürlich nicht immer ein <code>has_many</code> mit einem
    <code>belongs_to</code> verknüpfen. Wenn Sie nur eine Seite benötigen, so
    können Sie auf die jeweils andere verzichten. In der Regel ist es aber
    meistens praktisch in beide Richtungen agieren zu können.</para>

    <section>
      <title>Optionen</title>

      <para>Ich will an dieser Stelle nicht auf alle möglichen Optionen
      eingehen. Aber ein paar sind so praktisch und werden von mir in jedem
      Projekt benutzt, das ich sie hier vorstellen möchte. Für alle anderen
      verweise ich auf die Ruby on Rails Doku die Sie im Internet unter <uri
      xlink:href="http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
      bzw. auf Ihrem System mit <command>ri
      ActiveRecord::Associations::ClassMethods</command> auf der Shell abrufen
      können.</para>

      <section>
        <title>has_many</title>

        <para>Die meiner Meinung nach wichtigsten Optionen für
        <code>has_many</code>:<itemizedlist>
            <listitem>
              <para><code>:order =&gt; ''</code></para>

              <para>In unserem Flugplan wäre es schon sehr praktisch, wenn die
              Flüge nach den Flugzeiten sortiert wären. Dies geht mit
              folgender Einstellung:<programlisting>has_many :flight_schedules, :order =&gt; 'departure'
</programlisting></para>

              <para>Und falls es einmal umgekehrt sortiert werden
              sollte:<programlisting>has_many :flight_schedules, :order =&gt; 'departure DESC'
</programlisting></para>
            </listitem>

            <listitem>
              <para><code>:dependent =&gt; :destroy</code></para>

              <para>Wird ein Eintrag in der Flight Tabelle gelöscht, dann ist
              es ja nur sinnvoll, das auch alle dazu gehörigen
              Flugplan-Einträge in FlightSchedule gelöscht werden. Das kann
              mit <code>:dependent =&gt; :destroy</code> realisiert
              werden:<programlisting>has_many :flight_schedules, :dependent =&gt; :destroy
</programlisting></para>

              <para>Im folgenden Beispiel löschen wir einen
              <classname>Flight</classname> und dadurch werden alle 1:n
              <classname>FlightSchedule</classname> Einträge ebenfalls
              gelöscht:<screen>ruby-1.9.1-p378 &gt; <command>Flight.first</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 16:24:07", updated_at: "2010-06-17 16:24:07"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first.flight_schedules.first</command>
 =&gt; #&lt;FlightSchedule id: 1, flight_id: 1, departure: "2000-01-01 09:00:00", arrival: "2000-01-01 10:05:00", created_at: "2010-06-17 16:41:03", updated_at: "2010-06-17 16:41:03"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.first.destroy</command>
 =&gt; #&lt;Flight id: 1, flight_number: "RA 001", departure_airport: "FRA", destination_airport: "MUC", created_at: "2010-06-17 16:24:07", updated_at: "2010-06-17 16:24:07"&gt; 
ruby-1.9.1-p378 &gt; <command>FlightSchedule.exists?(1)</command>
 =&gt; false 
ruby-1.9.1-p378 &gt;</screen></para>

              <important>
                <para>Bitte denken Sie immer an den Unterschied zwischen den
                Methoden <methodname>destroy</methodname> (siehe <xref
                linkend="activerecord_destroy" />) und
                <methodname>delete</methodname> (siehe <xref
                linkend="activerecord_delete" />). Diese Abhängigkeit
                funktioniert nur mit der <methodname>destroy</methodname>
                Methode.</para>
              </important>
            </listitem>

            <listitem>
              <para><code>:readonly =&gt; :true</code></para>

              <para>Manchmal braucht man keinen Schreibzugriff auf die
              Verknüpfung. Dann kann man auch direkt mit
              <code>:readonly</code> arbeiten.<programlisting>has_many :flight_schedules, :readonly =&gt; :true</programlisting></para>
            </listitem>
          </itemizedlist></para>

        <para>Es gibt natürlich noch eine Menge anderer Optionen. Diese können
        Sie sich mit <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command> auf der
        Shell ausgeben lassen.</para>
      </section>

      <section>
        <title>belongs_to</title>

        <para>Die meiner Meinung nach wichtigeste Option für
        <methodname>belongs_to</methodname> ist:<itemizedlist>
            <listitem>
              <para><code>:touch =&gt; :true</code></para>

              <para>Damit wird bei einer Veränderung des
              <classname>FlightSchedules</classname> automatisch das Feld
              <varname>updated_at</varname> der Primary Datenbank
              <classname>Flight</classname> auf die aktuelle Uhrzeit gesetzt.
              </para>
            </listitem>
          </itemizedlist></para>

        <para>Auch hier sollten Sie einmal auf die Liste aller möglichen
        Optionen einen kurzen Blick werfen. Dazu in der Shell <command>ri
        ActiveRecord::Associations::ClassMethods#belongs_to</command>
        aufrufen.</para>
      </section>
    </section>

    <section>
      <title>Methoden</title>

      <section xml:id="has_many_build">
        <title xml:id="has_many_build.title">build</title>

        <para>Die Methode <methodname>build</methodname> erstellt eine neue
        Kind-Instanz die automatisch die Eltern-ID enthält:<screen>ruby-1.9.1-p378 &gt; <command>Flight.last</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>fra_txl = Flight.last</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>neuer_flugplan = fra_txl.flight_schedules.build(:departure =&gt; Time.now + 1.year, :arrival =&gt; Time.now + 1.year + 1.hour)</command>
 =&gt; #&lt;FlightSchedule id: nil, flight_id: 5, departure: "2011-06-17 21:05:43", arrival: "2011-06-17 22:05:43", created_at: nil, updated_at: nil&gt; 
ruby-1.9.1-p378 &gt;
</screen></para>

        <para>Jetzt muss <varname>neuer_flugplan</varname> nur noch mit
        <methodname>save</methodname> abgespeichert werden:<screen>ruby-1.9.1-p378 &gt; <command>neuer_flugplan.save</command>
 =&gt; true 
ruby-1.9.1-p378 &gt;</screen></para>

        <para>Der Vorteil liegt in der Sicherheit keine falsche ID zu nehmen
        und oft im übersichtlicheren Code.</para>
      </section>

      <section xml:id="has_many_create">
        <title xml:id="has_many_create.title">create</title>

        <para>Die Methode create arbeitet wie <methodname>build</methodname>,
        nur das danach quasi automatisch direkt ein
        <methodname>save</methodname> aufgerufen wird. Beispiel:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(5)</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 1 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.create(:departure =&gt; Time.now + 1.month, :arrival =&gt; Time.now + 1.month + 1.hour)</command>
 =&gt; #&lt;FlightSchedule id: 5, flight_id: 5, departure: "2010-07-17 21:14:08", arrival: "2010-07-17 22:14:08", created_at: "2010-06-17 19:14:08", updated_at: "2010-06-17 19:14:08"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 2 
ruby-1.9.1-p378 &gt;</screen></para>

        <important>
          <para>Bitte achten Sie bei der Verwendung von
          <methodname>create</methodname> immer auch auf die von Ihnen
          verwendeten Validierungs-Regeln (siehe <xref
          linkend="model_validierungen" />). Denn falls die Validierung einen
          Fehler ausgibt, dann der der neue Datensatz natürlich nicht
          gespeichert. Da ist manchmal der kleine Umweg über build
          einfacher.</para>
        </important>
      </section>

      <section xml:id="has_many_delete" xml:lang="">
        <title xml:id="has_many_delete.title">delete und destroy</title>

        <para>Mit den Methoden <methodname>destroy</methodname>,
        <methodname>destroy_all</methodname>, <methodname>delete</methodname>
        und <methodname>delete_all</methodname> kann man wie in <xref
        linkend="datensatz-loeschen" /> beschrieben Datensätze löschen. Im
        Kontext von <methodname>has_many</methodname> bedeutet das, das man
        die zu einem <classname>Flight</classname> gelisteten
        <classname>FlightSchedule</classname>-Datensätze in einem Streich
        löschen kann:<screen>ruby-1.9.1-p378 &gt; <command>Flight.find(5)</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 4 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.destroy_all</command>
 =&gt; {} 
ruby-1.9.1-p378 &gt; <command>Flight.find(5).flight_schedules.count</command>
 =&gt; 0 
ruby-1.9.1-p378 &gt; <command>Flight.find(5)</command>
 =&gt; #&lt;Flight id: 5, flight_number: "RA 005", departure_airport: "FRA", destination_airport: "TXL", created_at: "2010-06-17 16:24:15", updated_at: "2010-06-17 16:24:15"&gt; 
ruby-1.9.1-p378 &gt;</screen></para>
      </section>
    </section>

    <section>
      <title>Umsetzung im Webinterface</title>

      <para>Ziel soll es sein, dem User des Webinterfaces nicht nur die beiden
      bestehenden <uri
      xlink:href="http://0.0.0.0:3000/flights">http://0.0.0.0:3000/flights</uri>
      und <uri
      xlink:href="http://0.0.0.0:3000/flight_schedules">http://0.0.0.0:3000/flight_schedules</uri>
      Übersichten zu geben, sondern bei der Index-Übersicht von
      <varname>flights</varname> zu jeder Flugnummer auch die nächsten drei
      Flugtermine anzuzeigen. Bei der Einzelansicht zu einem
      <classname>Flight</classname> (show-View) sollen alle Flugtermine zu
      einer Flugnummer angezeigt werden.</para>
    </section>
  </section>
</chapter>
