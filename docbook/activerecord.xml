<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="activerecord_chapter"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="activerecord_chapter.title">ActiveRecord</title>

  <info>
    <collab>
      <person>
        <personname><firstname>Philipp</firstname><surname>Kempgen</surname></personname>
      </person>
    </collab>
  </info>

  <indexterm>
    <primary>ActiveRecord</primary>
  </indexterm>

  <indexterm>
    <primary>Active Record (Muster)</primary>
  </indexterm>

  <para><literal>ActiveRecord</literal> ist eine Abstaktionsschicht, die es
  uns einen sehr leichten Zugang zu einer <indexterm>
      <primary>SQL-Datenbank</primary>

      <see>Datenbank</see>
    </indexterm><indexterm>
      <primary>Datenbank</primary>

      <secondary>relational (SQL)</secondary>
    </indexterm><indexterm>
      <primary>relationale Datenbank</primary>

      <see>Datenbank</see>
    </indexterm>SQL-Datenbank zur Verfügung stellt.
  <literal>ActiveRecord</literal> implementiert das Architektur-Muster
  <foreignphrase xml:lang="en">Active Record</foreignphrase> <footnote>
      <para>siehe <uri
      xlink:href="http://en.wikipedia.org/wiki/Active_record_pattern">http://en.wikipedia.org/wiki/Active_record_pattern</uri></para>
    </footnote>.</para>

  <note>
    <para>Das nennt sich dann <indexterm>
        <primary>Objektrelationale Abbildung</primary>

        <see>ORM</see>
      </indexterm>objektrelationale Abbildung (<indexterm>
        <primary>Object-relational mapping</primary>

        <see>ORM</see>
      </indexterm><foreignphrase xml:lang="en">Object-relational
    mapping</foreignphrase>, <indexterm>
        <primary>ORM (Object-relational mapping)</primary>
      </indexterm><foreignphrase xml:lang="en">ORM</foreignphrase>). Ich
    empfinde das als zu trocken und langweilig, aber falls Sie heute Abend
    nicht einschlafen können, werfen Sie doch mal einen Blick auf <uri
    xlink:href="http://de.wikipedia.org/wiki/Objektrelationale_Abbildung">http://de.wikipedia.org/wiki/Objektrelationale_Abbildung</uri>.</para>
  </note>

  <para>Einer der Erfolgsrezepte von Rails ist sicherlich die Benutzung von
  <literal>ActiveRecord</literal>. Die Programmierung und Benutzung
  <quote>fühlt sich gut an</quote> und es ist viel weniger fehleranfällig als
  pures SQL. Bei der Arbeit mit diesem Kapitel hilft SQL-Wissen, aber es wird
  nicht vorausgesetzt, und es ist auch für die Arbeit mit
  <literal>ActiveRecord</literal> nicht notwendig.</para>

  <remark>FIXME: Wird irgendwo gesagt daß ActiveRecord der Default-ORM von
  Rails ist?</remark>

  <section xml:id="activerecord-howto-zum-kapitel">
    <title>Howto zum Kapitel</title>

    <para>Dieses Kapitel ist in sich selbst geschlossen. Allerdings wird das
    Wissen aus <xref linkend="ruby-grundlagen" /> und <xref
    linkend="erste_schritte_mit_rails" /> vorausgesetzt. Ohne dieses
    Grundwissen werden Sie keinen Spaß an diesem Kapitel haben!</para>

    <para>Der Rails-Anfänger sollte das Kapitel einmal von oben bis unten
    durcharbeiten. Das heißt konkret: Alle Schritte in der eigenen
    <foreignphrase xml:lang="en">Console</foreignphrase> (siehe <xref
    linkend="die_console" />) mit ausprobieren und ruhig selber links und
    rechts mal ein wenig experimentieren. Bitte nehmen Sie sich Zeit. Es ist
    ein wichtiges Kapitel!</para>

    <para><note>
        <para>Es geht in diesem Kapitel um ActiveRecord. Deshalb: Um die
        Beispiele so übersichtlich wie möglich zu halten werde ich deshalb
        keine Tests (siehe <xref linkend="tests" />) einbauen.</para>
      </note></para>

    <section xml:id="activerecord-keine-lust-auf-sql">
      <title>Keine Lust auf SQL?</title>

      <para>Hin und wieder werde ich den durch eine ActiveRecord-Methode
      erzeugten SQL-Code in der Log-Datei nachschlagen. Wenn Sie sich nicht
      für SQL interessieren: Einfach überlesen. Das Schöne an ActiveRecord ist
      ja dass man sich darum keinen Kopf machen muss. Für alle anderen dient
      es zum besseren Verständnis der im Hintergrund laufenden
      Optimierungen.</para>

      <tip>
        <para>Wenn Sie sich für diese Optimierungen interessieren, so empfehle
        ich Ihnen bei diesen Übungen und auch später bei der Entwicklung immer
        noch ein zweites Terminal mit einem <command>tail -f
        log/development.log</command> laufen zu lassen. Dort sehen Sie dann
        immer, was gerade auf der Datenbank-Ebene abläuft.</para>
      </tip>
    </section>

    <section xml:id="activerecord_blut_lecken">
      <title xml:id="activerecord_blut_lecken.title">Blut lecken</title>

      <para>Dieses Buch ist ein Einsteigerbuch. Entsprechend werden hier die
      Grundlagen für die Benutzung von ActiveRecord besprochen. Es wäre ein
      leichtes ein doppelt so dickes Buch nur über ActiveRecord zu schreiben.
      Lassen Sie sich von diesem Kapitel anfixen und forschen Sie in den
      Dokumentationen zu Rails weiter (siehe <xref
      linkend="weiterfuehrende_doku" />).</para>

      <tip>
        <para>Einer meiner besten Freunde bei der Entwicklung von
        Rails-Applikationen ist die Tabulator-Taste. Wann immer Sie eine
        Methode für ein bestimmte Problem suchen, dann stellen Sie es in der
        Rails-Console nach, und drücken Sie zweimal auf die Tabulatortaste um
        alle verfügbaren Methoden für die entsprechende Klasse aufzulisten.
        Die Namen der Methoden sind meistens selbsterklärend.</para>
      </tip>
    </section>
  </section>

  <section xml:id="activerecord_datenbank_anlegen">
    <title
    xml:id="activerecord_datenbank_anlegen.title">Datenbank/<quote>Model</quote>
    anlegen</title>

    <indexterm>
      <primary>Datenbank</primary>
    </indexterm>

    <indexterm>
      <primary>Model</primary>
    </indexterm>

    <note>
      <indexterm>
        <primary>Model&#8211;View&#8211;Controller</primary>

        <see>MVC</see>
      </indexterm>

      <indexterm>
        <primary>MVC</primary>
      </indexterm>

      <para><foreignphrase xml:lang="en">Model</foreignphrase> bezieht sich
      hier auf das Daten-Modell aus <foreignphrase
      xml:lang="en">Model&#8211;View&#8211;Controller</foreignphrase>
      (<acronym>MVC</acronym>).</para>
    </note>

    <para>Auch wenn ich mich nicht für Musik interessiere, so sind Musikalben
    für ein Datenbank-Beispiel sehr gut geeignet. Die benutzen Daten entnehme
    ich dabei der Wikipedia-Seite <uri
    xlink:href="http://en.wikipedia.org/wiki/The_500_Greatest_Albums_of_All_Time">http://en.wikipedia.org/wiki/The_500_Greatest_Albums_of_All_Time</uri>.</para>

    <para>Legen wir erst mal ein neues Rails-Projekt an:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new jukebox</command>
      create  
      create  README
      create  Rakefile
      <replaceable>[...]</replaceable>
      create  vendor/plugins
      create  vendor/plugins/.gitkeep

stefan@swmbp 0 1.9.2-p0 ~$ <command>cd jukebox</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
Using abstract (1.0.0) 
<replaceable>[...]</replaceable>
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Schauen wir uns mal die Hilfeseite von <command>rails generate
    model</command> an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails generate model</command></screen><screen>Usage:
  rails generate model NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME  # Orm to be invoked
                  # Default: active_record

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Create rails files for model generator.</screen></para>

    <remark>FIXME: Vorher mal kurz sagen was ein Model ist.</remark>

    <remark>FIXME: Wo bekommt man eine Liste der in ActiveRecord erlaubten
    types (integer, string, ...)? Geht z.B. statt integer auch int als
    Abkürzung?</remark>

    <para>Das klingt alles halbwegs logisch. Legen wir also das <foreignphrase
    xml:lang="en">Model</foreignphrase> <literal>album</literal> an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails generate model album position:integer name:string release_year:integer</command>
      invoke  active_record
      create    db/migrate/20100902194019_create_albums.rb
      create    app/models/album.rb
      invoke    test_unit
      create      test/unit/album_test.rb
      create      test/fixtures/albums.yml

stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <indexterm>
      <primary>Migrations</primary>
    </indexterm>

    <indexterm>
      <primary>Datenbank</primary>

      <secondary>Migrations</secondary>

      <see>Migrations</see>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Migrations</secondary>

      <see>Migrations</see>
    </indexterm>

    <para>Rails hat eine Datenbank-Migrations-Datei mit dem Namen
    <filename>db/migrate/20100902194019_create_albums.rb</filename> angelegt.
    In dieser Datei wird eine Klasse <classname>CreateAlbums</classname> als
    Tochter von <classname>ActiveRecord::Migration</classname> definiert. Die
    Methoden <methodname>self.up</methodname> und
    <methodname>self.down</methodname> werden benutzt, um eine Migration oder
    den dazu gehörigen Roll-Back zu definieren.<remark>FIXME:
    Modules/Namespaces sind noch nicht bekannt.</remark><remark>FIXME: Ich
    glaube die Methoden self.up/self.down werden üblicherweise nur up/down
    genannt, sind aber eben keine Instanz-Methoden (instance methods) sondern
    Klassen-Methoden (class methods) - oder umgekehrt. Siehe Remark dazu an
    anderer Stelle weiter vorne im Buch.</remark><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>cat db/migrate/20100902194019_create_albums.rb</command></screen><programlisting>class CreateAlbums &lt; ActiveRecord::Migration
  def self.up
    create_table :albums do |t|
      t.integer :position
      t.string :name
      t.integer :release_year

      t.timestamps
    end
  end

  def self.down
    drop_table :albums
  end
end</programlisting></para>

    <para>Mit <command>rake db:migrate</command> können wir die Migrationen
    ausführen, also die entsprechende Datenbank-Tabelle anlegen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake db:migrate</command>
(in /Users/stefan/jukebox)
==  CreateAlbums: migrating ===================================================
-- create_table(:albums)
   -&gt; 0.0015s
==  CreateAlbums: migrated (0.0016s) ==========================================

stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Weitere Details zu Migrationen werden wir später in <xref
    linkend="activerecord_migration" /> kennenlernen.</para>

    <para>Schauen wir mal in die Datei
    <filename>app/models/album.rb</filename>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>cat app/models/album.rb</command></screen><programlisting>class Album &lt; ActiveRecord::Base
end</programlisting></para>

    <para>hmmm… die Klasse <classname>Album</classname> ist also eine Tochter
    von <classname>ActiveRecord::Base</classname>. Logisch, da wir ja in
    diesem Kapitel ActiveRecord besprechen. ;-)</para>

    <para>Die eingebaute Hilfeseite zu
    <classname>ActiveRecord::Base</classname> ist etwas länger:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>ri -T ActiveRecord::Base | wc -l</command>
     454
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Deshalb werde ich sie hier nicht abbilden und überlasse es Ihrer
    Neugierde, mal <command>ri ActiveRecord</command>
    aufzurufen.<remark>FIXME: Was macht das -T bei ri, und warum soll der
    Leser das nicht benutzen obwohl es im Beispiel steht?</remark></para>

    <section xml:base="activerecord-types">
      <title xml:id="activerecord-types.title">Mögliche Datentypen in
      ActiveRecord</title>

      <para>ActiveRecord ist ein <foreignphrase
      xml:lang="en">Layer</foreignphrase> (Schicht, Ebene) zwischen
      Ruby<remark>FIXME: Ruby oder Rails? Geht ActiveRecord auch ohne
      Rails?</remark> und verschiedenen relationalen Datenbanken.</para>

      <para>Leider haben SQL-Datenbanken unterschiedliche Sichtweisen auf die
      Definition von Spalten und deren Inhalt. Darüber müssen wir uns keine
      Sorgen machen, da ActiveRecord dieses Problem für uns transparent
      löst.<itemizedlist>
          <listitem>
            <para>Vorteil:</para>

            <para>Wir können das DBMS hinter einer Rails-Applikation
            austauschen ohne dass dafür der Programmcode angefasst werden
            muss.</para>
          </listitem>

          <listitem>
            <para>Nachteil:</para>

            <para>Wir können nicht alle Besonderheiten des jeweiligen DBMS
            benutzen. Wir müssen quasi einen kleinsten gemeinsamen Nenner
            benutzen.</para>
          </listitem>
        </itemizedlist></para>

      <para>Um ein <foreignphrase xml:lang="en">Model</foreignphrase> zu
      generieren können Sie folgende Feldtypen benutzen:<itemizedlist>
          <listitem>
            <indexterm>
              <primary>binary</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>binary</literal></para>

            <para>Das ist im klassischen Sinn ein BLOB (<foreignphrase
            xml:lang="en">Binary Large Object</foreignphrase>)<remark>FIXME:
            Sicher? Oder bezieht sich da ggf. eine Länge auf Bytes statt auf
            Zeichen, also im Unterschied zu string/text?</remark>. Noch nie
            gehört? Dann werden sie es wahrscheinlich nicht brauchen.</para>

            <para>Siehe auch <uri
            xlink:href="http://de.wikipedia.org/wiki/Binary_Large_Object">http://de.wikipedia.org/wiki/Binary_Large_Object</uri></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>boolean</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>boolean</literal><remark>FIXME: Kann man das als
            bool abkürzen?</remark></para>

            <para>Ein Bool'scher Wert. Kann <literal>true</literal> (wahr)
            oder <literal>false</literal> (falsch) sein.</para>

            <para>Siehe auch <uri
            xlink:href="http://de.wikipedia.org/wiki/Boolesche_Variable">http://de.wikipedia.org/wiki/Boolesche_Variable</uri></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>date</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>date</literal></para>

            <para>Hier kann ein Datum abgespeichert werden.<remark>FIXME:
            Genauer. Format?</remark></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>datetime</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>datetime</literal></para>

            <para>Hier kann ein Datum inklusive Uhrzeit abgespeichert
            werden.<remark>FIXME: Genauer. Format?</remark></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>float</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>float</literal></para>

            <para>Zum Speichern einer Gleitkommazahl.<remark>FIXME: Genauer.
            Genauigkeit?</remark></para>

            <para>Siehe auch <uri
            xlink:href="http://de.wikipedia.org/wiki/Gleitkommazahl">http://de.wikipedia.org/wiki/Gleitkommazahl</uri></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>integer</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>integer</literal><remark>FIXME: Kann man das als
            int abkürzen?</remark></para>

            <para>Zum Speichern einer Ganzzahl.<remark>FIXME: Genauer.
            Min./max.?</remark></para>

            <para>Siehe auch <uri
            xlink:href="http://de.wikipedia.org/wiki/Integer_(Datentyp)">http://de.wikipedia.org/wiki/Integer_(Datentyp)</uri></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>primary_key</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>primary_key</literal></para>

            <remark>FIXME: Ist das ein eigenständiger Feldtyp? Im DBMS können
            ja z.B. auch Strings Primärschlüssel sein, d.h. der Feldtyp ist
            unabhängig vom Schlüssel-Typ.</remark>

            <para>Das ist ein Integer (Ganzzahl), der von der Datenbank
            automatisch bei jedem neuen Eintrag um 1 hochgezählt
            wird<remark>FIXME: Ist ein primary_key in ActiveRecord immer ein
            *auto_increment* primary_key in MySQL?</remark>. Dieser Feldtyp
            wird häufig als Schlüssel für die Verknüpfung von verschiedenen
            Datenbank-Tabellen bzw. <foreignphrase
            xml:lang="en">Models</foreignphrase> genommen.</para>

            <para>Siehe auch <uri
            xlink:href="http://de.wikipedia.org/wiki/Schl%C3%BCssel_%28Datenbank%29">http://de.wikipedia.org/wiki/Schlüssel_(Datenbank)</uri></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>string</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>string</literal><remark>FIXME: Kann man das als str
            abkürzen?</remark></para>

            <para>Ein String. Also eine beliebige Zeichenkette, bis max.
            2<superscript>8</superscript>-1 (= 255) Zeichen.<remark>255 oder
            doch 256? Zeichen oder Bytes?</remark></para>

            <para>Siehe auch <uri
            xlink:href="http://de.wikipedia.org/wiki/Zeichenkette">http://de.wikipedia.org/wiki/Zeichenkette</uri></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>text</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>text</literal></para>

            <para>Auch ein String. Allerdings ein gutes Stück größer. Hier
            können per Default bis zu 2<superscript>16</superscript> (= 65536)
            Zeichen gespeichert werden.</para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>time</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>time</literal></para>

            <para>Eine Uhrzeit.<remark>FIXME: Genauer. Format?</remark></para>
          </listitem>

          <listitem>
            <indexterm>
              <primary>timestamp</primary>

              <secondary>ActiveRecord</secondary>
            </indexterm>

            <para><literal>timestamp</literal></para>

            <para>Eine Uhrzeit mit Datum<remark>FIXME: Genauer.</remark>, die
            von der Datenbank automatisch befüllt wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Wir gehen in <xref linkend="migration" /> auf die einzelnen
      Datentypen noch näher ein und sprechen über verfügbare Optionen.</para>

      <remark>FIXME: Wäre cool hier eine Tabelle zu haben in der man sieht wie
      ActiveRecord-Datentypen auf MySQL-, PostgreSQL und SQLite-Datentypen
      gemappt werden.</remark>

      <remark>FIXME: Wie kann man einen kombinierten Primärschlüssel oder
      Sekundärschlüssel (Indizes, Keys) anlegen? Oder kommt das noch?</remark>

      <remark>FIXME: Was ist mit NULL/NOT NULL?</remark>

      <remark>FIXME: Können Spalten Default-Werte haben?</remark>
    </section>

    <section xml:id="activerecord_namenskonvention">
      <title xml:id="activerecord_namenskonvention.title">Namenskonventionen
      (CallRecord vs. call_record vs. call_records)</title>

      <indexterm>
        <primary>Inflections</primary>

        <secondary>ActiveRecord</secondary>

        <see>Inflections</see>
      </indexterm>

      <indexterm>
        <primary>Inflections</primary>

        <secondary>ActiveSupport</secondary>
      </indexterm>

      <remark>FIXME: Worum geht's hier überhaupt? Einstieg irgendwie
      unklar.</remark>

      <para>Für den Rails-Anfänger ist es oft schwer zu
      <quote>erfühlen</quote>, wann man z.B. <literal>CallRecord</literal>
      oder <literal>call_record</literal> benutzt. Außerdem ist nicht immer
      klar <quote>erfühlbar</quote>, wann ein Begriff im Plural und wann im
      Singular benutzt wird. So viel vorweg: Es ist alles logisch und man
      bekommt den Dreh auch recht schnell raus. Wichtig ist nur immer bei
      englischen Wörtern zu bleiben (siehe <xref
      linkend="warum_english" />).</para>

      <para>An dieser Stelle wollte ich ursprünglich in aller Länge und Breite
      über die Namenskonventionen philosophieren. Dann habe ich mir gedacht:
      <quote>Mein Gott, die Leser wollen schnell weiterkommen und nicht hier
      Ewigkeiten mit Theorie verbringen.</quote> Deshalb stelle ich Ihnen hier
      die Methoden vor, mit denen Sie selbst die Schreibweisen in der
      Rails-<foreignphrase xml:lang="en">Console</foreignphrase> rausfinden
      können:<remark>Wieso befinden wir uns hier jetzt in einem
      "phonebook"-Projekt?</remark><screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>"album".classify</command>
 =&gt; "Album" 
ruby-1.9.2-p0 &gt; <command>"album".tableize</command>
 =&gt; "albums" 
ruby-1.9.2-p0 &gt; <command>"album".foreign_key</command>
 =&gt; "album_id" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Wenn Sie zusammengesetzte Begriffe verwenden funktioniert das
      genauso:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>"call_record".classify</command>
 =&gt; "CallRecord" 
ruby-1.9.2-p0 &gt; <command>"call_record".tableize</command>
 =&gt; "call_records" 
ruby-1.9.2-p0 &gt; <command>"call_record".foreign_key</command>
 =&gt; "call_record_id" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <remark>FIXME: Haben "album" und "call_record" irgendwas mit dem
      jukebox-Projekt von oben zu tun oder sind das hier einfach nur fikitive
      hmm Dinger? Und was sind das überhaupt für Dinger/Objektnamen? Woher
      weiß man das man die im Singular eingeben soll?</remark>

      <para>Wenn Sie sich bei einer Klasse<remark>FIXME: Wieso jetzt Klasse?
      Bei welcher Klasse?</remark> nicht sicher sind, können Sie auch mit der
      Klasse und der Methode <methodname>name</methodname> arbeiten. Ich zeige
      Ihnen das mal anhand der Klasse <classname>Person</classname> (achten
      Sie einmal auf den Plural <literal>people</literal>):<remark>FIXME:
      Wieso ist das toll? Wäre das nicht einfacher wenn das den Plural *immer*
      mit s bilden würde. person =&gt; persons, fish =&gt; fishs, sheep =&gt;
      sheeps, child =&gt; childs, foot =&gt; foots. Bräuchte keine langen
      Erklärungen und wäre vermutlich auch noch schneller in der
      Ausführung.</remark><screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.name.tableize</command>
 =&gt; "people" 
ruby-1.9.2-p0 &gt; <command>Person.name.foreign_key</command>
 =&gt; "person_id" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen><remark>FIXME: Wäre gut oben erst
      mal zu sehen was der Wert von Person.name ist. Ich vermute
      "Person".(?)</remark></para>

      <para>Auf <uri
      xlink:href="http://rails.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html"
      xml:lang="en">http://rails.rubyonrails.org/classes/ActiveSupport/CoreExtensions/String/Inflections.html</uri>
      finden Sie eine komplette Liste der entsprechenden Methoden. Ich
      empfehle Ihnen aber jetzt erst mal sich in der Strömung treiben zu
      lassen. Falls Sie mal nicht sicher sind, können Sie mit den hier
      gezeigten Methoden die richtige Schreibweise rausfinden.<remark>FIXME:
      Schreibweise wofür? Also wann braucht man die verschiedenen
      Varianten?</remark></para>
    </section>

    <section>
      <title>Datenbank-Konfiguration</title>

      <indexterm>
        <primary>database.yml</primary>
      </indexterm>

      <para>Welche Datenbank wird per Default benutzt? Schauen wir mal in die
      Konfigurationsdatei für die Datenbank
      (<filename>config/database.yml</filename>):<remark>FIXME: Wieso/wann
      sind wir jetzt vom phonebook-Projekt wieder zum jukebox-Projekt
      gesprungen?</remark><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>cat config/database.yml</command></screen><programlisting># SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000</programlisting></para>

      <para>Da wir im <literal>development</literal>-Modus arbeiten hat Rails
      beim <command>rake db:migrate</command> eine neue SQLite3-Datenbank
      <filename>db/development.sqlite3</filename> angelegt und dort alle Daten
      gespeichert.</para>

      <para>Schauen wir mal mit dem Kommandozeilen-Client
      <literal>sqlite3</literal> rein:</para>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>sqlite3 db/development.sqlite3 </command>
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"

sqlite&gt; <command>.tables</command>
albums             schema_migrations

sqlite&gt; <command>.schema albums</command>
CREATE TABLE "albums" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "position" integer, "name" varchar(255), "release_year" integer, "created_at" datetime, "updated_at" datetime);

sqlite&gt; <command>.exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Tatsächlich, da ist eine Datenbank-Tabelle mit dem Namen
      <literal>albums</literal>. Diese wird von ActiveRecord benutzt.</para>
    </section>
  </section>

  <section xml:id="activerecord_datensaetze_hinzufuegen">
    <title xml:id="activerecord_datensaetze_hinzufuegen.title">Datensätze
    hinzufügen</title>

    <para>Eigentlich würde ich Ihnen ja gerne erst zeigen wie man sich
    Datensätze anzeigen lassen kann, aber da haben wir natürlich ein
    Henne-Ei-Problem. Deshalb jetzt erst mal das Anlegen von neuen Datensätzen
    mit ActiveRecord.</para>

    <section xml:id="activerecord_create">
      <title xml:id="activerecord_create.title">create</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>.create()</tertiary>
      </indexterm>

      <para>Die am häufigten zum Anlegen von neuen Datensätzen benutzte
      Methode ist <methodname>create</methodname>. Wie immer gibt es dazu eine
      eigene Hilfeseite im System:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>ri -T ActiveRecord::Base.create</command></screen><screen>ActiveRecord::Base.create

(from gem activerecord-3.0.0)
------------------------------------------------------------------------------
  create(attributes = nil) { |object| ... }

------------------------------------------------------------------------------

Creates an object (or multiple objects) and saves it to the database, if
validations pass. The resulting object is returned whether the object was
saved successfully to the database or not.

The attributes parameter can be either be a Hash or an Array of Hashes.
 These Hashes describe the attributes on the objects that are to be created.

Examples
  # Create a single new object
  User.create(:first_name =&gt; 'Jamie')

  # Create an Array of new objects
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])

  # Create a single object and pass it into a block to set other attributes.
  User.create(:first_name =&gt; 'Jamie') do |u|
    u.is_admin = false
  end

  # Creating an Array of new objects using a block, where the block is executed for each object:
  User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |u|
    u.is_admin = false
  end</screen><remark>FIXME: Wird die Ausgabe eigentlich anders umgebrochen
      wenn das Terminal-Fenster kleiner ist? Oder ist sichergestellt daß im
      Buch/Web 80 Monospace-Zeichen ohne Umbruch in eine Zeile
      passen?</remark></para>

      <para>Super, direkt mit Beispielen! Was will man mehr? Versuchen wir mal
      so in der <foreignphrase xml:lang="en">Console</foreignphrase> die
      ersten 3 Alben für die Jukebox anzulegen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.create(:position =&gt; 1, :name =&gt; "Sgt. Pepper's Lonely Hearts Club Band", :release_year =&gt; 1967)</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:position =&gt; 2, :name =&gt; "Pet Sounds", :release_year =&gt; 1966)</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.create(:position =&gt; 3, :name =&gt; "Revolver", :release_year =&gt; 1966)</command>
 =&gt; #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Sieht ja ganz gut aus, aber sind die Daten auch wirklich
      gespeichert worden? Schauen wir sicherheitshalber mal mit dem
      Kommandozeilen-Client <literal>sqlite3</literal> rein:</para>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>sqlite3 db/development.sqlite3 </command>
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"

sqlite&gt; <command>.tables</command>
albums             schema_migrations

sqlite&gt; <command>SELECT * FROM albums;</command>
1|1|Sgt. Pepper's Lonely Hearts Club Band|1967|2010-09-02 19:48:42.744962|2010-09-02 19:48:42.744962
2|2|Pet Sounds|1966|2010-09-02 19:49:07.513328|2010-09-02 19:49:07.513328
3|3|Revolver|1966|2010-09-02 19:49:27.511745|2010-09-02 19:49:27.511745

sqlite&gt; <command>.exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Tatsächlich, da ist eine Datenbank mit dem Namen
      <literal>albums</literal>, und in der sind die von uns eben erstellten
      Einträge. Die dafür von ActiveRecord erstellten SQL-Befehle können Sie
      sich in der Datei <filename>log/development.log</filename>
      anschauen:<screen>  SQL (0.3ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-10-09 11:56:42.140062', 'Sgt. Pepper''s Lonely Hearts Club Band', 1, 1967, '2010-10-09 11:56:42.140062')
  SQL (0.7ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-10-09 11:56:47.647848', 'Pet Sounds', 2, 1966, '2010-10-09 11:56:47.647848')
  SQL (0.3ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-10-09 11:56:52.232803', 'Revolver', 3, 1966, '2010-10-09 11:56:52.232803')</screen></para>
    </section>

    <section xml:id="activerecord_new">
      <title xml:id="activerecord_new.title">new</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>.new()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>.save()</tertiary>
      </indexterm>

      <para>Neben <methodname>create</methodname> gibt es auch
      <methodname>new</methodname>. Allerdings muss ein mit
      <methodname>new</methodname> erzeugtes Objekt extra mit
      <methodname>save</methodname> gespeichert werden (was Vor- und Nachteile
      hat):<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>highway61 = Album.new</command>
 =&gt; #&lt;Album id: nil, position: nil, name: nil, release_year: nil, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>highway61.position = 4</command>
 =&gt; 4 
ruby-1.9.2-p0 &gt; <command>highway61.name = 'Highway 61 Revisited'</command>
 =&gt; "Highway 61 Revisited" 
ruby-1.9.2-p0 &gt; <command>highway61.release_year = 1965</command>
 =&gt; 1965 
ruby-1.9.2-p0 &gt; <command>highway61</command>
 =&gt; #&lt;Album id: nil, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>highway61.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>highway61</command>
 =&gt; #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>In der Datei <filename>log/development.log</filename> finden Sie
      den zu erwartenden <literal>INSERT</literal>-Befehl:<programlisting>SQL (0.9ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-09-02 20:30:34.872261', 'Highway 61 Revisited', 4, 1965, '2010-09-02 20:30:34.872261')</programlisting></para>

      <para>Sie können der Methode <methodname>new</methodname> wie
      <methodname>create</methodname> auch direkt Parameter für den neuen
      Datensatz übergeben. Hier das obige Beispiel in einer Zeile:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>highway61 = Album.new(:position =&gt; 4, :name =&gt; 'Highway 61 Revisited', :release_year =&gt; 1965)</command>
 =&gt; #&lt;Album id: nil, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>highway61.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>

    <section xml:id="activerecord_new_record">
      <title xml:id="activerecord_new_record.title">new_record?</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>.new_record?()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>new_record?</methodname> können Sie
      sich anzeigen lassen, ob ein Datensatz schon gespeichert wurde oder
      nicht. Wurde ein neues Objekt mit <methodname>new</methodname> erstellt
      und noch nicht abgespeichert, dann ist das Ergebnis von
      <methodname>new_record?</methodname> <literal>true</literal>. Nach einem
      <methodname>save</methodname> ist es <literal>false</literal>.</para>

      <para>Gehen wir noch mal das Beispiel von <xref
      linkend="activerecord_new" /> durch, um dies zu zeigen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>highway61 = Album.new(:position =&gt; 4, :name =&gt; 'Highway 61 Revisited', :release_year =&gt; 1965)</command>
 =&gt; #&lt;Album id: nil, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>highway61.new_record?</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>highway61.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>highway61.new_record?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen><tip>
          <para>Bei bereits bestehenden Datensätzen können Sie eine
          Veränderung auch mit der Methode <methodname>changed?</methodname>
          überprüfen (siehe <xref linkend="activerecord_changed" />).</para>
        </tip></para>
    </section>
  </section>

  <section>
    <title>first, last und all</title>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>::first()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>::last()</tertiary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Methoden</secondary>

      <tertiary>::all()</tertiary>
    </indexterm>

    <para>In dem ein oder anderen Fall braucht man ja immer mal den ersten
    oder den letzten oder auch alle Datensätze. Wahrscheinlich deshalb gibt es
    für alle drei Fälle eine fertige Methode. Fangen wir mit den einfachsten
    <methodname>first</methodname> und <methodname>last</methodname>
    an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Ein kurzer Blick in <filename>log/development.log</filename> zeigt
    uns wie ActiveRecord das gemacht hat:<programlisting>  Album Load (0.4ms)  SELECT "albums".* FROM "albums" LIMIT 1
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" ORDER BY albums.id DESC LIMIT 1
</programlisting></para>

    <para>Und jetzt mal alle auf einemal mit
    <methodname>all</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.all</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Der dazu gehörige SQL-Code ist nicht überraschen:<programlisting>  Album Load (0.2ms)  SELECT "albums".* FROM "albums"</programlisting></para>

    <para>Die von <methodname>first</methodname>,
    <methodname>last</methodname> und <methodname>all</methodname> erzeugten
    Objekte sind aber unterschiedlich. Bei <methodname>first</methodname> und
    <methodname>all</methodname> wird ein <classname>Album</classname>
    ausgegeben und bei <methodname>all</methodname> ein Array:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.first.class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.all</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.all.class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Wenn <methodname>Album.all</methodname> ein Array zurückgibt, dann
    müsste man doch auch Iteratoren (siehe <xref linkend="iterator" /> und
    <xref linkend="array_iterator" />) benutzen können, oder? Ja, natürlich!
    Das ist ja das schöne daran. Kleiner Versuch mit
    <methodname>each</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.all.each do |album|</command>
ruby-1.9.2-p0 &gt;     <command>puts album.name</command>
ruby-1.9.2-p0 ?&gt;  <command>end</command>
Sgt. Pepper's Lonely Hearts Club Band
Pet Sounds
Revolver
Highway 61 Revisited
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Kann man dann auch <methodname>Album.all.first</methodname> als
    Alternative zu <methodname>first</methodname> benutzen? Ja, aber es macht
    keinen Sinn. Schauen wir mal:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.all.first</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <para>Sicherlich, das Ergebnis ist das gleiche, aber werfen wir mal einen
    Blick ins <filename>log/development.log</filename>:<programlisting>  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 1
  Album Load (0.3ms)  SELECT "albums".* FROM "albums"</programlisting></para>

    <para>Selbst bei unserer Mini-Datenbank sehen wir schon einen
    Geschwindigkeitsunterschied. Bei der Methode first wird ein <code>SELECT
    *</code> mit einem <code>LIMIT 1</code> abgerufen (erste Zeile). Beim
    <methodname>Album.all.first</methodname> wird ein die ganze Tabelle mit
    <code>SELECT *</code> eingelesen und dann innerhalb von Ruby das erste
    Element dieses Arrays rausgezogen. Bei dieser kleinen Applikation kann man
    sich das noch leisten, aber stellen Sie sich mal vor, es würde sich um
    eine Datenbank mit zig Millionen Einträgen handeln.</para>

    <tip>
      <para>Auch wenn ActiveRecord dem Programmierer schon sehr viel
      Denkarbeit abnimmt, sollte man immer überlegen, ob das gleiche Ergebnis
      nicht auch mit einem optimaleren Weg realisiert werden kann.</para>
    </tip>
  </section>

  <section xml:id="seed_rb">
    <title xml:id="seed_rb.title">Mit seeds.rb die Datenbank betanken</title>

    <indexterm>
      <primary>seeds.rb</primary>
    </indexterm>

    <para>Die Rails-Götter haben mit der Datei
    <filename>db/seeds.rb</filename> einen Weg geschaffen, eine frische
    Installation einfach und schnell mit Default-Werten zu füttern. Es handelt
    sich um ein normales Ruby-Programm innerhalb der Rails-Umgebung. Sie haben
    also vollen Zugriff auf alle Klassen und Methoden aus Ihrer
    Applikation.</para>

    <para>Um die in <xref linkend="activerecord_create" /> erstellten
    Datensätze in einer neuen Rails-Applikation zur Verfügung zu stellen,
    müssen Sie so nicht manuel mit <command>rails console</command> alles
    eingeben, sondern es reicht die folgende <filename>db/seeds.rb</filename>
    Datei:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Album.create("name"=&gt;"Sgt. Pepper's Lonely Hearts Club Band", "position"=&gt;1, "release_year"=&gt;1967)
Album.create("name"=&gt;"Pet Sounds", "position"=&gt;2, "release_year"=&gt;1966)
Album.create("name"=&gt;"Revolver", "position"=&gt;3, "release_year"=&gt;1966)
Album.create("name"=&gt;"Highway 61 Revisited", "position"=&gt;4, "release_year"=&gt;1965)</programlisting></para>

    <para>Das einspielen der Daten erfolgt dann mit <command>rake
    db:seed</command>. Um ganz sicher zu sein, sollten Sie im Rahmen dieses
    Buches immer mit <command>rake db:setup</command> die Datenbank neu
    aufsetzen und dann automatisch mit der seeds.rb füttern. Das sieht dann so
    aus:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake db:setup</command>
(in /Users/stefan/jukebox)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("albums", {:force=&gt;true})
   -&gt; 0.0159s
-- initialize_schema_migrations_table()
   -&gt; 0.0005s
-- assume_migrated_upto_version(20101004085045, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen>Die <filename>db/seeds.rb</filename>
    Datei bringe ich an dieser Stelle ein, weil sie einen einfachen
    Mechanismus bietet eine leere Datenbank mit Default-Werten zu fühlen. Das
    erleichtert uns im weiteren Verlauf des Buches das schnelle Setup von
    Beispiel-Szenarien.</para>

    <section>
      <title>Alternative Programmierung</title>

      <indexterm>
        <primary>seeds.rb</primary>
      </indexterm>

      <para>Die <filename>seeds.rb</filename> ist ein Ruby Programm.
      Entsprechend können wir alternativ auch folgenen Weg
      gehen:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

album_list = [["Sgt. Pepper's Lonely Hearts Club Band", 1967], 
              ["Pet Sounds", 1966], 
              ["Revolver", 1966], 
              ["Highway 61 Revisited", 1965]]

position = 1
album_list.each do |album|
  Album.create(:name =&gt; album[0], :release_year =&gt; album[1], :position =&gt; position )
  position = position + 1
end</programlisting></para>

      <para>Das Ergebnis ist das gleiche. Ich zeige Ihnen dieses Beispiel
      hier, um noch mal klar rauszuarbeiten, das Sie innerhalb der
      <filename>seeds.rb</filename> ganz normal programmieren können.</para>
    </section>

    <section>
      <title>seeds.rb aus bestehenden Daten erstellen</title>

      <indexterm>
        <primary>seeds.rb</primary>
      </indexterm>

      <para>Manchmal ist es praktisch den aktuellen Datenbestand einer
      Rails-Applikation in eine <filename>seeds.rb</filename> zu exportieren.
      Beim Schreiben dieses Buches hatte ich dieses Problem fast in jedem
      Kapitel. Es gibt dafür leider keinen Standard-Weg. Ich zeige Ihnen man
      es in diesem Fall machen kann. Komplexere Szenarien lassen sich daraus
      ableiten.</para>

      <para>Füllen Sie die Datei <filename>lib/tasks/apfelmus.rake</filename>
      mit folgendem Inhalt:<programlisting>namespace :album do
  desc "Prints all the Albums in a seeds.rb way."
  task :seed_format =&gt; :environment do
    Album.order('position').all.each do |album|
      puts "Album.create(#{album.serializable_hash.delete_if {|key, value| ['created_at','updated_at','id'].include?(key)}.to_s.gsub(/[{}]/,'')})"
    end
  end
end</programlisting></para>

      <para>Danach können Sie mit <command>rake album:seed_format</command>
      den entsprechenden <literal>rake</literal>-<quote><foreignphrase
      xml:lang="en">Task</foreignphrase></quote> abrufen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake album:seed_format</command>
(in /Users/stefan/jukebox)
Album.create("name"=&gt;"Sgt. Pepper's Lonely Hearts Club Band", "position"=&gt;1, "release_year"=&gt;1967)
Album.create("name"=&gt;"Pet Sounds", "position"=&gt;2, "release_year"=&gt;1966)
Album.create("name"=&gt;"Revolver", "position"=&gt;3, "release_year"=&gt;1966)
Album.create("name"=&gt;"Highway 61 Revisited", "position"=&gt;4, "release_year"=&gt;1965)
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Entweder können Sie dieses Programm so erweitern, das die Ausgabe
      direkt in die <filename>seeds.rb</filename> geschrieben wird oder Sie
      benutzen einfach die Shell:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake album:seed_format &gt;&gt; db/seeds.rb</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>
  </section>

  <section xml:id="queries">
    <title xml:id="queries.title">Suchen und Finden mit Queries</title>

    <para>Die Methoden <methodname>first</methodname> und
    <methodname>all</methodname> sind ja schon ganz nett, aber meistens will
    man ja doch nach etwas ganz bestimmten suchen.</para>

    <para>Für die hier verwendeten Beispiele verwenden Sie bitte die Datei
    <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting>Album.create("name"=&gt;"Sgt. Pepper's Lonely Hearts Club Band", "position"=&gt;1, "release_year"=&gt;1967)
Album.create("name"=&gt;"Pet Sounds", "position"=&gt;2, "release_year"=&gt;1966)
Album.create("name"=&gt;"Revolver", "position"=&gt;3, "release_year"=&gt;1966)
Album.create("name"=&gt;"Highway 61 Revisited", "position"=&gt;4, "release_year"=&gt;1965)
Album.create("name"=&gt;"Rubber Soul", "position"=&gt;5, "release_year"=&gt;1965)
Album.create("name"=&gt;"What's Going On", "position"=&gt;6, "release_year"=&gt;1971)
Album.create("name"=&gt;"Exile on Main St.", "position"=&gt;7, "release_year"=&gt;1972)
Album.create("name"=&gt;"London Calling", "position"=&gt;8, "release_year"=&gt;1979)
Album.create("name"=&gt;"Blonde on Blonde", "position"=&gt;9, "release_year"=&gt;1966)
Album.create("name"=&gt;"The Beatles", "position"=&gt;10, "release_year"=&gt;1968)</programlisting></para>

    <para>Danach die Datenbank mit <command>rake db:setup</command> neu
    aufsetzen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rake db:setup</command>
(in /Users/stefan/jukebox)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("albums", {:force=&gt;true})
   -&gt; 0.0183s
-- initialize_schema_migrations_table()
   -&gt; 0.0004s
-- assume_migrated_upto_version(20101004085045, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

    <section xml:id="find_vs_where">
      <title xml:id="find_vs_where.title">find vs. where</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>where()</tertiary>
      </indexterm>

      <para>Jahrelang war die <methodname>find</methodname> Methode die erste
      Wahl für Datenbankabfragen in Rails. Mit Rails 3.0 wurde
      <methodname>where</methodname> und Lazy Loading (siehe <xref
      linkend="lazy_loading" />) eingeführt. Die <methodname>find</methodname>
      Methode gibt es weiterhin und es wird sie wahrscheinlich aus
      historischen Gründen auch noch eine ganze Zeit geben. Meiner Meinung
      nach macht die Benutzung von <methodname>find</methodname> keinen Sinn,
      wenn ich die gleiche Abfrage auch performanter mit
      <methodname>where</methodname> realisieren kann. Deshalb werde ich auf
      <methodname>find</methodname> in diesem Buch nicht intensiv eingehen und
      nur die Suche nach einer Datenbank-ID und
      <methodname>find_by_<replaceable>*</replaceable></methodname>
      vorstellen. Alle Freunde von <methodname>find</methodname> verweise ich
      auf <command>ri ActiveRecord::FinderMethods.find</command> und auf <xref
      linkend="weiterfuehrende_doku" />.</para>
    </section>

    <section xml:id="activerecord_where">
      <title xml:id="activerecord_where.title">where</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>where()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>where</methodname> kann man nach
      bestimmten Werten in der Datenbank suchen. Suchen wir mal alle Alben aus
      dem Jahr 1966:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Ein Blick in die <filename>log/development.log</filename> zeigt
      uns die an die Datenbank gerichtete SQL-Abfrage dazu:<programlisting>  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" = 1966)
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "albums" WHERE ("albums"."release_year" = 1966)) AS subquery
</programlisting></para>

      <para>Sie können mir <methodname>where</methodname> auch nach Ranges
      suchen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966).count</command>
 =&gt; 5 
ruby-1.9.2-p0 &gt; exit
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Auch hier der kurze Blick in die
      <filename>log/development.log</filename> Datei:<programlisting>  Album Load (0.6ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966)) AS subquery
</programlisting></para>

      <para>Und Sie können auch mehrere Suchfaktoren mit Komma abgetrennt
      gleichzeitig angeben:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966, :position =&gt; 1..5)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1966, :position =&gt; 1..5).count</command>
 =&gt; 4 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Das erzeugte SQL wird entsprechend komplexer:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966) AND ("albums"."position" BETWEEN 1 AND 5)
  SQL (0.3ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1966) AND ("albums"."position" BETWEEN 1 AND 5)) AS subquery
</programlisting></para>

      <para>Oder auch ein Array von Parametern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; [1966,1968])</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Der Vollständigkeit halber auch hier noch die
      SQL-Abfrage:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" IN (1966, 1968))
</programlisting></para>

      <important>
        <para>Das Ergegebnis von <methodname>where</methodname> is immer ein
        Array. Auch wenn nur ein Treffer drin ist oder auch wenn gar kein
        Treffer ausgegeben wird. Wenn Sie den ersten Treffer suchen, dann
        müssen Sie <methodname>where</methodname> mit der
        <methodname>first</methodname> Methode verketten:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; [1966,1968]).first</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:53:00"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
      </important>

      <section xml:id="activerecord_sql">
        <title xml:id="activerecord_sql.title">SQL-Abfragen mit where</title>

        <para>Manchmal kommt man nicht drum rum und muss tatsächlich eine
        SQL-Abfrage selber definieren und durchführen. Es gibt in ActiveRecord
        zwei verschiedene Arten dies zu machen. Die eine "reinigt" (sanitize)
        jede Abfrage vor dem Ausführen und die andere gibt die Abfrage 1 zu 1
        so an die SQL-Datenbank weiter. Im normalfall sollte man immer auf
        sanitize Variante benutzen, weil man sonst sehr schnell Opfer einer
        SQL-Injection-Attacke werden kann (siehe <uri
        xlink:href="http://de.wikipedia.org/wiki/SQL-Injection">http://de.wikipedia.org/wiki/SQL-Injection</uri>).</para>

        <para>Falls Sie sich mit SQL nicht auskennen, dann können Sie diesen
        Abschnitt ruhig überspringen. Die hier benutzen SQL-Befehle werden
        nicht gesondert erklärt.</para>

        <section>
          <title>sanitized (gereinigte) Abfragen</title>

          <para>Bei dieser Variante werden alle dynamischen Suchanteile mit
          einem Fragezeichen markiert und erst nach dem fertigen SQL-String
          aufgelistet.</para>

          <para>Suchen wir einmal alle Alben, in deren Namen der String "on"
          enthalten ist:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where("name like ?", '%on%')</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

          <para>Die SQL-Abfrage wird korrekt ausgeführt (Auszug aus
          <filename>log/development.log</filename>):<programlisting>  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE (name like '%on%')
</programlisting></para>

          <para>Jetzt alle Alben die ab 1965 veröffentlicht wurden:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where("release_year &gt; ?", 1964)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;]
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

          <para>Auszug aus
          <filename>log/development.log</filename>:<programlisting>  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE (release_year &gt; 1964)
</programlisting></para>

          <para>Alle Alben die jünger als 1970 sind und deren Namen den String
          "on" enthalten:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where("name like ? AND release_year &gt; ?", '%on%', 1970)</command>
 =&gt; [#&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

          <para>Auszug aus
          <filename>log/development.log</filename>:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE (name like '%on%' AND release_year &gt; 1970)
</programlisting></para>

          <para>Wenn in der Variable <varname>apfelmus</varname> der gesuchte
          String enthalten ist, dann kann folgendermassen danach gesucht
          werden:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>apfelmus = 'ing'</command>
 =&gt; "ing" 
ruby-1.9.2-p0 &gt; <command>Album.where("name like ?", "%#{apfelmus}%")</command>
 =&gt; [#&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

          <para>Auszug aus
          <filename>log/development.log</filename>:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE (name like '%ing%')
</programlisting></para>
        </section>

        <section>
          <title>"Gefährliche" SQL-Abfragen</title>

          <para>Wenn Sie wirklich wissen was Sie tun, dann können Sie
          natürlich auch komplett die SQL-Abfrage definieren und auf das
          reinigen (sanitize) der Abfrage verzichten.</para>

          <para>Suchen wir einmal alle Alben, in deren Namen der String "on"
          enthalten ist:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where("name like '%on%'")</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

          <para>Natürlich sind die Ergebnisse dieser einfachen Abfrage
          identisch mit der gesanitizten Variante:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where("name like '%on%'") == Album.where("name like ?", "%on%")</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

          <para>Problematisch wird das ganze beim Einsatz von Variablen.
          Arbeiten wir nochmal mit der Variable apfelmus und fügen nach dem
          ersten Aufruf einen abgewandelten Beispiel-Hack von <uri
          xlink:href="http://de.wikipedia.org/wiki/SQL-Injection">http://de.wikipedia.org/wiki/SQL-Injection</uri>
          ein:</para>
        </section>
      </section>
    </section>

    <section xml:id="activerecord_order">
      <title xml:id="activerecord_order.title">order</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>order()</tertiary>
      </indexterm>

      <para>Jede <methodname>where</methodname> Datenbank-Anfrage kann mit der
      Methode <methodname>order</methodname> sortiert werden. Beispiel: Alle
      Alben aus den 60ern nach Namen sortiert:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1969).order(:name)</command>
 =&gt; [#&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Natürlich können wir auch alle Alben aus den 70ern in umgekehrter
      Reihenfolge sortieren:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1970..1979).order('name DESC')</command>
 =&gt; [#&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Hier noch die Ausgabe aus <filename>log/development.log</filename>
      zu den beiden Suchen:<programlisting>  Album Load (0.5ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY name
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979) ORDER BY name DESC
</programlisting></para>
    </section>

    <section xml:id="activerecord_limit">
      <title xml:id="activerecord_limit.title">limit</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>limit()</tertiary>
      </indexterm>

      <para>Das Ergebnis jeder Suche kann mit der Methode
      <methodname>limit</methodname> auf einen bestimmten Bereich eingegrenzt
      werden.</para>

      <para>Die ersten drei Datensätze in der Album Datenbank:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.limit(3)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die ersten 5 Alben aus den 60ern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1969).limit(5)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die ersten 5 Alben aus den 60ern nach dem Namen sortiert:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1969).order(:release_year).limit(5).order(:name)</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die zu den drei Abfragen gehörenden Einträge in der
      <filename>log/development.log</filename> Datei:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" LIMIT 3
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) LIMIT 5
  Album Load (0.4ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969) ORDER BY release_year, name LIMIT 5
</programlisting></para>

      <section xml:id="activerecord_offset">
        <title xml:id="activerecord_offset.title">offset</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>offset()</tertiary>
        </indexterm>

        <para>Mit der Methode <methodname>offset</methodname> kann die
        Startposition der <methodname>limit</methodname> Methode definiert
        werden.</para>

        <para>Als erstes geben wir die ersten beiden Datensätze aus und danach
        die ersten beiden Datensätze mit einem Offset von 5:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.limit(2)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.limit(2).offset(5)</command>
 =&gt; [#&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>Die <filename>log/development.log</filename> zeigt die
        entsprechende SQL-Abfrage:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" LIMIT 2
  Album Load (0.3ms)  SELECT "albums".* FROM "albums" LIMIT 2 OFFSET 5
</programlisting></para>
      </section>
    </section>

    <section xml:id="activerecord_average">
      <title xml:id="activerecord_average.title">average</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>average()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>average</methodname> kann man den
      Durchschnitt einer bestimmten Spalte in der Tabelle ausrechnen. Dafür
      ist unser Datenmaterial nicht besonders geeignet, aber versuchen wir mal
      zwei Beispiele aus den Fingern zu saugen. Als erstes berechnen wir das
      Durchschnitts Veröffentlichungsjahr aller Alben und danach das gleiche
      für die Alben aus den 60ern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.average(:release_year)</command>
 =&gt; 1968.5 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1969).average(:release_year)</command>
 =&gt; 1966.142857142857 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die <filename>log/development.log</filename> zeigt die
      entsprechende SQL-Abfrage:<programlisting>  SQL (0.2ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums"
  SQL (0.2ms)  SELECT AVG("albums"."release_year") AS avg_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
</programlisting></para>
    </section>

    <section xml:id="activerecord_group">
      <title xml:id="activerecord_group.title">group</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>group()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>group</methodname> kann das Ergebnis
      einer Abfrage gruppiert ausgegeben werden.</para>

      <para>Geben wir erst mal alle Alben nach dem Erscheinungsjahr gruppiert
      aus und dann alle nach Namen sortierten Alben nach dem Erscheinungsjahr
      gruppiert:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.group(:release_year)</command>
 =&gt; [#&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.order(:name).group(:release_year)</command>
 =&gt; [#&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 8, position: 8, name: "London Calling", release_year: 1979, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;, #&lt;Album id: 6, position: 6, name: "What's Going On", release_year: 1971, created_at: "2010-10-08 09:07:21", updated_at: "2010-10-08 09:07:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die <filename>log/development.log</filename> zeigt die
      entsprechende SQL-Abfrage:<programlisting>  Album Load (0.5ms)  SELECT "albums".* FROM "albums" GROUP BY release_year
  Album Load (0.5ms)  SELECT "albums".* FROM "albums" GROUP BY release_year ORDER BY name
</programlisting></para>

      <note>
        <para>Natürlich können Sie mit <code>==</code> überprüfen, ob die
        beiden letzten Abfragen identisch sind:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.group(:release_year) == Album.order(:name).group(:release_year)</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
      </note>
    </section>

    <section xml:id="activerecord_count">
      <title xml:id="activerecord_count.title">count</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>count()</tertiary>
      </indexterm>

      <para>Die Methode <methodname>count</methodname> zählt die Anzahl der
      Datensätze.</para>

      <para>Als erstes geben wir die Anzahl aller Alben in der Datenbank aus
      und danach die Anzahl der Alben in den 60ern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.count</command>
 =&gt; 10 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1969).count</command>
 =&gt; 7 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die <filename>log/development.log</filename> zeigt die
      entsprechende SQL-Abfrage:<programlisting>  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "albums"
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)) AS subquery
</programlisting></para>
    </section>

    <section xml:id="activerecord_maximum">
      <title xml:id="activerecord_maximum.title">maximum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>maximum()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>maximum</methodname> kann aus einer
      Abfrage der Eintrag mit dem höchsten Wert ausgegeben werden.</para>

      <para>Als erstes suchen wir aus allen Alben das mit dem höchsten
      Veröffentlichungsjahr und dann das gleiche für alle Alben aus den
      60ern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.maximum(:release_year)</command>
 =&gt; 1979 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1960..1969).maximum(:release_year)</command>
 =&gt; 1968 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die <filename>log/development.log</filename> zeigt die
      entsprechende SQL-Abfrage:<programlisting>  SQL (0.2ms)  SELECT MAX("albums"."release_year") AS max_id FROM "albums"
  SQL (0.2ms)  SELECT MAX("albums"."release_year") AS max_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1960 AND 1969)
</programlisting></para>
    </section>

    <section xml:id="activerecord_minimum">
      <title xml:id="activerecord_minimum.title">minimum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>minimum()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>minimum</methodname> kann aus einer
      Abfrage der Eintrag mit dem niedrigsten Wert ausgegeben werden.</para>

      <para>Als erstes suchen wir aus allen Alben das mit dem niedrigsten
      Veröffentlichungsjahr und dann das gleiche für alle Alben aus den
      70ern:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.minimum(:release_year)</command>
 =&gt; 1965 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1970..1979).minimum(:release_year)</command>
 =&gt; 1971 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die <filename>log/development.log</filename> zeigt die
      entsprechende SQL-Abfrage:<programlisting>  SQL (0.2ms)  SELECT MIN("albums"."release_year") AS min_id FROM "albums"
  SQL (0.2ms)  SELECT MIN("albums"."release_year") AS min_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
</programlisting></para>
    </section>

    <section xml:id="activerecord_sum">
      <title xml:id="activerecord_sum.title">sum</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>sum()</tertiary>
      </indexterm>

      <para>Mit der Methode sum kann man die Summe alle Einträge in einer
      bestimmten Spalte der Datenbankabfrage berechnen.</para>

      <para>Als erstes ziehen wir die Summe aller Veröffentlichungsjahre und
      danach die Summe aller Veröffentlichungsjahre in den 70ern (ja, ein
      sinnfreies Beispiel ;-)):<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.sum(:release_year)</command>
 =&gt; 19685 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1970..1979).sum(:release_year)</command>
 =&gt; 5922 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die <filename>log/development.log</filename> zeigt die
      entsprechende SQL-Abfrage:<programlisting>  SQL (0.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums"
  SQL (0.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
</programlisting></para>
    </section>

    <section xml:id="activerecord_find_id">
      <title xml:id="activerecord_find_id.title">Mit
      <methodname>find</methodname> nach Datenbank-IDs suchen</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find()</tertiary>
      </indexterm>

      <para>Sicherlich kann man auch mit where einen Datensatz anhand der
      Datensatz-ID suchen, aber hier ist find tatsächlich einen Tick
      praktischer. Wenn ich die ID eines Objektes kenne, kann ich das einzelne
      Objekt oder mehrere Objekte gleichzeitig anhand der ID suchen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find(2)</command>
 =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find(2).class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.find([1,3,7])</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-09-03 09:05:28", updated_at: "2010-09-03 09:05:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.find([1,3,7]).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Wenn man immer ein Array als Ergebnis haben will muss man nur nur
      einfach immer auch ein Array als Parameter übergeben:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find(5).class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.find([5]).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Wenn man nach einer ID sucht, sollte man sich allerdings ganz
      sicher sein, dass es diese ID auch gibt. Im Zweifelsfall kann/muss man
      das mit der Methode <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>exists?()</tertiary>
        </indexterm><methodname>exists?</methodname> vorher machen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find(50)</command>
ActiveRecord::RecordNotFound: Couldn't find Album with ID=50
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/relation/finder_methods.rb:296:in `find_one'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/relation/finder_methods.rb:281:in `find_with_ids'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/relation/finder_methods.rb:107:in `find'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/base.rb:439:in `find'
 from (irb):2
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands/console.rb:44:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.2-p0 &gt; <command>Album.exists?(50)</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>

    <section xml:id="activerecord_find_by">
      <title xml:id="activerecord_find_by.title">Attribute-basiertes find_by,
      find_last_by und find_all_by</title>

      <remark>FIXME: Gibt es auch find_first_by_*()?</remark>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_by_*()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_last_by_*()</tertiary>
      </indexterm>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>find_all_by_*()</tertiary>
      </indexterm>

      <para>Das Attribute basierte <methodname>find_by_</methodname> ist eine
      "magische" Methode, denn sie kann von Ihnen dynamisch erweitert werden.
      Die Funktionalität ist die gleiche wie die der
      <methodname>where</methodname> Methode (siehe <xref
      linkend="activerecord_where" />), aber die Lesbarkeit des Codes wird
      besser (meistens jedenfalls). Man kann treffend über den Sinn oder den
      Unsinn streiten. Probieren Sie es einmal aus und entscheiden Sie selber
      welchen Weg Sie gehen wollen.</para>

      <para>Eine Consolenbeispiel sagt mehr als tausend Worte. Ich verwende
      erst <methodname>where</methodname> und dann
      <methodname>find_by</methodname> für die gleiche Abfage.</para>

      <tip>
        <para>Sie können sich mit dem Befehl
        <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command> die
        normalerweise nur in log/development.log aufgezeichneten SQL-Abfragen
        auch direkt auf die Console ausgeben lassen.</para>
      </tip>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000100f2e1c0 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000100f2e198 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x00000100f2e148 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x00000100f2e120 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000100f2e0d0&gt;&gt;&gt;&gt; 


ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).first</command>
<emphasis>  SQL (0.4ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" = 1966) LIMIT 1
</emphasis> =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(1966)</command>
<emphasis>  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" = 1966) LIMIT 1
</emphasis> =&gt; #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 


ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).last</command>
<emphasis>  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" = 1966) ORDER BY albums.id DESC LIMIT 1
</emphasis> =&gt; #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_last_by_release_year(1966)</command>
<emphasis>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" = 1966) ORDER BY albums.id DESC LIMIT 1
</emphasis> =&gt; #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 

ruby-1.9.2-p0 &gt; exit
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <important>
        <para>Im Gegensatz zu <methodname>where</methodname> gibt
        <methodname>find_by</methodname> entweder ein Objekt der gesuchten
        Klasse (hier <classname>Album</classname>) oder
        <classname>nil</classname> aus. <methodname>where</methodname> gibt
        <emphasis>immer</emphasis> ein Array aus! Wenn man auf diesen
        Unterschied beim Programmieren nicht achtet, bekommt man über kurz
        oder lang einen Fehler an dieser Stelle.<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(1972)</command>
 =&gt; #&lt;Album id: 7, position: 7, name: "Exile on Main St.", release_year: 1972, created_at: "2010-09-03 09:05:28", updated_at: "2010-09-03 09:05:28"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(1972).class</command>
 =&gt; Album(id: integer, position: integer, name: string, release_year: integer, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(2010)</command>
 =&gt; nil 
ruby-1.9.2-p0 &gt; <command>Album.find_by_release_year(2010).class</command>
 =&gt; NilClass 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
      </important>

      <para>Die Methode <methodname>find_all_by</methodname> gibt wie
      <methodname>where</methodname> immer ein Array aus:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(2020).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <section xml:id="activerecord_find_by_and_verkettung">
        <title xml:id="activerecord_find_by_and_verkettung.title">Verkettung
        von mehreren Attributen</title>

        <para>Mit den Methoden <methodname>find_by_</methodname>,
        <methodname>find_last_by_</methodname> und
        <methodname>find_all_by_</methodname> lassen sich auch mehrere
        Suchattribute mit <methodname>and</methodname> verketten. Unsere
        aktuellen Datensätze lassen keine richtig guten Beispiele dafür zu.
        Deshalb ein paar wenig sinnvolle, aber die Methode beschreibende
        Abfragen in der mit <methodname>and</methodname> Attribute verkettet
        werden:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_by_position_and_release_year(1,1967)</command>
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_position_and_release_year(1,1967)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.find_by_position_and_name(5,'The Beatles')</command>
 =&gt; nil 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
      </section>

      <section>
        <title>find_or_create_by_</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>find_or_create_by_*()</tertiary>
        </indexterm>

        <para>Häufig hat man beim Programmieren die Aufgabenstellung einen
        bestimmten Datensatz zu suchen und falls er nicht existiert, dann
        diesen anzulegen. Das lässt sich sehr schön mit
        <methodname>find_or_create_by_</methodname> in einem Schritt
        vollziehen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>beatles = Album.find_or_create_by_name('The Beatles')</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 
ruby-1.9.2-p0 &gt; <command>ray_charles = Album.find_or_create_by_name('Crying Time')</command>
 =&gt; #&lt;Album id: 11, position: nil, name: "Crying Time", release_year: nil, created_at: "2010-10-06 12:15:26", updated_at: "2010-10-06 12:15:26"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>In der <filename>log/development.log</filename> lässt sich
        nachvollziehen, das nach der zweiten Anfrage direkt ein INSERT
        ausgeführt wurde, weil dieser Datensatz nicht
        existierte.<programlisting>  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."name" = 'The Beatles') LIMIT 1
  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."name" = 'Crying Time') LIMIT 1
  SQL (0.5ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-10-06 12:15:26.603938', 'Crying Time', NULL, NULL, '2010-10-06 12:15:26.603938')
</programlisting></para>

        <warning>
          <para>Bei der Benutzung von
          <methodname>find_or_create_by_</methodname> sollte man immer sicher
          sein, das der evt. neu anzulegende Datensatz in sich selber valide
          ist. Dies lässt sich einfach mit der <methodname>valid?</methodname>
          Methode realisieren (siehe <xref
          linkend="activerecord_validation" />).</para>
        </warning>

        <para>Wenn Sie zwar nach einem Album-Namen suchen, aber beim evtuellen
        <methodname>create</methodname> auch noch andere Daten angeben wollen,
        so geht das auch mit
        <methodname>find_or_create_by_</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>crying_time = Album.find_or_create_by_name('Genius Loves Company', :release_year =&gt; 2004)</command>
 =&gt; #&lt;Album id: 12, position: nil, name: "Genius Loves Company", release_year: 2004, created_at: "2010-10-07 13:23:58", updated_at: "2010-10-07 13:23:58"&gt; 
ruby-1.9.2-p0 &gt; <command>crying_time</command>
 =&gt; #&lt;Album id: 12, position: nil, name: "Genius Loves Company", release_year: 2004, created_at: "2010-10-07 13:23:58", updated_at: "2010-10-07 13:23:58"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>Ein Blick in die <filename>log/development.log</filename> zeigt,
        das zwar nur nach "Genius Loves Company" gesucht wurde, aber der neue
        Datensatz inklusive dem <literal>release_year</literal> angelegt
        wurde:<programlisting>  Album Load (0.2ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."name" = 'Genius Loves Company') LIMIT 1
  SQL (0.4ms)  INSERT INTO "albums" ("created_at", "name", "position", "release_year", "updated_at") VALUES ('2010-10-07 13:23:58.446037', 'Genius Loves Company', NULL, 2004, '2010-10-07 13:23:58.446037')
</programlisting></para>
      </section>

      <section>
        <title>find_or_initialize_</title>

        <indexterm>
          <primary>ActiveRecord</primary>

          <secondary>Methoden</secondary>

          <tertiary>find_or_initialize_*()</tertiary>
        </indexterm>

        <para>Die Methode <methodname>find_or_initialize_</methodname>
        arbeitet wie <methodname>find_or_create_by_</methodname>. Allerdings
        gibt es einen entscheidenen Unterschied:
        <methodname>find_or_initialize_</methodname> speichert einen neuen
        Datensatz nicht ab. Das muss später per <methodname>save</methodname>
        erfolgen. Kleines Beispiel:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>i_got_a_woman = Album.find_or_initialize_by_name('I Got a Woman', :release_year =&gt; 1955)</command>
 =&gt; #&lt;Album id: nil, position: nil, name: "I Got a Woman", release_year: 1955, created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 12, position: nil, name: "Genius Loves Company", release_year: 2004, created_at: "2010-10-07 13:23:58", updated_at: "2010-10-07 13:23:58"&gt; 
ruby-1.9.2-p0 &gt; <command>i_got_a_woman.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 13, position: nil, name: "I Got a Woman", release_year: 1955, created_at: "2010-10-07 16:05:59", updated_at: "2010-10-07 16:05:59"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
      </section>

      <section xml:id="activerecord_find_by_all_performance">
        <title
        xml:id="activerecord_find_by_all_performance.title">Performance</title>

        <para>Auch wenn die Methoden <methodname>where</methodname> und
        <methodname>find_all_by</methodname> sich oft gleich anfühlen, so gibt
        es bei einigen Szeanrien deutliche Performance-Unterschiede.
        Vereinfacht gesagt: Mit where machen Sie nie einen Fehler, da
        <methodname>where</methodname> Lazy Loading (siehe <xref
        linkend="lazy_loading" />) benutzt. Auf Lazy Loading gehen wir später
        noch mal dediziet ein. Hier aber schon mal ein kleiner
        Vorgeschmack:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000101255970 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000101255948 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x000001012558f8 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x000001012558d0 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000101255880&gt;&gt;&gt;&gt; 
ruby-1.9.2-p0 &gt; <command>Album.first</command>
<emphasis>  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 1
</emphasis> =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-10-06 10:16:18", updated_at: "2010-10-06 10:16:18"&gt; 



ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).count</command>
<emphasis>  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "albums" WHERE ("albums"."release_year" = 1966)) AS subquery
</emphasis> =&gt; 3 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966).count</command>
<emphasis>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."release_year" = 1966)
</emphasis> =&gt; 3 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>Die Kombination der Methoden <methodname>where</methodname> und
        <methodname>count</methodname> erstellt eine SQL-Abfrage die das
        Berechnen des Ergebnisses der SQL-Datenbank überlässt. Die Kombination
        der Methoden <methodname>find_all_by</methodname> und
        <methodname>count</methodname> fragt erst alle Datensätze bei der
        Datenbank ab, speichert diese dann in einem Array und zählt dann
        dieses Array. Das macht bei unserer Mini-Datenbank kaum einen
        Unterschied. Wenn Sie aber mit einer sehr grosse Datenbank arbeiten,
        dann wollen Sie die maximale Performance der SQL-Datenbank auszunutzen
        und nicht erst Daten hin und herschieben.</para>

        <para>Wie oben schon erwähnt: Diese Thematik wird in <xref
        linkend="lazy_loading" /> detailiert besprochen.</para>
      </section>
    </section>

    <section xml:id="activerecord_exists">
      <title xml:id="activerecord_exists.title">exists?</title>

      <para>Hin und wieder muss man wissen, ob es einen bestimmten Datensatz
      gibt und genau dafür gibt es die Methode
      <methodname>exists?</methodname>. Sie gibt als Ergebnis
      <literal>true</literal> oder <literal>false</literal> aus:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.exists?(10)</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.exists?(11)</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>Album.exists?(:name =&gt; 'The Beatles')</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.exists?(['name LIKE ?', '%Beatles%'])</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Die komplette Hilfe zur Methode <methodname>exists?</methodname>
      können Sie sich mit <command>ri
      ActiveRecord::FinderMethods.exists?</command> anzeigen lassen.</para>
    </section>

    <section xml:id="lazy_loading">
      <title xml:id="lazy_loading.title">Lazy Loading</title>

      <para>Seit Rails 3.0 wird bei ActiveRecords die Methode
      <methodname>where</methodname> und damit <emphasis>Lazy
      Loading</emphasis> verwendet. Dies ist ein Mechanismus, der eine
      Datenbankabfrage erst dann stellt, wenn der weitere Programmablauf nicht
      ohne das Ergebnis dieser realisiert werden kann. Vorher wird die Anfrage
      als <classname>ActiveRecord::Relation</classname> gespeichert.</para>

      <para>Schauen wir uns die Abfrage nach allen Alben aus dem Jahr 1966
      an.</para>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966)</command>
 =&gt; [#&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;] 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" = 1966)" 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Wenn aber <code>Album.where(:release_year =&gt; 1966)</code> ein
      <classname>ActiveRecord::Relation</classname> ist, warum bekommen wir
      dann in der Console ein Array ausgegeben? Die Console will uns das
      Entwicklerleben etwas einfacher machen und zeigt uns quasi automatisch
      das Ergebnis der <methodname>all</methodname> Methode an:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).all.class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Noch nicht ganz klar? Dann machen wir einen anderen Versuch. Hier
      schauen wir uns die Klassen von einem <methodname>find</methodname> und
      einem <methodname>where</methodname> an. Beide sind unterschiedlich
      (<methodname>where</methodname> liefert ein
      <classname>ActiveRecord::Relation</classname>). Wenn wir aber beide mit
      einem <code>==</code> vergleichen, dann ist das Ergebnis true. Wenn
      Rails das <code>==</code> sieht, denkt es sich "so, jetzt geht es nicht
      mehr anders, ich muss die Abfrage durchführen":<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966).class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1966).class == Album.find_all_by_release_year(1966).class</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>Album.find_all_by_release_year(1966) == Album.where(:release_year =&gt; 1966)</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Prinzipiel klar, aber der Sinn noch nicht ganz? Dann bauen wir uns
      mal eine Abfrage zusammen, in der wir mehrere Methoden verschachteln. In
      dem folgenden Beispiel wird <varname>a</varname> immer weiter definiert
      und erst ganz zum Schluss (beim Aufruf der Methode
      <methodname>all</methodname>) wird die Datenbankabfrage wirklich
      getätigt. Mit der Methode <methodname>to_sql</methodname> kann man sich
      immer die aktuelle SQL-Query ausgeben lassen.<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>a = Album.where(:release_year =&gt; 1965..1968)</command>
 =&gt; [#&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-05 21:29:19"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>a.to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" BETWEEN 1965 AND 1968)" 
ruby-1.9.2-p0 &gt; <command>a = a.order(:release_year)</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;, #&lt;Album id: 3, position: 3, name: "Revolver", release_year: 1966, created_at: "2010-09-02 19:49:27", updated_at: "2010-09-02 19:49:27"&gt;, #&lt;Album id: 9, position: 9, name: "Blonde on Blonde", release_year: 1966, created_at: "2010-09-03 09:06:28", updated_at: "2010-09-03 09:06:28"&gt;, #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-05 21:29:19"&gt;, #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-09-03 09:06:45", updated_at: "2010-09-03 09:06:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>a.to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" BETWEEN 1965 AND 1968) ORDER BY  release_year" 
ruby-1.9.2-p0 &gt; <command>a = a.limit(3)</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;] 
ruby-1.9.2-p0 &gt; <command>a.class</command>
 =&gt; ActiveRecord::Relation 
ruby-1.9.2-p0 &gt; <command>a.to_sql</command>
 =&gt; "SELECT     \"albums\".* FROM       \"albums\"  WHERE     (\"albums\".\"release_year\" BETWEEN 1965 AND 1968) ORDER BY  release_year LIMIT 3" 
ruby-1.9.2-p0 &gt; <command>a.all</command>
 =&gt; [#&lt;Album id: 4, position: 4, name: "Highway 61 Revisited", release_year: 1965, created_at: "2010-09-02 20:30:34", updated_at: "2010-09-02 20:30:34"&gt;, #&lt;Album id: 5, position: 5, name: "Rubber Soul", release_year: 1965, created_at: "2010-09-03 09:04:45", updated_at: "2010-09-03 09:04:45"&gt;, #&lt;Album id: 2, position: 2, name: "Pet Sounds", release_year: 1966, created_at: "2010-09-02 19:49:07", updated_at: "2010-09-02 19:49:07"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <section xml:id="activerecord_lazyloading_automatische_optimierung">
        <title
        xml:id="activerecord_lazyloading_automatische_optimierung.title">Automatische
        Optimierung</title>

        <para>Einer der grossen Vorteile von Lazy Loading ist die automatische
        Optimierung der SQL-Abfrage durch ActiveRecord.</para>

        <para>Ziehen wir mal die Summe aller Veröffentlichungsjahre der Alben
        die in dern 70ern rausgebracht wurden. Und danach sortieren wir die
        Alben vorher nach dem dem Namen und ziehen dann die Summe.<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1970..1979).sum(:release_year)</command>
 =&gt; 5922 
ruby-1.9.2-p0 &gt; <command>Album.where(:release_year =&gt; 1970..1979).order(:name).sum(:release_year)</command>
 =&gt; 5922 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

        <para>Das Ergebnis ist bei beiden Abfragen logischerweise identisch.
        Und ein Blick in die <filename>log/development.log</filename> zeigt
        auch, das ActiveRecord selbstständig die SQL-Abfrage optimiert hat.
        Bei beiden Anfragen wird der gleiche SQL-Code benutzt, weil die
        Sortierung nach Namen für das Ziehen der Summe völlig unerheblich
        ist:<programlisting>  SQL (0.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
  SQL (0.2ms)  SELECT SUM("albums"."release_year") AS sum_id FROM "albums" WHERE ("albums"."release_year" BETWEEN 1970 AND 1979)
</programlisting></para>
      </section>
    </section>

    <section>
      <title>Debugging in der Console</title>

      <para>Manchmal ist es nervig ständig zwischen einem Terminal mit der
      Rails Console und einem anderen Terminal mit dem Logfile zu wechseln, um
      zu sehen, was gerade von ActiveRecord mit der Datenbank gemacht wurde.
      Es gibt mit <command>ActiveRecord::Base.logger =
      Logger.new(STDOUT)</command> einen einfachen Weg diese Meldungen auch in
      der Console anzuzeigen:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000100a6e6d0 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000100a6e6a8 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x00000100a6e658 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x00000100a6e630 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000100a6e5e0&gt;&gt;&gt;&gt; 
ruby-1.9.2-p0 &gt; <command>Album.first</command>
  SQL (0.4ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Album Load (0.1ms)  SELECT "albums".* FROM "albums" LIMIT 1
 =&gt; #&lt;Album id: 1, position: 1, name: "Sgt. Pepper's Lonely Hearts Club Band", release_year: 1967, created_at: "2010-09-02 19:48:42", updated_at: "2010-09-02 19:48:42"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>
  </section>

  <section xml:id="activerecord_datensatz_veraendern">
    <title xml:id="activerecord_datensatz_veraendern.title">Einen Datensatz
    verändern</title>

    <para>Daten hinzufügen ist ja schon ganz nett, aber hin und wieder will
    man ja auch einen Datensatz editieren. Wir benutzen zur Beschreibung die
    Album-Datenbank aus <xref linkend="queries" />.</para>

    <section xml:id="activerecord_einfaches_editieren">
      <title xml:id="activerecord_einfaches_editieren.title">Einfaches
      Editieren</title>

      <para>Das einfache Editieren eines Datensatzes erfolgt in folgenden
      Schritten:<orderedlist>
          <listitem>
            <para>Suche des Datensatzes und erstellen einer entsprechenden
            Instanz</para>
          </listitem>

          <listitem>
            <para>Verändern der Werte</para>
          </listitem>

          <listitem>
            <para>Abspeichern des Datensatzes mit der Methode
            <methodname>save</methodname></para>
          </listitem>
        </orderedlist></para>

      <para>Wir suchen uns jetzt das Album mit dem Namen "The Beatles" und
      verändern den Namen in "Ein Test":<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>apfelmus = Album.where(:name =&gt; 'The Beatles').first</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:53:00"&gt; 
ruby-1.9.2-p0 &gt; <command>apfelmus.name = 'Ein Test'</command>
 =&gt; "Ein Test" 
ruby-1.9.2-p0 &gt; <command>apfelmus</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:53:00"&gt; 
ruby-1.9.2-p0 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:56:49"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>

    <section xml:id="activerecord_changed">
      <title xml:id="activerecord_changed.title">changed?</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>.changed?()</tertiary>
      </indexterm>

      <para>Wenn man sich nicht sicher ist, ob ein Datensatz verändert und
      noch nicht abgespeichert wurde, dann kann man dies mit der
      <methodname>changed?</methodname> Methode rausfinden:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>apfelmus = Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 19:56:49"&gt; 
ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>apfelmus.name = 'The Beatles'</command>
 =&gt; "The Beatles" 
ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>apfelmus.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>

    <section xml:id="activerecord_update_attributes">
      <title
      xml:id="activerecord_update_attributes.title">update_attributes</title>

      <indexterm>
        <primary>ActiveRecord</primary>

        <secondary>Methoden</secondary>

        <tertiary>::update_attributes()</tertiary>
      </indexterm>

      <para>Mit der Methode <methodname>update_attributes</methodname> kann
      man verschiedene Attribute eines Objektes auf einmal ändern und danach
      automatisch direkt speichern.</para>

      <para>Setzen wir damit das Beispiel von <xref
      linkend="activerecord_einfaches_editieren" /> um:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>apfelmus = Album.where(:name =&gt; 'The Beatles').first</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:22:17"&gt; 
ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>apfelmus.update_attributes(:name =&gt; 'Ein Test')</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>apfelmus.changed?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:22:38"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Ein solches Update lässt sich auch direkt an eine
      <methodname>where</methodname> Methode anknüpfen und ist dann fast
      atomar:<screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Album.where(:name =&gt; 'Ein Test').first</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "Ein Test", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:22:38"&gt; 
ruby-1.9.2-p0 &gt; <command>Album.where(:name =&gt; 'Ein Test').first.update_attributes(:name =&gt; 'The Beatles')</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>Album.where(:name =&gt; 'Ein Test').first</command> 
 =&gt; nil 
ruby-1.9.2-p0 &gt; <command>Album.last</command>
 =&gt; #&lt;Album id: 10, position: 10, name: "The Beatles", release_year: 1968, created_at: "2010-10-08 19:53:00", updated_at: "2010-10-08 20:24:41"&gt; 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>

      <para>Das es aber doch noch zwei SQL-Befehle sind zeigt sich in der
      <filename>log/development.log</filename>:<programlisting>  Album Load (0.3ms)  SELECT "albums".* FROM "albums" WHERE ("albums"."name" = 'Ein Test') LIMIT 1
  SQL (0.3ms)  UPDATE "albums" SET "name" = 'The Beatles', "updated_at" = '2010-10-08 20:24:41.644808' WHERE ("albums"."id" = 10)
</programlisting></para>
    </section>

    <section xml:id="activerecord_locking">
      <title xml:id="activerecord_locking.title">Locking</title>

      <para>Per Default benutzt Rails Optimistisches Locking der Datensätze.
      Dies kann aber umgeschaltet werden. Da für die meisten User
      Optimistisches Locking optimal ist und viele vor diesem Absatz nicht mal
      über das Problem nachgedacht haben, werde ich nicht weiter drauf
      eingehen, sondern auf die ri Hilfe verweisen. Wer pessimistisches
      Locking benötigt, der findet dort die notwendigen Schalter.</para>

      <para><screen>stefan@swmbp 0 1.9.2-p0 jukebox$ <command>ri -T ActiveRecord::Locking::Optimistic</command>
ActiveRecord::Locking::Optimistic

(from gem activerecord-3.0.0)
------------------------------------------------------------------------------
What is Optimistic Locking

Optimistic locking allows multiple users to access the same record for edits,
and assumes a minimum of conflicts with the data.  It does this by checking
whether another process has made changes to a record since it was opened, an
ActiveRecord::StaleObjectError is thrown if that has occurred and the update
is ignored.

Check out ActiveRecord::Locking::Pessimistic for an alternative.

Usage

Active Records support optimistic locking if the field lock_version is
present.  Each update to the record increments the lock_version column and the
locking facilities ensure that records instantiated twice will let the last
one saved raise a StaleObjectError if the first was also updated. Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.first_name = "should fail"
  p2.save # Raises a ActiveRecord::StaleObjectError

Optimistic locking will also check for stale data when objects are destroyed. 
Example:

  p1 = Person.find(1)
  p2 = Person.find(1)

  p1.first_name = "Michael"
  p1.save

  p2.destroy # Raises a ActiveRecord::StaleObjectError

You're then responsible for dealing with the conflict by rescuing the
exception and either rolling back, merging, or otherwise apply the business
logic needed to resolve the conflict.

You must ensure that your database schema defaults the lock_version column to
0.

This behavior can be turned off by setting
ActiveRecord::Base.lock_optimistically = false. To override the name of
the lock_version column, invoke the set_locking_column method. This
method uses the same syntax as set_table_name

------------------------------------------------------------------------------
Instance methods:

  attributes_from_column_definition


stefan@swmbp 0 1.9.2-p0 jukebox$ </screen></para>
    </section>
  </section>

  <section xml:id="activerecord_has_many">
    <title xml:id="activerecord_has_many.title">has_many - 1:n
    Verknüpfung</title>

    <para>Um has_many zu erklären erstellen wir uns ein Mini Telefonbuch. In
    diesem Telefonbuch gibt es ein Model mit Personen und ein Model mit
    Telefonnummern. Da jede Person mehrere Telefonnummern haben kann (z.B.
    Handy, Arbeit und Zuhause) benötigen wir zum Abbilden eine 1:n
    Verknüpfung. Mal schauen wie einfach das ganze mit ActiveRecord
    ist.</para>

    <para>Erstellen wir als erstes die Rails Applikation:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new phonebook</command>
      create  
      create  README
      <replaceable>[...]</replaceable>
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd phonebook</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
<replaceable>[...]</replaceable>
Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Jetzt legen wir die Personen Datenbank an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model person firstname:string lastname:string</command>
      invoke  active_record
      create    db/migrate/20101008205425_create_people.rb
      create    app/models/person.rb
      invoke    test_unit
      create      test/unit/person_test.rb
      create      test/fixtures/people.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <important>
      <para>Haben Sie gesehen wie Rails automatisch den Plural von person
      (nämlich people) genommen hat?</para>
    </important>

    <para>Und zum Schluss legen wir noch die Datenbank für die Telefonnummern
    an. In dieser benötigen wir ein Zuordnungsfeld zur Hauptdatenbank. Dieser
    Foreign-Key wird per Default immer als Name der Datenbank plus einem
    <literal>_id</literal> gesetzt:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model phonenumber person_id:integer name:string number:string</command>
      invoke  active_record
      create    db/migrate/20101008205906_create_phonenumbers.rb
      create    app/models/phonenumber.rb
      invoke    test_unit
      create      test/unit/phonenumber_test.rb
      create      test/fixtures/phonenumbers.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Danach ein <command>rake db:migrate</command> ausführen, damit die
    Datenbanken auch angelegt werden:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0013s
==  CreatePeople: migrated (0.0014s) ==========================================

==  CreatePhonenumbers: migrating =============================================
-- create_table(:phonenumbers)
   -&gt; 0.0018s
==  CreatePhonenumbers: migrated (0.0020s) ====================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Schauen wir uns das mal auf der Console an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>Phonenumber</command>
 =&gt; Phonenumber(id: integer, person_id: integer, name: string, number: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Die zwei Datenbanken sind eingerichtet und können mit ActiveRecord
    benutzt werden. Allerdings weiß ActiveRecord noch nichts von der 1:n
    Beziehung der beiden. Das ist aber recht einfach in zwei Schritten
    realisierbar:<itemizedlist>
        <listitem>
          <para>Wir fügen die <code>has_many</code> Option in die Model-Datei
          <filename>app/models/person.rb</filename> ein:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers
end</programlisting></para>
        </listitem>

        <listitem>
          <para>Im zweiten Schritt fügen wir in der Model-Datei
          <filename>app/models/phonenumber.rb</filename> die
          <code>belongs_to</code> Option ein:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
end</programlisting></para>
        </listitem>
      </itemizedlist></para>

    <para>Diese zwei einfachen Einträge generieren jetzt eine ganze Menge
    Rails-Magie.</para>

    <section xml:id="activerecord_1n_erstellen">
      <title xml:id="activerecord_1n_erstellen.title">Datensätze
      erstellen</title>

      <para>Wir wollen in diesem Beispiel für Fritz Meier seine Handy-Nummer
      (0171-12345678), seine Büro-Nummer (030-7777777) und seine
      Privat-Festnetznummer (030-8888888) abspeichern.</para>

      <section xml:id="activerecord_hinzufuegen_manuell">
        <title xml:id="activerecord_hinzufuegen_manuell.title">Manuell</title>

        <para>Wir löschen die Datenbank und erstellen erst ein Objekt mit den
        Person-Daten. Dann merken wir uns die ID für diesen Datensatz und
        erstellen danach die drei Telefonnummern-Datensätze mit dieser ID im
        Feld <literal>person_id</literal>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0039s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0033s
-- initialize_schema_migrations_table()
   -&gt; 0.0060s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0043s
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_handy = Phonenumber.create(:person_id =&gt; 1, :name =&gt; 'Mobile', :number =&gt; '0171-12345678')</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_office = Phonenumber.create(:person_id =&gt; 1, :name =&gt; 'Office', :number =&gt; '030-7777777')</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_home = Phonenumber.create(:person_id =&gt; 1, :name =&gt; 'Home', :number =&gt; '030-8888888')</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Die person_id von Hand einzutragen ist natürlich sehr
        fehleranfällig. Das gleiche Ergebnis könnten wir auch einen Tick
        schöner mit <literal>fritz.id</literal> realisieren:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_handy = Phonenumber.create(:person_id =&gt; fritz.id, :name =&gt; 'Mobile', :number =&gt; '0171-12345678')</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_office = Phonenumber.create(:person_id =&gt; fritz.id, :name =&gt; 'Office', :number =&gt; '030-7777777')</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_home = Phonenumber.create(:person_id =&gt; fritz.id, :name =&gt; 'Home', :number =&gt; '030-8888888')</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:28:42", updated_at: "2010-10-09 10:28:42"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:35:09", updated_at: "2010-10-09 10:35:09"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:35:45", updated_at: "2010-10-09 10:35:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:36:29", updated_at: "2010-10-09 10:36:29"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Immer noch nicht super praktisch, oder? Nur Geduld! ;-)</para>
      </section>

      <section xml:id="activerecord_hinzufuegen_create">
        <title xml:id="activerecord_hinzufuegen_create.title">create</title>

        <para>Jetzt versuchen wir das gleiche wie in <xref
        linkend="activerecord_hinzufuegen_manuell" />, aber benutzen diesmal
        ein wenige ActiveRecord Magie. Wir können mit der Methode
        <methodname>phonenumbers.create</methodname>
        (<methodname>phonenumbers</methodname> im Plural, weil ja 1 zu many =
        mehrere) zu jedem Person Objekt neue Telefonnummern hinzufügen. Diese
        werden automagisch korrekt mit der <literal>person_id</literal>
        bestückt:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:54:12", updated_at: "2010-10-09 10:54:12"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_handy = fritz.phonenumbers.create(:name =&gt; 'Mobile', :number =&gt; '0171-12345678')</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:54:58", updated_at: "2010-10-09 10:54:58"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_office = fritz.phonenumbers.create(:name =&gt; 'Office', :number =&gt; '030-7777777')</command>
 =&gt; #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:56:35", updated_at: "2010-10-09 10:56:35"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_home = fritz.phonenumbers.create(:name =&gt; 'Home', :number =&gt; '030-8888888')</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:57:21", updated_at: "2010-10-09 10:57:21"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 10:54:12", updated_at: "2010-10-09 10:54:12"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 10:54:58", updated_at: "2010-10-09 10:54:58"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 10:56:35", updated_at: "2010-10-09 10:56:35"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 10:57:21", updated_at: "2010-10-09 10:57:21"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Es geht sogar noch kürzer, da <methodname>create</methodname>
        auch ein Array von Hashes aktzeptiert. Wir können also alle
        Telefonnummer mit einer Zeile eintragen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:04:39", updated_at: "2010-10-09 11:04:39"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.create([{:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, {:name =&gt; 'Office', :number =&gt; '030-7777777'}, {:name =&gt; 'Home', :number =&gt; '030-8888888'}])</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:04:39", updated_at: "2010-10-09 11:04:39"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:05:45", updated_at: "2010-10-09 11:05:45"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Ich ahne was Sie sich jetzt fragen: "Geht es noch kürzer?".
        Klar: Wir können ja auch alles direkt in eine Zeile schreiben:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([{:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, {:name =&gt; 'Office', :number =&gt; '030-7777777'}, {:name =&gt; 'Home', :number =&gt; '030-8888888'}])</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.all</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 11:13:43", updated_at: "2010-10-09 11:13:43"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
      </section>

      <section xml:id="activerecord_hinzufuegen_build">
        <title xml:id="activerecord_hinzufuegen_build.title">build</title>

        <para>Die Methode <methodname>build</methodname> ähnelt der
        <methodname>create</methodname> Methode. Allerdings wird der Datensatz
        nicht abgespeichert. Dies erfolgt erst nach einem
        <methodname>save</methodname>:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
<replaceable>[...]</replaceable>
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier')</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 14:40:38", updated_at: "2010-10-09 14:40:38"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_handy = fritz.phonenumbers.build(:name =&gt; 'Mobile', :number =&gt; '0171-12345678')</command>
 =&gt; #&lt;Phonenumber id: nil, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: nil, updated_at: nil&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_handy.new_record?</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>fritz_handy.save</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>fritz_handy.new_record?</command>
 =&gt; false 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <warning>
          <para>Im Gegensatz zu <methodname>create</methodname> kann man mit
          build natürlich nicht eine Mutter und eine Elterninstanz mit jeweils
          einem <methodname>build</methodname> aufbauen. Das führt zu einem
          Fehler. Die Elterninstanz muss immer bereits existieren bzw. mit
          <methodname>create</methodname> erstellt werden. Beispiel:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.build(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.build([{:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, {:name =&gt; 'Office', :number =&gt; '030-7777777'}, {:name =&gt; 'Home', :number =&gt; '030-8888888'}])</command>
 NoMethodError: undefined method `build' for #&lt;Class:0x00000102c06018&gt;
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/activerecord-3.0.0/lib/active_record/base.rb:1016:in `method_missing'
 from (irb):2
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands/console.rb:44:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands/console.rb:8:in `start'
 from /Users/stefan/.rvm/gems/ruby-1.9.2-p0/gems/railties-3.0.0/lib/rails/commands.rb:23:in `&lt;top (required)&gt;'
 from script/rails:6:in `require'
 from script/rails:6:in `&lt;main&gt;'
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
        </warning>
      </section>
    </section>

    <section xml:id="activerecord_1n_zugreifen">
      <title xml:id="activerecord_1n_zugreifen.title">Auf Datensätze
      zugreifen</title>

      <para>Dafür brauchen wir Beispieldaten. Deshalb füllen Sie bitte die
      Datei <filename>db/seeds.rb</filename> mit folgendem
      Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Das praktische an der 1:n Zuordnung in ActiveRecord ist der super
      einfache Zugang zu den n-Instanzen. Schauen wir uns das mal für den
      ersten Datensatz an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers.class</command>
 =&gt; Array 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Ist das cool?! Daran freue ich mich jedes mal wieder aufs neue.
      Man kann einfach durch die Pluralform des n-Models auf die Datensätze
      zugreifen. Das Ergebnis wird als Array ausgegeben. Ob es auch andersrum
      geht? Schauen wir uns mal die erste Telefonnummer an:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.first.person</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.first.person.class</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Bingo! Auch ist ist der Zugriff zur zugeordneten Person-Klasse
      ganz einfach. Und da es sich nur um einen Datensatz handelt, wird hier
      die Singularform genommen.</para>

      <para>Und wenn ein Datensatz keine Telefonnummern hat? Schauen wir doch
      mal bei Herrn Udelhoven rein:<screen>ruby-1.9.2-p0 &gt; <command>udelhoven = Person.where(:lastname =&gt; 'Udelhoven').first</command>
 =&gt; #&lt;Person id: 4, firstname: nil, lastname: "Udelhoven", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; <command>udelhoven.phonenumbers</command>
 =&gt; [] 
ruby-1.9.2-p0 &gt; <command>udelhoven.phonenumbers.count</command>
 =&gt; 0 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Da zu diesem Datensatz keine Telefonnummern zugeordnet werden
      können, gibt <methodname>phonenumbers</methodname> ein leeres Array
      aus.</para>

      <para>Der Vollständigkeit halber müssten wir jetzt auch schauen was
      passiert, wenn zu einer Telefonnummer keine Person zuzuordnen
      ist:<screen>ruby-1.9.2-p0 &gt; <command>karteileiche = Phonenumber.create(:name =&gt; 'Auskunft', :number =&gt; '11833')</command>
 =&gt; #&lt;Phonenumber id: 8, person_id: nil, name: "Auskunft", number: "11833", created_at: "2010-10-09 20:29:38", updated_at: "2010-10-09 20:29:38"&gt; 
ruby-1.9.2-p0 &gt; <command>karteileiche.person</command>
 =&gt; nil 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Dieser neue Datensatz hatte keinen Eintrag (also
      <literal>nil</literal>) in der Spalte <literal>person_id</literal> und
      konnte deshalb keiner Person zugeordnet werden. Entsprechend ist das
      Ergebnis von <methodname>person</methodname> auch
      <literal>nil</literal>.</para>
    </section>

    <section>
      <title>Datensätze suchen</title>

      <para>Zum Suchen brauchen wir wieder definierte Beispieldaten. Deshalb
      füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit
      folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Legen wir mal los. Als erstes schauen wir uns mal an, wie viele
      Personen in der Datenbank sind:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.count</command>
 =&gt; 5 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Und wie viele Telefonnummern?<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.count</command>
 =&gt; 7 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Die normalen Suchen kennen Sie bereits aus <xref
      linkend="queries" />. So können Sie mit <methodname>where</methodname>
      z.B. alle Meier Einträge suchen:<screen>ruby-1.9.2-p0 &gt; <command>Person.where(:lastname =&gt; 'Meier')</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 14:59:14", updated_at: "2010-10-09 14:59:14"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 14:59:14", updated_at: "2010-10-09 14:59:14"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <warning>
        <para>Bitte achten Sie immer darauf, das
        <methodname>where</methodname> als Ergebnis immer ein Array ausgibt.
        Wenn Sie den ersten Datensatz aus der Ergebnisliste benötigen, müssen
        Sie noch ein <methodname>first</methodname> anfügen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.where(:lastname =&gt; 'Meier').first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.where(:lastname =&gt; 'Meier').first.class</command>
 =&gt; Person(id: integer, firstname: string, lastname: string, created_at: datetime, updated_at: datetime) 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
      </warning>

      <para>Aber in dem 1:n Kontext ist es natürlich interessanter
      verschachtelt zu suchen. Dazu gibt es verschiedene Möglichkeiten.</para>

      <section xml:id="activerecord_1n_joins">
        <title xml:id="activerecord_1n_joins.title">joins</title>

        <para>Wie können wir alle Personen rausfinden, die in unserer
        Datenbank eine Handynummer abgespeichert haben? Das geht mit einem
        join. Damit können wir die beiden Modele auch in der Suche
        verknüpfen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'}).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Drei Personen haben eine Handynummer. Und das konnten wir mit
        einer Zeile Ruby-Code rausbekommen. Bonus-Punkt: Man kann diese Zeile
        auch sehr leicht lesen! Schauen wir uns zu dieser Abfrage noch gerade
        die <filename>log/development.log</filename> an:<programlisting>  Person Load (0.3ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</programlisting></para>

        <para>Die Methode <methodname>joins</methodname> führt also zu einem
        SQL "INNER JOIN".</para>

        <para>Aber wir haben noch einen kleinen Denkfehler gemacht. Was ist
        wenn jemand zwei Handynummern in der Datenbank gespeichert hat? Wird
        diese Person dann doppelt gezählt? Probieren wir mal eine Suche nach
        allen Personen, die eine Handynummer und eine Privatnummer gespeichert
        haben aus.<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).count</command>
 =&gt; 6 
ruby-1.9.2-p0 &gt; <command>Person.count</command>
 =&gt; 5 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Tatsächlich! Obwohl wir nur 5 Personen in der Datenbank haben,
        gibt unser Logikfehler 6 Personen als Ergebnis aus. Aber kein Problem!
        Das Ergebnis unserer Abfrage ist ein Array und in einem Array können
        wir mit der Methode <methodname>uniq</methodname> alle doppelten
        Einträge löschen:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).uniq</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; ['Mobile', 'Home']}).uniq.count</command>
 =&gt; 4 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Tatsächlich haben also nur 4 Personen in unserer Datenbank eine
        Handynummer oder eine Privatnummer gespeichert.</para>

        <para>Über den gleichen <methodname>joins</methodname> Mechanismus
        können wir auch alle Personen, die mit Nachnamen 'Meier' heissen und
        eine Handynummer haben abfragen:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'}).count</command>
 =&gt; 1 
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:lastname =&gt; 'Meier', :phonenumbers =&gt; {:name =&gt; 'Mobile'}).first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; </screen></para>

        <para>Es gibt nur eine Person, auf die diese Suchkriterien
        zutreffen.</para>

        <para>Als letztes suchen wir jetzt mal alle Personen mit einer
        Berliner (030 Vorwahl) Rufnummer raus:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where("phonenumbers.number like ?", '030-%').uniq.count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt; </screen></para>

        <para>Natürlich können wir das ganze auch umdrehen. Lassen Sie uns mal
        alle Telefonnummern aus Berlin (030 Vorwahl) raussuchen, deren Person
        mit Nachnamen 'Meier' heißt:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where("number like ?", '030-%').where(:people =&gt; {:lastname =&gt; 'Meier'})</command>
 =&gt; [#&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where("number like ?", '030-%').where(:people =&gt; {:lastname =&gt; 'Meier'}).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Der <methodname>uniq</methodname> Trick klappt hier übrigens
        nicht:<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.joins(:person).where("number like ?", '030-%').where(:people =&gt; {:lastname =&gt; 'Meier'}).uniq.count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Bei der Personensuche konnte wir <methodname>uniq</methodname>
        auf das Ergebnis-Array sinnvoll ausführen, weil die einzelnen Personen
        doppelt im Array waren. Hier haben wir zwar bei den Phonenumber
        Datensätzen 3 und 4 die gleiche Telefonnummer '030-8888888', aber es
        sich halt verschiedene Datensätze. Man muss halt immer auch noch
        mitdenken. ;-)</para>
      </section>

      <section>
        <title>includes</title>

        <para>includes ähneln sehr joins (siehe <xref
        linkend="activerecord_1n_joins" />). Auch mit Ihnen kann man innerhalb
        einer 1:n Verknüpfung suchen. Schauen wir uns mal das "Wir suchen alle
        Personen mit einer Handynummer."-Beispiel mit
        <methodname>includes</methodname> und mit
        <methodname>joins</methodname> an:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Die Ergebnisse sind identisch, oder?<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'}).all == Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'}).all</command>
 =&gt; true 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Ja, die Ergebnisse sind identisch. Aber vielleicht haben Sie
        gemerkt, das ich bei beiden Anfragen ein <methodname>all</methodname>
        eingeschmuggelt habe. Schauen wir uns einmal den <code>==</code>
        Vergleich der beiden <classname>ActiveRecord::Relation</classname>
        an:<screen>ruby-1.9.2-p0 &gt; <command>Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'}) == Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
 =&gt; false 
ruby-1.9.2-p0 &gt;</screen></para>

        <para>Es handelt sich also um zwei verschiedene Abfragen, die das
        gleiche Ergebnis liefern. Da hilft nur ein Blick in die
        <filename>log/development.log</filename>. Als erstes die Ausgabe von
        <methodname>joins</methodname>:<programlisting>  Person Load (0.2ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</programlisting></para>

        <para>Und jetzt die <filename>log/development.log</filename> Ausgabe
        des includes:<programlisting>  Person Load (0.3ms)  SELECT "people"."id" AS t0_r0, "people"."firstname" AS t0_r1, "people"."lastname" AS t0_r2, "people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "phonenumbers"."id" AS t1_r0, "phonenumbers"."person_id" AS t1_r1, "phonenumbers"."name" AS t1_r2, "phonenumbers"."number" AS t1_r3, "phonenumbers"."created_at" AS t1_r4, "phonenumbers"."updated_at" AS t1_r5 FROM "people" LEFT OUTER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</programlisting></para>

        <para>Ich erspare Ihnen das Rätselraten:
        <methodname>joins</methodname> liest nur die <literal>people</literal>
        Datensätze ein und <methodname>includes</methodname> liest auch noch
        die dazu gehörigen <literal>phonenumbers</literal>. Schon bei unserem
        kleinen Beispiel sieht man das dies natürlich länger dauert.</para>

        <para>Warum kann der Einsatz von <methodname>includes</methodname>
        dann überhaupt Sinn machen? Wenn Sie schon bei dieser Abfrage wissen,
        das Sie alle Telefonnummern ebenfalls benötigen, dann macht ein
        <methodname>includes</methodname> Sinn, da dann nur eine
        Datenbankanfrage gestellt wird. ActiveRecord cached nämlich die
        Antwort.</para>

        <para>Ich zeige Ihnen das mal an einem Beispiel. Wir werden wieder
        alle Meiers mit einem Handy raussuchen und dann alle Handynummern
        ausgeben. Zur besseren Analyse der SQL-Abfragen, werden wir mit
        <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command> alle
        Ausgabe die normalerweise nur in
        <filename>log/development.log</filename> landen direkt auf der Console
        ausgeben. Als erstes die <methodname>joins</methodname>
        Variante:<screen>ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.logger = Logger.new(STDOUT)</command>
 =&gt; #&lt;Logger:0x00000102d3a308 @progname=nil, @level=0, @default_formatter=#&lt;Logger::Formatter:0x00000102d3a2e0 @datetime_format=nil&gt;, @formatter=nil, @logdev=#&lt;Logger::LogDevice:0x00000102d3a290 @shift_size=nil, @shift_age=nil, @filename=nil, @dev=#&lt;IO:&lt;STDOUT&gt;&gt;, @mutex=#&lt;Logger::LogDevice::LogDeviceMutex:0x00000102d3a268 @mon_owner=nil, @mon_count=0, @mon_mutex=#&lt;Mutex:0x00000102d3a218&gt;&gt;&gt;&gt; 
ruby-1.9.2-p0 &gt; <command>handybesitzer = Person.joins(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
<emphasis>  Person Load (0.2ms)  SELECT "people".* FROM "people" INNER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</emphasis> =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>handybesitzer.each do |einzelperson|</command>
ruby-1.9.2-p0 &gt;     <command>puts einzelperson.phonenumbers.first.number</command>
ruby-1.9.2-p0 ?&gt;  <command>end</command>
<emphasis>  Phonenumber Load (0.3ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
</emphasis>0171-12345678
<emphasis>  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 3) LIMIT 1
</emphasis>0171-1188811
<emphasis>  Phonenumber Load (0.1ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 5) LIMIT 1
</emphasis>0172-22225678
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; </screen></para>

        <para>Wir haben für die Ausgabe aller Handynummern insgesamt 4
        SQL-Abfragen gemacht und die brauchten in der Summe 0.8ms Zeit. Jetzt
        machen wir das gleiche Beispiel mal mit
        <methodname>includes</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>handybesitzer = Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:name =&gt; 'Mobile'})</command>
<emphasis>  Person Load (0.3ms)  SELECT "people"."id" AS t0_r0, "people"."firstname" AS t0_r1, "people"."lastname" AS t0_r2, "people"."created_at" AS t0_r3, "people"."updated_at" AS t0_r4, "phonenumbers"."id" AS t1_r0, "phonenumbers"."person_id" AS t1_r1, "phonenumbers"."name" AS t1_r2, "phonenumbers"."number" AS t1_r3, "phonenumbers"."created_at" AS t1_r4, "phonenumbers"."updated_at" AS t1_r5 FROM "people" LEFT OUTER JOIN "phonenumbers" ON "phonenumbers"."person_id" = "people"."id" WHERE ("phonenumbers"."name" = 'Mobile')
</emphasis> =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>handybesitzer.each do |einzelperson|</command>
ruby-1.9.2-p0 &gt;     <command>puts einzelperson.phonenumbers.first.number</command>                 
ruby-1.9.2-p0 ?&gt;  <command>end</command>                                                           
0171-12345678
0171-1188811
0172-22225678
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 3, firstname: "Horst", lastname: "Apfelmus", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Person id: 5, firstname: "Ernst", lastname: "Steinwurf", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

        <para>Hier haben wir nur eine SQL-Abfrage die 0.3ms gedauert hat. Die
        erste SQL-Abfrage dauert also länger, dafür spart man sich aber
        nachfolgende.</para>

        <para>Wäre es dann nicht besser immer mit
        <methodname>includes</methodname> zu arbeiten? Nein, es kommt immer
        auf den konkreten Fall an. Denn bei der Benutzung von includes werden
        ja initial viel mehr Daten transportiert. Die müssen von Ruby gecached
        und verarbeitet werden. Bei unserer kleinen Datenbank ist das egal.
        Aber stellen Sie sich das ganze mal mit allen Handynummern
        Deutschlands vor. Das ist eine Datenmenge, die man nicht unbedingt
        cachen will.</para>
      </section>
    </section>

    <section xml:id="has_many_delete" xml:lang="">
      <title xml:id="has_many_delete.title">delete und destroy</title>

      <para>Mit den Methoden <methodname>destroy</methodname>,
      <methodname>destroy_all</methodname>, <methodname>delete</methodname>
      und <methodname>delete_all</methodname> kann man wie in <xref
      linkend="datensatz-loeschen" /> beschrieben Datensätze löschen. Im
      Kontext von <methodname>has_many</methodname> bedeutet das, das man die
      zu einer <classname>Person</classname> gelisteten
      <classname>Phonenumber</classname>-Datensätze in einem Streich löschen
      kann:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers.destroy_all</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 20:20:23", updated_at: "2010-10-09 20:20:23"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>
    </section>

    <section xml:id="activerecord_1n_optionen">
      <title xml:id="activerecord_1n_optionen.title">Optionen</title>

      <para>Ich will an dieser Stelle nicht auf alle möglichen Optionen
      eingehen. Aber ein paar sind so praktisch und werden von mir in jedem
      Projekt benutzt, das ich sie hier vorstellen möchte. Für alle anderen
      verweise ich auf die Ruby on Rails Doku die Sie im Internet unter <uri
      xlink:href="http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://rails.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
      bzw. auf Ihrem System mit <command>ri
      ActiveRecord::Associations::ClassMethods</command> auf der Shell abrufen
      können.</para>

      <section>
        <title>has_many</title>

        <para>Die meiner Meinung nach wichtigsten Optionen für
        <code>has_many</code>:<itemizedlist>
            <listitem>
              <para><code>:order =&gt; :apfelmus</code></para>

              <para>Wer die Telefonnummern nach den Namen sortieren will, kann
              dies mit folgender <filename>app/models/person.rb</filename>
              erreichen:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :order =&gt; :name
end</programlisting></para>

              <para>Das Ergebnis in der Console sieht dann so aus:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;, #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-09 22:27:37", updated_at: "2010-10-09 22:27:37"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

              <para>Und falls es einmal umgekehrt sortiert werden
              sollte:<programlisting>has_many :phonenumbers, :order =&gt; 'name DESC'
</programlisting></para>
            </listitem>

            <listitem>
              <para><code>:dependent =&gt; :destroy</code></para>

              <para>Wird eine Person gelöscht wird, dann ist es ja nur
              sinnvoll, das auch alle Telefonnummern dieser Person automatisch
              mitgelöscht werden. Das kann mit <code>:dependent =&gt;
              :destroy</code> in der <filename>app/models/person.rb</filename>
              realisiert werden:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
end</programlisting></para>

              <para>Im folgenden Beispiel löschen wir die erste Person in der
              Datenbank. Dadurch werden automatisch alle Telefonnummern dieser
              Person mitgelöscht:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 22:27:36", updated_at: "2010-10-09 22:27:36"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 1).count</command>
 =&gt; 3 
ruby-1.9.2-p0 &gt; <command>Person.first.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-09 22:27:36", updated_at: "2010-10-09 22:27:36"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 1).count</command>
 =&gt; 0 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

              <important>
                <para>Bitte denken Sie immer an den Unterschied zwischen den
                Methoden <methodname>destroy</methodname> (siehe <xref
                linkend="activerecord_destroy" />) und
                <methodname>delete</methodname> (siehe <xref
                linkend="activerecord_delete" />). Diese Abhängigkeit
                funktioniert nur mit der <methodname>destroy</methodname>
                Methode.</para>
              </important>
            </listitem>
          </itemizedlist></para>

        <para>Es gibt natürlich noch eine Menge anderer Optionen. Diese können
        Sie sich mit <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command> auf der
        Shell ausgeben lassen.</para>
      </section>

      <section>
        <title>belongs_to</title>

        <para>Die meiner Meinung nach wichtigste Option für
        <methodname>belongs_to</methodname> ist:<itemizedlist>
            <listitem>
              <para><code>:touch =&gt; :true</code></para>

              <para>Damit wird bei einer Veränderung einer
              <classname>Phonenumber</classname> automatisch das Feld
              <literal>updated_at</literal> der Primary Datenbank
              <classname>People</classname> auf die aktuelle Uhrzeit gesetzt.
              Das sähe in der <filename>app/models/phonenumber.rb</filename>
              so aus:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person, :touch =&gt; :true
end</programlisting></para>
            </listitem>
          </itemizedlist></para>

        <para>Auch hier sollten Sie einmal auf die Liste aller möglichen
        Optionen einen kurzen Blick werfen. Dazu in der Shell <command>ri
        ActiveRecord::Associations::ClassMethods#belongs_to</command>
        aufrufen.</para>
      </section>
    </section>

    <section xml:id="activerecord_has_many_through">
      <title xml:id="activerecord_has_many_through.title">has_many
      through</title>

      <para>Zum Erklären von has_many through müssen wir unser Datenbank Model
      erweitern. Nehmen wir einmal an, das wir jeden Anruf mit Start- und
      Endzeit protokolieren. Das wäre dann eine 1:n Verknüpfung von
      <classname>Phonenumber</classname> auf ein
      <classname>CallRecord</classname>. Erstellen wir erst mal ein
      entsprechendes Model:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model CallRecord phonenumber_id:integer start:datetime end:datetime</command>
      invoke  active_record
      create    db/migrate/20101011071702_create_call_records.rb
      create    app/models/call_record.rb
      invoke    test_unit
      create      test/unit/call_record_test.rb
      create      test/fixtures/call_records.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Die Datenbank-Tabelle anlegen:<screen>stefan@swmbp 1 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateCallRecords: migrating ==============================================
-- create_table(:call_records)
   -&gt; 0.0013s
==  CreateCallRecords: migrated (0.0013s) =====================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Die <filename>app/models/phonenumber.rb</filename> muss noch
      angepasst werden:<programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  has_many :call_records
end</programlisting></para>

      <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
      brauchbaren Testdaten an:<programlisting>Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
             
Phonenumber.all.each do |phonenumber|
  (1..(Phonenumber.count - phonenumber.id)).each do |zaehler|
    phonenumber.call_records.create(:start =&gt; Time.now, :end =&gt; Time.now + zaehler.minutes)
  end
end</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 1 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("call_records", {:force=&gt;true})
   -&gt; 0.0075s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0079s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0074s
-- initialize_schema_migrations_table()
   -&gt; 0.0003s
-- assume_migrated_upto_version(20101011071702, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>So, dann schauen wir uns jetzt mal an, wie oft Herr Fritz Meier
      die erste Nummer in seinem Telefonbuch angerufen hat:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first.call_records</command>
 =&gt; [#&lt;CallRecord id: 1, phonenumber_id: 1, start: "2010-10-11 07:36:12", end: "2010-10-11 07:37:12", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt;, #&lt;CallRecord id: 2, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:38:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 3, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:39:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 4, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:40:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 5, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:41:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 6, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:42:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;] 
ruby-1.9.2-p0 &gt; <command>fritz.phonenumbers.first.call_records.count</command>
 =&gt; 6 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Im <filename>log/development.log</filename> schauen wir uns die
      letzten zwei Anfragen noch mal genau an:<programlisting>  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
  CallRecord Load (0.2ms)  SELECT "call_records".* FROM "call_records" WHERE ("call_records".phonenumber_id = 1)

  Phonenumber Load (0.2ms)  SELECT "phonenumbers".* FROM "phonenumbers" WHERE ("phonenumbers".person_id = 1) LIMIT 1
  SQL (0.1ms)  SELECT COUNT(*) AS count_id FROM (SELECT 1 FROM "call_records" WHERE ("call_records".phonenumber_id = 1)) AS subquery
</programlisting></para>

      <para>Um jetzt eine Aufstellung von allen Telefonaten von Herrn Fritz
      Meier zu erhalten, müssten wir umständlich alle seine eingetragenen
      Rufnummern in einer Schleife abarbeiten. Das geht aber mit ActiveRecord
      auch einfacher. Bitte ändern Sie Ihre
      <filename>app/models/person.rb</filename> wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
<emphasis>  has_many :call_records, :through =&gt; :phonenumbers
</emphasis>end</programlisting></para>

      <para>Das schauen wir uns jetzt mal in der Console an. Es liegt die
      Vermutung nahe, das wir jetzt auch ein
      <methodname>call_records</methodname> Zugriff von der Klasse
      <classname>Person</classname> haben:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.first.call_records.limit(5)</command>
 =&gt; [#&lt;CallRecord id: 1, phonenumber_id: 1, start: "2010-10-11 07:36:12", end: "2010-10-11 07:37:12", created_at: "2010-10-11 07:36:12", updated_at: "2010-10-11 07:36:12"&gt;, #&lt;CallRecord id: 2, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:38:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 3, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:39:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 4, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:40:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;, #&lt;CallRecord id: 5, phonenumber_id: 1, start: "2010-10-11 07:36:13", end: "2010-10-11 07:41:13", created_at: "2010-10-11 07:36:13", updated_at: "2010-10-11 07:36:13"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.first.call_records.count</command>
 =&gt; 15 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Bingo! ActiveRecord übernimmt wieder die Schwerstarbeit und
      liefert uns das SQL (siehe
      <filename>log/development.log</filename>):<programlisting>  Person Load (0.2ms)  SELECT "people".* FROM "people" LIMIT 1
  CallRecord Load (0.3ms)  SELECT "call_records".* FROM "call_records" INNER JOIN "phonenumbers" ON "call_records".phonenumber_id = "phonenumbers".id WHERE (("phonenumbers".person_id = 1)) LIMIT 5

  Person Load (0.3ms)  SELECT "people".* FROM "people" LIMIT 1
  SQL (0.2ms)  SELECT COUNT(*) AS count_id FROM "call_records" INNER JOIN "phonenumbers" ON "call_records".phonenumber_id = "phonenumbers".id WHERE (("phonenumbers".person_id = 1))
</programlisting></para>

      <para>Praktisch? Praktisch!</para>

      <para>Mehr Informationen und Beispiele zu has_many through finden Sie
      unter dem Stichwort "Many-to-many" auf <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri></para>
    </section>

    <section xml:id="activerecord_polymorphic">
      <title xml:id="activerecord_polymorphic.title">Polymorphic Association
      (Verknüpfungen)</title>

      <para>Schon das Wort "Polymorphic" lässt einen angespannt werden. Was
      mag damit gemeint sein? Auf <uri
      xlink:href="http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html">http://api.rubyonrails.org/classes/ActiveRecord/Associations/ClassMethods.html</uri>
      steht dazu: "Polymorphic associations on models are not restricted on
      what types of models they can be associated with." Na, das ist ja jetzt
      klar wir Klossbrühe! ;-)</para>

      <para>Ein Beispiel! Nehmen wir an, das wir zu den Personen und den
      Telefonnummern in unserer Applikation Kommentare einbauen wollen. Und
      zwar beliebig viele Kommentare. Mit dem Wissen aus <xref
      linkend="activerecord_has_many_through" /> könnten wir uns zwei Modelle
      anlegen und jeweils eine <methodname>has_many</methodname> Verbindung zu
      Person oder zu Phonenumber aufbauen. Bei zweien würde das sogar noch
      halbwegs praktikabel sein. Aber stellen Sie sich mal vor, Sie hätten
      gerne bei mehr Daten solche Kommentare. Dafür jedesmal ein eigenes Model
      bauen? Genau da kommt die Polymorphic Association zum tragen. Damit
      können Sie ein Model Comment mit beliebig vielen and Modellen
      verknüpfen.</para>

      <para>Erstellen wir erst mal das Model Comment:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails generate model Comment commentable_type:string commentable_id:integer comment:string</command>
      invoke  active_record
      create    db/migrate/20101011084411_create_comments.rb
      create    app/models/comment.rb
      invoke    test_unit
      create      test/unit/comment_test.rb
      create      test/fixtures/comments.yml
stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:migrate</command>
(in /Users/stefan/phonebook)
==  CreateComments: migrating =================================================
-- create_table(:comments)
   -&gt; 0.0013s
==  CreateComments: migrated (0.0013s) ========================================

stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Das "able" beim Namen "commentable" ist Rails-üblich, muss aber
      nicht sein. Wir brauchen ja zum Verknüpfen jetzt nicht nur die ID des
      Eintrages, sondern müssen auch noch wissen, um welches Model es sich
      eigentlich handelt. Da macht der Begriff "commentable_type" halbwegs
      Sinn.</para>

      <para>Jetzt müssen wir in <filename>app/models/comment.rb</filename>
      folgenden Eintrag machen:<programlisting>class Comment &lt; ActiveRecord::Base
  belongs_to :commentable, :polymorphic =&gt; true
end
</programlisting></para>

      <para>Jetzt den Eintrag in
      <filename>app/models/person.rb</filename><programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

      <para>Und noch den Eintrag in
      <filename>app/models/phonenumber.rb</filename><programlisting>class Phonenumber &lt; ActiveRecord::Base
  belongs_to :person
  
  has_many :comments, :as =&gt; :commentable
end</programlisting></para>

      <para>Und jetzt passen wir noch die <filename>db/seeds.rb</filename> mit
      brauchbaren Testdaten an:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

      <para>Die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:setup</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("comments", {:force=&gt;true})
   -&gt; 0.0053s
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0058s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0067s
-- initialize_schema_migrations_table()
   -&gt; 0.0004s
-- assume_migrated_upto_version(20101011084411, "db/migrate")
   -&gt; 0.0004s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Gehen wir mal in die Console und versuchen mal zwei Kommentare zu
      Herrn Fritz Meier anzulegen.<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz = Person.first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-11 09:00:51", updated_at: "2010-10-11 09:00:51"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 0 
ruby-1.9.2-p0 &gt; <command>fritz.comments.create(:comment =&gt; 'Ein Beispiel')</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz.comments.create(:comment =&gt; 'Noch ein Beispiel')</command>
 =&gt; #&lt;Comment id: 2, commentable_type: "Person", commentable_id: 1, comment: "Noch ein Beispiel", created_at: "2010-10-11 09:07:44", updated_at: "2010-10-11 09:07:44"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz.comments.count</command>
 =&gt; 2 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Das funktioniert also. Schauen wir uns mal den ersten Kommentar
      an:<screen>ruby-1.9.2-p0 &gt; <command>Comment.first</command>
 =&gt; #&lt;Comment id: 1, commentable_type: "Person", commentable_id: 1, comment: "Ein Beispiel", created_at: "2010-10-11 09:07:38", updated_at: "2010-10-11 09:07:38"&gt; 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Alles logisch. Alles gut. Aber so wie ich Sie einschätze wollen
      Sie jetzt auch sehen wie das mit Telefonnummern geht. Kein
      Problem.<screen>ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create(:comment =&gt; 'Und wieder ein Beispiel.')</command>
 =&gt; #&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments.create(:comment =&gt; 'xyz Beispiel')</command>
 =&gt; #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.first.comments</command>
 =&gt; [#&lt;Comment id: 3, commentable_type: "Phonenumber", commentable_id: 1, comment: "Und wieder ein Beispiel.", created_at: "2010-10-11 09:17:29", updated_at: "2010-10-11 09:17:29"&gt;, #&lt;Comment id: 4, commentable_type: "Phonenumber", commentable_id: 1, comment: "xyz Beispiel", created_at: "2010-10-11 09:18:06", updated_at: "2010-10-11 09:18:06"&gt;] 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Polymorphic Association sind sehr praktisch. Man sollte aber auch
      immer daran denken, das sie mehr Last auf der Datenbank erzeugen, als
      eine normale 1:n Abbildung. Normalerweise macht das den Bock nicht fett,
      aber man sollte es bei der Planung im Hinterkopf halten.</para>
    </section>
  </section>

  <section xml:id="datensatz-loeschen">
    <title>Einen Datensatz löschen</title>

    <para>Es gibt die Methoden <methodname>destroy</methodname> und
    <methodname>delete</methodname>, um Datensätze zu löschen. Diese Wortwahl
    empfinde ich als reichlich schwierig. Ich muss fast immer nachschlagen, um
    selbst sicher zu sein, welche Methode was macht.</para>

    <section xml:id="activerecord_destroy">
      <title xml:id="activerecord_destroy.title">destroy</title>

      <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
      löschen und dabei werden auch vorhandene Abhängigkeiten beachtet (siehe
      z.B. <code>:dependent =&gt; :destroy</code> in <xref
      linkend="activerecord_1n_optionen" />). Vereinfacht kann man sagen:
      "Lieber destroy nehmen, das ist sicherer, weil das Rails-System dann
      mehr mitdenkt."<important>
          <para>Die Instanz wird nach dem Löschen des Datenbankfeldes frozen
          (eingefroren). Sie ist also noch da, kann aber nicht verändert
          werden.</para>
        </important></para>

      <para>Für die Beispiele brauchen wir wieder definierte Daten. Deshalb
      füllen Sie bitte die Datei <filename>db/seeds.rb</filename> mit
      folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

      <para>Die Datei <filename>app/models/person.rb</filename> ändern Sie
      bitte wie folgt ab:<programlisting>class Person &lt; ActiveRecord::Base
  has_many :phonenumbers, :dependent =&gt; :destroy
end</programlisting></para>

      <para>Jetzt die Datenbank löschen und neu mit der
      <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Als erstes löschen wir Herrn Fritz Meier inklusive all seiner
      Telefonnummern:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>fritz_meier = Person.where(:lastname =&gt; 'Meier', :firstname =&gt; 'Fritz').first</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_meier.destroy</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.where(:lastname =&gt; 'Meier', :firstname =&gt; 'Fritz')</command>
  =&gt; [] 
ruby-1.9.2-p0 &gt; </screen></para>

      <para>Das war einfach. Was ist allerdings mit der Varible
      <literal>fritz_meier</literal>? Die existiert noch mit den Daten im
      sogenannten frozen-State. Zum Überprüfen gibt es die Methode
      <methodname>frozen?</methodname>:<screen>ruby-1.9.2-p0 &gt; <command>fritz_meier</command>
 =&gt; #&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 
ruby-1.9.2-p0 &gt; <command>fritz_meier.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 1, person_id: 1, name: "Mobile", number: "0171-12345678", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 2, person_id: 1, name: "Office", number: "030-7777777", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;, #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 
ruby-1.9.2-p0 &gt; <command>fritz_meier.frozen?</command>
 =&gt; true 
ruby-1.9.2-p0 &gt;</screen></para>

      <para>Der Datensatz ist also in der Datenbank gelöscht, aber das Objekt
      mit allen Daten ist noch im System vorhanden. Könnten wir damit den
      gesamten Datensatz wiederbeleben? Ja, allerdings ist das dann ein neuer
      Datensatz (er hat also nicht mehr die ID 1):<screen>ruby-1.9.2-p0 &gt; <command>Person.create(fritz_meier.attributes)</command>
 =&gt; #&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.where(:lastname =&gt; 'Meier', :firstname =&gt; 'Fritz')</command>
 =&gt; [#&lt;Person id: 6, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Jetzt fehlen allerdings noch die Telefonnummern. Die können Sie
      aber extra abspeichern (da sie ja noch im frozen Objekt vorhanden
      sind).</para>
    </section>

    <section xml:id="activerecord_delete">
      <title xml:id="activerecord_delete.title">delete</title>

      <para>Mit <methodname>delete</methodname> können Sie einen Datensatz
      direkt in der Datenbank löschen. Dabei werden keine Abhängigkeiten zu
      anderen Datensätzen im Model beachtet. Die Methode
      <methodname>delete</methodname> löscht also nur die eine Zeile in der
      Datenbank und sonst nichts.</para>

      <para>Löschen wir mal den Datensatz von Frau Meier:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.first</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 
ruby-1.9.2-p0 &gt; <command>Person.first.phonenumbers</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 
ruby-1.9.2-p0 &gt; <command>Person.first.delete</command>
 =&gt; #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt; 
ruby-1.9.2-p0 &gt; <command>Phonenumber.where(:person_id =&gt; 2)</command>
 =&gt; [#&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:54:36", updated_at: "2010-10-10 08:54:36"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

      <para>Es wird zwar der Datensatz von Frau Meier gelöscht, aber die
      Telefonnummern in der <classname>Phonenumber</classname> Datenbank
      bleiben als Karteileichen im System.</para>

      <para>Wie bei <methodname>destroy</methodname> geht das Objekt auch bei
      delete ein Objekt nach dem <methodname>delete</methodname> in den
      frozen-Status (siehe <xref linkend="activerecord_destroy" />).</para>
    </section>
  </section>

  <section xml:id="activerecord_transaction">
    <title xml:id="activerecord_transaction.title">Transaktionen
    (Transactions)</title>

    <indexterm>
      <primary>Transaktionen</primary>
    </indexterm>

    <indexterm>
      <primary>ActiveRecord</primary>

      <secondary>Transaktionen</secondary>

      <see>Transaktionen</see>
    </indexterm>

    <indexterm>
      <primary>Datenbank</primary>

      <secondary>Transaktionen</secondary>

      <see>Transaktionen</see>
    </indexterm>

    <para>Es gibt immer mal wieder Anwendungsgebiete, bei denen man eine
    Datenbank-Transaktion durchführen muss. Das klassische Beispiel dafür ist
    eine Geldbewegung von einem zu einem anderen Konto. Die macht nur Sinn,
    wenn beide Aktionen ausgeführt werden.</para>

    <para>Zum Zeigen einer Transaktion brauchen wir wieder definierte
    Beispieldaten. Deshalb füllen Sie bitte die Datei
    <filename>db/seeds.rb</filename> mit folgendem Inhalt:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Mayor.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Person.create(:firstname =&gt; 'Fritz', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-12345678'}, 
             {:name =&gt; 'Office', :number =&gt; '030-7777777'}, 
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Ute', :lastname =&gt; 'Meier').phonenumbers.create([
             {:name =&gt; 'Home', :number =&gt; '030-8888888'}])
Person.create(:firstname =&gt; 'Horst', :lastname =&gt; 'Apfelmus').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0171-1188811'}])
Person.create(:lastname =&gt; 'Udelhoven')
Person.create(:firstname =&gt; 'Ernst', :lastname =&gt; 'Steinwurf').phonenumbers.create([
             {:name =&gt; 'Mobile', :number =&gt; '0172-22225678'}, 
             {:name =&gt; 'Home', :number =&gt; '040-8888222'}])
</programlisting></para>

    <para>Jetzt die Datenbank löschen und neu mit der
    <filename>db/seeds.rb</filename> befüllen:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rake db:reset</command>
(in /Users/stefan/phonebook)
db/test.sqlite3 already exists
db/test.sqlite3 already exists
db/development.sqlite3 already exists
-- create_table("people", {:force=&gt;true})
   -&gt; 0.0035s
-- create_table("phonenumbers", {:force=&gt;true})
   -&gt; 0.0029s
-- initialize_schema_migrations_table()
   -&gt; 0.0047s
-- assume_migrated_upto_version(20101008205906, "db/migrate")
   -&gt; 0.0039s
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Eine Transaktion wird nach folgendem Muster
    durchgeführt:<programlisting>ActiveRecord::Base.transaction do
    was_immer_der_erste_schritt_ist
    was_immer_der_zweite_schritt_ist
    was_immer_der_dritte_schritt_ist
end</programlisting></para>

    <para>Herr und Frau Meier haben beide die gleiche Telefonnummer:<screen>stefan@swmbp 0 1.9.2-p0 phonebook$ <command>rails console</command>
Loading development environment (Rails 3.0.0)
ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:number =&gt; '030-8888888'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 
ruby-1.9.2-p0 &gt;</screen></para>

    <para>Jetzt wollen beide nach Hamburg umziehen und bekommen dort eine neue
    Telefonnummer. Jetzt wollen wir beim Ändern der Nummer sicher stellen, das
    beide Nummern sicher und in einer Transaktion geändert werden.</para>

    <para>Hier ist der Code dazu:</para>

    <para>Wenn wir in unserem Flugplan die Flugnummern des ersten und des
    zweiten Datensatzes austauschen wollen, dann wäre das auch ein klassischer
    Fall für eine Transaktion. An sonsten hätten wir bei einem Fehler zwei mal
    die gleiche Flugnummer in der Datenbank. Versuchen wir es einmal:<screen>ruby-1.9.2-p0 &gt; <command>Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:number =&gt; '030-8888888'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 
ruby-1.9.2-p0 &gt; <command>die_meiers = Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:number =&gt; '030-8888888'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 
ruby-1.9.2-p0 &gt; <command>herr_meier_telefon = die_meiers.first.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 3, person_id: 1, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt; 
ruby-1.9.2-p0 &gt; <command>frau_meier_telefon = die_meiers.last.phonenumbers.first</command>
 =&gt; #&lt;Phonenumber id: 4, person_id: 2, name: "Home", number: "030-8888888", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt; 
ruby-1.9.2-p0 &gt; <command>ActiveRecord::Base.transaction do</command>
ruby-1.9.2-p0 &gt;     <command>neue_nummer = '040-9999999'</command>
ruby-1.9.2-p0 ?&gt;  <command>herr_meier_telefon.number = neue_nummer</command>
ruby-1.9.2-p0 ?&gt;  <command>herr_meier_telefon.save</command>
ruby-1.9.2-p0 ?&gt;  <command>frau_meier_telefon.number = neue_nummer</command>
ruby-1.9.2-p0 ?&gt;  <command>frau_meier_telefon.save</command>
ruby-1.9.2-p0 ?&gt;  <command>end</command>
 =&gt; true 
ruby-1.9.2-p0 &gt; <command>die_meiers = Person.includes(:phonenumbers).where(:phonenumbers =&gt; {:number =&gt; '040-9999999'})</command>
 =&gt; [#&lt;Person id: 1, firstname: "Fritz", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;, #&lt;Person id: 2, firstname: "Ute", lastname: "Meier", created_at: "2010-10-10 08:21:57", updated_at: "2010-10-10 08:21:57"&gt;] 
ruby-1.9.2-p0 &gt; <command>exit</command>
stefan@swmbp 0 1.9.2-p0 phonebook$ </screen></para>

    <para>Beim Ende der Transaktion sehen wir dann in der
    <filename>log/development.log</filename> den entsprechenden
    Eintrag:<programlisting>  SQL (0.3ms)  UPDATE "phonenumbers" SET "number" = '040-9999999', "updated_at" = '2010-10-10 08:28:08.669155' WHERE ("phonenumbers"."id" = 3)
  SQL (0.1ms)  UPDATE "phonenumbers" SET "number" = '040-9999999', "updated_at" = '2010-10-10 08:28:08.678647' WHERE ("phonenumbers"."id" = 4)
</programlisting></para>

    <para>Da unsere Entwicklungsdatenbank SQLite keine Transaktionen
    unterstützt, sehen wir nur zwei normale SQL-Befehle.</para>

    <para>Jetzt werden Sie sagen "Ja, das hätte ich aber auch einfacher mit
    <methodname>update_attributes</methodname> realisieren können (siehe <xref
    linkend="activerecord_update_attributes" />)!" Meine Antwort darauf: Gut
    aufgepasst! Das hier ist ja nur ein Beispiel. ;-)</para>

    <para>Tansaktionen sind ein komplexes Thema. Wenn Sie mehr Informationen
    dazu suchen, können Sie die ri Hilfe dafür mit <command>ri
    ActiveRecord::Transactions::ClassMethods</command> auf der Shell
    abrufen.<important>
        <para>Die Methoden <methodname>save</methodname> und
        <methodname>destroy</methodname> werden automatisch in
        Transaktions-Wrapper ausgeführt. So stellt Rails sicher, das bei
        diesen Methoden kein undefinierter Zustand entsteht.</para>
      </important><warning>
        <para>Transaktionen werden nicht von jeder Datenbank nativ
        unterstützt. Bei unserem Beispiel oben sehen Sie, das SQLite es zum
        Beispiel nicht unterstützt. Meiner Meinung nach, schadet es nicht sie
        zu benutzen. Es kann ja sein, das die nächste Version Ihrer
        Lieblingsdatenbank Transaktionen unterstützt.</para>
      </warning></para>
  </section>

  <xi:include href="named_scope.xml" />

  <xi:include href="validation.xml" />

  <xi:include href="migration.xml" />
</chapter>
