<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="scaffolding"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="scaffolding.title">Scaffolding und REST</title>

  <indexterm>
    <primary>Scaffolding</primary>
  </indexterm>

  <indexterm>
    <primary>REST</primary>

    <secondary>Representational State Transfer</secondary>
  </indexterm>

  <indexterm>
    <primary>CRUD</primary>
  </indexterm>

  <section xml:id="scaffolding_einleitung">
    <title xml:id="scaffolding_einleitung.title">Einleitung</title>

    <para>In diesem Kapitel werden wir uns mit Scaffolding beschäftigen. Ich
    zeige Ihnen ein einfaches Scaffold und Sie müssen selbstständig das bisher
    angeeignete Wissen anwenden (sprich den Controller und die Views
    durcharbeiten).</para>

    <para>Scaffolding heißt nicht mehr, als dass per Generator ein Grundgerüst
    (<foreignphrase xml:lang="en">englisch: scaffold</foreignphrase>) für eine
    Applikation erstellt wird. Dieses Grundgerüst enthält nicht nur das
    <foreignphrase xml:lang="en">Model</foreignphrase>, sondern auch eine
    einfache Web-GUI (also <foreignphrase xml:lang="en">Views</foreignphrase>)
    und natürlich einen <foreignphrase
    xml:lang="en">Controller</foreignphrase>. Als Programmierparadigma wird
    hierfür REST (Representational State Transfer) benutzt.</para>

    <para>Eine Definition von REST finden Sie unter <uri
    xlink:href="http://de.wikipedia.org/wiki/Representational_State_Transfer">http://de.wikipedia.org/wiki/Representational_State_Transfer</uri>.
    Meine Super-Kurzversion: Der Erfinder Roy Fielding hat im Jahr 2000
    beschrieben, das man mit einem einfachen Regelwerk innerhalb der Idee von
    CRUD (siehe <uri
    xlink:href="http://de.wikipedia.org/wiki/CRUD">http://de.wikipedia.org/wiki/CRUD</uri>)
    und der Spezifikation des Hypertext-Transfer-Protokolls (HTTP) auf Daten
    zugreifen kann. Die Abkürzung CRUD steht für Create (SQL: INSERT), Read
    (SQL: SELECT), Update (SQL: UPDATE) und Delete (SQL: Delete). Dabei
    entstanden für Menschen gut lesbare URLs mit einer gewissen Logik. Sie
    werden in diesem Kapitel die einzelnen Pfade für die verschiedenen
    CRUD-Funktionen anhand von Beispielen sehen.</para>

    <para>Der meiner Meinung nach größte Teil des Frustes mit Rails entsteht
    regelmäßig dadurch, dass Anfänger ohne Ruby-Grundkenntnisse und ohne zu
    wissen, was ActiveRecord ist, mit Scaffolding schnell zu einem Ergebnis
    kommen, aber dann nicht weiterwissen. Da Sie aber <xref
    linkend="ruby-grundlagen"/>, <xref linkend="erste_schritte_mit_rails"/>
    und <xref linkend="activerecord_chapter"/> durchgearbeitet haben, werden
    Sie Scaffolding direkt verstehen und nutzen können.</para>

    <note>
      <para>Dieses Kapitel ist ein Einstieg in Scaffolding und keine alle
      Varianten abdeckende Enzyklopädie. Es geht um die Grundidee und ist eine
      Einleitung für Anfänger. Das gleiche gilt für REST.</para>
    </note>
  </section>

  <section xml:id="scaffold_anlegen">
    <title>Generieren eines Scaffolds</title>

    <indexterm>
      <primary>Scaffolding</primary>

      <secondary>Rails 3.2</secondary>
    </indexterm>

    <para>Legen wir zuerst mit Scaffolding eine Liste von Bundeskanzlern an.
    Dazu müssen Sie erst mal eine neue Rails-Applikation anlegen:<screen>MacBook:~ xyz$ <command>rails new history </command>
[...]
MacBook:~ xyz$ <command>cd history</command> 
MacBook:history xyz$</screen></para>

    <para>Schauen wir uns die Optionen von Scaffolding an:<screen>MacBook:history xyz$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field[:type][:index] field[:type][:index]] [options]

Options:
      [--skip-namespace]                        # Skip namespace (affects only isolated applications)
      [--old-style-hash]                        # Force using old style hash (:foo =&gt; 'bar') on Ruby &gt;= 1.9
  -o, --orm=NAME                                # Orm to be invoked
                                                # Default: active_record
      [--force-plural]                          # Forces the use of a plural ModelName
  -y, [--stylesheets]                           # Generate Stylesheets
                                                # Default: true
  -se, [--stylesheet-engine=STYLESHEET_ENGINE]  # Engine for Stylesheets
                                                # Default: scss
  -c, --scaffold-controller=NAME                # Scaffold controller to be invoked
                                                # Default: scaffold_controller
      [--assets]                                # Indicates when to generate assets
                                                # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
      [--indexes]              # Add indexes for references and belongs_to columns
                               # Default: true
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attributes are field arguments specifying the model's attributes. You can
    optionally pass the type and an index to each field. For instance:
    "title body:text tracking_id:integer:uniq" will generate a title field of
    string type, a body with text type and a tracking_id as an integer with an
    unique index. "index" could also be given instead of "uniq" if one desires
    a non unique index.

    Timestamps are added by default, so you don't have to specify them by hand
    as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title body:text published:boolean' gives
    you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a resources :posts declaration
    in config/routes.rb.

    If you want to remove all the generated files, run
    'rails destroy scaffold ModelName'.

Examples:
    `rails generate scaffold post`
    `rails generate scaffold post title body:text published:boolean`
    `rails generate scaffold purchase amount:decimal tracking_id:integer:uniq`
MacBook:history xyz$</screen></para>

    <para>Ich mache es kurz: Für unseren jetzigen Kenntnisstand können wir
    <command>rails generate scaffold</command> wie <command>rails generate
    model</command> benutzen (siehe <xref
    linkend="activerecord_datenbank_anlegen"/>). Legen wir jetzt das Scaffold
    für Bundeskanzler an:<screen>MacBook:history xyz$ <command>rails generate scaffold chancellor first_name last_name birthday:date day_of_death:date inauguration:date</command>
      invoke  active_record
      create    db/migrate/20120508171951_create_chancellors.rb
      create    app/models/chancellor.rb
      invoke    test_unit
      create      test/unit/chancellor_test.rb
      create      test/fixtures/chancellors.yml
       route  resources :chancellors
      invoke  scaffold_controller
      create    app/controllers/chancellors_controller.rb
      invoke    erb
      create      app/views/chancellors
      create      app/views/chancellors/index.html.erb
      create      app/views/chancellors/edit.html.erb
      create      app/views/chancellors/show.html.erb
      create      app/views/chancellors/new.html.erb
      create      app/views/chancellors/_form.html.erb
      invoke    test_unit
      create      test/functional/chancellors_controller_test.rb
      invoke    helper
      create      app/helpers/chancellors_helper.rb
      invoke      test_unit
      create        test/unit/helpers/chancellors_helper_test.rb
      invoke  assets
      invoke    coffee
      create      app/assets/javascripts/chancellors.js.coffee
      invoke    scss
      create      app/assets/stylesheets/chancellors.css.scss
      invoke  scss
      create    app/assets/stylesheets/scaffolds.css.scss
MacBook:history xyz$</screen></para>
  </section>

  <section xml:id="scaffold_migrate_und_seed">
    <title>Anlegen der Datenbank mit Beispieldaten</title>

    <para>Wie Sie sehen, wurde von <command>rails generate scaffold</command>
    schon das Model mit angelegt. Wir können entsprechend direkt <command>rake
    db:migrate</command> aufrufen:<screen>MacBook:history xyz$ <command>rake db:migrate</command>
==  CreateChancellors: migrating ==============================================
-- create_table(:chancellors)
   -&gt; 0.0018s
==  CreateChancellors: migrated (0.0019s) =====================================

MacBook:history xyz$</screen></para>

    <para>Legen wir in der <filename>db/seeds.rb</filename> die ersten sechs
    Kanzler an. Bei Walter Scheel bin ich mir nicht sicher, aber es handelt
    sich bei diesem Buch ja um ein Werk zum Thema Rails und nicht zur
    deutschen Nachkriegsgeschichte.<programlisting>Chancellor.create(:first_name =&gt; 'Konrad', :last_name =&gt; 'Adenauer', :birthday =&gt; '05.01.1876', :day_of_death =&gt; '19.04.1967', :inauguration =&gt; '15.09.1949')
Chancellor.create(:first_name =&gt; 'Ludwig', :last_name =&gt; 'Erhard', :birthday =&gt; '04.02.1897', :day_of_death =&gt; '05.05.1977', :inauguration =&gt; '16.10.1963')
Chancellor.create(:first_name =&gt; 'Kurt Georg', :last_name =&gt; 'Kiesinger', :birthday =&gt; '06.04.1904', :day_of_death =&gt; '09.03.1988', :inauguration =&gt; '01.12.1966')
Chancellor.create(:first_name =&gt; 'Willy', :last_name =&gt; 'Brandt', :birthday =&gt; '18.12.1913', :day_of_death =&gt; '08.10.1992', :inauguration =&gt; '21.10.1969')
Chancellor.create(:first_name =&gt; 'Walter', :last_name =&gt; 'Scheel', :birthday =&gt; '08.09.1919', :inauguration =&gt; '07.05.1974')
Chancellor.create(:first_name =&gt; 'Helmut', :last_name =&gt; 'Schmidt', :birthday =&gt; '23.12.1918', :inauguration =&gt; '16.05.1974')</programlisting></para>

    <para>Beispieldaten einspielen:<screen>MacBook:history xyz$ <command>rake db:seed</command>
MacBook:history xyz$ </screen></para>
  </section>

  <section xml:id="scaffold_routen">
    <title>Die Routen</title>

    <para><command>rails generate scaffold</command> hat für uns eine Route
    (dazu später in <xref linkend="routes"/> mehr), einen Controller und
    mehrere Views (siehe <xref linkend="dynamische_webseiten"/>) angelegt. Das
    hätten wir auch alles von Hand machen können. Scaffolding ist also nur ein
    Automatismus, der uns Arbeit bei den grundsätzlichen Dingen abnimmt. Dem
    liegt die Annahme zugrunde, dass man immer Datensätze ansehen, anlegen und
    löschen möchte.</para>

    <para>Ohne uns zu intensiv mit Routen zu beschäftigen, schauen wir gerade
    mal die verfügbaren Routen an. Dazu müssen Sie <command>rake
    routes</command> eingeben:<screen>MacBook:history xyz$ <command>rake routes</command>
    chancellors GET    /chancellors(.:format)          chancellors#index
                POST   /chancellors(.:format)          chancellors#create
 new_chancellor GET    /chancellors/new(.:format)      chancellors#new
edit_chancellor GET    /chancellors/:id/edit(.:format) chancellors#edit
     chancellor GET    /chancellors/:id(.:format)      chancellors#show
                PUT    /chancellors/:id(.:format)      chancellors#update
                DELETE /chancellors/:id(.:format)      chancellors#destroy
MacBook:history xyz$</screen></para>

    <para>Das sind alle in dieser Rails-Applikation zur Verfügung stehenden
    Routen und damit URLs. Alle Routes rufen Actions (also Methoden) im
    <classname>ChancellorsController</classname> auf.</para>
  </section>

  <section xml:id="scaffold_controller">
    <title>Der Controller</title>

    <para>Höchste Zeit, einen Blick in die Datei
    <filename>app/controllers/chancellors_controller.rb</filename> zu werfen.
    Scaffold erstellt automatisch die Methoden <methodname>index</methodname>,
    <methodname>show</methodname>, <methodname>new</methodname>,
    <methodname>create</methodname>, <methodname>update</methodname> und
    <methodname>destroy</methodname>. Diese Methoden bzw. Actions werden von
    den Routen aufgerufen.</para>

    <para>So viel vorweg: Sie müssen jetzt nicht Zeile für Zeile den
    Controller durcharbeiten. Es ist nur wichtig, dass Sie wissen, wo die
    Datei liegt und dass dort die einzelnen Methoden für die Aufrufe durch die
    Routen liegen. Dann können Sie später – bei Unklarheiten – dort
    nachschauen.<programlisting>class ChancellorsController &lt; ApplicationController
  # GET /chancellors
  # GET /chancellors.json
  def index
    @chancellors = Chancellor.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @chancellors }
    end
  end

  # GET /chancellors/1
  # GET /chancellors/1.json
  def show
    @chancellor = Chancellor.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.json { render json: @chancellor }
    end
  end

  # GET /chancellors/new
  # GET /chancellors/new.json
  def new
    @chancellor = Chancellor.new

    respond_to do |format|
      format.html # new.html.erb
      format.json { render json: @chancellor }
    end
  end

  # GET /chancellors/1/edit
  def edit
    @chancellor = Chancellor.find(params[:id])
  end

  # POST /chancellors
  # POST /chancellors.json
  def create
    @chancellor = Chancellor.new(params[:chancellor])

    respond_to do |format|
      if @chancellor.save
        format.html { redirect_to @chancellor, notice: 'Chancellor was successfully created.' }
        format.json { render json: @chancellor, status: :created, location: @chancellor }
      else
        format.html { render action: "new" }
        format.json { render json: @chancellor.errors, status: :unprocessable_entity }
      end
    end
  end

  # PUT /chancellors/1
  # PUT /chancellors/1.json
  def update
    @chancellor = Chancellor.find(params[:id])

    respond_to do |format|
      if @chancellor.update_attributes(params[:chancellor])
        format.html { redirect_to @chancellor, notice: 'Chancellor was successfully updated.' }
        format.json { head :no_content }
      else
        format.html { render action: "edit" }
        format.json { render json: @chancellor.errors, status: :unprocessable_entity }
      end
    end
  end

  # DELETE /chancellors/1
  # DELETE /chancellors/1.json
  def destroy
    @chancellor = Chancellor.find(params[:id])
    @chancellor.destroy

    respond_to do |format|
      format.html { redirect_to chancellors_url }
      format.json { head :no_content }
    end
  end
end
</programlisting></para>
  </section>

  <section xml:id="scaffold_views">
    <title>Die Views</title>

    <para>Jetzt starten wir den Rails-Webserver:<screen>MacBook:history xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.3 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-05-08 19:26:14] INFO  WEBrick 1.3.1
[2012-05-08 19:26:14] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.3.0]
[2012-05-08 19:26:14] INFO  WEBrick::HTTPServer#start: pid=43118 port=3000</screen></para>

    <note>
      <para>Falls Sie jetzt eine Warnung Ihrer eingebauten Firewall bekommen,
      zeigt dies, dass Sie <xref linkend="erste_schritte_mit_rails"/> nicht
      durchgearbeitet haben. ;-)</para>
    </note>

    <para>Jetzt ein kleiner Trommelwirbel … Spannung … den Webbrowser starten
    und die URL <uri
    xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>
    aufrufen. Sie sehen die Liste der Bundeskanzler als einfache
    Webseite.<screenshot>
        <info>
          <title>Index der eingetragenen Bundeskanzler</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_index.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn Sie jetzt auf den Link „New Chancellor“ klicken, dann bekommen
    Sie ein Eingabeformular für einen neuen Datensatz angezeigt:<screenshot>
        <info>
          <title>Eingabeformular für einen neuen Datensatz</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_new.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Gehen Sie mit dem Back-Button Ihres Browsers wieder zurück und
    klicken Sie auf den „Show“-Link in der Zeile von Konrad Adenauer. Sie
    sehen daraufhin folgende Seite:<screenshot>
        <info>
          <title>Anzeige eines einzelnen Datensatzes</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_show.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Wenn Sie jetzt auf „Edit“ klicken, bekommen Sie die Editieransicht
    zu diesem Datensatz:<screenshot>
        <info>
          <title>Editier-Formular für einen bestehenden Datensatz</title>
        </info>

        <mediaobject>
          <imageobject>
            <imagedata fileref="screenshots/chancellor_edit.jpg"/>
          </imageobject>
        </mediaobject>
      </screenshot></para>

    <para>Und wenn Sie auf der Index-Seite auf „Destroy“ klicken, können Sie
    nach einer Bestätigungsabfrage einen Datensatz löschen. Ist das cool?! Sie
    haben innerhalb von nicht mal 10 Minuten eine Web-Applikation geschrieben,
    mit der Sie Datensätze anlegen (<emphasis role="bold">c</emphasis>reate),
    auflisten und anschauen (<emphasis role="bold">r</emphasis>ead/<emphasis
    role="bold">r</emphasis>etrieve), bearbeiten (<emphasis
    role="bold">u</emphasis>pdate) und löschen (<emphasis
    role="bold">d</emphasis>elete/<emphasis role="bold">d</emphasis>estroy)
    können (CRUD)<indexterm>
        <primary>CRUD</primary>
      </indexterm>. Das ist der Zauber von Scaffolding.</para>

    <section xml:id="scaffold_wo_liegen_die_views">
      <title>Wo liegen die Views?</title>

      <para>Sie werden es sich schon denken können, aber schauen wir uns
      trotzdem das Verzeichnis <filename>app/views/chancellors</filename>
      an:<screen>MacBook:history xyz$ <command>ls app/views/chancellors</command> 
_form.html.erb
edit.html.erb
index.html.erb
new.html.erb
show.html.erb
MacBook:history xyz$</screen></para>

      <para>Für <methodname>index</methodname>, <methodname>edit</methodname>,
      <methodname>new</methodname> und <methodname>show</methodname> liegen
      dort die entsprechenden Views. Da <methodname>new</methodname> und
      <methodname>edit</methodname> beide ein Formular zum Bearbeiten der
      Daten benötigen, wird dieses im Sinne von DRY (<emphasis
      role="bold">D</emphasis>on't <emphasis role="bold">R</emphasis>epeat
      <emphasis role="bold">Y</emphasis>ourself) im Partial
      <filename>_form.html.erb</filename> abgelegt (siehe <xref
      linkend="partials"/>) und in <filename>new.html.erb</filename> und
      <filename>edit.html.erb</filename> mit einem <code>&lt;%= render 'form'
      %&gt;</code> eingebunden.</para>

      <para>Öffnen wir einmal die Datei
      <filename>app/views/chancellors/index.html.erb</filename>:<programlisting>&lt;h1&gt;Listing chancellors&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;First name&lt;/th&gt;
    &lt;th&gt;Last name&lt;/th&gt;
    &lt;th&gt;Birthday&lt;/th&gt;
    &lt;th&gt;Day of death&lt;/th&gt;
    &lt;th&gt;Inauguration&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @chancellors.each do |chancellor| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= chancellor.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.birthday %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_chancellor_path(chancellor) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', chancellor, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Chancellor', new_chancellor_path %&gt;
</programlisting></para>

      <para>Als mittlerweiler alter ERB-Hase werden Sie keine Probleme haben,
      den Code zu lesen und zu verstehen. Falls doch, empfehle ich noch mal
      einen schnellen Blick in <xref linkend="erb-programmieren"/>.</para>
    </section>

    <section xml:id="link_to">
      <title xml:id="link_to.title">link_to</title>

      <indexterm>
        <primary>link_to</primary>
      </indexterm>

      <para>In den vom scaffold Generator genierierten Views sind Sie zum
      ersten mal auf den Helper <code>link_to</code> gestossen. Damit werden
      <code>&lt;a href ...&gt;</code> Verlinkungen erzeugt. Man kann natürlich
      auch einen Link von Hand mit <code>&lt;a href="..."&gt;</code> im erb
      eintragen, aber für Verlinkungen innerhalb eines Rails-Projektes ist
      <code>link_to</code> praktischer, weil man die Namen der Routen als Ziel
      benutzen kann. Der Code wird damit wesentlich lesbarer. In obigen
      Beispiel gibt es folgende Routen:<screen>MacBook:history xyz$ <command>rake routes</command>
    chancellors GET    /chancellors(.:format)          chancellors#index
                POST   /chancellors(.:format)          chancellors#create
 new_chancellor GET    /chancellors/new(.:format)      chancellors#new
edit_chancellor GET    /chancellors/:id/edit(.:format) chancellors#edit
     chancellor GET    /chancellors/:id(.:format)      chancellors#show
                PUT    /chancellors/:id(.:format)      chancellors#update
                DELETE /chancellors/:id(.:format)      chancellors#destroy
MacBook:history xyz$</screen></para>

      <para>Der erste Teil dieser Route ist der Name der Route. Bei einem new
      Aufruf ist das <code>new_chancellor</code>. Ein Link auf
      <code>new_chancellor</code> sieht im erb-Code so aus (das können Sie am
      Ende der Datei <filename>app/views/chancellors/index.html.erb</filename>
      einsehen):<programlisting>&lt;%= link_to 'New Chancellor', new_chancellor_path %&gt;</programlisting></para>

      <para>Im HTML-Code der generierten Seite (<uri
      xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>)
      sehen Sie das Ergebnis:<programlisting>&lt;a href="/chancellors/new"&gt;New Chancellor&lt;/a&gt;</programlisting></para>

      <para>Mit <code>link_to</code> können sie auch auf Resourcen innerhalb
      einer RESTful Resource verlinken. Auch dafür finden Sie in
      <filename>app/views/chancellors/index.html.erb</filename> Beispiele. In
      der Tabelle wird zu jedem <varname>chancellor</varname> ein
      <code>show</code>, ein <code>edit</code> und ein <code>destroy</code>
      link gerendert:<programlisting>&lt;% @chancellors.each do |chancellor| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= chancellor.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.birthday %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
<emphasis>    &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_chancellor_path(chancellor) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', chancellor, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
</emphasis>  &lt;/tr&gt;
&lt;% end %&gt;</programlisting></para>

      <para>Rails bestimmt anhand der Resource und der gewählten Route
      automatisch die benötigte URL und das benötigte HTTP-Verb (sprich, ob es
      sich um ein POST, GET, PUT oder DELETE) handelt. Beim Index- und
      Show-Aufruf müssen Sie auf den Unterschied zwischen Plural und Singular
      achten. <code>link_to 'Show', chancellor</code> verlinkt auf einen
      einzelnen Datensatz und <code>link_to 'Show', chancellors_path</code>
      verlinkt auf die Index-Ansicht.</para>

      <para>Ob der Name der Route mit oder ohne den Zusatz <code>_path</code>
      in <code>link_to</code> verwendet wird, hängt davon ab, ob Rails sich
      anhand der restlichen Informationen die Route "denken" kann. Wird nur
      ein Objekt (in unserem Beispiel die Variable
      <varname>chancellor</varname>) angegeben, dann geht Rails automatisch
      davon aus, das es sich um eine show-Route handelt.</para>

      <para>Beispiele:</para>

      <informaltable>
        <tgroup cols="2">
          <tbody>
            <row>
              <entry><code>link_to 'Show', Chancellor.first</code></entry>

              <entry>Link zum ersten Chancellor Eintrag.</entry>
            </row>

            <row>
              <entry><code>link_to 'New Chancellor',
              new_chancellor_path</code></entry>

              <entry>Link zum Webinterface, in dem ein neuer Eintrag erstellt
              werden kann.</entry>
            </row>

            <row>
              <entry><code>link_to 'Edit',
              edit_chancellor_path(Chancellor.first)</code></entry>

              <entry>Link zum Formular, in dem der erste Chancellor Eintrag
              editiert werden kann.</entry>
            </row>

            <row>
              <entry><code>link_to 'Destroy', Chancellor.first, method:
              :delete</code></entry>

              <entry>Link zum Löschen des ersten Chancellor Eintrages.</entry>
            </row>
          </tbody>
        </tgroup>
      </informaltable>
    </section>

    <section xml:id="form_for">
      <title xml:id="form_for.title">form_for</title>

      <indexterm>
        <primary>form_for</primary>
      </indexterm>

      <para>Im vom <code>new</code> und <code>edit</code> View benutzten
      Partial <filename>app/views/chancellors/_form.html.erb</filename> finden
      Sie folgenden Code für das Chancellor-Formular:<programlisting>&lt;%= form_for(@chancellor) do |f| %&gt;
  &lt;% if @chancellor.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@chancellor.errors.count, "error") %&gt; prohibited this chancellor from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @chancellor.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;

  &lt;div class="field"&gt;
    &lt;%= f.label :first_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :first_name %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :last_name %&gt;&lt;br /&gt;
    &lt;%= f.text_field :last_name %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :birthday %&gt;&lt;br /&gt;
    &lt;%= f.date_select :birthday %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :day_of_death %&gt;&lt;br /&gt;
    &lt;%= f.date_select :day_of_death %&gt;
  &lt;/div&gt;
  &lt;div class="field"&gt;
    &lt;%= f.label :inauguration %&gt;&lt;br /&gt;
    &lt;%= f.date_select :inauguration %&gt;
  &lt;/div&gt;
  &lt;div class="actions"&gt;
    &lt;%= f.submit %&gt;
  &lt;/div&gt;
&lt;% end %&gt;
</programlisting></para>

      <para>Der Helper <code>form_for</code> kümmert sich in einem Block für
      Sie um die Erstellung des HTML-Formulars, mit dem der User die Daten für
      den Datensatz eingeben oder verändern kann. Wenn Sie hier ein
      <code>&lt;div class="field"&gt;</code> Element löschen, dann kann dies
      nicht mehr zur Eingabe im Web-Interface benutzt werden. Ich gehe an
      dieser Stelle nicht auf alle möglichen Form-Feld-Varianten ein. Die
      häufig benötigten werden ich bei späteren Beispielen benutzen und (falls
      sie nicht selbsterklärend sind) erklären.</para>

      <note>
        <para>Einen Überblick zu allen Form-Helpers finden Sie unter <uri
        xlink:href="http://guides.rubyonrails.org/form_helpers.html">http://guides.rubyonrails.org/form_helpers.html</uri></para>
      </note>

      <para>Bei der Verwendung von Validierungen im Model werden auftrettende
      Validierungsfehler im folgenden Code am Kopf des Formulars
      angezeigt:<programlisting>  &lt;% if @chancellor.errors.any? %&gt;
    &lt;div id="error_explanation"&gt;
      &lt;h2&gt;&lt;%= pluralize(@chancellor.errors.count, "error") %&gt; prohibited this chancellor from being saved:&lt;/h2&gt;

      &lt;ul&gt;
      &lt;% @chancellor.errors.full_messages.each do |msg| %&gt;
        &lt;li&gt;&lt;%= msg %&gt;&lt;/li&gt;
      &lt;% end %&gt;
      &lt;/ul&gt;
    &lt;/div&gt;
  &lt;% end %&gt;</programlisting></para>

      <para>Ein solcher Fehler würde dann vom Controller bemerkt und per
      Flash-Message wie folgt auf der Webseite angezeigt.</para>

      <para><screenshot>
          <info>
            <title>Flash-Error für einen neuen Datensatz</title>
          </info>

          <mediaobject>
            <imageobject>
              <imagedata fileref="screenshots/chancellor_error_flash.jpg"/>
            </imageobject>
          </mediaobject>
        </screenshot></para>
    </section>

    <section xml:id="scaffold_json_und_xml">
      <title>Zugriff per XML oder JSON</title>

      <indexterm>
        <primary>Web-API</primary>

        <secondary>XML-Format</secondary>
      </indexterm>

      <indexterm>
        <primary>Web-API</primary>

        <secondary>JSON-Format</secondary>
      </indexterm>

      <indexterm>
        <primary>XML</primary>

        <see>Web-API</see>
      </indexterm>

      <indexterm>
        <primary>JSON</primary>

        <see>Web-API</see>
      </indexterm>

      <indexterm>
        <primary>API</primary>

        <see>Web-API</see>
      </indexterm>

      <para>Rails' Scaffolding generiert per Default nicht nur den Zugriff per
      HTML für „menschliche“ Benutzer, sondern auch direkt noch eine
      Schnittstelle für Automaten. Damit lassen sich die gleichen Methoden
      <methodname>index</methodname>, <methodname>show</methodname>,
      <methodname>new</methodname>, <methodname>create</methodname>,
      <methodname>update</methodname> und <methodname>destroy</methodname>
      aufrufen. Eben nur in einem für eine Maschine einfacheren Format.
      Beispielhaft besprechen wir hier die
      <methodname>index</methodname>-Action, mit der alle Daten auf einmal
      ausgelesen werden. Über die gleiche Idee können aber auch Daten gelöscht
      (<methodname>destroy</methodname>) oder geändert
      (<methodname>update</methodname>) werden.</para>

      <para>Aktuell populäre Formate sind XML (siehe <link
      xlink:href="http://de.wikipedia.org/wiki/Extensible_Markup_Language">http://de.wikipedia.org/wiki/Extensible_Markup_Language</link>)
      und JSON (siehe <link
      xlink:href="http://de.wikipedia.org/wiki/JavaScript_Object_Notation">http://de.wikipedia.org/wiki/JavaScript_Object_Notation</link>).</para>

      <para>Wenn Sie keinen maschinellen Zugriff auf Daten benötigen, können
      Sie diese Beispiele überspringen. Sie sollten dann aber auch
      sicherheitshalber alle Zeilen mit <code>format.xml</code> bzw.
      <code>format.json</code> in den <code>respond_to</code>-Blöcken in Ihren
      Controllern löschen. Ansonsten haben Sie eine Schnittstelle zu den
      Daten, die Sie vielleicht irgendwann mal vergessen und die eine
      potenzielle Sicherheitslücke darstellen.</para>

      <section xml:id="scaffold_json">
        <title xml:id="scaffold_json_default.title">JSON als Default</title>

        <indexterm>
          <primary>Web-API</primary>

          <secondary>JSON-Format</secondary>
        </indexterm>

        <para>Ganz am Anfang von
        <filename>app/controllers/chancellors_controller.rb</filename> finden
        Sie den Eintrag für die
        <methodname>index</methodname>-Action:<programlisting>class ChancellorsController &lt; ApplicationController
<emphasis>  # GET /chancellors
  # GET /chancellors.json
  def index
    @chancellors = Chancellor.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @chancellors }
    end
  end
</emphasis><replaceable>[...]</replaceable></programlisting></para>

        <para>Der Code ist übersichtlich. In der Instanz-Variable
        <varname>@chancellors</varname> werden alle Bundeskanzler
        abgespeichert. Danach wird irgendetwas mit einem Format gemacht. Hmmm…
        da steht was von <code>json</code>. Probieren wir mal Folgendes aus:
        Bitte starten Sie mit <command>rails server</command> wieder den
        Rails-Server und gehen Sie mit Ihrem Web-Browser auf die URL <uri
        xlink:href="http://0.0.0.0:3000/chancellors.json">http://0.0.0.0:3000/chancellors.json</uri>.
        Heureka! Sie bekommen folgende Ansicht:<screenshot>
            <info>
              <title>Index-JSON-Anzeige</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/chancellors_index_json.jpg"/>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Die URL <uri
        xlink:href="http://0.0.0.0:3000/chancellors.json">http://0.0.0.0:3000/chancellors.json</uri>
        gibt uns alle Kanzler im JSON-Format aus. In Rails 3.0 war hier der
        Default noch XML. Ob XML oder JSON ist aber eigentlich auch egal. Die
        coolen JavaScript-Programmierer haben halt lieber JSON und da ja heute
        an jeder Ecke ein AJAX-Element eingebaut wird, lag der Schritt nahe,
        den Default von XML auf JSON zu ändern.</para>

        <para>Wenn Sie keine JSON-Ausgabe wünschen, müssen Sie diese Zeile in
        der <filename>app/controllers/chancellors_controller.rb</filename>
        löschen.</para>
      </section>

      <section xml:id="scaffold_json_und_xml_zusammen">
        <title>JSON und XML zusammen</title>

        <para>Wenn Sie in einer Rails-Applikation einmal eine JSON- und eine
        XML-Schnittstelle benötigen, so müssen Sie im Controller einfach nur
        beide Varianten im <code>respond_to</code>-Block angeben. Hier ein
        Beispiel mit der
        <filename>app/controllers/chancellors_controller.rb</filename> in der
        <methodname>index</methodname>-Action:<programlisting>class ChancellorsController &lt; ApplicationController
  # GET /chancellors
  # GET /chancellors.json
  def index
    @chancellors = Chancellor.all

    respond_to do |format|
      format.html # index.html.erb
      format.json { render json: @chancellors }
      <emphasis>format.xml { render xml: @chancellors }</emphasis>
    end
  end
[...]</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="wann_sollte_man_scaffold_benutzen">
    <title>Wann sollte man Scaffolding benutzen?</title>

    <para>Die Verwendung von Scaffolding sollte nie Selbstzweck sein. Es gibt
    sehr viele Rails-Entwickler, die nie Scaffolding benutzen und immer alles
    selber von Hand aufbauen. Ich finde Scaffolds für einen schnellen Einstieg
    in ein neues Projekt ganz praktisch. Aber es ist immer nur der
    Anfang.</para>

    <section xml:id="scaffold_minimal_beispiel_read_only">
      <title>Beispiel für ein Minimal-Projekt</title>

      <para>Nehmen wir einmal an, wir bräuchten auf die Schnelle eine
      Web-Seite, mit der man Kanzler auflisten und einzeln darstellen kann.
      Aber es würde keine Editier- oder Löschfunktion benötigt werden. In
      diesem Fall wäre ein Großteil des mit Scaffold angelegten Codes unnütz
      und müsste gelöscht werden. Probieren wir es nachfolgend aus:</para>

      <para><screen>MacBook:~ xyz$ <command>rails new history2</command>  
[...]
MacBook:~ xyz$ <command>cd history2</command>
MacBook:history2 xyz$ <command>rails generate scaffold chancellor first_name last_name birthday:date day_of_death:date inauguration:date</command>
[...]
MacBook:history2 xyz$ <command>rake db:migrate</command>
[...]
MacBook:history2 xyz$</screen></para>

      <para>Jetzt die <filename>db/seeds.rb</filename> mit den ersten sechs
      Kanzlern anlegen:<programlisting>Chancellor.create(:first_name =&gt; 'Konrad', :last_name =&gt; 'Adenauer', :birthday =&gt; '05.01.1876', :day_of_death =&gt; '19.04.1967', :inauguration =&gt; '15.09.1949')
Chancellor.create(:first_name =&gt; 'Ludwig', :last_name =&gt; 'Erhard', :birthday =&gt; '04.02.1897', :day_of_death =&gt; '05.05.1977', :inauguration =&gt; '16.10.1963')
Chancellor.create(:first_name =&gt; 'Kurt Georg', :last_name =&gt; 'Kiesinger', :birthday =&gt; '06.04.1904', :day_of_death =&gt; '09.03.1988', :inauguration =&gt; '01.12.1966')
Chancellor.create(:first_name =&gt; 'Willy', :last_name =&gt; 'Brandt', :birthday =&gt; '18.12.1913', :day_of_death =&gt; '08.10.1992', :inauguration =&gt; '21.10.1969')
Chancellor.create(:first_name =&gt; 'Walter', :last_name =&gt; 'Scheel', :birthday =&gt; '08.09.1919', :inauguration =&gt; '07.05.1974')
Chancellor.create(:first_name =&gt; 'Helmut', :last_name =&gt; 'Schmidt', :birthday =&gt; '23.12.1918', :inauguration =&gt; '16.05.1974')</programlisting></para>

      <para>Und diese Daten einspielen:<screen>MacBook:history2 xyz$ <command>rake db:seed</command>
MacBook:history2 xyz$</screen></para>

      <para>Da wir nur <methodname>index</methodname> und
      <methodname>show</methodname> benötigen, sollten wir die nicht
      benötigten Views löschen:<screen>MacBook:history2 xyz$ <command>rm app/views/chancellors/_form.html.erb</command> 
MacBook:history2 xyz$ <command>rm app/views/chancellors/new.html.erb</command> 
MacBook:history2 xyz$ <command>rm app/views/chancellors/edit.html.erb</command> 
MacBook:history2 xyz$</screen></para>

      <para>Die Datei
      <filename>app/controllers/chancellors_controller.rb</filename> können
      wir mit einem Editor vereinfachen. Sie muss so aussehen:<programlisting>class ChancellorsController &lt; ApplicationController
  # GET /chancellors
  def index
    @chancellors = Chancellor.all
  end

  # GET /chancellors/1
  def show
    @chancellor = Chancellor.find(params[:id])
  end
end</programlisting></para>

      <para>Da wir nur HTML und keine JSON-Ausgabe benötigen, können wir uns
      das <code>respond_to do |format|</code> Konstrukt sparen. Rails wird
      dann Fall automatisch HTML rendern.</para>

      <para>Wir brauchen nur die Routen für <methodname>index</methodname> und
      <methodname>show</methodname>. Bitte öffnen Sie die Datei
      <filename>config/routes.rb</filename> und ändern Sie sie wie folgt
      ab:<programlisting>History2::Application.routes.draw do
  resources :chancellors, :only =&gt; [ :index, :show ]
end</programlisting></para>

      <para>Ein <command>rake routes</command> zeigt uns, dass wirklich nur
      noch <methodname>index</methodname> und <methodname>show</methodname>
      geroutet werden:<screen>MacBook:history2 xyz$ <command>rake routes</command>
chancellors GET /chancellors(.:format)     chancellors#index
 chancellor GET /chancellors/:id(.:format) chancellors#show
MacBook:history2 xyz$</screen></para>

      <para>Wenn wir jetzt mit <command>rails server</command> den Server
      starten und die URL <uri
      xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>
      aufrufen, bekommen wir eine Fehlermeldung:<screen>MacBook:history2 xyz$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.2.3 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2012-05-08 22:46:28] INFO  WEBrick 1.3.1
[2012-05-08 22:46:28] INFO  ruby 1.9.3 (2012-04-20) [x86_64-darwin11.3.0]
[2012-05-08 22:46:28] INFO  WEBrick::HTTPServer#start: pid=43440 port=3000


Started GET "/chancellors" for 127.0.0.1 at 2012-05-08 22:46:41 +0200
Processing by ChancellorsController#index as HTML
  Chancellor Load (0.1ms)  SELECT "chancellors".* FROM "chancellors" 
  Rendered chancellors/index.html.erb within layouts/application (17.6ms)
Completed 500 Internal Server Error in 81ms

ActionView::Template::Error (undefined method `edit_chancellor_path' for #&lt;#&lt;Class:0x007fc9150437c0&gt;:0x007fc915047b18&gt;):
    20:     &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    21:     &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
    22:     &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
    23:     &lt;td&gt;&lt;%= link_to 'Edit', edit_chancellor_path(chancellor) %&gt;&lt;/td&gt;
    24:     &lt;td&gt;&lt;%= link_to 'Destroy', chancellor, confirm: 'Are you sure?', method: :delete %&gt;&lt;/td&gt;
    25:   &lt;/tr&gt;
    26: &lt;% end %&gt;
  app/views/chancellors/index.html.erb:23:in `block in _app_views_chancellors_index_html_erb__3473545449794762094_70250803843160'
  app/views/chancellors/index.html.erb:15:in `each'
  app/views/chancellors/index.html.erb:15:in `_app_views_chancellors_index_html_erb__3473545449794762094_70250803843160'


  Rendered /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/actionpack-3.2.3/lib/action_dispatch/middleware/templates/rescues/_trace.erb (27.7ms)
  Rendered /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/actionpack-3.2.3/lib/action_dispatch/middleware/templates/rescues/_request_and_response.erb (1.5ms)
  Rendered /Users/xyz/.rvm/gems/ruby-1.9.3-p194/gems/actionpack-3.2.3/lib/action_dispatch/middleware/templates/rescues/template_error.erb within rescues/layout (40.6ms)
</screen></para>

      <para>Die Fehlermeldung sagt, dass wir im View
      <filename>app/views/chancellors/index.html.erb</filename> eine Methode
      <methodname>edit_chancellor_path</methodname> aufrufen. Da wir aber nur
      noch <methodname>index</methodname> und <methodname>show</methodname>
      routen, gibt es keine <methodname>edit</methodname>-,
      <methodname>destroy</methodname>- oder
      <methodname>new</methodname>-Methoden mehr. Wir müssen entsprechend die
      Datei <filename>app/views/chancellors/index.html.erb</filename> im
      Editor wie folgt anpassen:<programlisting>&lt;h1&gt;Listing chancellors&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;First name&lt;/th&gt;
    &lt;th&gt;Last name&lt;/th&gt;
    &lt;th&gt;Birthday&lt;/th&gt;
    &lt;th&gt;Day of death&lt;/th&gt;
    &lt;th&gt;Inauguration&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @chancellors.each do |chancellor| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= chancellor.first_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.last_name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.birthday %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.day_of_death %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= chancellor.inauguration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', chancellor %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;</programlisting></para>

      <para>Und wo wir schon gerade dabei sind, ändern wir auch noch die
      <filename>app/views/chancellors/show.html.erb</filename> entsprechend
      ab:<programlisting>&lt;p&gt;
  &lt;b&gt;First name:&lt;/b&gt;
  &lt;%= @chancellor.first_name %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Last name:&lt;/b&gt;
  &lt;%= @chancellor.last_name %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Birthday:&lt;/b&gt;
  &lt;%= @chancellor.birthday %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Day of death:&lt;/b&gt;
  &lt;%= @chancellor.day_of_death %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Inauguration:&lt;/b&gt;
  &lt;%= @chancellor.inauguration %&gt;
&lt;/p&gt;</programlisting></para>

      <para>Jetzt ist unsere Applikation fertig. Starten Sie den Rails-Server
      mit <command>rails server</command> und öffnen Sie die URL <uri
      xlink:href="http://0.0.0.0:3000/chancellors">http://0.0.0.0:3000/chancellors</uri>
      im Browser.</para>

      <note>
        <para>Bei diesem Beispiel gehe ich nicht auf notwendige Veränderungen
        in den Tests ein, da dies keine Übung zum Test-Driven-Development ist,
        sondern eine Arbeitsweise mit Scaffolding aufzeigen soll.
        TDD-Entwickler werden schnell die Tests angepasst bekommen.</para>
      </note>
    </section>

    <section xml:id="scaffold_fazit">
      <title>Fazit</title>

      <para>Probieren Sie es aus. Arbeiten Sie einmal mit Scaffolds und einmal
      ohne. Dann werden Sie schnell ein Gefühl dafür bekommen, ob es in Ihre
      Arbeitsweise passt oder nicht. Ich empfinde Scaffolding als
      Arbeitserleichterung für Standard-Applikationen.</para>

      <para/>
    </section>
  </section>
</chapter>
