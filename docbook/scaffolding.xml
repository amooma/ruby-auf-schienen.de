<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="scaffolding" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="scaffolding.title">Scaffolding</title>

  <para>Nach so viel recht trockenem Ruby- und Rails-Handwerk schauen wir uns
  mal Scaffolding an. Sie werden bestimmt schon mal ein "Rails in 15 Minuten"
  Screencast gesehen haben, in dem mit Scaffolding ein Blog oder sonst was in
  rasenhafter Geschwindigkeit erstellt wurde. Dumm ist nur, das man danach
  nichts mit dem Code anfangen konnte, weil alle Grundlagen fehlten. Gut das
  Sie sich dieses Buch gekauft und schon fleissig bis hierhin gelesen haben!
  Mit diesem Vorwissen kann ich Ihnen jetzt die Magie des Scaffolding
  erklären.</para>

    <section>
      <title>Was ist Scaffolding?</title>

      <para>Scaffolding ist ein Generator-Skript, das dem Programmierer einen
      Haufen Arbeit abnimmt. Man bekommt mit einem Aufruf ein Daten-Model,
      einen Controller und eine Hand voll Views generiert, mit denen man die
      Datenbank via Webinterface einfach administrieren kann. In gefühlten 50%
      aller Fälle kann man mit Scaffolding Zeit sparen.</para>
    </section>

    <section>
      <title>Neues Rails Projekt erstellen</title>

      <para>Als Beispiel nehmen wir eine kleine Bücherliste mit den folgenden
      Feldern:<itemizedlist>
          <listitem>
            <para><varname>title:string</varname> - Titel des Buches</para>
          </listitem>

          <listitem>
            <para><varname>production_year:integer</varname> -
            Produktionsjahr</para>
          </listitem>

          <listitem>
            <para><varname>rating:integer</varname> - Bewertung (als Ganzahl
            von 1 bis 5 Sterne)</para>
          </listitem>
        </itemizedlist></para>

      <para>Erstellen wir mal eine neue Rails Applikation erstellen:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>rails new bibliography</command>
      create  
      create  README
      [...]
      create  vendor/plugins
      create  vendor/plugins/.gitkeep
stefan@swmbp 0 1.9.2-p0 ~$ <command>cd bibliography</command>
stefan@swmbp 0 1.9.2-p0 bibliography$ <command>bundle install</command>
Fetching source index for http://rubygems.org/
Using rake (0.8.7) 
[...]
Using rails (3.0.0) 
Using sqlite3-ruby (1.3.1) 
Your bundle is complete! Use `bundle show [gemname]` to see where a bundled gem is installed.

Your bundle was installed to `/Users/stefan/.rvm/gems/ruby-1.9.2-p0`
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>
    </section>

    <section xml:id="rails_generate_scaffold">
      <title xml:id="rails_generade_scaffold.title">rails generate
      scaffold</title>

      <para>Mit dem Rails-Skript-Aufruf <command>rails generate
      scaffold</command> kann man fertige Code generieren. Wer (wie ich) gerne
      mal vergisst wie das Skript aufgerufen werden muss, der gibt einfach
      <command>rails generate scaffold</command> ein und bekommt die folgende
      Hilfe angezeigt:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rails generate scaffold</command>
Usage:
  rails generate scaffold NAME [field:type field:type] [options]

Options:
  -o, --orm=NAME                  # Orm to be invoked
                                  # Default: active_record
      [--force-plural]            # Forces the use of a plural ModelName
  -c, --scaffold-controller=NAME  # Scaffold controller to be invoked
                                  # Default: scaffold_controller
  -y, [--stylesheets]             # Indicates when to generate stylesheets
                                  # Default: true

ActiveRecord options:
      [--migration]            # Indicates when to generate migration
                               # Default: true
      [--timestamps]           # Indicates when to generate timestamps
                               # Default: true
      [--parent=PARENT]        # The parent class for the generated model
  -t, [--test-framework=NAME]  # Test framework to be invoked
                               # Default: test_unit

TestUnit options:
      [--fixture]                   # Indicates when to generate fixture
                                    # Default: true
  -r, [--fixture-replacement=NAME]  # Fixture replacement to be invoked

ScaffoldController options:
  -e, [--template-engine=NAME]  # Template engine to be invoked
                                # Default: erb
      [--helper]                # Indicates when to generate helper
                                # Default: true

Runtime options:
  -f, [--force]    # Overwrite files that already exist
  -p, [--pretend]  # Run but do not make any changes
  -q, [--quiet]    # Supress status output
  -s, [--skip]     # Skip files that already exist

Description:
    Create rails files for scaffold generator.
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Wir müssen also nach <command>rails generate scaffold</command>
      den Namen des Models (bei uns <varname>book</varname>) und danach die
      Datenbankfelder mit den entsprechenden Feldtypen angeben.</para>

      <para>Dann legen wir mal los:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rails generate scaffold book title:string production_year:integer rating:integer</command>
      invoke  active_record
      create    db/migrate/20100902141449_create_books.rb
      create    app/models/book.rb
      invoke    test_unit
      create      test/unit/book_test.rb
      create      test/fixtures/books.yml
       route  resources :books
      invoke  scaffold_controller
      create    app/controllers/books_controller.rb
      invoke    erb
      create      app/views/books
      create      app/views/books/index.html.erb
      create      app/views/books/edit.html.erb
      create      app/views/books/show.html.erb
      create      app/views/books/new.html.erb
      create      app/views/books/_form.html.erb
      invoke    test_unit
      create      test/functional/books_controller_test.rb
      invoke    helper
      create      app/helpers/books_helper.rb
      invoke      test_unit
      create        test/unit/helpers/books_helper_test.rb
      invoke  stylesheets
      create    public/stylesheets/scaffold.css
stefan@swmbp 0 1.9.2-p0 bibliography$</screen>Und schon ist alles fertig.
      Allerdings ist in der Datenbank noch keine entsprechende Tabelle
      angelegt.</para>
    </section>

    <section xml:id="migration">
      <title xml:id="migration.title">Migrationen</title>

      <para><application>In der zweiten Ausgabezeile des Scaffoldings sehen
      wir die Ausgabe:</application><screen>      create    db/migrate/20100902141449_create_books.rb
</screen></para>

      <para>In der Datei
      <filename>db/migrate/20100902141449_create_books.rb</filename> finden
      sich die Anweisung, mit der die Datenbank erstellt und auch beim
      Roll-Back wieder gelöscht werden kann.<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>cat db/migrate/20100902141449_create_books.rb</command> 
class CreateBooks &lt; ActiveRecord::Migration
  def self.up
    create_table :books do |t|
      t.string :title
      t.integer :production_year
      t.integer :rating

      t.timestamps
    end
  end

  def self.down
    drop_table :books
  end
end
stefan@swmbp 0 1.9.2-p0 bibliography$ </screen></para>

      <para>Die in dieser Ruby-Datei angelegte Klasse
      <classname>CreateBooks</classname> ist ein Kind der Klasse
      <classname>ActiveRecord::Migration</classname> (siehe Zeile 1) und hat
      zwei Methoden:<itemizedlist>
          <listitem>
            <para><methodname>self.up</methodname> (Zeile 2). Wird aufgerufen,
            wenn die Migration durchgeführt wird.</para>
          </listitem>

          <listitem>
            <para><methodname>self.down</methodname> (Zeile 14). Wird
            aufgerufen, wenn für eine Migration ein Rollback durchgeführt
            wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Die Migration (also das Anlegen der Datenbank) wird mit
      <command>rake db:migrate</command> durchgeführt:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake db:migrate</command>
(in /Users/stefan/bibliography)
==  CreateBooks: migrating ====================================================
-- create_table(:books)
   -&gt; 0.0015s
==  CreateBooks: migrated (0.0016s) ===========================================

stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Die Datenbank-Tabelle <varname>books</varname> wird angelegt.
      Dabei sehen wir, das Tabellen-Namen automatisch den Plural der Models
      bekommen. Aber welche Datenbank wird überhaupt benutzt? Das wird in der
      Konfigurationsdatei <filename>config/database.yml</filename>
      definiert:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>cat config/database.yml</command> 
# SQLite version 3.x
#   gem install sqlite3-ruby (not necessary on OS X Leopard)
development:
  adapter: sqlite3
  database: db/development.sqlite3
  pool: 5
  timeout: 5000

# Warning: The database defined as "test" will be erased and
# re-generated from your development database when you run "rake".
# Do not set this db to the same as development or production.
test:
  adapter: sqlite3
  database: db/test.sqlite3
  pool: 5
  timeout: 5000

production:
  adapter: sqlite3
  database: db/production.sqlite3
  pool: 5
  timeout: 5000
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe
      <uri xlink:href="http://www.yaml.org/">http://www.yaml.org/</uri> bzw.
      <uri
      xlink:href="http://de.wikipedia.org/wiki/YAML">http://de.wikipedia.org/wiki/YAML</uri>)
      definiert. Für uns wichtig ist erst mal nur die development-Datenbank
      (erster Eintrag). Per default benutzt Rails dort
      <application>SQLite3</application>. SQLite3 mag nicht die richtige Wahl
      für die Analyse der weltweit gesammelten Wetterdaten sein, aber für die
      schnelle und unkompliziete Entwicklung von Rails-Anwendungen lernt man
      sie schnell zu schätzen. In der Produktions-Umgebung kann man später
      immer noch auf "grosse" Datenbanken wie MySQL oder PostgreSQL
      umsteigen.<footnote>
          <para>Einige Entwickler sind der Ansicht, das man auf jeden Fall
          immer mit der gleichen Datenbank entwicklen soll, die man später
          auch in der Produktion und im Testing benutzt. Andere sagen, das
          diese bei der Verwendung von Abstraktions-Layern nicht notwendig
          sei. Bitte entscheiden Sie hier selber. Ich programmiere eine Rails
          Applikation fast nur mit SQLite und verwende in der Produktion fast
          nur MySQL.</para>
        </footnote></para>

      <para>Um Ihre sicherlich vorhandene Neugierde zu befriedigen, schauen
      wir uns kurz noch die Datenbank mit dem Command-Line-Tool
      <application>sqlite3</application> an.<screen>stefan@swmbp 1 1.9.2-p0 bibliography$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.6.12
Enter ".help" for instructions
Enter SQL statements terminated with a ";"
sqlite&gt; <command>.tables</command>
books              schema_migrations
sqlite&gt; <command>.schema books</command>
CREATE TABLE "books" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "rating" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; <command>.quit</command>
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <para>Das Anlegen der Tabelle mit <command>rake db:migrate</command>
      wurde natürlich auch im <filename>log/development.log</filename>
      eingetragen:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>cat log/development.log </command>
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  select sqlite_version(*)
  SQL (1.7ms)  CREATE TABLE "schema_migrations" ("version" varchar(255) NOT NULL) 
  SQL (0.0ms)  PRAGMA index_list("schema_migrations")
  SQL (2.0ms)  CREATE UNIQUE INDEX "unique_schema_migrations" ON "schema_migrations" ("version")
  SQL (0.3ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
Migrating to CreateBooks (20100902141449)
  SQL (0.5ms)  CREATE TABLE "books" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "rating" integer, "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)  INSERT INTO "schema_migrations" ("version") VALUES ('20100902141449')
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)  SELECT "schema_migrations"."version" FROM "schema_migrations"
  SQL (0.1ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.0ms)  PRAGMA index_list("books")
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

      <section xml:id="active-record-auto-felder">
        <title>Automatisch zugefügte Felder (id, created_at und
        updated_at)</title>

        <para>Rails ist so freundlich uns beim Scaffolding automatisch
        folgende Felder hinzuzufügen:<itemizedlist>
            <listitem>
              <para><varname>id:integer</varname></para>

              <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von
              der Datenbank automatisch hochgezählt. Für alle SQL-Fans:
              AUTOINCREMENT NOT NULL</para>
            </listitem>

            <listitem>
              <para><varname>created_at:datetime</varname></para>

              <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
              eines Datensatzes gefüllt.</para>
            </listitem>

            <listitem>
              <para><varname>updated_at:datetime</varname></para>

              <para>Das Feld wird bei jeder Veränderung des Datensatzes
              automatisch an die aktuelle Zeit angepasst.</para>
            </listitem>
          </itemizedlist></para>

        <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
        Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten
        Felder schätzen. Sie weg zu lassen ist meist am falschen Ende
        gespart.</para>
      </section>

      <section xml:id="migration-rollback">
        <title>Migration Rollback</title>

        <para>Es soll schon vorgekommen sein, das übereilt eine Migration
        durchgeführt wurde. Natürlich passiert weder Ihnen noch mir so was.
        ;-) Aber falls mal ein Freund von Ihnen in diese Predulie gerät: Keine
        Panik! Dafür wurde in der Migrations-Class die Methode
        <methodname>self.down</methodname> angelegt. Testweise können wir ja
        mal unsere letzte Migration zurückrollen:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake db:rollback</command>
(in /Users/stefan/bibliography)
==  CreateBooks: reverting ====================================================
-- drop_table(:books)
   -&gt; 0.0016s
==  CreateBooks: reverted (0.0017s) ===========================================

stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

        <para>Sie können alles auf einmal zurück-rollen oder auch nur einzelne
        Migrationen. Mit dem Schalter <parameter>-T</parameter> bekommen Sie
        eine Hilfe zu allen möglichen Wegen aufgezeigt:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake -T db</command>
(in /Users/stefan/bibliography)
rake db:create          # Create the database from config/database.yml for th...
rake db:drop            # Drops the database for the current Rails.env (use d...
rake db:fixtures:load   # Load fixtures into the current environment's database.
rake db:migrate         # Migrate the database (options: VERSION=x, VERBOSE=f...
rake db:migrate:status  # Display status of migrations
rake db:rollback        # Rolls the schema back to the previous version (spec...
rake db:schema:dump     # Create a db/schema.rb file that can be portably use...
rake db:schema:load     # Load a schema.rb file into the database
rake db:seed            # Load the seed data from db/seeds.rb
rake db:setup           # Create the database, load the schema, and initializ...
rake db:structure:dump  # Dump the database structure to an SQL file
rake db:version         # Retrieves the current schema version number
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

        <para>Und mit <command>rake -T db:rollback</command> die Hilfe zu
        diesem bestimmten Befehl:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake -T db:rollback</command>
(in /Users/stefan/bibliography)
rake db:rollback  # Rolls the schema back to the previous version (specify st...
stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>

        <para>Aber spielen wir lieber unsere Migration wieder ein:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake db:migrate</command>
(in /Users/stefan/bibliography)
==  CreateBooks: migrating ====================================================
-- create_table(:books)
   -&gt; 0.0016s
==  CreateBooks: migrated (0.0022s) ===========================================

stefan@swmbp 0 1.9.2-p0 bibliography$</screen></para>
      </section>
    </section>

    <section xml:id="restful_datenbankzugriff_per_webbrowser">
      <title xml:id="restful_datenbankzugriff_per_webbrowser.title">RESTful
      Datenbankzugriff per Webbrowser</title>

      <para>Die Datenbank ist angelegt. Und der Vorteil von Scaffolding
      besteht darin, das wir jetzt auch direkt per Webbrowser in einer ersten
      Web-GUI darauf zugreifen können.</para>

      <para>Gemäss der CRUD Idee (siehe <uri
      xlink:href="http://de.wikipedia.org/wiki/CRUD">http://de.wikipedia.org/wiki/CRUD</uri>)
      bietet Rails dafür ein RESTful Webinterface an. Was heisst das? Sie
      können auf jede Resource innerhalb einer normalen Rails-Umgeben über
      definierte URLs zugreifen und damit folgende Datenbank-Operationen
      ausführen:<itemizedlist>
          <listitem>
            <para>C für CREATE</para>

            <para>SQL: <code>INSERT INTO books (title) VALUES ('The
            Journey')</code></para>
          </listitem>

          <listitem>
            <para>R für READ</para>

            <para>SQL: <code>SELECT * FROM books</code></para>
          </listitem>

          <listitem>
            <para>U für UPDATE</para>

            <para>SQL: <code>UPDATE books SET title = 'The Journey' WHERE id =
            1</code></para>
          </listitem>

          <listitem>
            <para>D für DELETE</para>

            <para>SQL: <code>DELETE FROM books WHERE id = 1</code></para>
          </listitem>
        </itemizedlist>Für den Rails-Neuling ist nicht direkt ersichtlich, wo
      den hier der grosse Vorteil liegt. Nachfolgend eine Mini-FAQ:<qandaset>
          <qandadiv>
            <qandaentry>
              <question>
                <para>Warum wird um das RESTful Interface in Ruby on Rails so
                ein Bohei gemacht?</para>
              </question>

              <answer>
                <para>Damit bekommt man ein sauberes und für alle
                Programmierer leicht verständliches Interface zu Ihrem System.
                Sie brauchen nur die URI
                <uri>http://localhost:3000/books</uri> und das Wissen, das es
                sich um ein RESTful Webdienst handelt und Sie können direkt
                loslegen.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful nur für die automatische Abfrage zwischen
                Computern gut?</para>
              </question>

              <answer>
                <para>Nein. RESTful ist auch ein guter Denkansatz, um URLs und
                damit ganze Webseiten strukturierter zu gestalten.</para>
              </answer>
            </qandaentry>

            <qandaentry>
              <question>
                <para>Ist RESTful Teil der <emphasis>Convention over
                Configuration</emphasis> Idee?</para>
              </question>

              <answer>
                <para>Ja! Jeder Rails-Entwickler kann sich so in kurzer Zeit
                in ein ihm neues Rails-Projekt einarbeiten.</para>
              </answer>
            </qandaentry>
          </qandadiv>
        </qandaset></para>

      <section>
        <title>Routen</title>

        <para>Schauen wir uns als erstes mal die vom Scaffolding erstellten
        Routen an:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rake routes</command>
(in /Users/stefan/bibliography)
    books GET    /books(.:format)          {:action=&gt;"index", :controller=&gt;"books"}
    books POST   /books(.:format)          {:action=&gt;"create", :controller=&gt;"books"}
 new_book GET    /books/new(.:format)      {:action=&gt;"new", :controller=&gt;"books"}
edit_book GET    /books/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"books"}
     book GET    /books/:id(.:format)      {:action=&gt;"show", :controller=&gt;"books"}
     book PUT    /books/:id(.:format)      {:action=&gt;"update", :controller=&gt;"books"}
     book DELETE /books/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"books"}
stefan@swmbp 0 1.9.2-p0 bibliography$ </screen></para>

        <para>In der zweiten Spalte der Ausgabe finden Sie eine Auflistung der
        URIs.</para>
      </section>

      <section>
        <title>Start des Webservers</title>

        <para>Als erstes starten wir wie immer mit rails server unseren
        Entwicklungswebserver:<screen>stefan@swmbp 0 1.9.2-p0 bibliography$ <command>rails server</command>
=&gt; Booting WEBrick
=&gt; Rails 3.0.0 application starting in development on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2010-09-02 16:32:22] INFO  WEBrick 1.3.1
[2010-09-02 16:32:22] INFO  ruby 1.9.2 (2010-08-18) [x86_64-darwin10.4.0]
[2010-09-02 16:32:22] INFO  WEBrick::HTTPServer#start: pid=54146 port=3000

</screen></para>
      </section>

      <section xml:id="restful_create">
        <title xml:id="restful_create.title">Create (Erstellen)</title>

        <para>Legen wir als erstes einmal einen neuen Datensatz an. Sie können
        das entsprechende Interface über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/new">http://0.0.0.0:3000/books/new</uri>
        abrufen. Bitte benutzen Sie dieses Interface um einen Beispiel-Film
        einzutragen:<screenshot>
            <info>
              <title>Neuen Film in die Datenbank eintragen.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/new_book.jpg"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Sieht ja schon mal nicht schlecht aus. Jetzt gehen wir mal
        Schritt für Schritt durch, was Rails gemacht hat. Die URI <uri
        xlink:href="http://0.0.0.0:3000/books/new">http://0.0.0.0:3000/books/new</uri>
        wird von der <code>new_book</code> Route gematched: <screen> new_book GET    /books/new(.:format)      {:action=&gt;"new", :controller=&gt;"books"}
</screen></para>

        <para>Dann öffnen wir mal die Datei für den Controller books
        (<filename>app/controllers/books_controller.rb</filename>) und schauen
        uns dort die Methode <methodname>new</methodname> an:<programlisting>  # GET /books/new
  # GET /books/new.xml
  def new
    @book = Book.new

    respond_to do |format|
      format.html # new.html.erb
      format.xml  { render :xml =&gt; @book }
    end
  end
</programlisting></para>

        <para>Nachdem Sie auf "Create Movie" geklickt haben, können Sie im
        Log-File folgenden Eintrag verfolgen:<screen>Started POST "/movies" for 127.0.0.1 at 2010-08-31 22:01:13 +0200
  Processing by MoviesController#create as HTML
  Parameters: {"utf8"=&gt;"✓", "authenticity_token"=&gt;"SeHUgt9pHvJh9YdI8RaPdVncr+T4AMARbRLE/+vQRg0=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Create Movie"}
  SQL (0.2ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.5ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-08-31 20:01:13.717959', 133, 'Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.', 1988, 5, 'Rain Man', '2010-08-31 20:01:13.717959')
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 141ms


Started GET "/movies/1" for 127.0.0.1 at 2010-08-31 22:01:13 +0200
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/application (11.3ms)
Completed 200 OK in 51ms (Views: 14.8ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Als Ergebnis bekommen Sie im Browserfenster den entsprechenden
        Eintrag angezeigt:<figure xml:id="screenshot_show_after_create">
            <title>Nach dem Abspeichern wird der neue Eintrag
            angezeigt.</title>

            <screenshot>
              <info>
                <title>Nach dem Abspeichern wird der neue Eintrag
                angezeigt.</title>
              </info>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="screenshots/movies_new_show.jpg"></imagedata>
                </imageobject>
              </mediaobject>
            </screenshot>
          </figure></para>
      </section>

      <section xml:id="restful_show">
        <title xml:id="restful_show.title">Show (Anzeigen eines einzelnen
        Datensatzes)</title>

        <para>Nach dem Erstellen (Create) eines neuen Datensatzes, können wir
        uns diesen natürlich jetzt einzeln anschauen. Da unter ActiveRecord
        automatisch eine unique ID für jeden Datensatz erstellt wird, können
        wir diese zum Aufruf benutzen. In diesem Fall ist es die 1 für den
        ersten Datensatz. Das geht über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri><figure
            xml:id="screenshot_show">
            <title xml:id="screenshot_show.title">Anzeigen des ersten
            Datensatzes</title>

            <screenshot>
              <info>
                <title>Anzeigen des ersten Datensatzes</title>
              </info>

              <mediaobject>
                <imageobject>
                  <imagedata fileref="screenshots/movies_show.jpg"
                             format="JPG"></imagedata>
                </imageobject>
              </mediaobject>
            </screenshot>
          </figure></para>

        <para>Im Log erscheint die folgende Ausgabe:<screen>Started GET "/movies/1" for 127.0.0.1 at 2010-08-31 22:02:12 +0200
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/application (36.3ms)
Completed 200 OK in 51ms (Views: 39.6ms | ActiveRecord: 0.2ms)
</screen></para>

        <para>Ihnen wird bestimmt beim Vergleich der Screenshots <xref
        linkend="screenshot_show" /> und <xref
        linkend="screenshot_show_after_create" /> aufgefallens ein, das bei
        <xref linkend="screenshot_show_after_create" /> am oben eine grüne
        Nachricht angezeigt wurde. Das ist eine sogenannte Flash-Nachricht.
        Dabei ist das Wording "Flash" meiner Meinung nach äusserst ungeschickt
        gewählt, weil bei "Flash" jeder automatisch an das Adobe-Flash-Format
        und nicht an eine Flash-artig (Flash = Blitz) erscheinende Nachricht
        denkt. So ist es aber bei Rails. Flash-Nachrichten werden immer auf
        der nächsten und nur auf der nächsten generierten Seite angezeigt. Wir
        kommen später auf Flash detailierter zu sprechen.</para>
      </section>

      <section xml:id="restful_edit">
        <title xml:id="restful_edit.title">Edit (Bearbeiten eines
        Datensatzes)</title>

        <para>Zum Editieren eines Datensatzes müssen wir wiederum die ID des
        Datensatzes kennen und können dann mit dieser (hier wieder die 1 als
        Beispiel) das Formular zum Bearbeiten des Filmes mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1/edit">http://0.0.0.0:3000/movies/1/edit</uri>
        aufrufen:<screenshot>
            <info>
              <title>Formular zum Editieren eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_edit.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File gibt es folgende Ausgabe:<screen>Started GET "/movies/1/edit" for 127.0.0.1 at 2010-08-31 22:03:15 +0200
  Processing by MoviesController#edit as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.1ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/_form.html.erb (13.2ms)
Rendered movies/edit.html.erb within layouts/application (16.4ms)
Completed 200 OK in 30ms (Views: 19.8ms | ActiveRecord: 0.1ms)
</screen></para>

        <para>Durch klicken auf "Update Movie" können wir dann den Datensatz
        updaten und bekommen ihn dann wieder im Show-View
        angezeigt:<screenshot>
            <info>
              <title>Der Show-View nach dem Update des Datensatzes.</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_show_after_update.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Auch hier wird wieder mit einer Flash-Message ein Feedback vom
        System zum User gegeben.</para>

        <para>Im Log-File sieht man das Update wie folgt:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-08-31 22:03:17 +0200
  Processing by MoviesController#update as HTML
  Parameters: {"utf8"=&gt;"✓", "authenticity_token"=&gt;"SeHUgt9pHvJh9YdI8RaPdVncr+T4AMARbRLE/+vQRg0=", "movie"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"133", "plot"=&gt;"Amerikanischer Roadmovie über zwei sehr ungleiche Brüder, die sich erst nach dem Tod des Vaters kennen lernen.", "rating"=&gt;"5"}, "commit"=&gt;"Update Movie", "id"=&gt;"1"}
  Movie Load (0.1ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 21ms


Started GET "/movies/1" for 127.0.0.1 at 2010-08-31 22:03:18 +0200
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.1ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/application (37.8ms)
Completed 200 OK in 51ms (Views: 41.1ms | ActiveRecord: 0.1ms)
</screen></para>
      </section>

      <section xml:id="restful_index">
        <title xml:id="restful_index.title">Index (Anzeigen aller
        Datensätze)</title>

        <para>Über die URI <uri
        xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
        können Sie sich eine Liste aller Filme in der Datenbank anzeigen
        lassen (logischerweise ist das bis jetzt nur ein Film):<screenshot
            xml:id="screenshot_movies_index">
            <info>
              <title xml:id="screenshot_movies_index.title">Index-Ansicht
              aller Filme</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/movies_index.jpg" format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Im Log-File findet sich folgende Ausgabe:<screen>Started GET "/movies" for 127.0.0.1 at 2010-08-31 22:04:30 +0200
  Processing by MoviesController#index as HTML
  Movie Load (0.4ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/application (12.1ms)
Completed 200 OK in 23ms (Views: 15.8ms | ActiveRecord: 0.4ms)
</screen></para>
      </section>

      <section>
        <title>Löschen eines Datensatzes</title>

        <para>Wenn Sie auf der Index-Seite auf "Destroy" klicken, so bekommen
        Sie folgende Meldung angezeigt:<screenshot>
            <info>
              <title>Sicherheitsabfrage beim Löschen eines Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/destroy_r_u_sure.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Klicken wir jetzt mutig auf "OK", bekommen wir wieder die
        Index-Seite, aber diesmal ganz ohne einen Film angezeigt:<screenshot>
            <info>
              <title>Index-Ansicht nach dem Löschen des einzigen
              Datensatzes</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="screenshots/index_after_destroy.jpg"
                           format="JPG"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot></para>

        <para>Zum Schluss noch der obligatorische Blick in das
        Log-File:<screen>Started POST "/movies/1" for 127.0.0.1 at 2010-08-31 22:04:55 +0200
  Processing by MoviesController#destroy as HTML
  Parameters: {"authenticity_token"=&gt;"SeHUgt9pHvJh9YdI8RaPdVncr+T4AMARbRLE/+vQRg0=", "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.3ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 50ms


Started GET "/movies" for 127.0.0.1 at 2010-08-31 22:04:55 +0200
  Processing by MoviesController#index as HTML
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/application (2.3ms)
Completed 200 OK in 12ms (Views: 5.5ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>
    </section>

    <section xml:id="routen">
      <title xml:id="routen.title">Routen</title>

      <para>Fassen wir mal kurz zusammen: Man kann also mit Scaffolding eine
      Web-GUI erstellen und auf diese Web-GUI anscheinen über eine feste
      CRUD-Stuktur zugreifen. Jetzt wäre ja mal interessant zu wissen, ob es
      noch mehr URIs gibt. Rails steuert das über sogenannte Routen. Alle
      Routen werden in der Datei <filename>config/routes.rb</filename>
      definiert. Standardmässig sind in dieser Datei recht viele Beispiele als
      Kommentare eingebaut. Schauen wir uns mal an, wie die aktuelle
      Konfiguration ohne diese Kommentare aussieht:<screen>MacBook:movie-app sw$ <command>cat config/routes.rb | grep -v "#" | grep -v "^$"</command>
MovieApp::Application.routes.draw do |map|
  resources :movies
  get "example/test"
end
MacBook:movie-app sw$</screen></para>

      <para>Interessant ist die Zeile:<programlisting>  resources :movies</programlisting></para>

      <para>Diese Zeile sagt Rails, das es die Resource movies mit allen
      Standard Routen ausstatten soll. Diese Routen können wir uns mit
      <command>rake routes</command> anzeigen lassen.<screen>MacBook:movie-app sw$ <command>rake routes</command>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
MacBook:movie-app sw$</screen></para>

      <para>Puh... das sind ja viel mehr, als wir oben benutzt haben. Oder
      doch nicht? Und jetzt muss ich das auch noch sinnvoll und strukturiert
      erklären! Die letzte Zeile ist dabei am einfachsten. Die kommt aus
      unserem ersten Beispiel. Kümmern wir uns also um die restlichen vom
      Scaffolding erzeugten Einträge.</para>

      <para>CRUD besteht zwar aus den vier Teilen Create, Read, Upate und
      Delete, aber diese Einzelelemente müssen in der RESTful Umsetzung weiter
      aufgeschlüsselt werden. Ziel bei REST ist es, das man eine
      Abfrage-Methodik definiert, die von allen Entwicklern gleich verstanden
      und auch benutzt werden kann. Dazu werden bei Webzugriffen die URIs und
      die HTTP-Verben benutzt. Was HTTP-Verben sind? Ich habe die Frage
      befürchtet. Bei der Entwicklung des HTTP-Protokolles wurden verschiedene
      Abfrage-Methoden definiert. Sie haben bestimmt bei einem HTML-Formular
      schon mal vom Unterschied zwischen GET und POST gelesen. GET und POST
      sind genau solche Verben. Für uns weiterhin interessant sind PUT und
      DELETE. Gerne verweise ich an dieser Stelle auf das RFC 2616 (<uri
      xlink:href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</uri>),
      falls Sie sich mit dieser Materie näher beschäftigen wollen.</para>

      <para>Für uns ist jetzt erst mal nur interessant, das gleiche URIs die
      mit unterschiedlichen Verben angesprochen werden unterschiedliche
      Aktionen in Ihrer Rails-Applikation auslösen. So können Sie in unserer
      Filmdatenbank über die URI <uri
      xlink:href="http://0.0.0.0:3000/movies">http://0.0.0.0:3000/movies</uri>
      sowohl mit GET eine Liste (Index) aller Filme anfordern, als auch mit
      POST einen neuen Filmeintrag abspeichern.</para>

      <para>Die Kombination aus Verb und URI wird in Rails als Route
      bezeichnet. Ist eine Route nicht definiert, passiert auch nichts. Ist
      eine Route definiert, dann wird damit auf eine "Action" und einen
      "Controller" verwiesen. Ich würde jetzt gerne erklären, was es mit
      beidem auf sich hat, aber vorher will ich noch kurz <xref
      linkend="restful_mit_xml" /> besprechen, damit wir das aktuelle Thema
      RESTful Zugriff sauber abgeschlossen haben.</para>
    </section>

    <section xml:id="restful_mit_xml">
      <title xml:id="restful_mit_xml.title">RESTful Datenbankzugriff per XML
      und curl</title>

      <para><tip>
          <para>Wenn Sie sich nicht für den Austausch von Daten per XML
          interessieren, dann können Sie diesen Abschnitt ruhig
          überspringen.</para>
        </tip>Das XML-Interface erleichtert den Austausch von Daten zwischen
      Maschinen. Dabei wird der ganze HTML-Balast abgeworfen und nur noch die
      reinen Daten per XML ausgetauscht. Beispielhaft führen wir dies mit dem
      Programm curl durch. Logischerweise geht es natürlich auch mit anderen
      Programmen oder Programmiersprachen. Wer die Art und Weise verstanden
      hat, kann von beliebigen Systemen eine Rails Applikation bedienen. Da
      dies naturgemäss auch gewisse Gefahren in sich birgt (z.B. kann eine
      Maschine per Brute-Force-Attacke schnell wie Unheil anrichten), kann man
      per Default bestimmte Aktionen nicht durchführen. Dies wird in der Datei
      <filename>app/controllers/application_controller.rb</filename> mit
      <code>protect_from_forgery</code> konfiguriert. Bitte deaktiven Sie
      diese Zeile für diese Beispiele wie folgt mit einem
      #-Zeichen:<programlisting>class ApplicationController &lt; ActionController::Base
  # protect_from_forgery
end
</programlisting></para>

      <para>Dadurch entfällt eine per default aktivierte Sicherheitsschicht,
      die einen Token austauscht, um die anonyme Interaktion von aussen zu
      underbinden. Im Log-File werden Sie den Unterschied merken (es fehlt der
      Eintrag <code>"authenticity_token"=&gt;"xyz"</code>). In späteren
      Kapiteln besprechen wir Authentifizierungsmechanismen um diese Zugriffe
      mit Passwörtern abzusichern.</para>

      <section>
        <title>new</title>

        <para>Um einen neuen Film einzutragen, benötigen Sie als erstes die
        Felder die ausgefüllt werden müssen. Dazu können Sie die URL <uri
        xlink:href="http://0.0.0.0:3000/movies/new.xml">http://0.0.0.0:3000/movies/new.xml</uri>
        abrufen:<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/new.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime" nil="true"&gt;&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer" nil="true"&gt;&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title nil="true"&gt;&lt;/title&gt;
  &lt;updated-at type="datetime" nil="true"&gt;&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/new.xml" for 127.0.0.1 at 2010-04-04 19:28:19
  Processing by MoviesController#new as XML
Completed 200 OK in 124ms (Views: 111.1ms | ActiveRecord: 0.0ms)
</screen></para>

        <para>In der XML-Ausgabe können wir erkennen wie die einzelnen Felder
        heissen und welche Typen (z.B. Integer) sie darstellen. Mit diesen
        Informationen können wir jetzt einen create Aufruf mit dem neuen
        Datensatz zusammenstellen:</para>

        <para>Danach können Sie mit einem create Aufruf die Daten für einen
        neuen Datensatz uploaden:<screen>MacBook:~ sw$ <command>curl -X POST -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Ausgabe im Log:<screen>Started POST "/movies" for 127.0.0.1 at 2010-04-04 20:30:10
  Processing by MoviesController#create as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1988"}}
  SQL (0.3ms)  INSERT INTO "movies" ("created_at", "duration", "plot", "production_year", "rating", "title", "updated_at") VALUES ('2010-04-04 18:30:10.440028', 133, NULL, 1988, 5, 'Rain Man', '2010-04-04 18:30:10.440028')
Redirected to http://0.0.0.0:3000/movies/6
Completed 302 Found in 27ms
</screen></para>

        <para>Als Ergebnis des curl Aufrufes bekommen Sie die den folgenden
        Code zurück:<screen>&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/2"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
</screen></para>

        <para>Das ist also quasi wie beim Aufruf mit dem Webbrowser, nur das
        ein Show des neuen Datensatzes so beim XML-Aufruf wenig Sinn
        macht.</para>
      </section>

      <section>
        <title>index</title>

        <para>Um das Ergebnis des Index-Aufrufes sinnvoller zu gestalten, habe
        ich vorher zwei mal den Film Rain Man eingetragen. Jetzt müssen wir
        mit curl die URI <uri
        xlink:href="http://0.0.0.0:3000/movies.xml">http://0.0.0.0:3000/movies.xml</uri>
        abrufen.<screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movies type="array"&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;1&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
  &lt;/movie&gt;
  &lt;movie&gt;
    &lt;created-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/created-at&gt;
    &lt;duration type="integer"&gt;133&lt;/duration&gt;
    &lt;id type="integer"&gt;2&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
    &lt;rating type="integer"&gt;5&lt;/rating&gt;
    &lt;title&gt;Rain Man&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2010-04-04T18:35:30Z&lt;/updated-at&gt;
  &lt;/movie&gt;
&lt;/movies&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies.xml" for 127.0.0.1 at 2010-04-04 20:39:09
  Processing by MoviesController#index as XML
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies"
Completed 200 OK in 23ms (Views: 9.6ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>show</title>

        <para>Einen einzelnen Film kann man sich mit der ID des Eintrages
        (hier die 1) und der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri>
        anschauen. <screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started GET "/movies/1.xml" for 127.0.0.1 at 2010-04-04 20:40:06
  Processing by MoviesController#show as XML
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.3ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Completed 200 OK in 37ms (Views: 8.8ms | ActiveRecord: 0.3ms)
</screen></para>
      </section>

      <section>
        <title>edit - update</title>

        <para>Zum Editieren eines Eintrages downloaden wir diesen Eintrag erst
        wieder von der entsprechenden URL <uri
        xlink:href="http://0.0.0.0:3000/movies/1.xml">http://0.0.0.0:3000/movies/1.xml</uri><screen>MacBook:~ sw$ <command>curl -X GET -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;movie&gt;
  &lt;created-at type="datetime"&gt;2010-04-04T18:35:28Z&lt;/created-at&gt;
  &lt;duration type="integer"&gt;133&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1988&lt;/production-year&gt;
  &lt;rating type="integer"&gt;5&lt;/rating&gt;
  &lt;title&gt;Rain Man&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2010-04-04T19:05:23Z&lt;/updated-at&gt;
&lt;/movie&gt;
MacBook:~ sw$</screen></para>

        <para>Danach übermitteln wir den entsprechenden Eintrag mit PUT neu
        auf die URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>.
        Dabei ist es egal, ob wir wirklich neue oder wieder die gleichen Daten
        übermitteln. Wichtig dabei ist, das wir die <parameter>id</parameter>
        des Eintrages mit übertragen:<screen>MacBook:~ sw$ <command>curl -X PUT -H 'Content-Type: application/xml' -d '&lt;movie&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;duration&gt;133&lt;/duration&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;production-year&gt;1989&lt;/production-year&gt;&lt;/movie&gt;' http://0.0.0.0:3000/movies/1</command>    
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies/1"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started PUT "/movies/1" for 127.0.0.1 at 2010-04-04 21:12:32
  Processing by MoviesController#update as */*
  Parameters: {"movie"=&gt;{"title"=&gt;"Rain Man", "duration"=&gt;"133", "rating"=&gt;"5", "production_year"=&gt;"1989"}, "id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.4ms)  UPDATE "movies" SET "production_year" = 1989, "updated_at" = '2010-04-04 19:12:32.237009' WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies/1
Completed 302 Found in 70ms
</screen></para>

        <para>ActiveRecord ist dabei intelligent genug nur wirkliche
        Veränderungen einzutragen.</para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URI <uri
        xlink:href="http://0.0.0.0:3000/movies/1">http://0.0.0.0:3000/movies/1</uri>
        und einem DELETE Aufruf wieder aus der Datenbank löschen.<screen>MacBook:~ sw$ <command>curl -X DELETE -H 'Content-Type: application/xml' http://0.0.0.0:3000/movies/1</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://0.0.0.0:3000/movies"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
MacBook:~ sw$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Started DELETE "/movies/1" for 127.0.0.1 at 2010-04-04 21:14:44
  Processing by MoviesController#destroy as */*
  Parameters: {"id"=&gt;"1"}
  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
  SQL (0.2ms)  DELETE FROM "movies" WHERE ("movies"."id" = 1)
Redirected to http://0.0.0.0:3000/movies
Completed 302 Found in 22ms
</screen></para>
      </section>
    </section>
</chapter>
