<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ruby-grundlagen"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id='ruby-grundlagen.title'>Ruby Grundlagen</title>

  <section xml:id="ruby-grundlagen-einleitung">
    <title>Einleitung</title>

    <para>Genauso wie dieses Buch Grundkenntnisse in HTML vorraussetzt, so
    muss der Leser auch ein Grundverständnis von Programmierung mitbringen.
    Allerdings schreibt schon der Ruby-Erfinder Yukihiro Matsumoto in seinem
    Buch "The Ruby Programming Language"<footnote>
        <para>Das Buch ist sehr empfehlenswert für jeden der Ruby verstehen
        will.</para>
      </footnote>:</para>

    <para><quote>It is easy to program in Ruby, but Ruby is not a simple
    language.</quote></para>

    <para>Dieses Kapitel ist eine Gradwanderung zwischen falscher
    Vereinfachung und unnötiger Ausführlichkeit. Es geht ja nicht darum ein
    Ruby-Guru zu werden, sondern Rails zu verstehen. Ich kann Ihnen nicht
    versprechen, das Sie nach diesem Kapitel alles verstehen. Ich kann Ihnen
    auch nicht versprechen, das es gerade in diesem Kapitel nicht auch ein
    wenig holprig zugehen. Ich kann Ihnen aber versprechen, das sich die
    Lektüre lohnt.</para>

    <para>Ich habe lange den Fehler gemacht und versucht mit Rails zu
    arbeiten, ohne eine Ahnung von Ruby zu haben. Ruby sah so einfach aus und
    deshalb habe ich mir keine Gedanken darüber gemacht. Da ich aber Ruby
    nicht verstand, konnte ich auch Rails nicht verstehen. Deshalb habe ich es
    immer wieder in die virtuelle Ecke gelegt und weiter mit PHP gearbeitet.
    Erst nachdem ich mir Ruby intensiv angeschaut hatte, viel der Groschen.
    Heute bin ich so ein grosser Ruby und Rails Fan, das ich mir sogar die
    Mühe mache dazu ein Buch zu schreiben, um es Ihnen näher zu
    bringen.</para>
  </section>

  <section xml:id="ruby-ist-eine-skriptsprache">
    <title>Eine Skriptsprache</title>

    <para>Ruby ist eine Skriptsprache. Es wird also nicht kompiliert und dann
    ausgeführt, sondern von einem Interpreter eingelesen und dann Zeile für
    Zeile abgearbeitet.</para>
  </section>

  <section xml:id="hello-world-in-ruby">
    <title>Hello World</title>

    <para>Ein einfaches Ruby <filename>hello-world.rb</filename> Programm
    besteht aus folgender Zeile:<programlisting>puts 'Hello World!'
</programlisting></para>

    <para>Und kann auf der Kommandozeile wie folgt aufgerufen werden:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!
sw@debian:~/sandbox$ </screen></para>

    <section xml:id="puts-und-print">
      <title>puts und print</title>

      <para>Wer im Internet nach Beispiel zu Ruby sucht, findet zwei typische
      Möglichkeiten Bildschirmausgaben zu starten:<itemizedlist>
          <listitem>
            <para><application>puts</application></para>

            <para>Gibt einen String aus und bendet die Ausgabe mit einer
            Zeilenschaltung.</para>
          </listitem>

          <listitem>
            <para><application>print</application></para>

            <para>Gibt einen String aus und bendet die Ausgabe nicht mit einer
            Zeilenschaltung. Sollte der String selber eine Zeilenschaltung
            enthalten, so wird diese normal ausgeben.</para>
          </listitem>
        </itemizedlist>Beispielprogramm (eine Erweiterung des
      <filename>hello-world.rb</filename> Programmes):<programlisting>puts 'Hello World!'
puts
puts '------------'
print 'Hello World!'
print
puts '------------'
</programlisting>Die dazu gehörige Bildschirmausgabe:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!

------------
Hello World!------------
sw@debian:~/sandbox$</screen></para>
    </section>
  </section>

  <section xml:id="irb">
    <title>irb</title>

    <para><acronym>irb</acronym> steht für Interactive Ruby Shell und ist eine
    Art Sandbox in der man beliebig mit Ruby rumspielen kann. irb wird mit der
    Eingabe von <command>irb</command> auf der Shell gestartet und durch
    Eingabe von <command>exit</command> wieder beendet.</para>

    <para>Ein Beispiel sagt mehr als tausend Worte:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):003:0&gt; <command>exit</command>
sw@debian:~/sandbox$ </screen></para>

    <para>In diesem Kapitel werden viele Beispiele innerhalb von
    <application>irb</application> erarbeitet. Sie werden auch später bei der
    Arbeit oft innerhalb von irb neue Sachen ausprobieren, weil es so herlich
    schnell und unkompliziert ist.</para>
  </section>

  <section xml:id="kommentare-in-ruby">
    <title>Kommentare</title>

    <para>Ein Kommentar in einem Ruby-Programm wird mit einem
    <code>#</code>-Zeichen eingeleitet und von einer Zeilenendschaltung
    beendet. Als Beispiel erweitere ich das obige
    <filename>hello-world.rb</filename> um einen Kommentar.<programlisting># Programm zum Anzeigen von "Hello World!"
# by Stefan Wintermeyer

puts 'Hello World!'</programlisting></para>

    <para>Ein Kommentar kann auch nach einer Programmzeile
    stehen:<programlisting># Programm zum Anzeigen von "Hello World!"
# by Stefan Wintermeyer

puts 'Hello World!' # Ausgabe</programlisting></para>

    <para>Ein #-Zeichen innerhalb von Anführungszeichen wird nicht als Anfang
    eines Kommentars behandelt. Beispielprogramm:<programlisting># Beispielprogramm
# by Stefan Wintermeyer

puts 'Hello World!'
puts '############'
puts
puts '1#2#3#4#5#6#' # Kommentar dazu
</programlisting> Die Bildschirmausgabe dazu:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!
############

1#2#3#4#5#6#
sw@debian:~/sandbox$</screen></para>

    <section xml:id="kommentare-im-irb">
      <title>Kommentare im irb</title>

      <para>Kommentar innerhalb von irb machen logischweise selten richtig
      Sinn, da in irb erarbeiteter Code quasi Wegwerf-Code ist. Innerhalb
      dieses Buches werden aber immer mal wieder Kommentare zur Erklärung auch
      im irb benutzt. Diese können Sie problemlos mit kopieren und im irb
      einfügen.</para>
    </section>
  </section>

  <section xml:id="ruby-ist-objekt-orientiert">
    <title>Ruby ist Objekt-orientiert</title>

    <para>Ruby kennt nur Objekte. Alles ist ein Objekt (was ja fast schon
    zen-artig ist). Jedes Objekt ist eine Instance einer Klasse. Die Class
    eines Objektes lässt sich mit der Methode <code>.class</code>
    rausfinden.</para>

    <para>Ein Objekt in Ruby ist eingekapselt und kann von Aussen nur mit den
    Methoden des entsprechenden Objektes erreicht werden. Was das heißt? Ich
    kann von Aussen keine Variable in einem Objekt dirket verändern. Das
    entsprechende Objekt muss mir dafür eine Methode zur Verfügung
    stellen.</para>

    <important>
      <para>Sie haben keine Ahnung was eine Class und was ein Objekt ist?
      Keine Panik! Ich werde es keinem erzählen und man kann auch ganz gut
      damit arbeiten, ohne sich grosse Gedanken darüber zu machen - Mit dem
      Thema alleine könnte man ein ganzes Buch füllen. Ganz grob: Eine Class
      ist ein Container für irgendwas und eine Methode verändert etwas in
      diesem Container.</para>

      <para>Lesen Sie bitte weiter und schauen Sie sich die Beispiele an.
      Stück für Stück wird das Puzzle dann klarer.</para>
    </important>

    <section xml:id="ruby-methoden">
      <title>Methoden</title>

      <para>In anderen Programmiersprachen würden man zu Ruby-Methoden
      Begriffe wie die folgenen verwenden:<itemizedlist>
          <listitem>
            <para>Funktionen</para>
          </listitem>

          <listitem>
            <para>Prozeduren</para>
          </listitem>

          <listitem>
            <para>Subroutinen</para>
          </listitem>

          <listitem>
            <para>Makros</para>
          </listitem>
        </itemizedlist></para>

      <para>Da Ruby objektorientiert angelegt ist, sind es in Ruby halt
      Methoden. Man darf sich da an dem Namen nicht stören.<note>
          <para>Es gibt zwei Arten von Methoden (Class Method und Instance
          Method). Ich will es an dieser Stelle nicht zu kompliziert machen
          und übergehe diese "Feinheit" einfach mal.</para>
        </note></para>

      <para>An so einer Stelle sucht man immer nach einem guten Beispiel, aber
      es fallen nur eigentlich unsinnige Beispiele ein. Das Problem ist dabei
      die Prämisse, das man nur Wissen benutzen kann/darf, das bis zu dieser
      Stelle schon im Buch beschrieben wurde.</para>

      <para>Nehmen wir also an, das wir folgenden Code-Ablauf aus welchem
      Grund auch immer häufig verwenden:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):002:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):003:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):004:0&gt; <command>exit</command>
</screen></para>

      <para>Wir möchten also drei mal hintereinander den String 'Hello World!'
      ausgeben. Da dies unseren täglichen Arbeitsablauf stark in die Länge
      zieht, definieren wir jetzt eine Methode (mit dem sinnfreien Namen
      <methodname>drei_mal</methodname>), mit der man das alles auf einmal
      machen kann.<important>
          <para>Namen von Methoden fangen immer kleingeschrieben.</para>
        </important><screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>def drei_mal</command>  # Start der Definition
irb(main):002:1&gt; <command>puts 'Hello World!'</command>
irb(main):003:1&gt; <command>puts 'Hello World!'</command>
irb(main):004:1&gt; <command>puts 'Hello World!'</command>
irb(main):005:1&gt; <command>end</command>           # Ende der Definition
=&gt; nil
irb(main):006:0&gt; <command>drei_mal</command>      # Aufruf der Methode
Hello World!
Hello World!
Hello World!
=&gt; nil
irb(main):007:0&gt; <command>exit</command>
</screen></para>

      <para>Bei der Definition eines Moduls kann man benötigte Parameter
      definieren und diese innerhalb des Moduls benutzen. Damit können wir
      eine Methode erstellen, der wir einen String als Parameter übergeben und
      den dann drei mal ausgeben lassen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>def drei_mal(dummy)</command> # Parameter: dummy
irb(main):002:1&gt; <command>puts dummy</command>
irb(main):003:1&gt; <command>puts dummy</command>
irb(main):004:1&gt; <command>puts dummy</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>drei_mal('Hello World!')</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
</screen></para>

      <para>Die Klammern beim Aufruf kann man sich übrigens sparen. <screen>irb(main):007:0&gt; <command>drei_mal 'Hello World!'</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
</screen></para>

      <tip>
        <para>Ruby-Gurus und Möchte-Gern-Ruby-Gurus werden über "unnötige"
        Klammern in Ihren Programmen die Nase rüpfen und wahrscheinlich mehr
        oder weniger blöde Kommentare mit Vergleichen zu Java und anderen
        Programmiersprachen machen.</para>

        <para>Es gilt in der Ruby-Community eine einfache Regel: Je weniger
        Klammern, desto cooler! ;-)</para>
      </tip>

      <para>Und wenn man keinen Parameter angibt, kommt die Fehlermeldung:
      <code>wrong number of arguments</code><screen>irb(main):008:0&gt; <command>drei_mal</command>
ArgumentError: wrong number of arguments (0 for 1)
 from (irb):8
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
irb(main):009:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section xml:id="ruby-class">
      <title>Class (Klassen)</title>

      <para>Eine Class ist nichts anderes als eine Ansammlung von Methoden.
      Der Name einer Class beginnt immer mit einem Grossbuchstaben. Nehmen wir
      mal an, das die Methode zur neuen Class Dies_und_das gehört. Dann würde
      Sie in einem Ruby-Programm folgendermassen definiert:<programlisting>class Dies_und_das      # Start der Klassendefinition
  def drei_mail
    puts 'Hello World!'
    puts 'Hello World!'
    puts 'Hello World!'
  end
end                     # Ende der Klassendefinition</programlisting></para>

      <para>Spielen wir das mal im irb durch:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Dies_und_das</command>
irb(main):002:1&gt; <command>def drei_mal</command>
irb(main):003:2&gt; <command>puts 'Hello World!'</command>
irb(main):004:2&gt; <command>puts 'Hello World!'</command>
irb(main):005:2&gt; <command>puts 'Hello World!'</command>
irb(main):006:2&gt; <command>end</command>
irb(main):007:1&gt; <command>end</command>
=&gt; nil
</screen></para>

      <para>Jetzt probieren wir mal aus, die Methode
      <methodname>drei_mail</methodname> aufzurufen:<screen>irb(main):008:0&gt; <command>Dies_und_das.drei_mal</command>
NoMethodError: undefined method `drei_mal' for Dies_und_das:Class
 from (irb):8
from /usr/local/bin/irb:12:in `&lt;main&gt;'
</screen></para>

      <para>Das gibt eine Fehlermeldung, den
      <classname>Dies_und_das</classname> ist hier ein Class und kein Objekt.
      Es funktioniert nur, wenn wir vorher ein neuen Objekt (eine neue
      Instance) der Class <classname>Dies_und_das</classname> mit der Methode
      <methodname>new</methodname> generiert haben:<screen>irb(main):009:0&gt; <command>abc = Dies_und_das.new</command>
=&gt; #&lt;Dies_und_das:0x9ebb3f0&gt;
irb(main):010:0&gt; <command>abc.drei_mal</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
irb(main):011:0&gt; <command>exit</command>
</screen></para>

      <section>
        <title>Liste aller Instance-Methoden</title>

        <para>Für eine Class kann man mit der Methode instance_methods alle
        Instance-Methoden auslesen. Probieren wir das mal mit der Class
        <classname>Dies_und_das</classname> aus (die legen wir dazu noch mal
        neu im <application>irb</application> an):<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Dies_und_das</command>
irb(main):002:1&gt; <command>def drei_mal</command>
irb(main):003:2&gt; <command>puts 'Hello World!'</command>
irb(main):004:2&gt; <command>puts 'Hello World!'</command>
irb(main):005:2&gt; <command>puts 'Hello World!'</command>
irb(main):006:2&gt; <command>end</command>
irb(main):007:1&gt; <command>end</command>
=&gt; nil
irb(main):008:0&gt; <command>Dies_und_das.instance_methods</command>
=&gt; [:drei_mal, :nil?, :===, :=~, :!~, :eql?, :class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :define_singleton_method, :hash, :__id__, :object_id, :to_enum, :enum_for, :gem, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
</screen></para>

        <para>Das ist ja viel mehr, als wir definiert haben! Das liegt daran,
        das jede neue Class von Ruby direkt mal ein Grundprogramm an
        Instance-Methoden mitbekommt. Wenn wir nur die von uns definierten
        Instance-Methoden auflisten wollen, so geht das wie folgt:<screen>irb(main):009:0&gt; <command>Dies_und_das.instance_methods(false)</command>
=&gt; [:drei_mal]
irb(main):010:0&gt;</screen></para>
      </section>

      <section>
        <title>private Methoden</title>

        <para>Es ist häufig sinnvoll eine Methode nur innerhalb der eigenen
        Class bzw. der eigenen Instance aufzurufen. Solche Methoden nennt man
        private Methoden und sie werden innerhalb einer Class unterhalb des
        Schlüsselwortes private aufgeführt.</para>

        <para>irb Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Beispiel</command>         # Definition der Class Beispiel
irb(main):002:1&gt; <command>def mach_was</command>           # Definition der Methode mach_was
irb(main):003:2&gt; <command>puts 'Was'</command>           
irb(main):004:2&gt; <command>end</command>
irb(main):005:1&gt; <command>def mach_noch_was</command>      # Definition der Methode mach_noch_was
irb(main):006:2&gt; <command>puts noch_was_machen</command>
irb(main):007:2&gt; <command>end</command>
irb(main):008:1&gt; 
irb(main):009:1* <command>private</command>                # Start der private Methoden
irb(main):010:1&gt; <command>def noch_was_machen</command>    # Definition der Methode noch_was_machen
irb(main):011:2&gt; <command>puts 'Noch was.'</command>
irb(main):012:2&gt; <command>end</command>
irb(main):013:1&gt; <command>end</command>
=&gt; nil
irb(main):014:0&gt; <command>test = Beispiel.new</command>    # Neue Instance von Beispiel
=&gt; #&lt;Beispiel:0x8bb6ffc&gt;
irb(main):015:0&gt; <command>test.mach_was</command>          # Methode mach_was wird aufgerufen
Was
=&gt; nil
irb(main):016:0&gt; <command>test.mach_noch_was</command>     # Methode mach_noch_was wird aufgerufen
Noch was.

=&gt; nil
irb(main):017:0&gt; <command>test.noch_was_machen</command>   # Kann nicht von aussen aufgerufen werden.
NoMethodError: private method `noch_was_machen' called for #&lt;Beispiel:0x8bb6ffc&gt;
 from (irb):17
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
irb(main):018:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>initialize Methode</title>

        <para>Wenn man eine neue Instanz erstellt (also die Methode
        <methodname>.new</methodname> aufruft), dann gibt es einen Mechanismus
        eine Art Start-Skript ablaufen zu lassen. Dieser Mechanismus ist die
        Methode <methodname>initialize</methodname>. Die Methode ist
        automatisch eine private Methode, auch wenn Sie nicht explizit im
        Bereich private aufgeführt wird.</para>

        <para>irb Beispiel<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Beispiel</command>
irb(main):002:1&gt; <command>def initialize</command>
irb(main):003:2&gt; <command>puts 'Hello World!'</command>
irb(main):004:2&gt; <command>end</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>test = Beispiel.new</command>
Hello World!
=&gt; #&lt;Beispiel:0x99f1e24&gt;
irb(main):007:0&gt; <command>exit</command>
</screen></para>

        <para>Die Instance <classname>test</classname> wird mit
        <methodname>Beispiel.new</methodname> erstellt und als erstes wird
        dabei die Methode <methodname>initialize</methodname> abgearbeitet.
        Deshalb sieht man im irb die <application>puts</application>-Ausgabe
        aus der irb-Zeile 3.</para>

        <para>Die new Methode aktzeptiert die bei der
        <methodname>initialize</methodname> Methode angegebenen
        Parameter:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Beispiel</command>
irb(main):002:1&gt; <command>def initialize(aaa)</command>   # Definition Parameter aaa
irb(main):003:2&gt; <command>puts aaa</command>              # Ausgabe von aaa
irb(main):004:2&gt; <command>end</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>test = Beispiel.new('Hello World!')</command>
Hello World!
=&gt; #&lt;Beispiel:0x86bed84&gt;
irb(main):007:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Vererben</title>

        <para>Eine Class kann in eine andere Class vererbt werden. Bei der
        Definition der Class muss dabei die Eltern-Class mit einem &lt;
        (kleiner als) Zeichen angefügt werden:<programlisting>class Beispiel &lt; Elternklasse</programlisting>Von
        dieser Möglichkeit wir in Rails sehr oft gebraucht gemacht (an sonsten
        würde ich Sie damit hier nicht bemühen).</para>

        <para>Im folgenden Beispiel generieren wir die Class
        <classname>Literatur</classname> und fügen die Methode
        <methodname>antwort_auf_alle_fragen_des_universums</methodname> hinzu.
        Danach erstellen wir eine Class <classname>Allgemeinwissen</classname>
        und vererben dorthin die Class <classname>Literatur</classname>. Die
        Instance egon hat Zugriff auf alle Methoden und die Instance fritz nur
        auf die der Class <classname>Literatur</classname>.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Literatur</command>
irb(main):002:1&gt; <command>def antwort_auf_alle_fragen_des_universums</command>
irb(main):003:2&gt; <command>42</command>
irb(main):004:2&gt; <command>end</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>class Allgemeinwissen &lt; Literatur</command>     
irb(main):007:1&gt; <command>def pi</command>
irb(main):008:2&gt; <command>3.14</command>
irb(main):009:2&gt; <command>end</command>
irb(main):010:1&gt; <command>end</command>
=&gt; nil
irb(main):011:0&gt; <command>fritz = Literatur.new</command>
=&gt; #&lt;Literatur:0x90e7098&gt;
irb(main):012:0&gt; <command>egon = Allgemeinwissen.new</command>
=&gt; #&lt;Allgemeinwissen:0x90da0ac&gt;
irb(main):013:0&gt; <command>egon.antwort_auf_alle_fragen_des_universums</command>
=&gt; 42
irb(main):014:0&gt; <command>egon.pi</command>
=&gt; 3.14
irb(main):015:0&gt; <command>fritz.antwort_auf_alle_fragen_des_universums</command>
=&gt; 42
irb(main):016:0&gt; <command>fritz.pi</command>
NoMethodError: undefined method `pi' for #&lt;Literatur:0x90e7098&gt;
 from (irb):21
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
irb(main):017:0&gt; <command>exit</command>
</screen></para>
      </section>
    </section>

    <section>
      <title>Variablen</title>

      <para>Wir wissen ja jetzt, das in Ruby alles ein Objekt ist. Also muss
      auch eine Variable ein Objekt sein.</para>

      <section>
        <title>Namenskonventionen</title>

        <para>Normale Variablen werden kleingeschrieben. Konstanten fangen mit
        einem Grossbuchstaben an.<important>
            <para>Eine Konstante kann in Ruby auch mit einem neuen Wert
            überschrieben werden (allerdings wird dabei eine Warnung
            ausgegeben). Man sollte sich also nicht auf Unveränderlichkeit
            einer Konstanten verlassen.</para>
          </important> Auf der sicheren Seite ist man, wenn man nur
        ASCII-Zeichen verwendet. Allerdings könnten Sie mit Ruby 1.9 und der
        richtigen Codierung auch problemlos Sonderzeichen und Umlaute in einem
        Variablennamen verwenden. Die Höfflichkeit gegenüber anderen (evt.
        ausländischen) Programmierern die diese Zeichen vielleicht nicht fix
        und fertig auf der Tastatur haben, ist aber Grund eher auf rein ASCII
        zu gehen.</para>
      </section>

      <section>
        <title>String</title>

        <para>Probieren wir mal ein wenig im irb aus.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Ein Test.'</command>
=&gt; "Ein Test."
irb(main):002:0&gt; <command>a.class</command>
=&gt; String
</screen></para>

        <para>Das war einfach. Ruby erschaft also automagisch ein Objekt mit
        der Class String. Das ginge auch mit der Methode
        <methodname>new</methodname>:<screen>irb(main):003:0&gt; <command>b = String.new('Noch ein Test.')</command>
=&gt; "Noch ein Test."
irb(main):004:0&gt; <command>b.class</command>
=&gt; String
</screen></para>

        <para>Wenn wir
        <classname>String</classname><methodname>.new</methodname> ohne einen
        Parameter aufrufen, dann wird auch ein Objekt der Class
        <classname>String</classname> erstellt. Nur ist das dann leer:<screen>irb(main):005:0&gt; <command>c = String.new</command>
=&gt; ""
irb(main):006:0&gt; <command>c.class</command>
=&gt; String
irb(main):007:0&gt; <command>exit</command>
</screen></para>

        <section>
          <title>Einfache und doppelte Anführungszeichen</title>

          <para>Strings können nicht nur in einfachen Anführungszeichen,
          sondern auch in doppelten Anführungzeichen definiert werden. Bei den
          doppelten Anführungszeichen gibt es dann aber eine Besonderheit: Man
          kann Expressions innerhalb eines <code>#{}</code> Konstruktes
          einbinden. Das Ergebnis wird dann automatisch an die entsprechende
          Stelle im String eingesetzt.</para>

          <para>Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'blau'</command>
=&gt; blau
irb(main):002:0&gt; <command>b = "Farbe: #{a}"</command>
=&gt; "Farbe: blau"
irb(main):003:0&gt; <command>b.class</command>
=&gt; String
irb(main):004:0&gt; <command>exit</command>
</screen></para>

          <para>Ist das Ergebnis der Expression kein String, versucht Ruby die
          Methode <methodname>to_s</methodname> anzuwenden.</para>
        </section>
      </section>

      <section>
        <title>Zahlen</title>

        <section>
          <title>Fixnum und Bignum</title>

          <para>In <classname>Fixnum</classname> und
          <classname>Bignum</classname> sind
          <classname>Integer</classname>-Klassen (sprich ganze Zahlen). Ein
          Fixnum ist ein Integer, der in einem Word gespeichert werden kann
          (falls Sie nicht wissen, was ein Word ist =&gt; egal). Wird ein
          Fixnum größer, wandelt es sich automatisch in ein Bignum um.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>20.class</command>
=&gt; Fixnum
irb(main):002:0&gt; <command>a = 20</command>
=&gt; 20
irb(main):003:0&gt; <command>a.class</command>
=&gt; Fixnum
irb(main):004:0&gt; <command>a = a * 555555555</command> # Das Ergebnis wird automatisch ein Bignum.
=&gt; 11111111100
irb(main):005:0&gt; <command>a.class</command>
=&gt; Bignum
irb(main):006:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>Float</title>

          <para><classname>Float</classname> ist eine Class für reele Zahlen.
          Dabei wird die englische Schreibweise für das Komma (also ein Punkt)
          benutzt.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 20.424</command>
=&gt; 20.424
irb(main):002:0&gt; <command>a.class</command>
=&gt; Float
irb(main):003:0&gt; <command>42.2.class</command>
=&gt; Float
irb(main):004:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>Einfache Berechnungen</title>

          <para>Rechnen mit Integers und Floats ist so einfach, das man alles
          anhand von ein paar Zeilen irb Code beschreiben kann:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>b = 23</command>
=&gt; 23
irb(main):003:0&gt; <command>a + b</command>          # Addition von zwei Fixnums
=&gt; 33
irb(main):004:0&gt; <command>(a + b).class</command>  # Das Ergebnis ist ein Fixnum.
=&gt; Fixnum
irb(main):005:0&gt; <command>c = a + b</command>
=&gt; 33
irb(main):006:0&gt; <command>c.class</command>
=&gt; Fixnum
irb(main):007:0&gt; <command>d = 3.14</command>
=&gt; 3.14
irb(main):008:0&gt; <command>e = a + d</command>      # Addition Fixnum und Float
=&gt; 13.14
irb(main):009:0&gt; <command>e.class</command>        # Das Ergebnis ist ein Float.
=&gt; Float
irb(main):010:0&gt; <command>a * b</command>
=&gt; 230
irb(main):011:0&gt; <command>(a * b).class</command>
=&gt; Fixnum
irb(main):012:0&gt; <command>(a * b * d).class</command>
=&gt; Float
irb(main):013:0&gt; <command>b - a</command>
=&gt; 13
irb(main):014:0&gt; <command>a += 1</command>         # a = a + 1
=&gt; 11
irb(main):015:0&gt; <command>exit</command>
</screen></para>
        </section>
      </section>

      <section>
        <title>Booleans und nil</title>

        <para>Für Booleans (true und false) und für nil gibt es jeweils eine
        eigene Class:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>true.class</command>
=&gt; TrueClass
irb(main):002:0&gt; <command>false.class</command>
=&gt; FalseClass
irb(main):003:0&gt; <command>nil.class</command>
=&gt; NilClass
irb(main):004:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Reichweite von Variablen</title>

        <para>Variablen haben je nach Art eine unterschiedliche "Reichweite"
        innerhalb der Ruby oder Ruby on Rails Applikation. Am besten zeigt
        sich das mit diesem kleinen Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>def test</command>
irb(main):003:1&gt; <command>a = 20</command>
irb(main):004:1&gt; <command>end</command>
=&gt; nil
irb(main):005:0&gt; <command>puts a</command>
10
=&gt; nil
irb(main):006:0&gt; <command>test</command>
=&gt; 20
irb(main):007:0&gt; <command>puts a</command>
10
=&gt; nil
irb(main):008:0&gt; <command>exit</command>
</screen></para>

        <para>Obwohl die Methode <methodname>test</methodname> den Wert der
        Variable <varname>a</varname> auf 20 gesetzt hat, wurde dabei nur eine
        lokale Variable gesetzt. Das vorher im Hauptprogramm gesetzte
        <varname>a</varname> war davon nicht betroffen.</para>

        <section>
          <title>Lokale Variablen (aaa oder _aaa)</title>

          <para>Lokale Variablen fangen entweder mit einem kleinen Buchstaben
          oder mit einem Underscore (_) an. Ihre Reichweite beschränkt sich
          auf die aktuelle Umgebung (z.B. auf die aktuelle Methode).
          Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>aaa = 10</command>    # Lokale Variable aaa
=&gt; 10
irb(main):002:0&gt; <command>_bbb = 20</command>   # Lokale Variable _bbb
=&gt; 20
irb(main):003:0&gt; <command>puts aaa</command>
10
=&gt; nil
irb(main):004:0&gt; <command>puts _bbb</command>
20
=&gt; nil
irb(main):005:0&gt; <command>def test</command>    # Definition der Methode test
irb(main):006:1&gt; <command>aaa = 1000</command>  # Lokale Variable aaa
irb(main):007:1&gt; <command>_bbb = 2000</command> # Lokale Variable _bbb
irb(main):008:1&gt; <command>puts aaa</command>    # Ausgabe von aaa
irb(main):009:1&gt; <command>puts _bbb</command>   # Ausgabe von _bbb
irb(main):010:1&gt; <command>end</command>         # Ende der Methode test
=&gt; nil
irb(main):011:0&gt; <command>puts aaa</command>
10
=&gt; nil
irb(main):012:0&gt; <command>puts _bbb</command>
20
=&gt; nil
irb(main):013:0&gt; <command>test</command>        # Aufruf der Methode test
1000                         # siehe irb-Zeile 8
2000                         # siehe irb-Ziele 9
=&gt; nil
irb(main):014:0&gt; <command>puts aaa</command>
10
=&gt; nil
irb(main):015:0&gt; <command>puts _bbb</command>
20
=&gt; nil
irb(main):016:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>Globale Variablen ($aaa)</title>

          <para>Eine globale Variable fäng mit einem
          <varname>$</varname>-Zeichen an und ist im gesamten Programm
          erreichbar. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>$aaa = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>puts $aaa</command>
10
=&gt; nil
irb(main):003:0&gt; <command>def test</command>    # Definition der Methode test
irb(main):004:1&gt; <command>$aaa = 20</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>puts $aaa</command>   # Ausgabe von $aaa
10
=&gt; nil
irb(main):007:0&gt; <command>test</command>        # Aufruf der Methode test
=&gt; 20
irb(main):008:0&gt; <command>puts $aaa</command>   # Ausgabe von $aaa
20
=&gt; nil
irb(main):009:0&gt; <command>$aaa.class</command>
=&gt; Fixnum
irb(main):010:0&gt; <command>exit</command>
</screen></para>

          <para>Globale Variablen werden recht selten benutzt.</para>
        </section>

        <section>
          <title>Instance Variablen (@aaa)</title>

          <para>Instance Variablen gelten nur innerhalb einer Klasse, dort
          aber überall. Also quasi eine Mini-Version von Globalen Variablen.
          Im Gegensatz zu globalen Variablen findet man Instance Variablen in
          einer Rails-Applikation an jeder Ecke. Wir gehen die Sachen über ein
          Beispielprogramm mit dem Namen <filename>farbe.rb</filename>
          an:<programlisting>class Wand
  def initialize
    @farbe = 'weiss'
  end

  def farbe
    @farbe
  end

  def streich_alles_rot
    @farbe = 'rot'
  end

  def streich_alles_gelb
    @farbe = 'gelb'
  end

  def streich_alles_rosa
    farbe = 'rosa'
  end
end

meine_wand = Wand.new

puts meine_wand.farbe

meine_wand.streich_alles_rot

puts meine_wand.farbe

meine_wand.streich_alles_rosa

puts meine_wand.farbe
</programlisting>Wenn wir diese Programm starten, gibt es folgende
          Ausgabe:<screen>sw@debian:~/sandbox$ <command>ruby farbe.rb</command>
weiss
rot
rot
sw@debian:~/sandbox$</screen></para>

          <para>In der <methodname>initialize</methodname> Methode setzen wir
          die Instance Variable <varname>@farbe</varname> auf den Wert
          <parameter>weiss</parameter>. Die Methoden
          <methodname>streich_alles_rot</methodname> und
          <methodname>streich_alles_gelb</methodname> verändern diese Instance
          Variable. Die Methode <methodname>streich_alles_rosa</methodname>
          hingegen setzt nur eine lokale Variable mit dem Namen
          <varname>farbe</varname> (es fehlt das
          <varname>@</varname>-Zeichen).</para>

          <para>Mit der Methode <methodname>farbe</methodname> können wir uns
          ausserhalb der Instance den Wert von <varname>@farbe</varname>
          ausgeben lassen.</para>
        </section>
      </section>
    </section>

    <section xml:id="ruby-symbol">
      <title>Symbol</title>

      <para>Ist es schlimm, wenn Symbols an dieser Stelle nicht genau erklärt
      werden? Zur Benutzung von Symbols braucht man nämlich nur wissen wie ein
      Symbol aussieht und das ist leicht gezeigt:<programlisting>:symbolname</programlisting></para>

      <para>Es fängt also mit einem Doppelpunkt gefolgt von einem kleinen
      Buchstaben an. Symbols werden Sie in Rails einige male sehen und im Lauf
      der Zeit kommt Sinn rein. Fall Sie es dann nicht mehr aushalten, können
      Sie mit <command>ri Symbol</command> die Hilfeseite zur Class Symbol
      aufrufen.</para>
    </section>

    <section xml:id="mehr-zu-ruby-methoden">
      <title>Noch ein paar Worte zu Methoden</title>

      <para>Jetzt haben Sie ein wenig mehr Grundwissen und da können wir bei
      den Methoden ein kleine Stufe tiefer gehen.</para>

      <section>
        <title>getter und setter</title>

        <para>Da Intance Variablen nur innerhalb der jeweiligen Instance
        existieren, muss man um exportieren einer solchen Variable immer eine
        getter Methode schreiben. Wenn wir eine Class
        <classname>Raum</classname> definieren, die als Instance Variablen
        <varname>@tueren</varname> und <varname>@fenster</varname> hat (für
        die Anzahl der Türen und Fenster des Raumes), so können wir wie folgt
        eine getter Methode für <methodname>tueren</methodname> und
        <methodname>fenster</methodname> erstellen (Beispielprogramm
        <filename>raum.rb</filename>):<programlisting>class Raum
  def initialize
    @tueren = 1     # ein neuer Raum hat eine Tuer
    @fenster = 1    # ein neuer Raum hat ein Fenster
  end

  def tueren
    @tueren         # der Wert von @tueren wird ausgeben
  end

  def fenster
    @fenster        # der Wert von @fenster wird ausgegeben
  end
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster
</programlisting></para>

        <para>Die Ausführung des Programmes:<screen>sw@debian:~/sandbox$ <command>ruby raum.rb</command> 
1
1
sw@debian:~/sandbox$</screen></para>

        <para>Da dieses Problem so häufig auftritt, gibt es dafür schon eine
        vorgefertigte getter Methode mit dem Namen
        <methodname>attr_reader</methodname> die wie folgt im Programm
        <filename>raum.rb</filename> angewendet werden würde:<programlisting>class Raum
  def initialize
    @tueren = 1
    @fenster = 1
  end

  attr_reader :tueren, :fenster   # die Namen werden als Symbol angegeben
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster
</programlisting></para>

        <note>
          <para>attr_reader ist ein gutes Beispiel für Meta-Programmierung in
          Ruby. Sie werden gerade bei der Arbeit mit Rails immer wieder auf
          Meta-Programmierung stossen und sich über die Automagie
          freuen.</para>
        </note>

        <para>Wenn man von Aussen die Anzahl der Türen oder Fenster verändern
        will, so braucht man dafür eine setter Methode. Die kann wie folgt
        realisiert werden:<programlisting>class Raum
  def initialize
    @tueren = 1
    @fenster = 1
  end

  attr_reader :tueren, :fenster

  def tueren=(value)             # setter fuer tueren
    @tueren = value
  end

  def fenster=(value)            # setter fuer fenster
    @fenster = value
  end

end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster

wohnzimmer.fenster = 2           # fenster wird neu geschrieben

puts wohnzimmer.fenster
</programlisting></para>

        <para>Die entsprechende Ausgabe dazu:<screen>sw@debian:~/sandbox$ <command>ruby raum.rb</command>
1
1
2
sw@debian:~/sandbox$</screen></para>

        <para>Natürlich gibt es dazu auch einen vorgefertigten Weg. Mit der
        Methode <methodname>attr_writer</methodname> können Sie den Code von
        raum.rb weiter vereinfachen:<programlisting>class Raum
  def initialize
    @tueren = 1
    @fenster = 1
  end

  attr_reader :tueren, :fenster

  attr_writer :tueren, :fenster

end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster

wohnzimmer.fenster = 2

puts wohnzimmer.fenster
</programlisting></para>

        <para>Und (wer hätte das gedacht!) es gibt auch eine Methode
        <methodname>attr_accessor</methodname>, die getter und setter
        kombiniert. Der Code für <filename>raum.rb</filename> sähe dann so
        aus:<screen>class Raum
  def initialize
    @tueren = 1
    @fenster = 1
  end

  attr_accessor :tueren, :fenster

end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster

wohnzimmer.fenster = 2

puts wohnzimmer.fenster
</screen></para>
      </section>

      <section>
        <title>Mitgelieferte Methoden bei String</title>

        <para>Die meisten Klassen kommen von Hause aus schon mit einem ganzen
        Sack voll äusserst praktischer Methoden. Diese Methoden werden immer
        mit einem Punkt abgetrennt hinter dem entsprechenden Objekt
        geschrieben.</para>

        <para>Hier ein paar Beispiele für Methoden der Class
        <classname>String</classname>.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Das Haus.'</command>
=&gt; "Das Haus."
irb(main):002:0&gt; <command>a.class</command>     # .class gibt immer die Class des Objektes aus
=&gt; String
irb(main):003:0&gt; <command>a.size</command>      # Laenge des Strings
=&gt; 9
irb(main):004:0&gt; <command>a.downcase</command>  # Umwandlung in Kleinbuchstaben
=&gt; "das haus."
irb(main):005:0&gt; <command>a.upcase</command>    # Umwandlung in Grossbuchstaben
=&gt; "DAS HAUS."
irb(main):006:0&gt; <command>a.reverse</command>   # Buchstabenreihenfolge umdrehen
=&gt; ".suaH saD"
irb(main):007:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Verketten von Methoden</title>

        <para>Man kommt nicht direkt drauf, aber wenn man sich an das Arbeiten
        mit Ruby gewöhnt hat, dann ist es auch völlig selbstverständlich (weil
        logisch) verschiedene Methoden zu verketten.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Das Haus.'</command>
=&gt; "Das Haus."
irb(main):002:0&gt; <command>a.class</command>
=&gt; String
irb(main):003:0&gt; <command>a.upcase.reverse</command>  # Grossbuchstaben umgedreht
=&gt; ".SUAH SAD"
irb(main):004:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Von einem zum anderen (Konvertieren)</title>

        <para>Logischerweise gibt es eine ganze Reihe von praktischen Instance
        Methoden, um Objekte von einer Class in eine andere zu wandeln. Als
        erstes verwandelt wir mal mit der Methode
        <methodname>.to_s</methodname> ein Fixnum in einen String.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>a.class</command>
=&gt; Fixnum
irb(main):003:0&gt; <command>b = a.to_s</command>
=&gt; "10"
irb(main):004:0&gt; <command>exit</command>
</screen></para>

        <para>Nichts anderes macht übrigens <application>puts</application>,
        wenn man mit puts ein Fixnum oder ein Float ausgibt (es fügt bei
        Nicht-Strings einfach die Methode <methodname>.to_s</methodname> hinzu
        und gibt das Ergebnis aus).</para>

        <para>Jetzt wandeln wir mal mit der Methode
        <methodname>.to_i</methodname> ein Float in ein Fixnum um.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>c = 10.0</command>
=&gt; 10.0
irb(main):002:0&gt; <command>c.class</command>
=&gt; Float
irb(main):003:0&gt; <command>d = c.to_i</command>
=&gt; 10
irb(main):004:0&gt; <command>d.class</command>
=&gt; Fixnum
irb(main):005:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>to_s Methode bei eigener Class</title>

        <para>Man sollte - und wenn es nur für das einfachere Debugging ist -
        bei selbst erstellten Class-en immer eine Methode
        <methodname>to_s</methodname> einbauen. Dann kann man ein
        entsprechendes Objekt einfach mit <application>puts</application>
        ausgeben (puts gibt ein Objekt automatisch unter Verwendung der
        <methodname>to_s</methodname> Methode aus).</para>

        <para>Ein Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Tier</command>
irb(main):002:1&gt; <command>def initialize(de_name,en_name)</command>
irb(main):003:2&gt; <command>@de_name = de_name</command>
irb(main):004:2&gt; <command>@en_name = en_name</command>
irb(main):005:2&gt; <command>end</command>
irb(main):006:1&gt; <command>def to_s</command>
irb(main):007:2&gt; <command>@de_name + ' (' + @en_name + ')'</command>
irb(main):008:2&gt; <command>end</command>
irb(main):009:1&gt; <command>end</command>
=&gt; nil
irb(main):010:0&gt; <command>lumpi = Tier.new('Hund', 'Dog')</command>
=&gt; #&lt;Tier:0x873b5c8 @de_name="Hund", @en_name="Dog"&gt;
irb(main):011:0&gt; <command>hansi = Tier.new('Wellensittich', 'Budgerigar')</command>           
=&gt; #&lt;Tier:0x86b60f8 @de_name="Wellensittich", @en_name="Budgerigar"&gt;
irb(main):012:0&gt; <command>puts lumpi</command>
Hund(Dog)
=&gt; nil
irb(main):013:0&gt; <command>puts hansi</command>
Wellensittich(Budgerigar)
=&gt; nil
irb(main):014:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>"+" ist eine Methode?</title>

        <para>Wieso steht bei der Liste der Methoden beim
        <classname>String</classname> auch das Pluszeichen? Schauen wir mal
        mit <application>ri</application> nach.<screen>sw@debian:~/sandbox$ <command>ri String.+</command>
--------------------------------------------------------------- String#+
     str + other_str   =&gt; new_str

     From Ruby 1.9.1
------------------------------------------------------------------------
     Concatenation---Returns a new +String+ containing _other_str_
     concatenated to _str_.

        "Hello from " + self.to_s   #=&gt; "Hello from main"

sw@debian:~/sandbox$</screen></para>

        <para>hmmm... mal schauen was da bei <classname>Fixnum</classname>
        steht.<screen>sw@debian:~/sandbox$ <command>ri Fixnum.+</command>
--------------------------------------------------------------- Fixnum#+
     fix + numeric   =&gt;  numeric_result

     From Ruby 1.9.1
------------------------------------------------------------------------
     Performs addition: the class of the resulting object depends on the
     class of +numeric+ and on the magnitude of the result.

sw@debian:~/sandbox$</screen></para>

        <para>Spielen wir damit mal im irb. Wir müssten ja dann das
        <methodname>+</methodname> genauso wie jede andere Methode mit einem
        Punkt an die Class hängen können und die zweite Zahl in einer Klammer
        als Parameter anfügen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>10 + 10</command>
=&gt; 20
irb(main):002:0&gt; <command>10+10</command>
=&gt; 20
irb(main):003:0&gt; <command>10.+10</command>
=&gt; 20
irb(main):004:0&gt; <command>10.+(10)</command>
=&gt; 20
irb(main):005:0&gt; <command>exit</command>
</screen></para>

        <para>Aha! Das Pluszeichen ist tatsächlich eine Methode und diese
        Methode nimmt den nächsten Wert als Parameter. Eigentlich müssten wir
        diesen Wert in einer Klammer setzen, aber Ruby erspart mit
        durchdachter Syntax.</para>

        <section>
          <title>Kann ich die Methode + überschreiben?</title>

          <para>Ja, man kann alle Methoden überschreiben. Logischerweise macht
          das bei Methoden wie <methodname>+</methodname> wenig Sinn, ausser
          man will damit seine Programmierkollegen in den Wahnsinn treiben.
          Damit Sie mir glauben, führe ich jetzt im irb mal eine kleine Demo
          aus.</para>

          <para>Das Ziel ist es die Methode <methodname>+</methodname> für
          Fixnum umzuschreiben. Als Ergebnis jeder Addition soll die Zahl 42
          rauskommen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>10 + 10</command>
=&gt; 20
irb(main):002:0&gt; <command>10 + 5555</command>
=&gt; 5565
irb(main):003:0&gt; <command>class Fixnum</command> 
irb(main):004:1&gt; <command>def +(name, *args, &amp;blk)</command>
irb(main):005:2&gt; <command>42</command>
irb(main):006:2&gt; <command>end</command>
irb(main):007:1&gt; <command>end</command>
=&gt; nil
irb(main):008:0&gt; <command>10 + 10</command>
=&gt; 42
irb(main):042:0&gt; <command>10 + 5555</command>
=&gt; 42
irb(main):042:0&gt; <command>exit</command>
</screen></para>

          <para>In den Zeilen 1 und 2 führen wir die normale Addition durch.
          In den Zeilen 3 bis 7 definieren wir die Methode
          <methodname>+</methodname> für die Class
          <classname>Fixnum</classname> neu und danach führen wir noch einmal
          die Berechnung durch. Dann allerdings mit anderen
          Ergebnissen.</para>
        </section>
      </section>

      <section>
        <title>Liste aller Methoden für eine bestimmte Class</title>

        <para>Nun hat man nicht immer alle Methoden-Namen im Kopf, weiß aber
        das es für das spezielle Problem eine perfekte Methode gibt (passiert
        mir ständig).</para>

        <section>
          <title>Im irb</title>

          <para>Mit der Methode methods kann man die zur Verfügung stehenden
          Methoden anzeigen. Allerdings weiß man dann nicht unbedingt was
          diese genau machen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Das blaue Haus.'</command>
=&gt; "Das blaue Haus."
irb(main):002:0&gt; <command>a.methods</command>
=&gt; [:&lt;=&gt;, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :&lt;&lt;, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :&gt;, :&gt;=, :&lt;, :&lt;=, :between?, :nil?, :!~, :class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :define_singleton_method, :__id__, :object_id, :to_enum, :enum_for, :gem, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
irb(main):003:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>http://ruby-doc.org via Google und Co.</title>

          <para>Unter <olink>http://ruby-doc.org</olink> finden Sie online
          eine optisch aufbereitete und unter einander verlinkte Ruby
          Dokumentaion. Der einfachste Weg dort eine Liste der Methoden zu
          bekommen ist sicherlich eine Suchmaschine. Einfach "Ruby" und den
          Namen der Class als Suchbegriff eingeben und dann bekommt man meist
          als ersten Eintrag diese offizielle Ruby Dokumentation
          angezeigt.</para>

          <para>Wenn ich alle Methoden für die Class String suche, dann suche
          in in Google nach "ruby string" und bekomme als ersten Treffer die
          URL
          <olink>http://ruby-doc.org/core/classes/String.html</olink>.<footnote>
              <para>Wer ganz sicher gehen will, kann auch folgenden Suchstring
              nehmen "String site:ruby-doc.org"</para>
            </footnote> Auf dieser Seite bekomme ich dann Beispiele zu allen
          Methoden.</para>
        </section>

        <section>
          <title>Hilfe per ri</title>

          <para>Es gibt noch eine eingebaute Hilfe (das Programm
          <application>ri</application>) die wir anstatt Google auf der
          Kommandozeile aufrufen können. Sehr praktisch, allerdings nicht so
          schön bunt. ;-)</para>

          <para>Wenn Sie Informationen zur Class String suchen, dann können
          Sie diese auf der Kommandozeile wie folgt ausgeben:<screen>sw@debian:~/sandbox$ <command>ri String</command>
------------------------------------------------- Class: String &lt; Object
     A +String+ object holds and manipulates an arbitrary sequence of
     bytes, typically representing characters. String objects may be
     created using +String::new+ or as literals.

     Because of aliasing issues, users of strings should be aware of the
     methods that modify the contents of a +String+ object. Typically,
     methods with names ending in ``!'' modify their receiver, while
     those without a ``!'' return a new +String+. However, there are
     exceptions, such as +String#[]=+.

     Enhance the String class with a XML escaped character version of
     to_s.

     User defined methods to be added to String.

------------------------------------------------------------------------


Includes:
---------

     Comparable


Class methods:
--------------

     new, try_convert, yaml_new


Instance methods:
-----------------

     %, *, +, &lt;&lt;, &lt;=&gt;, ==, ===, =~, [], []=, ascii_only?, block_scanf,
     bytes, bytesize, capitalize, capitalize!, casecmp, center, chars,
     chomp, chomp!, chop, chop!, chr, clear, codepoints, concat, count,
     crypt, delete, delete!, downcase, downcase!, dump, each_byte,
     each_char, each_codepoint, each_line, empty?, encode, encode!,
     encoding, end_with?, eql?, ext, force_encoding, getbyte, gsub,
     gsub!, hash, hex, include?, index, initialize_copy, insert,
     inspect, intern, is_binary_data?, is_complex_yaml?, iseuc, isjis,
     issjis, isutf8, kconv, length, lines, ljust, lstrip, lstrip!,
     match, next, next!, oct, ord, parse_csv, partition, pathmap,
     pathmap_explode, pathmap_partial, pathmap_replace, replace,
     reverse, reverse!, rindex, rjust, rpartition, rstrip, rstrip!,
     scan, scanf, setbyte, shellescape, shellsplit, size, slice, slice!,
     split, squeeze, squeeze!, start_with?, strip, strip!, sub, sub!,
     succ, succ!, sum, swapcase, swapcase!, to_blob, to_d, to_f, to_i,
     to_s, to_str, to_sym, to_yaml, toeuc, tojis, tolocale, tosjis,
     toutf16, toutf32, toutf8, tr, tr!, tr_s, tr_s!, unpack, upcase,
     upcase!, upto, valid_encoding?
sw@debian:~/sandbox$</screen></para>

          <para>Suchen wir jetzt Informationen zu einer bestimmten Methode,
          dann geht das auch mit ri. Als Beispiel nehmen wir mal gsub. Das ist
          eine Methode, mit der man Elemente in einem String austauschen kann
          (immer wieder praktisch).<screen>sw@debian:~/sandbox$ <command>ri String.gsub</command>
------------------------------------------------------------ String#gsub
     str.gsub(pattern, replacement)       =&gt; new_str
     str.gsub(pattern) {|match| block }   =&gt; new_str

     From Ruby 1.9.1
------------------------------------------------------------------------
     Returns a copy of _str_ with _all_ occurrences of _pattern_
     replaced with either _replacement_ or the value of the block. The
     _pattern_ will typically be a +Regexp+; if it is a +String+ then no
     regular expression metacharacters will be interpreted (that is
     +/\d/+ will match a digit, but +'\d'+ will match a backslash
     followed by a 'd').

     If a string is used as the replacement, special variables from the
     match (such as +$&amp;+ and +$1+) cannot be substituted into it, as
     substitution into the string occurs before the pattern match
     starts. However, the sequences +\1+, +\2+, +\k&lt;group_name&gt;+, and so
     on may be used to interpolate successive groups in the match.

     In the block form, the current match string is passed in as a
     parameter, and variables such as +$1+, +$2+, +$`+, +$&amp;+, and +$'+
     will be set appropriately. The value returned by the block will be
     substituted for the match on each call.

     The result inherits any tainting in the original string or any
     supplied replacement string.

        "hello".gsub(/[aeiou]/, '*')                  #=&gt; "h*ll*"
        "hello".gsub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; "h&lt;e&gt;ll&lt;o&gt;"
        "hello".gsub(/./) {|s| s[0].ord.to_s + ' '}   #=&gt; "104 101 108 108 111 "
        "hello".gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}')  #=&gt; "h{e}ll{o}"

sw@debian:~/sandbox$</screen></para>
        </section>
      </section>
    </section>
  </section>

  <section xml:id="ruby-if-condition">
    <title>if-Condition</title>

    <para>Eine Abstrakte if-Condition sieht so aus:<programlisting>if expression
  programm
end</programlisting></para>

    <para>Das Programm zwischen der Expression und <code>end</code> wird immer
    dann ausgeführt, wenn das Ergebnis der Expression nicht
    <parameter>false</parameter> und nicht <parameter>nil</parameter>
    ist.</para>

    <para>Das Konstrukt für eine einfache if-Verzweigung in einem
    Ruby-Programm sieht wie folgendes Beispielprogramm aus:<programlisting>a = 10

if a == 10 then   # a == 10 ist die Expression
  puts 'a ist 10' # das Programm
end
</programlisting></para>

    <para>Eine Expression kann man sehr gut im irb ausprobieren:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>a == 10</command>
=&gt; true
irb(main):003:0&gt; <command>exit</command>
</screen></para>

    <section>
      <title>Kurzform</title>

      <para>Eine häufig anzutreffende Kurzform eine If-Condition ist im
      folgenden Code zu finden:<programlisting>a = 10

# Langversion
#
if a == 10 then
  puts 'a ist 10'
end

# Kurzversion
#
puts 'a ist 10' if a == 10
</programlisting></para>
    </section>

    <section>
      <title>else</title>

      <para>Man kann es sich schon denken, aber der Vollständigkeit halber
      auch hierzu noch ein kleines Beispiel:<programlisting>a = 10

if a == 10 then
  puts 'a ist 10'
else
  puts 'a ist nicht 10'
end
</programlisting></para>
    </section>
  </section>

  <section xml:id="ruby-schleifen">
    <title>Schleifen</title>

    <para>Es gibt verschiedenen Arten Schleifen in Ruby zu realisieren. Dabei
    kommt im Rails-Umfeld vor allen Dingen die Interator-Variante häufig zum
    Einsatz.</para>

    <section>
      <title>While und Until</title>

      <para>Eine While-Schleife sieht abstrakt wie folgt aus:<programlisting>while expression do
  programm
end</programlisting></para>

      <para>Und praktisch wie in folgendem irb-Beispiel:<screen>irb(main):001:0&gt; <command>i = 0</command>             # i wird auf 0 gesetzt
=&gt; 0
irb(main):002:0&gt; <command>while i &lt;= 5 do</command>   # Schleifendefinition
irb(main):003:1* <command>i = i + 1</command>         # i wird um 1 erhöht
irb(main):004:1&gt; <command>puts i</command>            # i wird ausgegeben
irb(main):005:1&gt; <command>end</command>               # Ende der Schleife
1
2
3
4
5
6
=&gt; nil
irb(main):006:0&gt; <command>exit</command>
</screen></para>

      <para>Until-Schleifen werden ähnlich aufgebaut:<programlisting>until expression
  programm
end</programlisting></para>

      <para>Auch hier das irb-Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>i = 5</command>
=&gt; 5
irb(main):002:0&gt; <command>until i == 0</command>
irb(main):003:1&gt; <command>i = i - 1</command>
irb(main):004:1&gt; <command>puts i</command>
irb(main):005:1&gt; <command>end</command>
4
3
2
1
0
=&gt; nil
irb(main):006:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section>
      <title>Blocks und Iteratoren</title>

      <para>"Block" und "Iterator" gehören zu den Lieblingswörter vieler
      Ruby-Programmierer. Jetzt zeige ich Ihnen mal warum.</para>

      <para>Bei der Schleife<programlisting>5.times { |i| puts i }</programlisting>
      ist <varname>i</varname> der Iterator und <code>puts i</code> der
      Block.</para>

      <para>Das ganze kann aber auch in der folgenden Form ausgedrückt
      werden:<programlisting>5.times do |i|
  puts i
end</programlisting></para>

      <section>
        <title>Iterator</title>

        <para>Ein Iterator ist nicht weiter als eine bestimmte Art von
        Methoden. "Iterate" steht dabei für "Wiederholen". Bei der Class
        Fixnum gibt es zum Beispiel den Iterator
        <methodname>times</methodname>. Mal schauen was uns
        <application>ri</application> dazu als Hilfe anbietet:<screen>sw@debian:~/sandbox$ <command>ri Fixnum.times</command>
---------------------------------------------------------- Integer#times
     int.times {|i| block }     =&gt; int

     From Ruby 1.9.1
------------------------------------------------------------------------
     Iterates block _int_ times, passing in values from zero to _int_ -
     1.

        5.times do |i|
          print i, " "
        end

     _produces:_

        0 1 2 3 4

sw@debian:~/sandbox$</screen></para>

        <para>Und dort steht auch direkt ein schönes Beispiel, welches wir im
        <application>irb</application> ausprobieren:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>5.times do |i|</command>
irb(main):002:1* <command>puts i</command>
irb(main):003:1&gt; <command>end</command>
0
1
2
3
4
=&gt; 5
irb(main):004:0&gt; <command>exit</command>
</screen></para>

        <para>Und es gibt auch noch eine kurze Schreibweise für kleine
        Blocks:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>5.times { |i| puts i }</command>
0
1
2
3
4
=&gt; 5
irb(main):002:0&gt; <command>exit</command>
</screen></para>

        <para>Ein Interator muss übrigens nicht zwangsläufig auch eine
        Variable dem Block übergeben:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>5.times { puts 'Das blaue Haus.' }</command>
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
=&gt; 5
irb(main):002:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Block</title>

        <para>Ein Block ist nichts anderes, als das von einem Iterator
        ausgelöste Programm. Im Block hat man Zugriff auf die vom Iterator
        übergebene lokale Variable.</para>
      </section>

      <section>
        <title>upto Methode</title>

        <para>Neben <methodname>times</methodname> gibt es noch die
        <methodname>upto</methodname> Methode, um leicht eine Schleife zu
        realisieren. ri gibt uns auch hier ein schönes Beispiel.<screen>sw@debian:~/sandbox$ <command>ri Fixnum.upto</command>
----------------------------------------------------------- Integer#upto
     int.upto(limit) {|i| block }     =&gt; int

     From Ruby 1.9.1
------------------------------------------------------------------------
     Iterates _block_, passing in integer values from _int_ up to and
     including _limit_.

        5.upto(10) { |i| print i, " " }

     _produces:_

        5 6 7 8 9 10

sw@debian:~/sandbox$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="ruby-array-und-hash">
    <title>Arrays und Hashes</title>

    <para>Wie in vielen Programmiersprachen sind auch in Ruby Arrays und
    Hashes beliebte Mechanismen, um Daten zu speichern.</para>

    <section>
      <title>Array</title>

      <para>Eine Array ist eine Liste von Objekten. Spielen wir doch einmal
      ein wenig im irb.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = [1,2,3,4,5]</command>
=&gt; [1, 2, 3, 4, 5]
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>exit</command>
</screen></para>

      <para>Das ist einfach und verständlich. Mal schauen, ob das so auch mit
      Strings im Array funktioniert.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = ['Test', 'Apfelbaum', 'blau']</command>
=&gt; ["Test", "Apfelbaum", "blau"]
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>a[1]</command>
=&gt; "Apfelbaum"
irb(main):004:0&gt; <command>a[1].class</command>
=&gt; String
irb(main):005:0&gt; <command>exit</command>
</screen></para>

      <para>Das geht auch. Dann fehlt nur noch ein Array mit einem Mix aus
      beidem. Ist klar, das es gehen muss, weil das Array ja Objekte speichert
      und es egal ist, welche Art von Objekten (sprich String, Fixnum oder
      Float) das ist. Aber ein Versuch schadet ja nicht.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = [1, 2, 'Haus', 'Baum', 4]</command>
=&gt; [1, 2, "Haus", "Baum", 4]
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>a[0]</command>
=&gt; 1
irb(main):004:0&gt; <command>a[0].class</command>
=&gt; Fixnum
irb(main):005:0&gt; <command>a[2]</command>
=&gt; "Haus"
irb(main):006:0&gt; <command>a[2].class</command>
=&gt; String
irb(main):007:0&gt; <command>exit</command>
</screen></para>

      <para>Schauen wir uns als nächstes mal die ri Hilfeseite zu Array
      an.<screen>sw@debian:~/sandbox$ <command>ri Array</command>
-------------------------------------------------- Class: Array &lt; Object
     Arrays are ordered, integer-indexed collections of any object.
     Array indexing starts at 0, as in C or Java. A negative index is
     assumed to be relative to the end of the array---that is, an index
     of -1 indicates the last element of the array, -2 is the next to
     last element in the array, and so on.

------------------------------------------------------------------------


Includes:
---------

     Enumerable


Class methods:
--------------

     [], new, try_convert


Instance methods:
-----------------

     &amp;, *, +, -, &lt;&lt;, &lt;=&gt;, ==, [], []=, abbrev, assoc, at, clear,
     collect, collect!, combination, compact, compact!, concat, count,
     cycle, dclone, delete, delete_at, delete_if, drop, drop_while,
     each, each_index, empty?, eql?, fetch, fill, find_index, first,
     flatten, flatten!, frozen?, hash, include?, index, initialize_copy,
     insert, inspect, join, last, length, map, map!, pack, permutation,
     pop, pretty_print, pretty_print_cycle, product, push, rassoc,
     reject, reject!, replace, reverse, reverse!, reverse_each, rindex,
     sample, select, shelljoin, shift, shuffle, shuffle!, size, slice,
     slice!, sort, sort!, take, take_while, to_a, to_ary, to_csv, to_s,
     to_yaml, transpose, uniq, uniq!, unshift, values_at,
     yaml_initialize, zip, |
sw@debian:~/sandbox$</screen></para>

      <para>Arrays können also auch (wie jede Class) mit der Methode new
      erstellt werden. Einzelne neue Elemente können dann mit der Methode
      <methodname>&lt;&lt;</methodname> hinzugefügt werden. Auch hierzu ein
      Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = Array.new</command>
=&gt; []
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>a &lt;&lt; 'erster Eintrag'</command>
=&gt; ["erster Eintrag"]
irb(main):004:0&gt; <command>a &lt;&lt; 'zweiter Eintrag'</command>
=&gt; ["erster Eintrag", "zweiter Eintrag"]
irb(main):005:0&gt; <command>a &lt;&lt; 'dritter Eintrag'</command>
=&gt; ["erster Eintrag", "zweiter Eintrag", "dritter Eintrag"]
irb(main):006:0&gt; <command>a.size</command>
=&gt; 3
irb(main):007:0&gt; <command>exit</command>
</screen></para>

      <para>Aber versuchen wir doch mal ein Array mit Einträgen aus einer
      selbstdefinierten Klasse zu erstellen:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Tier</command>              # Definition einer Class Tier
irb(main):002:1&gt; <command>def initialize(de_name,en_name)</command>
irb(main):003:2&gt; <command>@de_name = de_name</command>
irb(main):004:2&gt; <command>@en_name = en_name</command>
irb(main):005:2&gt; <command>end</command>
irb(main):006:1&gt; <command>def to_s</command>
irb(main):007:2&gt; <command>@de_name + ' (' + @en_name + ')'</command>
irb(main):008:2&gt; <command>end</command>
irb(main):009:1&gt; <command>end</command>
=&gt; nil
irb(main):010:0&gt; <command>lumpi = Tier.new('Hund', 'Dog')</command>
=&gt; #&lt;Tier:0x873b5c8 @de_name="Hund", @en_name="Dog"&gt;
irb(main):011:0&gt; <command>hansi = Tier.new('Wellensittich', 'Budgerigar')</command>           
=&gt; #&lt;Tier:0x86b60f8 @de_name="Wellensittich", @en_name="Budgerigar"&gt;
irb(main):012:0&gt; <command>haustiere = Array.new</command>   # haustiere ist ein Array
=&gt; []
irb(main):013:0&gt; <command>haustiere &lt;&lt; hansi</command>      # hansi wird dem Array hinzugefuegt
=&gt; [#&lt;Tier:0x8d11f18 @de_name="Wellensittich", @en_name="Budgerigar"&gt;]
irb(main):014:0&gt; <command>haustiere &lt;&lt; lumpi</command>      # lumpi wird dem Array hinzugefuegt
=&gt; [#&lt;Tier:0x8d11f18 @de_name="Wellensittich", @en_name="Budgerigar"&gt;, #&lt;Tier:0x8d9751c @de_name="Hund", @en_name="Dog"&gt;]
irb(main):015:0&gt; <command>haustiere.count</command>
=&gt; 2
irb(main):016:0&gt; <command>puts haustiere[1]</command>       # Ausgabe der Position 1
Hund (Dog)
=&gt; nil
irb(main):017:0&gt; <command>puts haustiere[0]</command>       # Ausgabe der Position 0
Wellensittich (Budgerigar)
=&gt; nil
irb(main):018:0&gt; <command>exit</command>
</screen></para>

      <section>
        <title>Iterator (each)</title>

        <para>Mit der Methode <methodname>each</methodname> kann man sich
        Stück für Stück durch ein Array arbeiten. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>einkaufsliste = ['Eier', 'Butter', 'Mehl']</command>
=&gt; ["Eier", "Butter", "Mehl"]
irb(main):002:0&gt; <command>einkaufsliste.each do |produkt|</command>
irb(main):003:1* <command>puts produkt</command>
irb(main):004:1&gt; <command>end</command>
Eier
Butter
Mehl
=&gt; ["Eier", "Butter", "Mehl"]
irb(main):005:0&gt; <command>exit</command>
</screen></para>

        <para>Auch hier gibt Ihnen <application>ri</application> Hilfe und ein
        Beispiel, falls Sie mal vergessen haben sollten wie
        <methodname>each</methodname> anzuwenden ist:<screen>sw@debian:~/sandbox$ <command>ri Array.each</command>
------------------------------------------------------------- Array#each
     array.each {|item| block }   -&gt;   array

     From Ruby 1.9.1
------------------------------------------------------------------------
     Calls _block_ once for each element in _self_, passing that element
     as a parameter.

        a = [ "a", "b", "c" ]
        a.each {|x| print x, " -- " }

     produces:

        a -- b -- c --

sw@debian:~/sandbox$</screen></para>
      </section>
    </section>

    <section>
      <title>Hash</title>

      <para>Ein Hash ist eine Liste aus Key-und-Value Paaren. Ein Beispiel mit
      Strings als Key:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>preisliste = { '6 Eier' =&gt; 1.2, '12 Eier' =&gt; 2, '500 gr Butter' =&gt; 0.99 }</command>
=&gt; {"6 Eier"=&gt;1.2, "12 Eier"=&gt;2, "500 gr Butter"=&gt;0.99}
irb(main):002:0&gt; <command>preisliste['12 Eier']</command>
=&gt; 2
irb(main):003:0&gt; <command>preisliste.count</command>
=&gt; 3
irb(main):004:0&gt; <command>exit</command>
</screen></para>

      <para>Die Benutzung von Symbols als Keys ist Speicher-Effizienter (auch
      wenn, das bei diesem Beispiel natürlich keinen grossen Unterschied
      macht):<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>farben = { :black =&gt; '#000000', :white =&gt; ':FFFFFF', :green =&gt; '#00C000', :blue =&gt; '#0000FF' }
=&gt; {:black=&gt;"#000000", :white=&gt;":FFFFFF", :green=&gt;"#00C000", :blue=&gt;"#0000FF"}</command>
irb(main):002:0&gt; <command>puts farben[:green]</command>
#00C000
=&gt; nil
irb(main):003:0&gt; <command>exit</command>
</screen></para>

      <para>Natürlich können in Hashes nicht nur Strings, sondern auch selbst
      definierte Class-en als Objekte im Value gespeichert werden (siehe
      Array-Beispiel).</para>

      <para>Wie zu Array gibt es auch zu Hash eine sehr gute ri
      Hilfe-Seite:<screen>sw@debian:~/sandbox$ <command>ri Hash</command>
--------------------------------------------------- Class: Hash &lt; Object
     A +Hash+ is a collection of key-value pairs. It is similar to an
     +Array+, except that indexing is done via arbitrary keys of any
     object type, not an integer index. The order in which you traverse
     a hash by either key or value may seem arbitrary, and will
     generally not be in the insertion order.

     Hashes have a _default value_ that is returned when accessing keys
     that do not exist in the hash. By default, that value is +nil+.

------------------------------------------------------------------------


Includes:
---------

     Enumerable


Class methods:
--------------

     [], new, try_convert


Instance methods:
-----------------

     ==, [], []=, assoc, clear, compare_by_identity,
     compare_by_identity?, default, default=, default_proc,
     default_proc=, delete, delete_if, each, each_key, each_pair,
     each_value, empty?, eql?, fetch, flatten, has_key?, has_value?,
     hash, include?, initialize_copy, inspect, invert, key, key?, keys,
     length, member?, merge, merge!, pretty_print, pretty_print_cycle,
     rassoc, rehash, reject, reject!, replace, select, shift, size,
     store, to_a, to_hash, to_s, to_yaml, update, value?, values,
     values_at, yaml_initialize
sw@debian:~/sandbox$</screen></para>

      <section>
        <title>Iterator (each)</title>

        <para>Mit der Methode <methodname>each</methodname> kann man sich
        Stück für Stück durch ein Hash arbeiten. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>einkaufsliste = { 'Eier' =&gt; 6, 'Butter' =&gt; '500 gr' }</command>
=&gt; {"Eier"=&gt;6, "Butter"=&gt;"500 gr"}
irb(main):002:0&gt; <command>einkaufsliste.each do |key,value|</command>
irb(main):003:1* <command>puts "Produkt: #{key} - Menge: #{value}"</command>
irb(main):004:1&gt; <command>end</command>
Produkt: Eier - Menge: 6
Produkt: Butter - Menge: 500 gr
=&gt; {"Eier"=&gt;6, "Butter"=&gt;"500 gr"}
irb(main):005:0&gt; <command>exit</command>
</screen></para>

        <para>Auch hier gibt Ihnen <application>ri</application> Hilfe und ein
        Beispiel, falls Sie mal vergessen haben sollten wie
        <methodname>each</methodname> anzuwenden ist:<screen>sw@debian:~/sandbox$ <command>ri Hash.each</command>
-------------------------------------------------------------- Hash#each
     hsh.each {| key, value | block } -&gt; hsh
     hsh.each_pair {| key, value | block } -&gt; hsh

     From Ruby 1.9.1
------------------------------------------------------------------------
     Calls _block_ once for each key in _hsh_, passing the key-value
     pair as parameters.

        h = { "a" =&gt; 100, "b" =&gt; 200 }
        h.each {|key, value| puts "#{key} is #{value}" }

     _produces:_

        a is 100
        b is 200

sw@debian:~/sandbox$</screen></para>
      </section>
    </section>
  </section>
</chapter>
