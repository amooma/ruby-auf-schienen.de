<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ruby-grundlagen" xml:lang="de"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title xml:id="ruby-grundlagen.title">Ruby-Grundlagen</title>

  <section xml:id="ruby-grundlagen-einleitung">
    <title>Einleitung</title>

    <para>Genauso wie dieses Buch Grundkenntnisse in HTML voraussetzt, so muss
    der Leser - also Sie - auch ein Grundverständnis von Programmierung
    mitbringen. Allerdings schreibt schon der Ruby-Erfinder Yukihiro Matsumoto
    in seinem Buch <quote><citetitle>The Ruby Programming
    Language</citetitle></quote><footnote>
        <para>Das Buch ist sehr empfehlenswert für jeden, der Ruby verstehen
        will. David Flanagan hat zusammen mit Yukihiro Matsumoto (a.k.a. Matz)
        super Arbeit geleistet.</para>
      </footnote> über Ruby:</para>

    <para><quote>It is easy to program in Ruby, but Ruby is not a simple
    language.</quote></para>

    <para>Dieses Kapitel ist eine Gratwanderung zwischen falscher
    Vereinfachung und für den Rails-Anfänger unnötiger Ausführlichkeit. Es
    geht ja nicht darum, ein Ruby-Guru zu werden, sondern Ruby on Rails zu
    verstehen. Ich gehe auf die wichtigsten Sachen ein. Alles Weitere liegt
    dann an Ihnen. Wenn Sie sich mehr für Ruby interessieren, dann empfehle
    ich Ihnen das Buch "The Ruby Programming Language" von David Flanagan und
    Yukihiro Matsumoto.</para>

    <note>
      <para>Lange habe ich den Fehler gemacht und versucht, Ruby on Rails zu
      verstehen, ohne eine Ahnung von Ruby zu haben. Ruby sah so einfach aus,
      und deshalb habe ich mir keine Gedanken darüber gemacht. Da ich aber
      Ruby nicht grundlegend verstand, konnte ich auch Rails nicht verstehen.
      Deshalb habe ich es immer wieder in die virtuelle Ecke gelegt und weiter
      mit PHP gearbeitet. Erst nachdem ich mir Ruby intensiv angeschaut hatte,
      fiel der Groschen. <footnote>
          <para>Heute bin ich ein so großer Ruby-on-Rails-Fan, dass ich mir
          sogar die Mühe mache, dazu ein Buch zu schreiben, um es Ihnen
          näherzubringen. ;-)</para>
        </footnote></para>
    </note>
  </section>

  <section xml:id="ruby-ist-eine-skriptsprache">
    <title>Eine Skriptsprache</title>

    <para>Ruby ist eine Skriptsprache. Es wird also nicht kompiliert und dann
    ausgeführt, sondern von einem Interpreter eingelesen und dann Zeile für
    Zeile abgearbeitet.</para>
  </section>

  <section xml:id="hello-world-in-ruby">
    <title>Hello World</title>

    <indexterm>
      <primary>Hello World</primary>

      <secondary>in Ruby</secondary>
    </indexterm>

    <indexterm>
      <primary>Hallo Welt</primary>

      <see>Hello World</see>
    </indexterm>

    <para>Ein einfaches Ruby-Programm <filename>hello-world.rb</filename>
    besteht aus folgender Zeile:<programlisting>puts 'Hello World!'
</programlisting></para>

    <para>Öffnen Sie mit Ihrem Lieblingseditor eine neue Datei mit dem Namen
    <filename>hello-world.rb</filename> und fügen Sie die obige Zeile in diese
    Datei ein. Dann können Sie dieses Ruby-Programm wie folgt auf der
    Kommandozeile ausführen:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!
sw@debian:~/sandbox$ </screen></para>

    <para>Eine Programmzeile in einem Ruby-Programm muss nicht durch ein
    Semikolon beendet werden. Der Ruby-Interpreter ist sogar so intelligent,
    zu erkennen, wenn eine Programmzeile wegen der besseren Lesbarkeit in zwei
    oder mehr Zeilen aufgeteilt wird. Ich erspare Ihnen jetzt die
    entsprechenden Beispiele und erwähne es nur, damit Sie später nicht
    sagen/denken <quote>Geht das denn so?</quote></para>

    <para>Einrücken von Code ist ebenfalls nicht notwendig. Allerdings
    erleichtert das die Lesbarkeit für den Menschen ungemein!</para>

    <section xml:id="puts-und-print">
      <title>puts und print</title>

      <indexterm>
        <primary>puts()</primary>
      </indexterm>

      <indexterm>
        <primary>print()</primary>
      </indexterm>

      <para>Wer im Internet nach Beispielen zu Ruby sucht, findet zwei
      typische Möglichkeiten, Texte auszugeben:<itemizedlist>
          <listitem>
            <para><code>puts</code></para>

            <para>Gibt einen String aus, gefolgt von einem
            Zeilenvorschub.</para>
          </listitem>

          <listitem>
            <para><code>print</code></para>

            <para>Gibt einen String aus (ohne Zeilenvorschub). Sollte der
            String selber einen Zeilenvorschub enthalten, so wird dieser
            normal ausgegeben.</para>
          </listitem>
        </itemizedlist>Beispielprogramm (eine Erweiterung des Programms
      <filename>hello-world.rb</filename>):<programlisting>puts 'Hello World!'
puts
puts '------------'
print 'Hello World!'
print
puts '------------'
</programlisting></para>

      <para>Die dazugehörige Bildschirmausgabe:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!

------------
Hello World!------------
sw@debian:~/sandbox$ </screen></para>
    </section>

    <section xml:id="kommentare-in-ruby">
      <title>Kommentare</title>

      <indexterm>
        <primary>Kommentare</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>Ein Kommentar in einem Ruby-Programm wird mit einem
      <code>#</code>-Zeichen eingeleitet und von einem Zeilenvorschub beendet.
      Als Beispiel erweitere ich das obige <filename>hello-world.rb</filename>
      um einen Kommentar:<programlisting><emphasis role="bold"># Programm zum Anzeigen von "Hello World!"</emphasis>
<emphasis role="bold"># by Stefan Wintermeyer</emphasis>

puts 'Hello World!'</programlisting></para>

      <para>Ein Kommentar kann auch nach einer Programmzeile
      stehen:<programlisting># Programm zum Anzeigen von "Hello World!"
# by Stefan Wintermeyer

puts 'Hello World!'  <emphasis role="bold"># Ausgabe</emphasis></programlisting></para>

      <para>Ein <code>#</code>-Zeichen innerhalb von Strings in
      Anführungszeichen wird nicht als Anfang eines Kommentars behandelt.
      Beispielprogramm:<programlisting># Beispielprogramm
# by Stefan Wintermeyer

puts 'Hello World!'
puts <emphasis role="bold">'############'</emphasis>
puts
puts <emphasis role="bold">'1#2#3#4#5#6#'</emphasis>  # Kommentar dazu
</programlisting></para>

      <para>Die Bildschirmausgabe dazu:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!
############

1#2#3#4#5#6#
sw@debian:~/sandbox$ </screen></para>
    </section>

    <section xml:id="ri">
      <title>Hilfe per ri</title>

      <indexterm>
        <primary>ri</primary>

        <secondary><quote>Ruby Index</quote> (Ruby-Hilfe)</secondary>
      </indexterm>

      <indexterm>
        <primary>Ruby</primary>

        <secondary>ri (eingebaute Hilfe)</secondary>

        <see>ri</see>
      </indexterm>

      <indexterm>
        <primary>Ruby Index</primary>

        <see>ri</see>
      </indexterm>

      <para>Man hat ja beim Programmieren nicht immer ein Ruby-Buch zur Hand.
      Aber daran haben die Ruby-Entwickler gedacht und mit dem Programm
      <literal>ri</literal> eine eigene Hilfe eingebaut (natürlich nur, wenn
      Sie diese auch mit installiert haben). <acronym>ri</acronym> steht für
      <quote><emphasis role="bold">R</emphasis>uby <emphasis
      role="bold">I</emphasis>ndex</quote>.</para>

      <para>Jetzt haben wir eine typische Henne-Ei-Situation. Wie kann ich
      Ihnen die Hilfe zu Ruby erklären, wenn wir gerade erst mit Ruby
      anfangen? Ich greife also voraus und zeige Ihnen, wie Sie Informationen
      zur Klasse <classname>String</classname> suchen können:<screen>sw@debian:~/sandbox$ <command>ri String</command>
= String &lt; Object

------------------------------------------------------------------------------
= Includes:
Comparable (from ruby site)

(from ruby site)
------------------------------------------------------------------------------
A String object holds and manipulates an arbitrary sequence of bytes,
typically representing characters. String objects may be created using
String::new or as literals.

Because of aliasing issues, users of strings should be aware of the methods
that modify the contents of a String object.  Typically, methods with names
ending in ``!'' modify their receiver, while those without a ``!'' return a
new String.  However, there are exceptions, such as String#[]=.


Rake extension methods for String. 

[...]</screen></para>

      <para>Suchen wir jetzt Informationen zu einer bestimmten Methode
      (Henne-Ei!), dann geht das auch mit <literal>ri</literal>. Als Beispiel
      nehmen wir mal <methodname>gsub</methodname>. Das ist eine Methode, mit
      der sich Teile in einem <classname>String</classname> austauschen lassen
      (immer wieder praktisch).<screen>sw@debian:~/sandbox$ <command>ri String.gsub</command>
= String.gsub

(from ruby site)
------------------------------------------------------------------------------
  str.gsub(pattern, replacement)       -&gt; new_str
  str.gsub(pattern, hash)              -&gt; new_str
  str.gsub(pattern) {|match| block }   -&gt; new_str
  str.gsub(pattern)                    -&gt; enumerator

------------------------------------------------------------------------------

Returns a copy of str with the all occurrences of
pattern substituted for the second argument. The
pattern is typically a Regexp; if given as a String, any regular
expression metacharacters it contains will be interpreted literally, e.g.
'\\\d' will match a backlash followed by 'd', instead of a digit.

If replacement is a String it will be substituted for
the matched text. It may contain back-references to the pattern's capture
groups of the form \\\d, where d is a group number, or \\\k&lt;n&gt;, where n is
a group name. If it is a double-quoted string, both back-references must be
preceded by an additional backslash. However, within
replacement the special match variables, such as &amp;$,
will not refer to the current match.

If the second argument is a Hash, and the matched text is one of its keys, the
corresponding value is the replacement string.

In the block form, the current match string is passed in as a parameter, and
variables such as $1, $2, $`, $&amp;, and $' will be set appropriately. The value
returned by the block will be substituted for the match on each call.

The result inherits any tainting in the original string or any supplied
replacement string.

When neither a block nor a second argument is supplied, an Enumerator is
returned.

  "hello".gsub(/[aeiou]/, '*')                  #=&gt; "h*ll*"
  "hello".gsub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; "h&lt;e&gt;ll&lt;o&gt;"
  "hello".gsub(/./) {|s| s.ord.to_s + ' '}      #=&gt; "104 101 108 108 111 "
  "hello".gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}')  #=&gt; "h{e}ll{o}"
  'hello'.gsub(/[eo]/, 'e' =&gt; 3, 'o' =&gt; '*')    #=&gt; "h3ll*"</screen></para>

      <para>Das Programm <command>ri</command> gibt die Ausgabe immer in dem
      von der Shell definierten Pager-Programm aus (z.B.
      <command>less</command>). Sie können aber auch mit dem Schalter
      <command>-T</command> alles direkt auf STDOUT ausgeben. Im Buch werde
      ich beide Varianten benutzen.</para>
    </section>
  </section>

  <section xml:id="irb">
    <title>irb</title>

    <indexterm>
      <primary>irb</primary>

      <secondary><quote>Interactive Ruby</quote> (Ruby-Shell,
      Ruby-Konsole)</secondary>
    </indexterm>

    <indexterm>
      <primary>Ruby-Shell</primary>

      <see>irb</see>
    </indexterm>

    <indexterm>
      <primary>Interactive Ruby</primary>

      <see>irb</see>
    </indexterm>

    <para><acronym>irb</acronym> steht für <quote><emphasis
    role="bold">I</emphasis>nteractive <emphasis
    role="bold">R</emphasis>u<emphasis role="bold">b</emphasis>y</quote> und
    ist eine Art Sandkasten, in dem man beliebig mit Ruby herumspielen kann.
    irb wird mit der Eingabe von <command>irb</command> auf der Shell
    gestartet und durch Eingabe von <command>exit</command> wieder
    beendet.</para>

    <para>Ein Beispiel sagt mehr als tausend Worte:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
1.9.3p194 :003:0&gt; <command>exit</command>
sw@debian:~/sandbox$ </screen></para>

    <para>In diesem Kapitel werden viele Beispiele innerhalb von
    <application>irb</application> erarbeitet. Sie werden auch später bei der
    Arbeit oft innerhalb von <literal>irb</literal> neue Sachen ausprobieren,
    weil es so herrlich schnell und unkompliziert ist.</para>

    <section xml:id="kommentare-im-irb">
      <title>Kommentare im irb</title>

      <para>Kommentare innerhalb von <literal>irb</literal> machen
      logischerweise selten richtig Sinn, da in <literal>irb</literal>
      erarbeiteter Code quasi Wegwerf-Code ist. Innerhalb dieses Buches werden
      aber immer mal wieder Kommentare zur Erklärung auch im
      <literal>irb</literal> benutzt. Diese können Sie problemlos mit kopieren
      und im <literal>irb</literal> einfügen oder auch weglassen.</para>
    </section>
  </section>

  <section xml:id="ruby-ist-objekt-orientiert">
    <title>Ruby ist objektorientiert</title>

    <para>Ruby kennt nur Objekte. Alles ist ein Objekt (was ja fast schon
    zen-artig ist). Jedes Objekt ist eine Instanz (Instance) einer Klasse
    (Class). Die Klasse eines Objektes lässt sich mit der Methode
    <methodname>.class</methodname> herausfinden.</para>

    <para>Ein Objekt in Ruby ist eingekapselt und kann von außen nur mit den
    Methoden des entsprechenden Objektes erreicht werden. Was das heißt? Ich
    kann von außen keine Eigenschaft in einem Objekt direkt verändern. Das
    entsprechende Objekt muss mir dafür eine Methode zur Verfügung
    stellen.</para>

    <note>
      <para>Sie haben keine Ahnung, was eine Klasse und was ein Objekt ist?
      Keine Panik! Ich werde es keinem erzählen, und man kann auch ganz gut
      damit arbeiten, ohne sich große Gedanken darüber zu machen. Allein mit
      diesem Thema ließe sich ein eigenes und viel dickeres Buch füllen. Ganz
      grob: Ein Objekt ist ein Container für irgendetwas und eine Methode
      verändert etwas in diesem Container.</para>

      <para>Lesen Sie bitte weiter und schauen Sie sich die Beispiele an.
      Stück für Stück wird das Puzzle dann klarer.</para>
    </note>

    <section xml:id="ruby-methoden">
      <title>Methoden (Methods)</title>

      <indexterm>
        <primary>Methoden</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>In anderen Programmiersprachen würde man für Ruby-Methoden
      Begriffe wie die folgenden verwenden: Funktionen, Prozeduren,
      Subroutinen und natürlich Methoden.</para>

      <note>
        <para>Es gibt zwei Arten von Methoden (Class Methods und Instance
        Methods). Ich will es an dieser Stelle nicht zu kompliziert machen und
        übergehe diesen <quote>feinen</quote> Unterschied einfach mal.</para>
      </note>

      <para>An einer derartigen Stelle sucht man immer nach einem guten
      Beispiel, aber es fallen einem eigentlich nur unsinnige ein. Das Problem
      ist dabei die Prämisse, dass man lediglich Wissen benutzen kann/darf,
      das bis zu dieser Stelle bereits im Buch beschrieben wurde.</para>

      <para>Nehmen wir also an, dass wir folgenden Code-Ablauf - aus welchem
      Grund auch immer - häufig verwenden:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
1.9.3p194 :002:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
1.9.3p194 :003:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>

      <para>Wir möchten also dreimal hintereinander den String <quote>Hello
      World!</quote> ausgeben. Da dies unseren täglichen Arbeitsablauf stark
      in die Länge zieht, definieren wir jetzt eine Methode (mit dem
      sinnfreien Namen <methodname>drei_mal</methodname>), mit der sich das
      alles auf einmal erledigen lässt.<important>
          <para>Namen von Methoden werden immer kleingeschrieben.</para>
        </important><screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>def drei_mal</command>  # Start der Definition
1.9.3p194 :002:1&gt; <command>  puts 'Hello World!'</command>
1.9.3p194 :003:1&gt; <command>  puts 'Hello World!'</command>
1.9.3p194 :004:1&gt; <command>  puts 'Hello World!'</command>
1.9.3p194 :005:1&gt; <command>end</command>           # Ende der Definition
=&gt; nil
1.9.3p194 :006:0&gt; <command>drei_mal</command>      # Aufruf der Methode
Hello World!
Hello World!
Hello World!
=&gt; nil
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>

      <para>Bei der Definition einer Methode kann man benötigte Parameter
      definieren und diese innerhalb der Methode benutzen. Damit können wir
      eine Methode erstellen, der wir einen String als Parameter übergeben,
      und diesen dann dreimal ausgeben lassen.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>def drei_mal(apfelmus)</command>
1.9.3p194 :002:1&gt; <command>  puts apfelmus</command>
1.9.3p194 :003:1&gt; <command>  puts apfelmus</command>
1.9.3p194 :004:1&gt; <command>  puts apfelmus</command>
1.9.3p194 :005:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :006:0&gt; <command>drei_mal('Hello World!')</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
</screen></para>

      <para>Die Klammern beim Aufruf können Sie übrigens weglassen.<screen>1.9.3p194 :007:0&gt; <command>drei_mal 'Hello World!'</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
</screen></para>

      <tip>
        <para>Ruby-Gurus und Möchtegern-Ruby-Gurus werden über
        <quote>unnötige</quote> Klammern in Ihren Programmen die Nase rümpfen
        und wahrscheinlich mehr oder weniger blöde Kommentare mit Vergleichen
        zu Java und anderen Programmiersprachen machen.</para>

        <para>Es gilt in der Ruby-Community eine einfache Regel: Je weniger
        Klammern, desto cooler! <literal>;-)</literal></para>

        <para>Unter uns: Für weniger Klammern gibt es keinen Orden.
        Entscheiden Sie selber, womit Sie sich am wohlsten fühlen.</para>
      </tip>

      <para>Wenn man bei der obigen Methode keinen Parameter angibt, erscheint
      die Fehlermeldung: <quote><literal>wrong number of
      arguments</literal></quote>:<screen>1.9.3p194 :008:0&gt; <command>drei_mal</command>
ArgumentError: wrong number of arguments (0 for 1)
 from (irb):8
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
1.9.3p194 :009:0&gt; <command>exit</command>
</screen></para>

      <para>Sie können der Variable <varname>apfelmus</varname> einen Default
      Wert geben und können dann die Methode auch ohne Parameter
      aufrufen:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>def drei_mal(apfelmus = 'blau')</command>
1.9.3p194 :002:1&gt; <command>  puts apfelmus</command>
1.9.3p194 :003:1&gt; <command>  puts apfelmus</command>
1.9.3p194 :004:1&gt; <command>  puts apfelmus</command>
1.9.3p194 :005:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :006:1 &gt; <command>drei_mal('Hello World!')</command>
Hello World!
Hello World!
Hello World!
 =&gt; nil 
1.9.3p194 :007:1 &gt; <command>drei_mal</command>
blau
blau
blau
 =&gt; nil 
1.9.3p194 :008:1 &gt; <command>exit</command></screen></para>
    </section>

    <section xml:id="ruby-class">
      <title>Klassen (Classes)</title>

      <indexterm>
        <primary>Klassen</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>class</primary>

        <see>Klassen in Ruby</see>
      </indexterm>

      <para>Eine Klasse ist zunächst mal eine Ansammlung von Methoden. Der
      Name einer Klasse beginnt immer mit einem Großbuchstaben. Nehmen wir
      einmal an, dass die Methode zur neuen Klasse
      <classname>Dies_und_das</classname> gehört. Dann würde sie in einem
      Ruby-Programm folgendermaßen definiert:<programlisting>class Dies_und_das       # Beginn der Klassendefinition
  def drei_mal
    puts 'Hello World!'
    puts 'Hello World!'
    puts 'Hello World!'
  end
end                      # Ende der Klassendefinition</programlisting></para>

      <para>Spielen wir das mal im <literal>irb</literal> durch:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Dies_und_das</command>
1.9.3p194 :002:1&gt; <command>  def drei_mal</command>
1.9.3p194 :003:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :004:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :005:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :006:2&gt; <command>  end</command>
1.9.3p194 :007:1&gt; <command>end</command>
=&gt; nil
</screen></para>

      <para>Jetzt probieren wir aus, die Methode
      <methodname>drei_mal</methodname> aufzurufen:<screen>1.9.3p194 :008:0&gt; <command>Dies_und_das.drei_mal</command>
NoMethodError: undefined method `drei_mal' for Dies_und_das:Class
 from (irb):8
from /usr/local/bin/irb:12:in `&lt;main&gt;'
</screen></para>

      <para>Das gibt eine Fehlermeldung, denn
      <classname>Dies_und_das</classname> ist eine Klasse und keine Instanz.
      Da wir hier mit Instanz-Methoden arbeiten, funktioniert es nur, wenn wir
      vorher ein neues Objekt (also eine neue Instanz) der Klasse
      <classname>Dies_und_das</classname> mit der Klassen-Methode
      <methodname>new</methodname> erzeugt haben:<screen>1.9.3p194 :009:0&gt; <command>abc = Dies_und_das.new</command>
=&gt; #&lt;Dies_und_das:0x9ebb3f0&gt;
1.9.3p194 :010:0&gt; <command>abc.drei_mal</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
1.9.3p194 :011:0&gt; <command>exit</command>
</screen></para>

      <para>Auf den genauen Unterschied von Instanz- und Klassen-Methoden gehe
      ich in <xref linkend="class_methods_vs_instance_methods"/> ein. Wieder
      so ein Henne-Ei-Problem.</para>

      <section xml:id="ruby-private-methods">
        <title>Private Methoden</title>

        <indexterm>
          <primary>Methoden</primary>

          <secondary>private, in Ruby</secondary>
        </indexterm>

        <para>Es ist häufig sinnvoll, eine Methode nur innerhalb der eigenen
        Klasse bzw. der eigenen Instanz aufzurufen. Solche Methoden nennt man
        private Methoden (im Gegensatz zu den öffentlichen Methoden), und sie
        werden innerhalb einer Klasse unterhalb des Schlüsselwortes
        <literal>private</literal> aufgeführt.</para>

        <para>irb-Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Beispiel</command>         # Klasse Beispiel
1.9.3p194 :002:1&gt; <command>  def mach_was</command>         # Methode mach_was
1.9.3p194 :003:2&gt; <command>    puts 'Was.'</command>           
1.9.3p194 :004:2&gt; <command>  end</command>
1.9.3p194 :005:1&gt; <command>  def mach_noch_was</command>    # Methode mach_noch_was
1.9.3p194 :006:2&gt; <command>    puts 'Noch was.'</command>
1.9.3p194 :007:2&gt; <command>  end</command>
1.9.3p194 :008:1&gt;   
1.9.3p194 :009:1* <command>  private</command>              # Beginn der privaten Methoden
1.9.3p194 :010:1&gt; <command>  def noch_mehr</command>        # Methode noch_mehr
1.9.3p194 :011:2&gt; <command>    puts 'Noch was.'</command>
1.9.3p194 :012:2&gt; <command>  end</command>
1.9.3p194 :013:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :014:0&gt; <command>test = Beispiel.new</command>    # Neue Instanz von Beispiel
=&gt; #&lt;Beispiel:0x8bb6ffc&gt;
1.9.3p194 :015:0&gt; <command>test.mach_was</command>          # Methode .mach_was aufrufen
Was.
=&gt; nil
1.9.3p194 :016:0&gt; <command>test.mach_noch_was</command>     # Methode .mach_noch_was aufrufen
Noch was.

=&gt; nil
1.9.3p194 :017:0&gt; <command>test.noch_mehr</command>   # Kann nicht von außen aufgerufen werden.
NoMethodError: private method `noch_mehr' called for #&lt;Beispiel:0x8bb6ffc&gt;
 from (irb):17
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
1.9.3p194 :018:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="ruby-initialize">
        <title xml:id="ruby-initialize.title">Methode initialize()</title>

        <indexterm>
          <primary>initialize()</primary>

          <secondary>bei Klassen in Ruby</secondary>
        </indexterm>

        <indexterm>
          <primary>new()</primary>

          <secondary>bei Klassen in Ruby</secondary>

          <see>initialize()</see>
        </indexterm>

        <indexterm>
          <primary>Konstruktor</primary>

          <secondary>von Klassen in Ruby</secondary>

          <see>initialize()</see>
        </indexterm>

        <para>Wird eine neue Instanz erstellt (also die Methode
        <methodname>new</methodname> aufgerufen), dann wird als Erstes und
        automatisch die Methode <methodname>initialize</methodname>
        abgearbeitet. Die Methode ist automatisch eine private Methode, auch
        wenn sie nicht explizit im Bereich <literal>private</literal>
        aufgeführt wird.</para>

        <para>irb-Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Beispiel</command>
1.9.3p194 :002:1&gt; <command>  def initialize</command>
1.9.3p194 :003:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :004:2&gt; <command>  end</command>
1.9.3p194 :005:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :006:0&gt; <command>test = Beispiel.new</command>
Hello World!
=&gt; #&lt;Beispiel:0x99f1e24&gt;
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>

        <para>Die Instanz <code>test</code> wird mit <code>Beispiel.new</code>
        erstellt, und dabei wird zuerst die Methode
        <methodname>initialize</methodname> abgearbeitet. Deshalb sieht man im
        irb die <code>puts</code>-Ausgabe aus der irb-Zeile 3.</para>

        <para>Die Methode <methodname>new</methodname> akzeptiert die bei der
        Methode <methodname>initialize</methodname> angegebenen
        Parameter:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Beispiel</command>
1.9.3p194 :002:1&gt; <command>  def initialize(aaa)</command>   # Definition Parameter aaa
1.9.3p194 :003:2&gt; <command>    puts aaa</command>            # Ausgabe von aaa
1.9.3p194 :004:2&gt; <command>  end</command>
1.9.3p194 :005:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :006:0&gt; <command>test = Beispiel.new('Hello World!')</command>
Hello World!
=&gt; #&lt;Beispiel:0x86bed84&gt;
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="ruby-class-inheritance">
        <title>Vererbung</title>

        <indexterm>
          <primary>Vererbung</primary>

          <secondary>bei Klassen in Ruby</secondary>
        </indexterm>

        <para>Eine Klasse kann von einer anderen Klasse erben. Bei der
        Definition der Klasse muss dabei die Eltern-Klasse mit einem
        <literal>&lt;</literal> (Kleiner-als-Zeichen) angefügt
        werden:<programlisting>class Beispiel &lt; Elternklasse</programlisting>Von
        dieser Möglichkeit wird in Rails sehr oft Gebrauch gemacht (ansonsten
        würde ich Sie damit hier nicht behelligen).</para>

        <para>Im folgenden Beispiel definieren wir die Klasse
        <classname>Literatur</classname> und fügen die Methode
        <methodname>antwort_auf_alle_fragen_des_universums</methodname> hinzu.
        Danach definieren wir eine Klasse
        <classname>Allgemeinwissen</classname> und vererben dorthin die Klasse
        <classname>Literatur</classname>. Die Instanz <code>egon</code> hat
        Zugriff auf alle Methoden und die Instanz <code>fritz</code> nur auf
        die der Klasse <classname>Literatur</classname>.<footnote>
            <para>Bei dem Satz wird einem ja schwindelig. ;-)</para>
          </footnote><screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Literatur</command>
1.9.3p194 :002:1&gt; <command>  def antwort_auf_alle_fragen_des_universums</command>
1.9.3p194 :003:2&gt; <command>    42</command>
1.9.3p194 :004:2&gt; <command>  end</command>
1.9.3p194 :005:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :006:0&gt; <command>class Allgemeinwissen &lt; Literatur</command>     
1.9.3p194 :007:1&gt; <command>  def pi</command>
1.9.3p194 :008:2&gt; <command>    3.14</command>
1.9.3p194 :009:2&gt; <command>  end</command>
1.9.3p194 :010:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :011:0&gt; <command>fritz = Literatur.new</command>
=&gt; #&lt;Literatur:0x90e7098&gt;
1.9.3p194 :012:0&gt; <command>egon = Allgemeinwissen.new</command>
=&gt; #&lt;Allgemeinwissen:0x90da0ac&gt;
1.9.3p194 :013:0&gt; <command>egon.antwort_auf_alle_fragen_des_universums</command>
=&gt; 42
1.9.3p194 :014:0&gt; <command>egon.pi</command>
=&gt; 3.14
1.9.3p194 :015:0&gt; <command>fritz.antwort_auf_alle_fragen_des_universums</command>
=&gt; 42
1.9.3p194 :016:0&gt; <command>fritz.pi</command>
NoMethodError: undefined method `pi' for #&lt;Literatur:0x90e7098&gt;
 from (irb):21
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
1.9.3p194 :017:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="class_methods_vs_instance_methods">
        <title>Class Methods und Instance Methods</title>

        <indexterm>
          <primary>Class Methods und Instance Methods</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <para>Es gibt zwei wichtige Arten von Methoden: Klassen-Methoden
        (Class Methods) und Instanz-Methoden (Instance Methods).</para>

        <para>Was eine Klasse ist, wissen Sie jetzt. Und eine Instanz einer
        solchen Klasse wird mit der Klassen-Methode
        <methodname>new</methodname> erstellt. Eine Klassen-Methode kann nur
        im Zusammenhang mit der Klasse aufgerufen werden (die Methode
        <methodname>new</methodname> ist zum Beispiel eine Klassen-Methode).
        Eine Instanz-Methode ist eine Methode, die nur mit einer Instanz
        funktioniert. So können Sie nicht die Methode
        <methodname>new</methodname> auf eine Instanz anwenden.</para>

        <para>Probieren wir erstmal aus, eine Instanz-Methode als
        Klassen-Methode aufzurufen:<screen>sw@debian:~/sandbox$ <command>irb</command>
ruby-1.9.2-p0 &gt; <command>class Wohnung</command>
1.9.3p194 ?&gt;  <command>def putzen</command>
1.9.3p194 ?&gt;    <command>puts 'Wirklich?'</command>
1.9.3p194 ?&gt;    <command>end</command>
1.9.3p194 ?&gt;  <command>end</command>
 =&gt; nil 
1.9.3p194 &gt; <command>Wohnung.putzen</command>
NoMethodError: undefined method `putzen' for Wohnung:Class
 from (irb):15
 from /Users/stefan/.rvm/rubies/1.9.3p194/bin/irb:17:in `&lt;main&gt;'
1.9.3p194 &gt; </screen></para>

        <para>Das geht also nicht. Dann erstellen wir eine neue Instanz der
        Klasse und versuchen es erneut:<screen>1.9.3p194 &gt; <command>apfelmus = Wohnung.new</command>
 =&gt; #&lt;Wohnung:0x00000100a06990&gt; 
1.9.3p194 &gt; <command>apfelmus.putzen</command>
Wirklich?
 =&gt; nil 
1.9.3p194 &gt; </screen></para>

        <para>Jetzt müssen wir nur noch herausfinden, wie man eine
        Klassen-Methode definiert. Rails Hardcore-Gurus würden Sie jetzt in
        die Tiefen des Quellcodes entführen und dort in ActiveRecord Beispiele
        heraussuchen. Das erspare ich Ihnen und zeige ein abstraktes
        Beispiel:<screen>1.9.3p194 &gt; <command>class Apfelkuchen</command>
1.9.3p194 ?&gt;  <command>def self.backen</command>
1.9.3p194 ?&gt;    <command>puts 'sinnfreies Beispiel'</command>
1.9.3p194 ?&gt;    <command>end</command>
1.9.3p194 ?&gt;  <command>end</command>
 =&gt; nil 
1.9.3p194 &gt; <command>Apfelkuchen.backen</command>
sinnfreies Beispiel
 =&gt; nil 
1.9.3p194 &gt; 
</screen></para>

        <para>Und noch der Gegenbeweis:<screen>1.9.3p194 &gt; <command>lieblingskuchen = Apfelkuchen.new</command>
 =&gt; #&lt;Apfelkuchen:0x0000010181a9c8&gt; 
1.9.3p194 &gt; <command>lieblingskuchen.backen</command>
NoMethodError: undefined method `backen' for #&lt;Apfelkuchen:0x0000010181a9c8&gt;
 from (irb):25
 from /Users/stefan/.rvm/rubies/1.9.3p194/bin/irb:17:in `&lt;main&gt;'
1.9.3p194 &gt;</screen></para>

        <para>Es gibt verschiedene Schreibweisen, um Klassen-Methoden zu
        definieren. Die zwei häufigsten:<itemizedlist>
            <listitem>
              <para><code>self.xyz</code></para>

              <programlisting># Variante 1
# mit self.xyz
#
class Apfelmus
  def self.backen
    puts 'sinnfreies Beispiel'
  end
end</programlisting>
            </listitem>

            <listitem>
              <para><code>class &lt;&lt; self</code></para>

              <programlisting># Variante 2
# mit class &lt;&lt; self
#
class Apfelmus
  class &lt;&lt; self
    def backen
      puts 'sinnfreies Beispiel'
    end
  end
end</programlisting>
            </listitem>
          </itemizedlist></para>

        <para>Das Ergebnis ist immer das gleiche.</para>

        <section xml:id="ruby-instance-methods">
          <title>Liste aller Instanz-Methoden</title>

          <indexterm>
            <primary>Instanz-Methoden</primary>

            <secondary>in Ruby</secondary>
          </indexterm>

          <indexterm>
            <primary>instance_methods()</primary>

            <see>Instanz-Methoden in Ruby</see>
          </indexterm>

          <para>Für eine Klasse kann man mit der Methode
          <methodname>instance_methods</methodname> alle definierten Methoden
          auslesen. Wir probieren das mit der Klasse
          <classname>Dies_und_das</classname> aus (diese legen wir dazu noch
          mal neu im <application>irb</application> an):<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Dies_und_das</command>
1.9.3p194 :002:1&gt; <command>  def drei_mal</command>
1.9.3p194 :003:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :004:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :005:2&gt; <command>    puts 'Hello World!'</command>
1.9.3p194 :006:2&gt; <command>  end</command>
1.9.3p194 :007:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :008:0&gt; <command>Dies_und_das.instance_methods</command>
=&gt; [:drei_mal, :nil?, :===, :=~, :!~, :eql?, :class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :to_s, :inspect, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :define_singleton_method, :hash, :__id__, :object_id, :to_enum, :enum_for, :gem, :==, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
</screen></para>

          <para>Das ist ja viel mehr, als wir definiert haben! Das liegt
          daran, dass jede neue Klasse von Ruby standardmäßig ein Grundgerüst
          an Methoden mitbekommt. Wenn wir nur die von uns definierten
          Methoden auflisten wollen, so geht das wie folgt:<screen>1.9.3p194 :009:0&gt; <command>Dies_und_das.instance_methods(false)</command>
=&gt; [:drei_mal]
1.9.3p194 :010:0&gt; </screen></para>
        </section>
      </section>
    </section>
  </section>

  <section xml:id="ruby_variablen">
    <title xml:id="ruby_variablen.title">Variablen</title>

    <indexterm>
      <primary>Variablen</primary>

      <secondary>in Ruby</secondary>
    </indexterm>

    <para>Sie wissen bereits, dass in Ruby alles ein Objekt ist. Also muss
    auch eine Variable ein Objekt sein.</para>

    <section xml:id="variablen_namenskonventionen">
      <title
      xml:id="variablen_namenskonventionen.title">Namenskonventionen</title>

      <para>Normale Variablen werden kleingeschrieben. <indexterm>
          <primary>Konstanten</primary>

          <secondary>in Ruby</secondary>
        </indexterm>Konstanten fangen mit einem Großbuchstaben an.<important>
          <para>Eine Konstante kann in Ruby auch mit einem neuen Wert
          überschrieben werden (allerdings wird dabei eine Warnung
          ausgegeben). Man sollte sich also nicht auf Unveränderlichkeit einer
          Konstanten verlassen.</para>
        </important></para>

      <para>Auf der sicheren Seite ist man, wenn man nur ASCII-Zeichen
      verwendet. Allerdings könnten Sie mit Ruby 1.9 und der richtigen
      Kodierung auch mehr oder weniger problemlos Sonderzeichen und Umlaute in
      einem Variablennamen verwenden. Die Höflichkeit gegenüber anderen (evtl.
      ausländischen) Programmierern, die diese Zeichen vielleicht nicht fix
      und fertig auf der Tastatur haben, ist aber Grund genug, nur reines
      ASCII zu benutzen.</para>
    </section>

    <section xml:id="variablen_string">
      <title xml:id="var_string.title">Strings</title>

      <indexterm>
        <primary>Strings</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <para>Probieren wir mal ein wenig im <literal>irb</literal> aus. Die
      Methode <methodname>.class</methodname> gibt uns dabei an, um welche
      Klasse es sich handelt.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 'Ein Test.'</command>
=&gt; "Ein Test."
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; String
</screen></para>

      <para>Das war einfach. Ruby erschafft also <quote>automagisch</quote>
      ein Objekt der Klasse <classname>String</classname>. Das ginge auch mit
      einem expliziten Aufruf der Methode
      <methodname>new</methodname>:<screen>1.9.3p194 :003:0&gt; <command>b = String.new('Noch ein Test.')</command>
=&gt; "Noch ein Test."
1.9.3p194 :004:0&gt; <command>b.class</command>
=&gt; String
</screen></para>

      <para>Wenn wir <code>String.new</code> ohne einen Parameter aufrufen,
      dann wird ebenfalls ein Objekt der Klasse <classname>String</classname>
      erstellt. Nur ist das dann ein leerer String:<screen>1.9.3p194 :005:0&gt; <command>c = String.new</command>
=&gt; ""
1.9.3p194 :006:0&gt; <command>c.class</command>
=&gt; String
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>

      <section xml:id="ruby-strings-quotes">
        <title>Einfache und doppelte Anführungszeichen</title>

        <indexterm>
          <primary>Anführungszeichen</primary>

          <secondary>bei Strings in Ruby</secondary>
        </indexterm>

        <indexterm>
          <primary>Quotes</primary>

          <secondary>bei Strings in Ruby</secondary>

          <see>Anführungszeichen</see>
        </indexterm>

        <note>
          <para>Ein Hinweis vorweg: Wenn hier im Zusammenhang mit Strings von
          einfachen oder doppelten Anführungszeichen zu Rede ist, dann sind
          damit keine Anführungszeichen im typografisch korrekten Sinn gemeint
          (siehe <uri
          xlink:href="http://de.wikipedia.org/wiki/Anf%C3%BChrungszeichen">http://de.wikipedia.org/wiki/Anführungszeichen</uri>),
          sondern die als <emphasis>Apostrophe</emphasis>
          (<literal>'</literal>) bzw. <emphasis>Quotation Mark</emphasis>
          (<literal>"</literal>) bekannten ASCII-Zeichen.</para>
        </note>

        <para>Strings können nicht nur in einfachen Anführungszeichen (single
        quotes), sondern auch in doppelten Anführungszeichen (double quotes)
        definiert werden. Bei den doppelten Anführungszeichen gibt es
        allerdings eine Besonderheit: Man kann Ausdrücke (Expressions) mit dem
        Konstrukt <code>#{}</code> einbinden. Das Ergebnis wird dann
        automatisch an die entsprechende Stelle im String eingesetzt.</para>

        <para>Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 'blau'</command>
=&gt; blau
1.9.3p194 :002:0&gt; <command>b = "Farbe: #{a}"</command>
=&gt; "Farbe: blau"
1.9.3p194 :003:0&gt; <command>b.class</command>
=&gt; String
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>

        <para>Ist das Ergebnis des Ausdrucks kein String, versucht Ruby die
        Methode <methodname>to_s</methodname> anzuwenden, um den Wert des
        Objekts in einen String umzuwandeln.</para>
      </section>
    </section>

    <section xml:id="vartype_zahlen">
      <title xml:id="vartype_string.title">Ganzzahlen (Integer)</title>

      <indexterm>
        <primary>Integer</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <section xml:id="ruby-variables-fixnum-bignum">
        <title>Fixnum und Bignum</title>

        <indexterm>
          <primary>Fixnum</primary>

          <secondary>Variablen in Ruby</secondary>
        </indexterm>

        <indexterm>
          <primary>Bignum</primary>

          <secondary>Variablen in Ruby</secondary>
        </indexterm>

        <para><classname>Fixnum</classname> und <classname>Bignum</classname>
        sind <classname>Integer</classname>-Klassen (sprich Ganzzahlen). Ein
        <classname>Fixnum</classname> ist ein <classname>Integer</classname>,
        der in einem <quote>Word</quote> gespeichert werden kann.<footnote>
            <para>Falls Sie nicht wissen, was ein <quote>Word</quote> ist:
            egal.</para>
          </footnote> Wird ein <classname>Fixnum</classname> größer, wandelt
        es sich automatisch in ein <classname>Bignum</classname> um.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>20.class</command>
=&gt; Fixnum
1.9.3p194 :002:0&gt; <command>a = 20</command>
=&gt; 20
1.9.3p194 :003:0&gt; <command>a.class</command>
=&gt; Fixnum
1.9.3p194 :004:0&gt; <command>a = a * 555555555</command>  # Ergebnis wird automatisch ein Bignum.
=&gt; 11111111100
1.9.3p194 :005:0&gt; <command>a.class</command>
=&gt; Bignum
1.9.3p194 :006:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="ruby-variables-float">
        <title>Fließkommazahlen (Float)</title>

        <indexterm>
          <primary>Float</primary>

          <secondary>Variablen in Ruby</secondary>
        </indexterm>

        <para><classname>Float</classname> ist eine Klasse für reelle Zahlen
        (<quote>Fließkomma-Zahlen</quote>). Dabei wird die englische
        Schreibweise für das Komma (also ein Punkt) benutzt.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 20.424</command>
=&gt; 20.424
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; Float
1.9.3p194 :003:0&gt; <command>42.2.class</command>
=&gt; Float
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="ruby-einfache-berechnungen">
        <title>Einfache Berechnungen</title>

        <para>Rechnen mit Integers und Floats ist so einfach, dass man alles
        anhand von ein paar Zeilen Code im <literal>irb</literal> beschreiben
        kann:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 10</command>
=&gt; 10
1.9.3p194 :002:0&gt; <command>b = 23</command>
=&gt; 23
1.9.3p194 :003:0&gt; <command>a + b</command>          # Addition von zwei Fixnums
=&gt; 33
1.9.3p194 :004:0&gt; <command>(a + b).class</command>  # Das Ergebnis ist ein Fixnum.
=&gt; Fixnum
1.9.3p194 :005:0&gt; <command>c = a + b</command>
=&gt; 33
1.9.3p194 :006:0&gt; <command>c.class</command>
=&gt; Fixnum
1.9.3p194 :007:0&gt; <command>d = 3.14</command>
=&gt; 3.14
1.9.3p194 :008:0&gt; <command>e = a + d</command>      # Addition Fixnum und Float
=&gt; 13.14
1.9.3p194 :009:0&gt; <command>e.class</command>        # Das Ergebnis ist ein Float.
=&gt; Float
1.9.3p194 :010:0&gt; <command>a * b</command>
=&gt; 230
1.9.3p194 :011:0&gt; <command>(a * b).class</command>
=&gt; Fixnum
1.9.3p194 :012:0&gt; <command>(a * b * d).class</command>
=&gt; Float
1.9.3p194 :013:0&gt; <command>b - a</command>
=&gt; 13
1.9.3p194 :014:0&gt; <command>a += 1</command>         # a = a + 1
=&gt; 11
1.9.3p194 :015:0&gt; <command>exit</command>
</screen></para>
      </section>
    </section>

    <section xml:id="vartype_boolean_und_nil">
      <title xml:id="vartype_boolean_und_nil.title">Bool'sche Werte (Booleans)
      und nil</title>

      <indexterm>
        <primary>Boolean</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>true</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>false</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>nil</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>null</primary>

        <secondary>Variablen in Ruby</secondary>

        <see>nil</see>
      </indexterm>

      <para>Für bool'sche Werte (<code>true</code> und <code>false</code>) und
      für <code>nil</code> (kein Wert) gibt es jeweils eigene Klassen:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>true.class</command>
=&gt; TrueClass
1.9.3p194 :002:0&gt; <command>false.class</command>
=&gt; FalseClass
1.9.3p194 :003:0&gt; <command>nil.class</command>
=&gt; NilClass
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>

      <para><literal>nil</literal> (kein Wert <footnote>
          <para><uri
          xlink:href="http://de.wikipedia.org/wiki/Nullwert">http://de.wikipedia.org/wiki/Nullwert</uri></para>
        </footnote>) stammt übrigens als Kurzform vom lateinischen Wort
      <foreignphrase xml:lang="la">nihil</foreignphrase> (nichts <footnote>
          <para><uri
          xlink:href="http://de.wikipedia.org/wiki/Nichts">http://de.wikipedia.org/wiki/Nichts</uri></para>
        </footnote>) oder Programmiersprachen-historisch gesehen von
      <quote><foreignphrase xml:lang="en">not in list</foreignphrase></quote>
      (nicht in der Liste) aus dem Erbe der Programmiersprache Lisp (deren
      Name ein Akronym für <foreignphrase xml:lang="en">List
      Processing</foreignphrase> ist).</para>
    </section>

    <section xml:id="scope_von_variablen">
      <title xml:id="scope_von_variablen.title">Gültigkeitsbereich (Scope) von
      Variablen</title>

      <indexterm>
        <primary>Scope</primary>

        <secondary>Variablen in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>Geltungsbereich</primary>

        <see>Scope</see>
      </indexterm>

      <indexterm>
        <primary>Gültigkeitsbereich</primary>

        <see>Scope</see>
      </indexterm>

      <para>Variablen haben je nach Art einen unterschiedlichen
      Geltungsbereich (oder eine unterschiedliche <quote>Reichweite</quote>)
      innerhalb der Ruby- und damit auch innerhalb einer
      Ruby-on-Rails-Applikation. Man muss bei der Programmierung diese
      Reichweite immer im Hinterkopf behalten, weil sonst merkwürdige Effekte
      auftreten.</para>

      <section xml:id="ruby-local-variables">
        <title>Lokale Variablen (aaa oder _aaa)</title>

        <indexterm>
          <primary>Lokale Variablen</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>in Ruby</secondary>

          <tertiary>lokale</tertiary>
        </indexterm>

        <para>Lokale Variablen fangen entweder mit einem kleinen Buchstaben
        oder mit einem Unterstrich (<literal>_</literal>) an. Ihr
        Gültigkeitsbereich beschränkt sich auf die aktuelle Umgebung (z. B.
        auf die aktuelle Methode). Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>aaa = 10</command>    # Lokale Variable aaa
=&gt; 10
1.9.3p194 :002:0&gt; <command>_bbb = 20</command>   # Lokale Variable _bbb
=&gt; 20
1.9.3p194 :003:0&gt; <command>puts aaa</command>
10
=&gt; nil
1.9.3p194 :004:0&gt; <command>puts _bbb</command>
20
=&gt; nil
1.9.3p194 :005:0&gt; <command>def test</command>       # Definition der Methode test
1.9.3p194 :006:1&gt; <command>  aaa = 1000</command>   # Lokale Variable aaa
1.9.3p194 :007:1&gt; <command>  _bbb = 2000</command>  # Lokale Variable _bbb
1.9.3p194 :008:1&gt; <command>  puts aaa</command>     # Ausgabe von aaa
1.9.3p194 :009:1&gt; <command>  puts _bbb</command>    # Ausgabe von _bbb
1.9.3p194 :010:1&gt; <command>end</command>            # Ende der Methode test
=&gt; nil
1.9.3p194 :011:0&gt; <command>puts aaa</command>
10
=&gt; nil
1.9.3p194 :012:0&gt; <command>puts _bbb</command>
20
=&gt; nil
1.9.3p194 :013:0&gt; <command>test</command>        # Aufruf der Methode test
1000                         # siehe irb-Zeile 8
2000                         # siehe irb-Ziele 9
=&gt; nil
1.9.3p194 :014:0&gt; <command>puts aaa</command>
10
=&gt; nil
1.9.3p194 :015:0&gt; <command>puts _bbb</command>
20
=&gt; nil
1.9.3p194 :016:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="ruby-global-variables">
        <title>Globale Variablen ($aaa)</title>

        <indexterm>
          <primary>Globale Variablen</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>in Ruby</secondary>

          <tertiary>globale</tertiary>
        </indexterm>

        <para>Eine globale Variable fängt mit einem
        <literal>$</literal>-Zeichen an und ist im gesamten Programm
        erreichbar. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>$aaa = 10</command>
=&gt; 10
1.9.3p194 :002:0&gt; <command>puts $aaa</command>
10
=&gt; nil
1.9.3p194 :003:0&gt; <command>def test</command>    # Definition der Methode test
1.9.3p194 :004:1&gt; <command>  $aaa = 20</command>
1.9.3p194 :005:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :006:0&gt; <command>puts $aaa</command>   # Ausgabe von $aaa
10
=&gt; nil
1.9.3p194 :007:0&gt; <command>test</command>        # Aufruf der Methode test
=&gt; 20
1.9.3p194 :008:0&gt; <command>puts $aaa</command>   # Ausgabe von $aaa
20
=&gt; nil
1.9.3p194 :009:0&gt; <command>$aaa.class</command>
=&gt; Fixnum
1.9.3p194 :010:0&gt; <command>exit</command>
</screen></para>

        <para>Globale Variablen werden recht selten benutzt.</para>
      </section>

      <section xml:id="ruby-instance-variables">
        <title>Instanz-Variablen (@aaa)</title>

        <indexterm>
          <primary>Instanz-Variablen</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <indexterm>
          <primary>Variablen</primary>

          <secondary>in Ruby</secondary>

          <tertiary>Instanz-Variablen</tertiary>
        </indexterm>

        <para>Instanz-Variablen (<quote><emphasis
        role="bold">A</emphasis>ttribute</quote>, daher das
        <literal>@</literal>) gelten nur innerhalb einer Klasse, dort aber
        überall – sozusagen eine Mini-Version von globalen Variablen. Im
        Gegensatz zu globalen Variablen findet man Instanz-Variablen in einer
        Rails-Applikation an jeder Ecke. Wir gehen die Sache über ein
        Beispielprogramm namens <filename>farbe.rb</filename>
        an:<programlisting>class Wand
  
  def initialize
    <emphasis role="bold">@farbe</emphasis> = 'weiß'
  end
  
  def farbe
    <emphasis role="bold">@farbe</emphasis>
  end
  
  def streich_alles_rot
    <emphasis role="bold">@farbe</emphasis> = 'rot'
  end
  
  def streich_alles_gelb
    <emphasis role="bold">@farbe</emphasis> = 'gelb'
  end
  
  def streich_alles_rosa
    farbe = 'rosa'         # Achtung: Dies ist eine lokale Variable.
  end
  
end

meine_wand = Wand.new
puts meine_wand.farbe

meine_wand.streich_alles_rot
puts meine_wand.farbe

meine_wand.streich_alles_rosa
puts meine_wand.farbe
</programlisting>Wenn Sie dieses Programm starten, erscheint folgende
        Ausgabe:<screen>sw@debian:~/sandbox$ <command>ruby farbe.rb</command>
weiß
rot
rot
sw@debian:~/sandbox$ </screen></para>

        <para>In der Methode <indexterm>
            <primary>initialize()</primary>
          </indexterm><methodname>initialize</methodname> setzen wir die
        Instanz-Variable <varname>@farbe</varname> auf den Wert
        <quote>weiß</quote>. Die Methoden
        <methodname>streich_alles_rot</methodname> und
        <methodname>streich_alles_gelb</methodname> verändern diese
        Instanz-Variable. Die Methode
        <methodname>streich_alles_rosa</methodname> hingegen setzt nur eine
        lokale Variable mit dem Namen <varname>farbe</varname> (es fehlt das
        <literal>@</literal>-Zeichen).</para>

        <para>Mit der Methode <methodname>farbe</methodname> können wir uns
        außerhalb der Instanz den Wert von <varname>@farbe</varname> ausgeben
        lassen.</para>
      </section>
    </section>
  </section>

  <section xml:id="noch_mal_methoden">
    <title>Noch mal Methoden</title>

    <para>Um die Menge der Henne-Ei-Probleme in diesem Kapitel erträglich zu
    halten, müssen wir uns jetzt noch einmal mit Methoden beschäftigen und
    dabei das bis jetzt Erlernte kombinieren.</para>

    <section xml:id="getter_und_setter_methoden">
      <title>Getter und Setter</title>

      <indexterm>
        <primary>Getter</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>Setter</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>Da <indexterm>
          <primary>Instanz-Variablen</primary>

          <secondary>in Ruby</secondary>
        </indexterm>Instanz-Variablen (<quote>Attribute</quote>) nur innerhalb
      der jeweiligen Instanz existieren, muss man zum Exportieren einer
      solchen Variable immer eine <quote>Getter</quote>-Methode schreiben.
      Wenn wir eine Klasse <classname>Raum</classname> definieren, die als
      Instanz-Variablen <varname>@tueren</varname> und
      <varname>@fenster</varname> hat (für die Anzahl der Türen und Fenster
      des Raumes), so können wir wie folgt Getter-Methoden
      <methodname>tueren</methodname> und <methodname>fenster</methodname>
      erstellen (Beispielprogramm
      <filename>raum.rb</filename>):<programlisting>class Raum
  def initialize
    @tueren  = 1   # ein neuer Raum hat eine Tür
    @fenster = 1   # ein neuer Raum hat ein Fenster
  end
  
  <emphasis role="bold">def tueren</emphasis>
    <emphasis role="bold">@tueren</emphasis>        # der Wert von @tueren wird zurückgegeben
  <emphasis role="bold">end</emphasis>
  
  <emphasis role="bold">def fenster</emphasis>
    <emphasis role="bold">@fenster</emphasis>       # der Wert von @fenster wird zurückgegeben
  <emphasis role="bold">end</emphasis>
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster
</programlisting></para>

      <para>Die Ausführung des Programmes:<screen>sw@debian:~/sandbox$ <command>ruby raum.rb</command> 
1
1
sw@debian:~/sandbox$ </screen></para>

      <para>Da dieses Szenario – dass man einfach nur einen Wert identisch
      zurückgeben will – so häufig auftritt, gibt es dafür schon eine
      vorgefertigte Getter-Methode namens <indexterm>
          <primary>attr_reader()</primary>
        </indexterm><methodname>attr_reader</methodname>, die wie folgt im
      Programm <filename>raum.rb</filename> angewendet werden
      würde:<programlisting>class Raum
  def initialize
    @tueren  = 1
    @fenster = 1
  end
  
  <emphasis role="bold">attr_reader :tueren, :fenster</emphasis>   # die Namen werden als Symbol angegeben
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster
</programlisting></para>

      <note>
        <para><methodname>attr_reader</methodname> ist ein gutes Beispiel für
        Meta-Programmierung in Ruby. Sie werden gerade bei der Arbeit mit
        Rails immer wieder auf Meta-Programmierung stoßen und sich über die
        Automagie freuen.</para>
      </note>

      <para>Wenn man von außen die Anzahl der Türen oder Fenster verändern
      will, so braucht man dafür eine <quote>Setter</quote>-Methode. Die kann
      wie folgt realisiert werden:<programlisting>class Raum
  def initialize
    @tueren  = 1
    @fenster = 1
  end
  
  attr_reader :tueren, :fenster
  
  <emphasis role="bold">def tueren=(value)</emphasis>       # Setter fuer tueren
    <emphasis role="bold">@tueren = value</emphasis>
  <emphasis role="bold">end</emphasis>
  
  <emphasis role="bold">def fenster=(value)</emphasis>      # Setter fuer fenster
    <emphasis role="bold">@fenster = value</emphasis>
  <emphasis role="bold">end</emphasis>
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster

wohnzimmer.fenster = 2     # fenster wird neu gesetzt

puts wohnzimmer.fenster
</programlisting></para>

      <para>Die entsprechende Ausgabe dazu:<screen>sw@debian:~/sandbox$ <command>ruby raum.rb</command>
1
1
2
sw@debian:~/sandbox$ </screen></para>

      <para>Sie können es sich wahrscheinlich schon denken: Natürlich gibt es
      dazu ebenfalls einen vorgefertigten und kürzeren Weg. Mit der Methode
      <indexterm>
          <primary>attr_writer()</primary>
        </indexterm><methodname>attr_writer</methodname> können Sie den Code
      von <filename>raum.rb</filename> weiter vereinfachen:<programlisting>class Raum
  def initialize
    @tueren  = 1
    @fenster = 1
  end
  
  attr_reader :tueren, :fenster
  
  <emphasis role="bold">attr_writer :tueren, :fenster</emphasis>
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster

wohnzimmer.fenster = 2

puts wohnzimmer.fenster
</programlisting></para>

      <para>Und (wer hätte das gedacht!) es gibt auch eine Methode <indexterm>
          <primary>attr_accessor()</primary>
        </indexterm><methodname>attr_accessor</methodname>, die Getter und
      Setter kombiniert. Der Code für <filename>raum.rb</filename> sähe dann
      so aus:<screen>class Raum
  def initialize
    @tueren  = 1
    @fenster = 1
  end
  
  <emphasis role="bold">attr_accessor :tueren, :fenster</emphasis>
end

wohnzimmer = Raum.new

puts wohnzimmer.tueren
puts wohnzimmer.fenster

wohnzimmer.fenster = 2

puts wohnzimmer.fenster
</screen></para>
    </section>

    <section xml:id="ruby-string-methods">
      <title>Mitgelieferte Methoden bei String</title>

      <para>Die meisten Klassen kommen von Hause aus schon mit einem ganzen
      Sack voll äußerst praktischer Methoden. Diese Methoden werden immer mit
      einem Punkt abgetrennt hinter dem entsprechenden Objekt
      geschrieben.</para>

      <para>Hier ein paar Beispiele für Methoden der Klasse
      <classname>String</classname>.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 'Das Haus.'</command>
=&gt; "Das Haus."
1.9.3p194 :002:0&gt; <command>a.class</command>     # Name der Klasse
=&gt; String
1.9.3p194 :003:0&gt; <command>a.size</command>      # Länge des Strings
=&gt; 9
1.9.3p194 :004:0&gt; <command>a.downcase</command>  # Umwandlung in Kleinbuchstaben
=&gt; "das haus."
1.9.3p194 :005:0&gt; <command>a.upcase</command>    # Umwandlung in Großbuchstaben
=&gt; "DAS HAUS."
1.9.3p194 :006:0&gt; <command>a.reverse</command>   # Buchstabenreihenfolge umdrehen
=&gt; ".suaH saD"
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section xml:id="ruby-method-chain">
      <title>Verketten von Methoden (Method chaining)</title>

      <indexterm>
        <primary>Methoden</primary>

        <secondary>in Ruby verketten</secondary>
      </indexterm>

      <indexterm>
        <primary>Method chaining</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>Man kommt nicht direkt darauf, aber wenn man sich an das Arbeiten
      mit Ruby gewöhnt hat, dann ist es auch völlig selbstverständlich (weil
      logisch), verschiedene Methoden zu verketten.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 'Das Haus.'</command>
=&gt; "Das Haus."
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; String
1.9.3p194 :003:0&gt; <command>a.upcase.reverse</command>  # Großbuchstaben umgedreht
=&gt; ".SUAH SAD"
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section xml:id="ruby-casting">
      <title>Von einem zum anderen konvertieren</title>

      <indexterm>
        <primary>Casten</primary>

        <secondary>von Objekten in Ruby</secondary>
      </indexterm>

      <para>Logischerweise gibt es eine ganze Reihe von praktischen
      Instanz-Methoden, um Objekte von einer Klasse in eine andere zu wandeln
      (zu <quote>cast</quote>en). Als Erstes verwandeln wir mit der Methode
      <indexterm>
          <primary>to_s()</primary>

          <secondary>in Ruby</secondary>
        </indexterm><methodname>.to_s</methodname> ein
      <classname>Fixnum</classname> in einen
      <classname>String</classname>.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 10</command>
=&gt; 10
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; Fixnum
1.9.3p194 :003:0&gt; <command>b = a.to_s</command>
=&gt; "10"
1.9.3p194 :004:0&gt; <command>b.class</command>
 =&gt; String 
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>

      <para>Nichts anderes macht übrigens <code>puts</code>, wenn man mit
      <code>puts</code> ein <classname>Fixnum</classname> oder ein
      <classname>Float</classname> ausgibt (es fügt bei Nicht-Strings einfach
      implizit die Methode <methodname>.to_s</methodname> hinzu und gibt das
      Ergebnis aus).</para>

      <para>Jetzt wandeln wir mit der Methode <indexterm>
          <primary>to_i()</primary>

          <secondary>in Ruby</secondary>
        </indexterm><methodname>.to_i</methodname> ein
      <classname>Float</classname> in ein <classname>Fixnum</classname>
      um.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>c = 10.0</command>
=&gt; 10.0
1.9.3p194 :002:0&gt; <command>c.class</command>
=&gt; Float
1.9.3p194 :003:0&gt; <command>d = c.to_i</command>
=&gt; 10
1.9.3p194 :004:0&gt; <command>d.class</command>
=&gt; Fixnum
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section xml:id="ruby-to_s">
      <title>Methode to_s bei eigenen Klassen</title>

      <indexterm>
        <primary>to_s()</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>Man sollte – und wenn es nur für das einfachere Debugging ist –
      bei selbstdefinierten Klassen immer eine Methode
      <methodname>to_s</methodname> einbauen. Dann kann man ein entsprechendes
      Objekt einfach mit <code>puts</code> ausgeben (<code>puts</code> gibt
      ein Objekt automatisch unter Verwendung der Methode
      <methodname>to_s</methodname> aus).</para>

      <para>Ein Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Tier</command>
1.9.3p194 :002:1&gt; <command>  def initialize(de_name,en_name)</command>
1.9.3p194 :003:2&gt; <command>    @de_name = de_name</command>
1.9.3p194 :004:2&gt; <command>    @en_name = en_name</command>
1.9.3p194 :005:2&gt; <command>  end</command>
1.9.3p194 :006:1&gt; <command>  def to_s</command>
1.9.3p194 :007:2&gt; <command>    @de_name + ' (' + @en_name + ')'</command>
1.9.3p194 :008:2&gt; <command>  end</command>
1.9.3p194 :009:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :010:0&gt; <command>lumpi = Tier.new('Hund', 'Dog')</command>
=&gt; #&lt;Tier:0x873b5c8 @de_name="Hund", @en_name="Dog"&gt;
1.9.3p194 :011:0&gt; <command>hansi = Tier.new('Wellensittich', 'Budgerigar')</command>           
=&gt; #&lt;Tier:0x86b60f8 @de_name="Wellensittich", @en_name="Budgerigar"&gt;
1.9.3p194 :012:0&gt; <command>puts lumpi</command>
Hund (Dog)
=&gt; nil
1.9.3p194 :013:0&gt; <command>puts hansi</command>
Wellensittich (Budgerigar)
=&gt; nil
1.9.3p194 :014:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section xml:id="ruby-method-plus">
      <title>Ist <quote>+</quote> eine Methode?</title>

      <para>Wieso steht bei der Liste der Methoden beim
      <classname>String</classname> auch das Pluszeichen? Schauen wir mal mit
      <literal>ri</literal> nach:<screen>sw@debian:~/sandbox$ <command>ri String.+</command>

(from ruby site)
------------------------------------------------------------------------------
  str + other_str   -&gt; new_str

------------------------------------------------------------------------------

Concatenation---Returns a new String containing other_str
concatenated to str.

  "Hello from " + self.to_s   #=&gt; "Hello from main"


sw@debian:~/sandbox$</screen></para>

      <para>hmmm … Mal sehen, was da bei <classname>Fixnum</classname>
      steht:<screen>sw@debian:~/sandbox$ <command>ri Fixnum.+</command>
(from ruby site)
------------------------------------------------------------------------------
  fix + numeric  -&gt;  numeric_result

------------------------------------------------------------------------------

Performs addition: the class of the resulting object depends on the class of
numeric and on the magnitude of the result.

sw@debian:~/sandbox$</screen></para>

      <para>Spielen wir damit einmal im <literal>irb</literal>. Wir müssten ja
      dann das <methodname>+</methodname> genauso wie jede andere Methode mit
      einem Punkt an das Objekt hängen können und die zweite Zahl in einer
      Klammer als Parameter anfügen:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>10 + 10</command>
=&gt; 20
1.9.3p194 :002:0&gt; <command>10+10</command>
=&gt; 20
1.9.3p194 :003:0&gt; <command>10.+10</command>
=&gt; 20
1.9.3p194 :004:0&gt; <command>10.+(10)</command>
=&gt; 20
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>

      <para>Aha! Das Pluszeichen ist tatsächlich eine Methode, und diese
      Methode nimmt den nächsten Wert als Parameter. Eigentlich müssten wir
      diesen Wert in einer Klammer setzen, aber Ruby erspart uns das mit
      durchdachter Syntax.</para>

      <section xml:id="ruby-method-plus-overriding">
        <title>Kann ich die Methode + überschreiben?</title>

        <para>Ja, man kann alle Methoden überschreiben. Logischerweise macht
        das bei Methoden wie <methodname>+</methodname> wenig Sinn, außer man
        will damit seine Programmierkollegen in den Wahnsinn treiben. Damit
        Sie mir glauben, zeige ich jetzt im <literal>irb</literal> eine kleine
        Demo.</para>

        <para>Das Ziel ist es, die Methode <methodname>+</methodname> für
        <classname>Fixnum</classname> zu überschreiben. Als Ergebnis jeder
        Addition soll die Zahl 42 herauskommen.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>10 + 10</command>
=&gt; 20
1.9.3p194 :002:0&gt; <command>10 + 5555</command>
=&gt; 5565
1.9.3p194 :003:0&gt; <command>class Fixnum</command> 
1.9.3p194 :004:1&gt; <command>  def +(name, *args, &amp;blk)</command>
1.9.3p194 :005:2&gt; <command>    42</command>
1.9.3p194 :006:2&gt; <command>  end</command>
1.9.3p194 :007:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :008:0&gt; <command>10 + 10</command>
=&gt; 42
1.9.3p194 :042:0&gt; <command>10 + 5555</command>
=&gt; 42
1.9.3p194 :042:0&gt; <command>exit</command>
</screen></para>

        <para>In den Zeilen 1 und 2 führen wir die normale Addition durch. In
        den Zeilen 3 bis 7 definieren wir die Methode
        <methodname>+</methodname> für die Class <classname>Fixnum</classname>
        neu, und danach führen wir noch einmal die Berechnung durch. Dann
        allerdings mit anderen Ergebnissen.</para>
      </section>

      <section xml:id="ruby-class-methods-irb">
        <title>Liste aller Methoden für eine bestimmte Klasse</title>

        <para>Nun hat man nicht immer alle Methoden-Namen im Kopf, weiß aber,
        dass es für das spezielle Problem eine perfekte Methode gibt (passiert
        mir ständig).</para>

        <section>
          <title>Im irb</title>

          <para>Mit der Methode <indexterm>
              <primary>methods()</primary>

              <secondary>in Ruby</secondary>
            </indexterm><methodname>methods</methodname> kann man die zur
          Verfügung stehenden Methoden anzeigen. Allerdings weiß man dann
          nicht unbedingt, was diese genau machen.<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 'Das blaue Haus.'</command>
=&gt; "Das blaue Haus."
1.9.3p194 :002:0&gt; <command>a.methods</command>
=&gt; [:&lt;=&gt;, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :&lt;&lt;, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :&gt;, :&gt;=, :&lt;, :&lt;=, :between?, :nil?, :!~, :class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :define_singleton_method, :__id__, :object_id, :to_enum, :enum_for, :gem, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
1.9.3p194 :003:0&gt; <command>exit</command>
</screen></para>
        </section>
      </section>
    </section>
  </section>

  <section xml:id="ruby-if-condition">
    <title>if-Bedingung (if-Condition)</title>

    <indexterm>
      <primary>if</primary>

      <secondary>Bedingung in Ruby</secondary>
    </indexterm>

    <indexterm>
      <primary>Bedingte Ausführung</primary>

      <secondary>in Ruby</secondary>
    </indexterm>

    <para>Eine abstrakte <literal>if</literal>-Bedingung sieht folgendermaßen
    aus:<programlisting>if ausdruck
  programm
end</programlisting></para>

    <para>Das Programm zwischen dem Ausdruck (<foreignphrase
    xml:lang="en">Expression</foreignphrase>) und <code>end</code> wird immer
    dann ausgeführt, wenn das Ergebnis des Ausdrucks nicht
    <literal>false</literal> und nicht <literal>nil</literal> ist.<note>
        <para>Es kann auch ein <code>then</code> nach der Expression benutzt
        werden:<programlisting>if ausdruck then
  programm
end</programlisting></para>
      </note></para>

    <para>Das Konstrukt für eine einfache <literal>if</literal>-Verzweigung in
    einem Ruby-Programm sieht wie nachfolgendes Beispielprogramm
    aus:<programlisting>a = 10

<emphasis role="bold">if a == 10     </emphasis>    # die Expression
  puts 'a ist 10'  # das Programm
<emphasis role="bold">end</emphasis>
</programlisting></para>

    <para>Eine <foreignphrase xml:lang="en">Expression</foreignphrase> kann
    man sehr gut im <literal>irb</literal> ausprobieren:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 10</command>
=&gt; 10
1.9.3p194 :002:0&gt; <command>a == 10</command>
=&gt; true
1.9.3p194 :003:0&gt; <command>exit</command>
</screen></para>

    <section xml:id="ruby-if-condition-short">
      <title>Kurzform</title>

      <indexterm>
        <primary>if</primary>

        <secondary>Bedingung in Ruby (Kurzform)</secondary>
      </indexterm>

      <para>Eine häufig anzutreffende Kurzform einer
      <literal>if</literal>-Bedinung ist im folgenden Code zu
      finden:<programlisting>a = 10

# Langversion
#
if a == 10 then
  puts 'a ist 10'
end

# Kurzversion
#
<emphasis role="bold">puts 'a ist 10' if a == 10</emphasis></programlisting></para>
    </section>

    <section xml:id="ruby-if-condition-else">
      <title>else</title>

      <indexterm>
        <primary>else</primary>

        <secondary>Bedingung in Ruby (Kurzform)</secondary>
      </indexterm>

      <para>Man kann es sich schon denken, aber der Vollständigkeit halber
      auch hierzu noch ein kleines Beispiel:<programlisting>a = 10

if a == 10 then
  puts 'a ist 10'
else
  puts 'a ist nicht 10'
end
</programlisting></para>
    </section>

    <section xml:id="ruby-if-condition-elsif">
      <title>elsif</title>

      <indexterm>
        <primary>elseif</primary>

        <secondary>Bedingung in Ruby (Kurzform)</secondary>
      </indexterm>

      <para>Auch hier ist den meisten Programmierern klar, worum es sich
      handelt. Beispiel:<programlisting>a = 10

if a == 10 then
  puts 'a ist 10'
elsif a == 20 then
  puts 'a ist 20'
end
</programlisting></para>
    </section>
  </section>

  <section xml:id="ruby-schleifen">
    <title>Schleifen (Loops)</title>

    <indexterm>
      <primary>Schleifen</primary>

      <secondary>in Ruby</secondary>
    </indexterm>

    <para>Es gibt verschiedene Arten, Schleifen in Ruby zu realisieren. Dabei
    kommt im Rails-Umfeld vor allen Dingen die Iterator-Variante häufig zum
    Einsatz.</para>

    <section xml:id="ruby-loops-while-until">
      <title>while und until</title>

      <indexterm>
        <primary>Schleifen</primary>

        <secondary>in Ruby</secondary>

        <tertiary>while</tertiary>
      </indexterm>

      <indexterm>
        <primary>Schleifen</primary>

        <secondary>in Ruby</secondary>

        <tertiary>until</tertiary>
      </indexterm>

      <indexterm>
        <primary>while</primary>

        <secondary>Schleifen in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>until</primary>

        <secondary>Schleifen in Ruby</secondary>
      </indexterm>

      <para>Eine While-Schleife sieht abstrakt wie folgt aus:<programlisting>while ausdruck do
  programm
end</programlisting></para>

      <para><note>
          <para>Das <code>do</code> nach dem <code>ausdruck</code> ist
          optional. Oft sieht man auch:<programlisting>while ausdruck
  programm
end</programlisting></para>
        </note>Und praktisch wie in folgendem
      <literal>irb</literal>-Beispiel:<screen>1.9.3p194 :001:0&gt; <command>i = 0</command>             # i wird auf 0 gesetzt
=&gt; 0
1.9.3p194 :002:0&gt; <command>while i &lt; 3 do</command>   # Schleife
1.9.3p194 :003:1&gt; <command>  puts i</command>          # i wird ausgegeben
1.9.3p194 :004:1&gt; <command>  i = i + 1</command>       # i wird um 1 erhöht
1.9.3p194 :005:1&gt; <command>end</command>               # Ende der Schleife
0
1
2
=&gt; nil
1.9.3p194 :006:0&gt; <command>exit</command>
</screen></para>

      <para>Until-Schleifen werden ähnlich aufgebaut:<programlisting>until ausdruck
  programm
end</programlisting></para>

      <para>Auch hier das <literal>irb</literal>-Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>i = 5</command>
=&gt; 5
1.9.3p194 :002:0&gt; <command>until i == 0</command>
1.9.3p194 :003:1&gt; <command>i = i - 1</command>
1.9.3p194 :004:1&gt; <command>puts i</command>
1.9.3p194 :005:1&gt; <command>end</command>
4
3
2
1
0
=&gt; nil
1.9.3p194 :006:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section xml:id="ruby-blocks-iterators">
      <title>Blöcke (Blocks) und Iteratoren (Iterators)</title>

      <indexterm>
        <primary>Blöcke</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <indexterm>
        <primary>Iteratoren</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para><quote>Block</quote> und <quote>Iterator</quote> gehören zu den
      Lieblingswörtern vieler Ruby-Programmierer. Jetzt zeige ich Ihnen mal
      warum.</para>

      <para>Bei der Schleife<programlisting>5.times { |i| puts i }</programlisting>ist
      <varname>i</varname> der Iterator und <code>puts i</code> der
      Block.</para>

      <para>Das Ganze kann aber auch in der folgenden Syntax ausgedrückt
      werden:<programlisting>5.times do |i|
  puts i
end</programlisting></para>

      <section xml:id="iterator">
        <title>Iteratoren (Iterators)</title>

        <indexterm>
          <primary>Iteratoren</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <para>Iteratoren sind nichts weiter als eine bestimmte Art von
        Methoden. (Das englische Wort <quote><foreignphrase
        xml:lang="en">iterate</foreignphrase></quote> heißt
        <quote>wiederholen</quote>.) Bei der Klasse
        <classname>Fixnum</classname> gibt es zum Beispiel den Iterator
        <indexterm>
            <primary>times()</primary>

            <secondary>in Ruby</secondary>
          </indexterm><methodname>times</methodname>. Mal schauen, was uns
        <literal>ri</literal> dazu als Hilfe anbietet:<screen>sw@debian:~/sandbox$ <command>ri Fixnum.times</command>
= Fixnum.times

(from ruby site)
=== Implementation from Integer
------------------------------------------------------------------------------
  int.times {|i| block }  -&gt;  self
  int.times               -&gt;  an_enumerator

------------------------------------------------------------------------------

Iterates block int times, passing in values from zero to int - 1.

If no block is given, an enumerator is returned instead.

  5.times do |i|
    print i, " "
  end

produces:

  0 1 2 3 4

sw@debian:~/sandbox$ </screen></para>

        <para>Und dort steht auch direkt ein schönes Beispiel, das wir im
        <application>irb</application> ausprobieren:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>5.times do |i|</command>
1.9.3p194 :002:1* <command>puts i</command>
1.9.3p194 :003:1&gt; <command>end</command>
0
1
2
3
4
=&gt; 5
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>

        <para>Und es gibt auch noch eine Einzeilen-Schreibweise für kleine
        Blöcke:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>5.times { |i| puts i }</command>
0
1
2
3
4
=&gt; 5
1.9.3p194 :002:0&gt; <command>exit</command>
</screen></para>

        <para>Ein Iterator muss übrigens dem Block nicht zwangsläufig eine
        Variable übergeben:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>5.times { puts 'Das blaue Haus.' }</command>
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
=&gt; 5
1.9.3p194 :002:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section xml:id="ruby-block">
        <title>Blöcke (Blocks)</title>

        <indexterm>
          <primary>Blöcke</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <para>Ein Block ist nichts anderes, als das von einem Iterator
        ausgelöste Programm. Im Block hat man Zugriff auf die vom Iterator
        übergebene(n) lokale(n) Variable(n).</para>
      </section>

      <section xml:id="ruby-upto">
        <title>Methode upto</title>

        <para>Neben <methodname>times</methodname> gibt es noch die Methode
        <indexterm>
            <primary>upto()</primary>

            <secondary>in Ruby</secondary>
          </indexterm><methodname>upto</methodname>, um leicht eine Schleife
        zu realisieren. <literal>ri</literal> gibt uns auch hier ein schönes
        Beispiel:<screen>sw@debian:~/sandbox$ <command>ri Fixnum.upto</command>
= Fixnum.upto

(from ruby site)
=== Implementation from Integer
------------------------------------------------------------------------------
  int.upto(limit) {|i| block }  -&gt;  self
  int.upto(limit)               -&gt;  an_enumerator

------------------------------------------------------------------------------

Iterates block, passing in integer values from int up to and
including limit.

If no block is given, an enumerator is returned instead.

  5.upto(10) { |i| print i, " " }

produces:

  5 6 7 8 9 10

sw@debian:~/sandbox$ </screen></para>
      </section>
    </section>
  </section>

  <section xml:id="ruby-array-und-hash">
    <title>Arrays und Hashes</title>

    <indexterm>
      <primary>Arrays</primary>

      <secondary>in Ruby</secondary>
    </indexterm>

    <indexterm>
      <primary>Hashes</primary>

      <secondary>in Ruby</secondary>
    </indexterm>

    <para>Wie in vielen Programmiersprachen sind auch in Ruby <foreignphrase
    xml:lang="en">Arrays</foreignphrase> und <foreignphrase
    xml:lang="en">Hashes</foreignphrase> beliebte Strukturen, um Daten zu
    speichern.</para>

    <section xml:id="ruby_array">
      <title xml:id="ruby_array.title">Arrays</title>

      <indexterm>
        <primary>Arrays</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>Eine Array ist eine Liste von Objekten. Spielen wir doch einmal
      ein wenig im <literal>irb:</literal><screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = [1,2,3,4,5]</command>
=&gt; [1, 2, 3, 4, 5]
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; Array
1.9.3p194 :003:0&gt; <command>exit</command>
</screen></para>

      <para>Das ist einfach und verständlich.</para>

      <para>Mal schauen, ob das so auch mit Strings im Array
      funktioniert:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = ['Test', 'Apfelbaum', 'blau']</command>
=&gt; ["Test", "Apfelbaum", "blau"]
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; Array
1.9.3p194 :003:0&gt; <command>a[1]</command>
=&gt; "Apfelbaum"
1.9.3p194 :004:0&gt; <command>a[1].class</command>
=&gt; String
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>

      <para>Das geht auch.</para>

      <para>Dann fehlt nur noch ein Array mit einem Mix aus beidem. Ist klar,
      dass es gehen muss, weil das Array ja Objekte speichert und es egal ist,
      welche Art von Objekten (sprich <classname>String</classname>,
      <classname>Fixnum</classname>, <classname>Float</classname>, …) das
      sind. Aber ein Versuch schadet ja nicht:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = [1, 2, 'Haus', 'Baum', 4]</command>
=&gt; [1, 2, "Haus", "Baum", 4]
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; Array
1.9.3p194 :003:0&gt; <command>a[0]</command>
=&gt; 1
1.9.3p194 :004:0&gt; <command>a[0].class</command>
=&gt; Fixnum
1.9.3p194 :005:0&gt; <command>a[2]</command>
=&gt; "Haus"
1.9.3p194 :006:0&gt; <command>a[2].class</command>
=&gt; String
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>

      <para>Sehen wir uns als Nächstes mal die
      <literal>ri</literal>-Hilfeseite zu <classname>Array</classname>
      an:<screen>sw@debian:~/sandbox$ <command>ri Array</command>
= Array &lt; Object

------------------------------------------------------------------------------
= Includes:
Enumerable (from ruby site)

(from ruby site)
------------------------------------------------------------------------------
Arrays are ordered, integer-indexed collections of any object. Array indexing
starts at 0, as in C or Java.  A negative index is assumed to be relative to
the end of the array---that is, an index of -1 indicates the last element of
the array, -2 is the next to last element in the array, and so on.

------------------------------------------------------------------------------
= Class methods:

  [], new, try_convert

= Instance methods:
  &amp;, *, +, -, &lt;&lt;, &lt;=&gt;, ==, [], []=, abbrev, assoc, at, clear, collect,
  collect!, combination, compact, compact!, concat, count, cycle, dclone,
  delete, delete_at, delete_if, drop, drop_while, each, each_index, empty?,
  eql?, fetch, fill, find_index, first, flatten, flatten!, frozen?, hash,
  include?, index, initialize_copy, insert, inspect, join, keep_if, last,
  length, map, map!, pack, permutation, pop, pretty_print, pretty_print_cycle,
  product, push, rassoc, reject, reject!, repeated_combination,
  repeated_permutation, replace, reverse, reverse!, reverse_each, rindex,
  rotate, rotate!, sample, select, select!, shelljoin, shift, shuffle,
  shuffle!, size, slice, slice!, sort, sort!, sort_by!, take, take_while,
  to_a, to_ary, to_csv, to_s, transpose, uniq, uniq!, unshift, values_at, zip,
  |

sw@debian:~/sandbox$ </screen></para>

      <para>Arrays können also auch (wie jede Klasse) mit der Methode
      <methodname>new</methodname> erstellt werden. Einzelne neue Elemente
      lassen sich dann mit der Methode <methodname>&lt;&lt;</methodname>
      hinzufügen. Auch hierzu ein Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = Array.new</command>
=&gt; []
1.9.3p194 :002:0&gt; <command>a.class</command>
=&gt; Array
1.9.3p194 :003:0&gt; <command>a &lt;&lt; 'erster Eintrag'</command>
=&gt; ["erster Eintrag"]
1.9.3p194 :004:0&gt; <command>a &lt;&lt; 'zweiter Eintrag'</command>
=&gt; ["erster Eintrag", "zweiter Eintrag"]
1.9.3p194 :005:0&gt; <command>a &lt;&lt; 'dritter Eintrag'</command>
=&gt; ["erster Eintrag", "zweiter Eintrag", "dritter Eintrag"]
1.9.3p194 :006:0&gt; <command>a.size</command>
=&gt; 3
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>

      <para>Aber versuchen wir doch mal, ein Array mit Einträgen aus einer
      selbstdefinierten Klasse zu erstellen:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>class Tier</command>              # Definition einer Klasse Tier
1.9.3p194 :002:1&gt; <command>  def initialize(de_name,en_name)</command>
1.9.3p194 :003:2&gt;     <command>@de_name = de_name</command>
1.9.3p194 :004:2&gt; <command>    @en_name = en_name</command>
1.9.3p194 :005:2&gt; <command>  end</command>
1.9.3p194 :006:1&gt;   <command>def to_s</command>
1.9.3p194 :007:2&gt; <command>    @de_name + ' (' + @en_name + ')'</command>
1.9.3p194 :008:2&gt; <command>  end</command>
1.9.3p194 :009:1&gt; <command>end</command>
=&gt; nil
1.9.3p194 :010:0&gt; <command>lumpi = Tier.new('Hund', 'Dog')</command>
=&gt; #&lt;Tier:0x873b5c8 @de_name="Hund", @en_name="Dog"&gt;
1.9.3p194 :011:0&gt; <command>hansi = Tier.new('Wellensittich', 'Budgerigar')</command>           
=&gt; #&lt;Tier:0x86b60f8 @de_name="Wellensittich", @en_name="Budgerigar"&gt;
1.9.3p194 :012:0&gt; <command>haustiere = Array.new</command>   # haustiere ist ein Array
=&gt; []
1.9.3p194 :013:0&gt; <command>haustiere &lt;&lt; hansi</command>      # hansi wird hinzugefuegt
=&gt; [#&lt;Tier:0x8d11f18 @de_name="Wellensittich", @en_name="Budgerigar"&gt;]
1.9.3p194 :014:0&gt; <command>haustiere &lt;&lt; lumpi</command>      # lumpi wird hinzugefuegt
=&gt; [#&lt;Tier:0x8d11f18 @de_name="Wellensittich", @en_name="Budgerigar"&gt;, #&lt;Tier:0x8d9751c @de_name="Hund", @en_name="Dog"&gt;]
1.9.3p194 :015:0&gt; <command>haustiere.count</command>
=&gt; 2
1.9.3p194 :016:0&gt; <command>puts haustiere[1]</command>       # Ausgabe der Position 1
Hund (Dog)
=&gt; nil
1.9.3p194 :017:0&gt; <command>puts haustiere[0]</command>       # Ausgabe der Position 0
Wellensittich (Budgerigar)
=&gt; nil
1.9.3p194 :018:0&gt; <command>exit</command>
</screen></para>

      <section xml:id="array_iterator">
        <title xml:id="array_iterator.title">Iterator each</title>

        <indexterm>
          <primary>Iteratoren</primary>

          <secondary>in Ruby</secondary>

          <tertiary>each()</tertiary>
        </indexterm>

        <para>Mit der Methode <indexterm>
            <primary>each()</primary>

            <secondary>in Ruby</secondary>
          </indexterm><methodname>each</methodname> kann man sich Stück für
        Stück durch ein Array arbeiten. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>einkaufsliste = ['Eier', 'Butter', 'Mehl']</command>
=&gt; ["Eier", "Butter", "Mehl"]
1.9.3p194 :002:0&gt; <command>einkaufsliste.each do |produkt|</command>
1.9.3p194 :003:1* <command>  puts produkt</command>
1.9.3p194 :004:1&gt; <command>end</command>
Eier
Butter
Mehl
=&gt; ["Eier", "Butter", "Mehl"]
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>

        <para>Auch hier gibt Ihnen <literal>ri</literal> Hilfe und ein
        Beispiel, falls Sie mal vergessen haben sollten, wie
        <methodname>each</methodname> anzuwenden ist:<screen>sw@debian:~/sandbox$ <command>ri Array.each</command>
= Array.each

(from ruby site)
------------------------------------------------------------------------------
  ary.each {|item| block }   -&gt; ary
  ary.each                   -&gt; an_enumerator

------------------------------------------------------------------------------

Calls block once for each element in self, passing that element as a
parameter.

If no block is given, an enumerator is returned instead.

  a = [ "a", "b", "c" ]
  a.each {|x| print x, " -- " }

produces:

  a -- b -- c --

sw@debian:~/sandbox$ </screen></para>
      </section>
    </section>

    <section xml:id="ruby_hash">
      <title xml:id="ruby_hash.title">Hashes</title>

      <indexterm>
        <primary>Hashes</primary>

        <secondary>in Ruby</secondary>
      </indexterm>

      <para>Ein <quote><foreignphrase
      xml:lang="en">Hash</foreignphrase></quote> ist eine Liste aus
      Schlüssel-/Wert-Paaren (<foreignphrase xml:lang="en">key/value
      pairs</foreignphrase>). Ein Beispiel mit Strings als Schlüssel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>preisliste = { '6 Eier' =&gt; 1.2, '12 Eier' =&gt; 2, '500 gr Butter' =&gt; 0.99 }</command>
=&gt; {"6 Eier"=&gt;1.2, "12 Eier"=&gt;2, "500 gr Butter"=&gt;0.99}
1.9.3p194 :002:0&gt; <command>preisliste['12 Eier']</command>
=&gt; 2
1.9.3p194 :003:0&gt; <command>preisliste.count</command>
=&gt; 3
1.9.3p194 :004:0&gt; <command>exit</command>
</screen></para>

      <para>Natürlich können in Hashes nicht nur Strings, sondern – wie bei
      Arrays – auch selbstdefinierte Klassen als Objekte in den Werten
      gespeichert werden (siehe <xref linkend="ruby_array"/>).</para>

      <para>Wie zu <classname>Array</classname> gibt es auch zu
      <classname>Hash</classname> eine sehr gute
      <literal>ri</literal>-Hilfeseite:<screen>sw@debian:~/sandbox$ <command>ri Hash</command>
= Hash &lt; Object

------------------------------------------------------------------------------
= Includes:
Enumerable (from ruby site)

(from ruby site)
------------------------------------------------------------------------------
A Hash is a collection of key-value pairs. It is similar to an Array, except
that indexing is done via arbitrary keys of any object type, not an integer
index. Hashes enumerate their values in the order that the corresponding keys
were inserted.

Hashes have a default value that is returned when
accessing keys that do not exist in the hash. By default, that value is nil.

------------------------------------------------------------------------------
= Class methods:

  [], new, try_convert

= Instance methods:
  ==, [], []=, assoc, clear, compare_by_identity, compare_by_identity?,
  default, default=, default_proc, default_proc=, delete, delete_if, each,
  each_key, each_pair, each_value, empty?, eql?, fetch, flatten, has_key?,
  has_value?, hash, include?, initialize_copy, inspect, invert, keep_if, key,
  key?, keys, length, member?, merge, merge!, pretty_print,
  pretty_print_cycle, rassoc, rehash, reject, reject!, replace, select,
  select!, shift, size, store, to_a, to_hash, to_s, update, value?, values,
  values_at

sw@debian:~/sandbox$ </screen></para>

      <section xml:id="ruby_symbol">
        <title xml:id="ruby_symbol.title">Symbole (Symbols)</title>

        <indexterm>
          <primary>Symbole (Symbols)</primary>

          <secondary>in Ruby</secondary>
        </indexterm>

        <para><foreignphrase xml:lang="en">Symbols</foreignphrase> sind eine
        <quote>merkwürdige</quote> und schwer erklärbare Sache. Allerdings
        sind sie auch sehr praktisch und werden unter anderem bei Hashes
        häufig benutzt. Normalerweise werden bei Variablen immer neue Objekte
        angelegt:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>a = 'Beispiel 1'</command>
 =&gt; "Beispiel 1" 
1.9.3p194 :002:0&gt; <command>a.object_id</command>
 =&gt; 2156685080 
1.9.3p194 :003:0&gt; <command>a = 'Beispiel 2'</command>
 =&gt; "Beispiel 2" 
1.9.3p194 :004:0&gt; <command>a.object_id</command>
 =&gt; 2151901180 
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>

        <para>Wir haben zweimal die Variable <varname>a</varname>, aber einmal
        hat sie die Objekt-ID <code>2156685080</code> und dann die Objekt-ID
        <code>2151901180</code>. Wir könnten das immer so weitermachen. Es
        würde jedes Mal eine andere Objekt-ID und damit ein neues Objekt
        herauskommen. Das ist prinzipiell nicht weiter schlimm und im Sinne
        der Objektorientierung auch logisch. Allerdings ist es auch ein recht
        verschwenderischer Umgang mit Speicherplatz.</para>

        <para>Ein Symbol wird durch einen Doppelpunkt vor dem Namen definiert
        und kann selber keine Werte speichern, aber hat immer die gleiche
        Objekt-ID und ist deshalb sehr gut als Schlüssel (<foreignphrase
        xml:lang="en">key</foreignphrase>) geeignet:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>:a.object_id</command>
 =&gt; 373448 
1.9.3p194 :002:0&gt; <command>exit</command>
</screen></para>

        <para>Machen wir noch mal einen kleinen Versuch, um den Unterschied
        klarer herauszustellen. Wir benutzen 3-mal hintereinander ein
        String-Objekt mit dem Inhalt <quote><literal>white</literal></quote>
        und dann 3-mal hintereinander das Symbol <literal>:white</literal>.
        Bei <literal>"white"</literal> wird immer ein neues Objekt angelegt.
        Beim Symbol <literal>:white</literal> nur beim ersten Mal:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>'white'.object_id</command>
 =&gt; 2152156400 
1.9.3p194 :002:0&gt; <command>'white'.object_id</command>
 =&gt; 2152152240 
1.9.3p194 :003:0&gt; <command>'white'.object_id</command>
 =&gt; 2152164440 
1.9.3p194 :004:0&gt; <command>:white.object_id</command>
 =&gt; 373448 
1.9.3p194 :005:0&gt; <command>:white.object_id</command>
 =&gt; 373448 
1.9.3p194 :006:0&gt; <command>:white.object_id</command>
 =&gt; 373448 
1.9.3p194 :007:0&gt; <command>exit</command>
</screen></para>

        <para>Die Benutzung von Symbolen als Schlüssel ist bei Hashes sehr
        viel speichereffizienter:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>farben = { :black =&gt; '#000000', :white =&gt; ':FFFFFF', :green =&gt; '#00C000', :blue =&gt; '#0000FF' }
=&gt; {:black=&gt;"#000000", :white=&gt;":FFFFFF", :green=&gt;"#00C000", :blue=&gt;"#0000FF"}</command>
1.9.3p194 :002:0&gt; <command>puts farben[:green]</command>
#00C000
=&gt; nil
1.9.3p194 :003:0&gt; <command>exit</command>
</screen></para>

        <para>Symbole werden Sie in Rails noch oft sehen. Wenn Sie weitere
        Informationen zu Symbols suchen, können Sie mit <command>ri
        Symbol</command> die Hilfeseite zur Klasse
        <classname>Symbol</classname> aufrufen.</para>
      </section>

      <section xml:id="ruby-hash-iterator-each">
        <title>Iterator each</title>

        <indexterm>
          <primary>Iteratoren</primary>

          <secondary>in Ruby</secondary>

          <tertiary>each()</tertiary>
        </indexterm>

        <para>Mit der Methode <indexterm>
            <primary>each()</primary>

            <secondary>in Ruby</secondary>
          </indexterm><methodname>each</methodname> kann man sich Stück für
        Stück durch einen Hash arbeiten. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
1.9.3p194 :001:0&gt; <command>einkaufsliste = { 'Eier' =&gt; 6, 'Butter' =&gt; '500 gr' }</command>
=&gt; {"Eier"=&gt;6, "Butter"=&gt;"500 gr"}
1.9.3p194 :002:0&gt; <command>einkaufsliste.each do |key,value|</command>
1.9.3p194 :003:1* <command>  puts "Produkt: #{key} - Menge: #{value}"</command>
1.9.3p194 :004:1&gt; <command>end</command>
Produkt: Eier - Menge: 6
Produkt: Butter - Menge: 500 gr
=&gt; {"Eier"=&gt;6, "Butter"=&gt;"500 gr"}
1.9.3p194 :005:0&gt; <command>exit</command>
</screen></para>

        <para>Auch hier gibt Ihnen <literal>ri</literal> Hilfe und ein
        Beispiel, falls Sie mal vergessen haben sollten, wie
        <methodname>each</methodname> anzuwenden ist:<screen>sw@debian:~/sandbox$ <command>ri Hash.each</command>
= Hash.each

(from ruby site)
------------------------------------------------------------------------------
  hsh.each      {| key, value | block } -&gt; hsh
  hsh.each_pair {| key, value | block } -&gt; hsh
  hsh.each                              -&gt; an_enumerator
  hsh.each_pair                         -&gt; an_enumerator

------------------------------------------------------------------------------

Calls block once for each key in hsh, passing the key-value
pair as parameters.

If no block is given, an enumerator is returned instead.

  h = { "a" =&gt; 100, "b" =&gt; 200 }
  h.each {|key, value| puts "#{key} is #{value}" }

produces:

  a is 100
  b is 200

sw@debian:~/sandbox$ </screen></para>
      </section>
    </section>
  </section>

  <section xml:id="ruby_sonstiges">
    <title xml:id="ruby_sonstiges.title">Sonstiges</title>

    <section xml:id="range_class">
      <title xml:id="range_class.title">Range</title>

      <indexterm>
        <primary>Range</primary>
      </indexterm>

      <para>Die <classname>Range</classname> Klasse repräsentiert einen
      Interval. Start- und Endpunkt des Intervals wird zwischen normalen
      Klammern mit zwei Punkten in der Mitte definiert. Ein Beispiel in dem
      wir einen Range wie einen Iterator mit <methodname>each</methodname>
      benutzen:<screen>stefan@swmbp 0 1.9.2-p0 ~$ <command>irb</command>
1.9.3p194 &gt; <command>(0..3)</command>
 =&gt; 0..3 
1.9.3p194 &gt; <command>(0..3).class</command>
 =&gt; Range 
1.9.3p194 &gt; <command>(0..3).each do |i|</command>
1.9.3p194 &gt;     <command>puts i</command>
1.9.3p194 ?&gt;  <command>end</command>
0
1
2
3
 =&gt; 0..3 
1.9.3p194 &gt; </screen></para>

      <para>Mit der Methode <methodname>to_a</methodname> kann aus einem
      <classname>Range</classname> ein <classname>Array</classname> generiert
      werden:<screen>1.9.3p194 &gt; <command>(0..3).to_a</command>
 =&gt; [0, 1, 2, 3] 
1.9.3p194 &gt;</screen></para>

      <para>Ein Range kann man aus Objekten jeden Types generieren. Wichtig
      ist nur, das die Objekte mit <methodname>&lt;=&gt;</methodname>
      vergleichbar sind und die Methode <methodname>succ</methodname> zum
      Hochzählen auf den nächsten Wert benutzen. So können Sie mit Range auch
      Buchstaben repräsentieren:<screen>1.9.3p194 &gt; <command>('a'..'h').to_a</command>
 =&gt; ["a", "b", "c", "d", "e", "f", "g", "h"] 
1.9.3p194 &gt; 
</screen></para>

      <para>Als alternative Schreibweise werden Sie manchmal auf auf
      <methodname>Range.new()</methodname> stossen. Dann wird der Start- und
      Endpunkt nicht mit zwei Punkten, sondern mit einem Komma abgetrennt. Das
      sieht dann so aus:<screen>1.9.3p194 &gt; <command>(0..3) == Range.new(0,3)</command>
 =&gt; true 
1.9.3p194 &gt; <command>exit</command>
stefan@swmbp 0 1.9.3p194 ~$ </screen></para>
    </section>
  </section>
</chapter>
