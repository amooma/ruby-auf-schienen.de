<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="dvd-katalog"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>DVD-Katalog</title>

  <para>Nachdem Sie sich im letzten Kapitel mühsam in die Ruby-Grundlagen
  eingelesen haben, können wir jetzt spannender weitermachen. In diesem
  Kapitel starten wir ein erstes Rails-Projekt und arbeiten uns damit Stück
  für Stück in die Materie ein.</para>

  <para>Auch in diesem Kapitel wird es manchmal hoppla-hopp zu gehen. Wir
  stossen auf typische Henne-Ei-Probleme wir zum Beispiel: "Wie erkläre ich
  MVC (Model-View-Controller)?". Ich habe mich für den "Wir fangen mal an und
  erklären bei der Arbeit."-Ansatz entschieden.</para>

  <para>Um endlich mal Ordnung in unsere DVD-Sammlung - ich höre schon die
  Stimmen "Wie, die benutzen immer noch DVDs und keine Blue-Rays?" - zu
  bringen erstellen wir ein Rails-Projekt, das uns bei der Verwaltung
  hilft.</para>

  <section xml:id="arbeits-umgebung-development">
    <title>Arbeits-Umgebung (Development)</title>

    <para>Rails kennt drei verschiedene Arbeits-Umgebungen:<itemizedlist>
        <listitem>
          <para>Development</para>
        </listitem>

        <listitem>
          <para>Testing</para>
        </listitem>

        <listitem>
          <para>Production</para>
        </listitem>
      </itemizedlist></para>

    <para>Wir arbeiten in diesem Kapitel nur mit der Development Umgebung. So
    bald Sie ein besseres Gefühl für Rails bekommen haben, starten wir mit
    Tests und benötigen dafür die entsprechende Umgebung (dort wird z.B. beim
    Start eines Tests die Test-Datenbank neu gefühlt und beim Beenden wird
    gelöscht). Später erkläre ich Ihnen dann die verschiedenen Szenarien, wie
    Sie Ihre Rails-Applikation aus der Development-Umgebung in die
    Production-Umgebung ausrollen können.</para>

    <para>Die Development-Umgebung bringt bis auf einen Editor und einen
    Webbrowser alles mit, was Sie zum Entwickeln benötigen. So müssen Sie
    nicht extra einen Webserver installieren, sondern können den eingebauten
    Rails-Webserver benutzen. Der besticht nicht durch extreme Performance,
    aber das benötigen wir bei der Entwicklung ja auch nicht. Später kann man
    dann auf grosse Systeme wie <application>Apache</application> umsteigen.
    Das gleiche gilt für die Datenbank.</para>

    <para>Um in der Development-Umgebung zu arbeiten, müssen Sie erst mal
    nichts verändern. Alle Befehle gelten per Default auf die
    Development-Umgebung.</para>
  </section>

  <section xml:id="dvd-neues-projekt-anfangen">
    <title>Ein neues Rails-Projekt anfangen</title>

    <para>Als aller erstes müssen wir mal ein neues Rails-Projekt erstellen.
    Da Ruby on Rails ein Framework ist, müssen wir erst mal die entsprechende
    Verzeichnisstruktur und die Grundkonfiguration inkl. einiger Skripte
    einrichten. Das geht aber mit dem <command>rails projektname</command>
    ratz-fatz:<screen>sw@debian:~$ <command>rails dvd-sammlung</command>
      create  
      create  app/controllers
      create  app/helpers
      create  app/models
      create  app/views/layouts
      create  config/environments
      create  config/initializers
      create  config/locales
      create  db
      create  doc
      create  lib
      create  lib/tasks
      create  log
      create  public/images
      create  public/javascripts
      create  public/stylesheets
      create  script/performance
      create  test/fixtures
      create  test/functional
      create  test/integration
      create  test/performance
      create  test/unit
      create  vendor
      create  vendor/plugins
      create  tmp/sessions
      create  tmp/sockets
      create  tmp/cache
      create  tmp/pids
      create  Rakefile
      create  README
      create  app/controllers/application_controller.rb
      create  app/helpers/application_helper.rb
      create  config/database.yml
      create  config/routes.rb
      create  config/locales/en.yml
      create  db/seeds.rb
      create  config/initializers/backtrace_silencers.rb
      create  config/initializers/inflections.rb
      create  config/initializers/mime_types.rb
      create  config/initializers/new_rails_defaults.rb
      create  config/initializers/session_store.rb
      create  config/environment.rb
      create  config/boot.rb
      create  config/environments/production.rb
      create  config/environments/development.rb
      create  config/environments/test.rb
      create  script/about
      create  script/console
      create  script/dbconsole
      create  script/destroy
      create  script/generate
      create  script/runner
      create  script/server
      create  script/plugin
      create  script/performance/benchmarker
      create  script/performance/profiler
      create  test/test_helper.rb
      create  test/performance/browsing_test.rb
      create  public/404.html
      create  public/422.html
      create  public/500.html
      create  public/index.html
      create  public/favicon.ico
      create  public/robots.txt
      create  public/images/rails.png
      create  public/javascripts/prototype.js
      create  public/javascripts/effects.js
      create  public/javascripts/dragdrop.js
      create  public/javascripts/controls.js
      create  public/javascripts/application.js
      create  doc/README_FOR_APP
      create  log/server.log
      create  log/production.log
      create  log/development.log
      create  log/test.log
sw@debian:~$ </screen></para>

    <tip>
      <para>Bitte überprüfen Sie an dieser Stelle, ob Sie auch wirklich mit
      der Ruby Version 1.9 und Rails 2.3.x arbeiten (<command>ruby
      -v</command> und <command>rails -v</command>). An sonsten werden Sie
      irgendwann in Merkwürdigkeiten laufen. Falls Sie beides noch nicht
      installiert haben finden Sie weitere Infos im <xref
      linkend="installation-und-versionsauswahl" /> .</para>
    </tip>

    <para>Als erstes (so sollte man sich das direkt angewöhnen) prüfen wir
    mal, ob die Installation funktioniert. Dazu starten wir den mitgelieferten
    Server:<screen>sw@debian:~/dvd-sammlung$ <command>./script/server</command> 
=&gt; Booting WEBrick
=&gt; Rails 2.3.5 application starting on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2009-12-24 23:05:22] INFO  WEBrick 1.3.1
[2009-12-24 23:05:22] INFO  ruby 1.9.1 (2009-12-07) [i686-linux]
[2009-12-24 23:05:22] INFO  WEBrick::HTTPServer#start: pid=18474 port=3000
</screen></para>

    <para>Mit dieser Konfiguration können Sie einen Webbrowser auf dem
    entsprechenden System mit der URL http://0.0.0.0:3000 oder einfacher mit
    http://localhost:3000 starten und sehen Sie den Output der Default-Seite.
    Wenn Sie eine grafischen Browser benutzen sieht das natürlich etwas
    schöner aus.<footnote>
        <para>Im Sinne der Barrierefreiheit benutze ich in diesem Buch
        grafische Browser nur, wenn es gar nicht mehr anders geht. Das wird
        z.B. bei AJAX-Applikationen sein.</para>
      </footnote><screen>sw@debian:~$ <command>w3m -dump http://localhost:3000</command>
  • [site:rubyonrails.org] [Search] the Rails site
  • Join the community

      □ Ruby on Rails
      □ Official weblog
      □ Wiki
  • Browse the documentation

      □ Rails API
      □ Ruby standard library
      □ Ruby core
      □ Rails Guides

Welcome aboard

You’re riding Ruby on Rails!

About your application’s environment

Getting started

Here’s how to get rolling:

 1. Use script/generate to create your models and controllers

    To see all available options, run it without parameters.

 2. Set up a default route and remove or rename this file

    Routes are set up in config/routes.rb.

 3. Create your database

    Run rake db:migrate to create your database. If you're not using SQLite
    (the default), edit config/database.yml with your username and password.

 
sw@debian:~</screen></para>

    <para>Wenn Sie jetzt auf den "About your application’s environment Link"
    klicken, dann bekommen Sie Informationen zu der von Ihnen benutzten
    Umgebung (ganz praktisch um zu überprüfen, ob auch alle richtig
    ist):<screen>Ruby version            1.9.1 (i686-linux)
RubyGems version        1.3.5
Rack version            1.0
Rails version           2.3.5
Active Record version   2.3.5
Active Resource version 2.3.5
Action Mailer version   2.3.5
Active Support version  2.3.5
Application root        /home/sw/dvd-sammlung
Environment             development
Database adapter        sqlite3
Database schema version 0</screen></para>

    <para>Den Webserver können Sie jederzeit mit <command>CTRL-C</command>
    wieder beenden:<screen>^C[2009-12-24 23:10:00] INFO  going to shutdown ...
[2009-12-24 23:10:00] INFO  WEBrick::HTTPServer#start done.
Exiting
sw@debian:~/dvd-sammlung$</screen></para>

    <section xml:id="andere-ip-oder-port">
      <title>Andere IP-Adresse oder Port gewünscht?</title>

      <para>Per default antwortet der eingebaute Rails-Webserver auf die
      IP-Adresse 0.0.0.0 und den Port 3000. Damit lässt sich super auf einem
      lokalen System entwickeln. Wenn Sie aber Ihren Webbrowser auf einem
      anderen System laufen lassen, als Ihre Rails-Installation, können Sie
      natürlich nicht auf dessen 0.0.0.0 IP-Adresse zugreifen. Sie können aber
      problemlos beide Angaben ändern wie die eingebaute Hilfeseite
      anzeigt:<screen>sw@debian:~/dvd-sammlung$ <command>./script/server -h</command>
Usage: server [options]
    -p, --port=port                  Runs Rails on the specified port.
                                     Default: 3000
    -b, --binding=ip                 Binds Rails to the specified ip.
                                     Default: 0.0.0.0
    -c, --config=file                Use custom rackup configuration file
    -d, --daemon                     Make server run as a Daemon.
    -u, --debugger                   Enable ruby-debugging for the server.
    -e, --environment=name           Specifies the environment to run this server under (test/development/production).
                                     Default: development
    -P, --path=/path                 Runs Rails app mounted at a specific path.
                                     Default: /

    -h, --help                       Show this help message.
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Sollten Sie zum Beispiel (wie ich es oft mache) Ihren Rails-Server
      innerhalb einer VMware laufen lassen, aber von Ihrem Host-Betriebssystem
      den Browser benutzen wollen, so können Sie den Server wie folgt
      starten:<screen>sw@debian:~/dvd-sammlung$ <command>./script/server -b 192.168.248.134</command>
=&gt; Booting WEBrick
=&gt; Rails 2.3.5 application starting on http://192.168.248.134:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2009-12-24 23:19:28] INFO  WEBrick 1.3.1
[2009-12-24 23:19:28] INFO  ruby 1.9.1 (2009-12-07) [i686-linux]
[2009-12-24 23:19:28] INFO  WEBrick::HTTPServer#start: pid=18506 port=3000
</screen></para>

      <para>Damit wäre Ihr Rails-Entwicklungssystem über die URL
      http://192.168.248.134:3000 ansteuerbar.</para>
    </section>

    <section xml:id="es-laeuft-schon-ein-webserver">
      <title>Es läuft schon ein Webserver</title>

      <para>Einer der Gründe für das initiale Starten des Webservers am Anfang
      des Projektes ist zu überprüfen, ob nicht schon ein Rails-Server auf dem
      gleichen System läuft. In diesem Fall bekommen Sie die folgende
      Fehlermeldung ausgegeben:<programlisting>sw@debian:~/dvd-sammlung$ <command>./script/server</command> 
=&gt; Booting WEBrick
=&gt; Rails 2.3.5 application starting on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2009-12-25 00:22:20] INFO  WEBrick 1.3.1
[2009-12-25 00:22:20] INFO  ruby 1.9.1 (2009-12-07) [i686-linux]
[2009-12-25 00:22:20] WARN  TCPServer Error: Address already in use - bind(2)
Exiting
/usr/local/lib/ruby/1.9.1/webrick/utils.rb:73:in `initialize': Address already in use - bind(2) (Errno::EADDRINUSE)
 from /usr/local/lib/ruby/1.9.1/webrick/utils.rb:73:in `new'
 from /usr/local/lib/ruby/1.9.1/webrick/utils.rb:73:in `block in create_listeners'
 from /usr/local/lib/ruby/1.9.1/webrick/utils.rb:70:in `each'
 from /usr/local/lib/ruby/1.9.1/webrick/utils.rb:70:in `create_listeners'
 from /usr/local/lib/ruby/1.9.1/webrick/server.rb:74:in `listen'
 from /usr/local/lib/ruby/1.9.1/webrick/server.rb:62:in `initialize'
 from /usr/local/lib/ruby/1.9.1/webrick/httpserver.rb:24:in `initialize'
 from /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.0.1/lib/rack/handler/webrick.rb:10:in `new'
 from /usr/local/lib/ruby/gems/1.9.1/gems/rack-1.0.1/lib/rack/handler/webrick.rb:10:in `run'
 from /usr/local/lib/ruby/gems/1.9.1/gems/rails-2.3.5/lib/commands/server.rb:111:in `&lt;top (required)&gt;'
 from ./script/server:3:in `require'
 from ./script/server:3:in `&lt;main&gt;'
sw@debian:~/dvd-sammlung$ </programlisting></para>

      <para>Suchen Sie in so einem Fall bitte nach dem schon laufenden
      Rails-System und beenden Sie es mit <command>CTRL-C</command>.
      Alternativ können Sie natürlich Ihr neues System auf einem anderen Port
      starten. Aber das erhöht nicht gerade die Übersichtlichkeit beim
      Entwickeln. ;-)</para>
    </section>

    <section xml:id="logging">
      <title>Logging</title>

      <para>In der Datei <filename>log/development.log</filename> finden Sie
      das Log des Webservers. Bei der Entwicklung von Rails-Applikationen hat
      es sich für mich als sehr praktisch erwiesen immer ein Terminal offen zu
      haben, das mit einem <command>tail -f log/development.log</command> das
      aktuelle Log anzeigt.<screen>sw@debian:~/dvd-sammlung$ <command>tail -f log/development.log</command> 
# Logfile created on 2009-12-25 12:30:33 +0100

Processing Rails::InfoController#properties (for 127.0.0.1 at 2009-12-25 12:30:59) [GET]
  SQL (0.5ms)    SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

Completed in 23ms (View: 4, DB: 1) | 200 OK [http://localhost/rails/info/properties]
</screen></para>

      <section xml:id="logging-statische-oder-dynamische-seite">
        <title>Statische und dynamisch generierte Seiten</title>

        <para>Statische Seite wie die default <filename>index.html</filename>
        oder auch die 404.html Fehler-Seite liegen im Unterverzeichnis
        public<screen>sw@debian:~/dvd-sammlung$ <command>ls public</command>
404.html  500.html     images      javascripts  stylesheets
422.html  favicon.ico  index.html  robots.txt
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Die Auslieferung einer solchen Seite oder einer Datei aus diesem
        Verzeichnis wird nicht im <filename>log/development.log</filename>
        angezeigt. Übrigens haben die Dateien im public-Verzeichnis eine
        höhere Prio, als die dynamisch gerenderten Seiten. Falls Sie also zwei
        Seiten mit dem gleichen Namen haben, dann wird Rails die statische
        Variante ausliefern. Deshalb werden Sie später die
        <filename>index.html</filename> Seite entweder umbenennen oder ganz
        löschen müssen (sonst würde Ihre Applikation immer nur mit dieser
        statischen Webseite starten).</para>
      </section>
    </section>
  </section>

  <section xml:id="dvd-scaffolding">
    <title>Scaffolding</title>

    <para>Die typischen "Ich zeige Euch mal Ruby on Rails in 15 Minuten"
    Videos arbeiten alle mit der Magie des Scaffolding. Leider ist das
    meistens kontraproduktiv, weil man zwar sehr schnell ein Grundgerüst
    stehen hat, aber danach erst mal im Regen steht. Das alte "ohne
    Ruby-Grundkenntnisse kommt man nicht weiter"-Problem schlägt dann zu. Aber
    Sie haben sich ja schon das Ruby-Kapitel gekämpft und kommen deshalb
    direkt zu den Vorzügen von Scaffolding.</para>

    <section xml:id="dvd-datenbankmodell">
      <title>Datenbankmodell</title>

      <para>In früheren Rails-Versionen musste man die Datenbank von Hand
      anlegen. ActiveRecord hat dann die Felder an bestimmten Namensmerkmalen
      erkannt. Heute gibt es in Rails dazu eigene noch dazu äusserst
      praktische Tools. Denn Sie wollen ja nicht nur jetzt eine Datebank für
      Ihre Entwicklungs-Umgebung einrichten, sondern benötigen später auch ein
      Tool, das Ihre Produktions-Datenbank Schritt für Schritt
      mitzieht.</para>

      <para>Wir wollen DVDs katalogisieren. Dazu benötigen wir mindestens
      folgende Datenbankfelder:<itemizedlist>
          <listitem>
            <para><varname>title:string</varname> - Titel oder Name der
            DVD</para>
          </listitem>

          <listitem>
            <para><varname>production_year:integer</varname> -
            Produktionsjahr</para>
          </listitem>

          <listitem>
            <para><varname>duration:integer</varname> - Abspieldauer</para>
          </listitem>

          <listitem>
            <para><varname>plot:text</varname> - Story des Films</para>
          </listitem>

          <listitem>
            <para><varname>rating:integer</varname> - Bewertung (ein 5 Sterne
            System)</para>
          </listitem>
        </itemizedlist></para>

      <section>
        <title>Warum alle Feldnamen, Methoden und Classes auf
        Englisch?</title>

        <para>Ganz tief im Herzen liebt Rails die englische Sprache. Damit
        muss man sich abfinden und versuchen diese Liebe zu übernehmen. So
        verwenden sehr viele Mechanismen automagisch Plural oder Singular von
        Englischen Wörtern. Wenn man sich damit anfreundet Datenbankfelder und
        Datenbanken an sich mit englischen Wörter zu benennen, dann kann man
        die ganze Macht dieser Magie ausnutzen.</para>
      </section>

      <section xml:id="dvd-ist-das-ein-model">
        <title>Ist das jetzt ein Model (laut der MVC-Idee)?</title>

        <para>Kurze Antwort: Ja. Wir müssen dem Model nur noch einen Namen
        geben. "<varname>dvd</varname>" macht wohl am meisten Sinn.</para>
      </section>
    </section>

    <section xml:id="script-generate">
      <title>./script/generate</title>

      <para>Mit dem Rails-Skript <filename>./script/generate</filename> kann
      man fertige Code generieren. Wer (wie ich) gerne mal vergisst wie das
      Skript aufgerufen werden muss, der gibt einfach
      <filename>./script/generate</filename> ein und bekommt die folgende
      Hilfe angezeigt:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate</command> 
Usage: ./script/generate generator [options] [args]

Rails Info:
    -v, --version                    Show the Rails version number and quit.
    -h, --help                       Show this help message and quit.

General Options:
    -p, --pretend                    Run but do not make any changes.
    -f, --force                      Overwrite files that already exist.
    -s, --skip                       Skip files that already exist.
    -q, --quiet                      Suppress normal output.
    -t, --backtrace                  Debugging: show backtrace on errors.
    -c, --svn                        Modify files with subversion. (Note: svn must be in path)
    -g, --git                        Modify files with git. (Note: git must be in path)


Installed Generators
  Builtin: controller, helper, integration_test, mailer, metal, migration, model, observer, performance_test, plugin, resource, scaffold, session_migration

More are available at http://wiki.rubyonrails.org/rails/pages/AvailableGenerators
  1. Download, for example, login_generator.zip
  2. Unzip to directory /home/sw/.rails/generators/login
     to use the generator with all your Rails apps
     or to /home/sw/dvd-sammlung/lib/generators/login
     to use with this app only.
  3. Run generate with no arguments for usage information
       ./script/generate login

Generator gems are also available:
  1. gem search -r generator
  2. gem install login_generator
  3. ./script/generate login

sw@debian:~/dvd-sammlung$</screen></para>

      <para>Interessant ist für uns der Teil in dem die "Installed Generators"
      aufgelistet werden. Wenn wir scaffold benutzen wollen und dazu weitere
      Hilfe brauchen, dann geht dies wiederrum einfach mit der eingebauten
      Hilfe:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate scaffold</command>
Usage: ./script/generate scaffold ModelName [field:type, field:type]

Options:
        --skip-timestamps            Don't add timestamps to the migration file for this model
        --skip-migration             Don't generate a migration file for this model
        --force-plural               Forces the generation of a plural ModelName

Rails Info:
    -v, --version                    Show the Rails version number and quit.
    -h, --help                       Show this help message and quit.

General Options:
    -p, --pretend                    Run but do not make any changes.
    -f, --force                      Overwrite files that already exist.
    -s, --skip                       Skip files that already exist.
    -q, --quiet                      Suppress normal output.
    -t, --backtrace                  Debugging: show backtrace on errors.
    -c, --svn                        Modify files with subversion. (Note: svn must be in path)
    -g, --git                        Modify files with git. (Note: git must be in path)

Description:
    Scaffolds an entire resource, from model and migration to controller and
    views, along with a full test suite. The resource is ready to use as a
    starting point for your RESTful, resource-oriented application.

    Pass the name of the model (in singular form), either CamelCased or
    under_scored, as the first argument, and an optional list of attribute
    pairs.

    Attribute pairs are column_name:sql_type arguments specifying the
    model's attributes. Timestamps are added by default, so you don't have to
    specify them by hand as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the resource immediately.

    For example, 'scaffold post title:string body:text published:boolean'
    gives you a model with those three attributes, a controller that handles
    the create/show/update/destroy, forms to create and edit your posts, and
    an index that lists them all, as well as a map.resources :posts
    declaration in config/routes.rb.

    If you want to remove all the generated files, run
    'script/destroy scaffold ModelName'.

Examples:
    `./script/generate scaffold post`
    `./script/generate scaffold post title:string body:text published:boolean`
    `./script/generate scaffold purchase order_id:integer amount:decimal`
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Wir müssen also nach <application>./script/generate
      scaffold</application> den Namen des Models (bei uns "dvd") und danach
      die Datenbankfelder mit den entsprechenden Feldtypen angeben.</para>
    </section>

    <section xml:id="dvd-script-generate-anwenden">
      <title>Und los gehts</title>

      <para>Dann legen wir mal los:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate scaffold dvd title:string production_year:integer duration:integer plot:text rating:integer</command>
      exists  app/models/
      exists  app/controllers/
      exists  app/helpers/
      create  app/views/dvds
      exists  app/views/layouts/
      exists  test/functional/
      exists  test/unit/
      create  test/unit/helpers/
      exists  public/stylesheets/
      create  app/views/dvds/index.html.erb
      create  app/views/dvds/show.html.erb
      create  app/views/dvds/new.html.erb
      create  app/views/dvds/edit.html.erb
      create  app/views/layouts/dvds.html.erb
      create  public/stylesheets/scaffold.css
      create  app/controllers/dvds_controller.rb
      create  test/functional/dvds_controller_test.rb
      create  app/helpers/dvds_helper.rb
      create  test/unit/helpers/dvds_helper_test.rb
       route  map.resources :dvds
  dependency  model
      exists    app/models/
      exists    test/unit/
      exists    test/fixtures/
      create    app/models/dvd.rb
      create    test/unit/dvd_test.rb
      create    test/fixtures/dvds.yml
      create    db/migrate
      create    db/migrate/20091224213402_create_dvds.rb
sw@debian:~/dvd-sammlung$</screen>Und schon ist alles fertig. Allerdings ist
      in der Datenbank noch keine entsprechende Tabelle angelegt.</para>
    </section>

    <section xml:id="dvd-migration">
      <title>Migrationen</title>

      <para><application>./script/generate scaffold</application> hat uns
      schon alles eingerichtet. Allerdings müssen wir noch in der Datenbank
      die Tabelle für unsere Daten anlegen. Rails nimmt uns aber die Arbeit
      ab. Im Verzeichnis <filename>db/migrate</filename> liegen
      Migrationsdateien, die mit einem Timestamp im Namen versehen sind. Im
      Laufe eines Projektes werden es immer mehr. Sie können mit dem Tool
      <application>rake</application> in die Datenbank eingespielt werden.
      Aber schauen wir uns erst mal den Inhalt der Migrationsdatei zum Modell
      <varname>dvd</varname> an:<screen>sw@debian:~/dvd-sammlung$ <command>cat -n db/migrate/20091224213402_create_dvds.rb</command>
     1 class CreateDvds &lt; ActiveRecord::Migration
     2   def self.up
     3     create_table :dvds do |t|
     4       t.string :title
     5       t.integer :production_year
     6       t.integer :duration
     7       t.text :plot
     8       t.integer :rating
     9 
    10       t.timestamps
    11     end
    12   end
    13 
    14   def self.down
    15     drop_table :dvds
    16   end
    17 end
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Die in dieser Ruby-Datei angelegte Class
      <classname>CreateDvds</classname> ist ein Kind der Klasse
      <classname>ActiveRecord::Migration</classname> (siehe Zeile 1) und hat
      zwei Methoden:<itemizedlist>
          <listitem>
            <para><methodname>self.up</methodname> (Zeile 2). Wird aufgerufen,
            wenn die Migration durchgeführt wird.</para>
          </listitem>

          <listitem>
            <para><methodname>self.down</methodname> (Zeile 14). Wird
            aufgerufen, wenn für eine Migration ein Rollback durchgeführt
            wird.</para>
          </listitem>
        </itemizedlist></para>

      <para>Führen wir mal eine Migration durch:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreateDvds: migrating =====================================================
-- create_table(:dvds)
   -&gt; 0.0012s
==  CreateDvds: migrated (0.0024s) ============================================

sw@debian:~/dvd-sammlung$</screen></para>

      <para>Die Tabelle <varname>dvds</varname> wird angelegt. Dabei sehen
      wir, das Tabellen-Namen automatisch den Plural der Models bekommen. Aber
      welche Datenbank wird überhaupt benutzt? Das wird in der
      Konfigurationsdatei <filename>config/database.yml</filename>
      definiert:<screen>sw@debian:~/dvd-sammlung$ <command>cat -n config/database.yml</command> 
     1 # SQLite version 3.x
     2 #   gem install sqlite3-ruby (not necessary on OS X Leopard)
     3 development:
     4   adapter: sqlite3
     5   database: db/development.sqlite3
     6   pool: 5
     7   timeout: 5000
     8 
     9 # Warning: The database defined as "test" will be erased and
    10 # re-generated from your development database when you run "rake".
    11 # Do not set this db to the same as development or production.
    12 test:
    13   adapter: sqlite3
    14   database: db/test.sqlite3
    15   pool: 5
    16   timeout: 5000
    17 
    18 production:
    19   adapter: sqlite3
    20   database: db/production.sqlite3
    21   pool: 5
    22   timeout: 5000
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Dort werden drei verschiedene Datenbanken im YAML-Format (siehe
      http://www.yaml.org/ bzw. http://de.wikipedia.org/wiki/YAML) definiert.
      Für uns wichtig ist erst mal nur die development-Datenbank (Zeile 3 bis
      7). Per default benutzt Rails dort <application>sqlite3</application>.
      sqlite3 mag nicht die richtige Wahl für die Analyse der weltweit
      gesammelten Wetterdaten sein, aber für die schnelle und unkompliziete
      Entwicklung von Rails-Anwendungen lernt man sie schnell zu schätzen. In
      der Produktions-Umgebung kann man später immer noch auf "grosse"
      Datenbanken wie MySQL umsteigen.<footnote>
          <para>Es gibt unter einigen Entwicklern die Ansicht, das man auf
          jeden Fall immer mit der gleichen Datenbank entwicklen soll, die man
          später auch in der Produktion und im Testing benutzt. Ich verstehe
          die Argumentation, bin aber anderer Ansicht. Wir werden das Thema
          später bei der Definition von eigenen SQL-Abfragen noch mal
          besprechen.</para>
        </footnote></para>

      <para>Um Ihre Neugierde zu befriedigen, schauen wir uns kurz noch die
      Datenbank mit dem Command-Line-Tool <application>sqlite3</application>
      an.<screen>sw@debian:~/dvd-sammlung$ <command>sqlite3 db/development.sqlite3</command> 
SQLite version 3.5.9
Enter ".help" for instructions
sqlite&gt; <command>.tables</command> 
dvds               schema_migrations
sqlite&gt; <command>.schema dvds</command>
CREATE TABLE "dvds" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime);
sqlite&gt; .quit
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Das Anlegen der Tabelle mit <application>rake
      db:migrate</application> wurde natürlich auch im
      <filename>log/development.log</filename> eingetragen:<programlisting>  SQL (0.1ms)   select sqlite_version(*)
  SQL (409.9ms)   CREATE TABLE "schema_migrations" ("version" varchar(255) NOT NULL) 
  SQL (58.5ms)   CREATE UNIQUE INDEX "unique_schema_migrations" ON "schema_migrations" ("version")
  SQL (0.2ms)    SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)   SELECT version FROM schema_migrations
Migrating to CreateDvds (20091225115807)
  SQL (0.3ms)   CREATE TABLE "dvds" ("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL, "title" varchar(255), "production_year" integer, "duration" integer, "plot" text, "rating" integer, "created_at" datetime, "updated_at" datetime) 
  SQL (0.1ms)   INSERT INTO schema_migrations (version) VALUES ('20091225115807')
  SQL (0.2ms)    SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.1ms)   SELECT version FROM schema_migrations
  SQL (0.1ms)    SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  SQL (0.5ms)   PRAGMA index_list("dvds")
</programlisting></para>

      <section xml:id="active-record-auto-felder">
        <title>Automatisch zugefügte Felder (id, created_at und
        updated_at)</title>

        <para>Rails ist so freundlich uns beim Scaffolding per Default immer
        noch folgende Felder hinzuzufügen:<itemizedlist>
            <listitem>
              <para><varname>id:integer</varname></para>

              <para>Das ist die Unique-ID des Datensatzes. Das Feld wird von
              der Datenbank automatisch hochgezählt. Für alle SQL-Fans:
              AUTOINCREMENT NOT NULL</para>
            </listitem>

            <listitem>
              <para><varname>created_at:datetime</varname></para>

              <para>Das Feld wird von ActiveRecord automatisch beim Erstellen
              eines Datensatzes gefüllt.</para>
            </listitem>

            <listitem>
              <para><varname>updated_at:datetime</varname></para>

              <para>Das Feld wird bei jeder Veränderung des Datensatzes
              automatisch an die aktuelle Zeit angepasst.</para>
            </listitem>
          </itemizedlist></para>

        <para>Am Anfang fragt man sich: "Muss das sein? Macht das wirklich
        Sinn?". Aber mit der Zeit lernt man diese automatisch gehandelten
        Felder lieben.</para>

        <para>Falls Sie anderer Meinung sind: Sie können die Erstellung von
        <varname>created_at</varname> und <varname>updated_at</varname> mit
        dem Schalter <parameter>--skip-timestamps</parameter> beim Scaffolding
        deaktivieren.</para>
      </section>

      <section xml:id="migration-rollback">
        <title>Migration Rollback</title>

        <para>Es soll schon vorgekommen sein, das übereilt eine Migration
        durchgeführt wurde. Natürlich passiert weder Ihnen noch mir so was.
        Aber falls mal ein Freund von Ihnen in diese Predulie gerät: Keine
        Panik! Dafür benutzen wir ja Rails und Rails hat sich dazu schon etwas
        ausgedacht. Dafür wurde in der Migrations-Class die Methode
        <methodname>self.down</methodname> angelegt. Testweise können wir ja
        mal unsere letzte Migration zurückrollen:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:rollback</command>
(in /home/sw/dvd-sammlung)
==  CreateDvds: reverting =====================================================
-- drop_table(:dvds)
   -&gt; 0.0005s
==  CreateDvds: reverted (0.0016s) ============================================

sw@debian:~/dvd-sammlung$</screen></para>

        <para>Sie können alles auf einmal zurück-rollen oder auch nur einzelne
        Migrationen. Mit dem Schalter <parameter>-T</parameter> bekommen Sie
        eine Hilfe zu allen möglichen Wegen aufgezeigt:<screen>sw@debian:~/dvd-sammlung$ <command>rake -T db</command>
(in /home/sw/dvd-sammlung)
rake db:abort_if_pending_migrations  # Raises an error if there are pending m...
rake db:charset                      # Retrieves the charset for the current ...
rake db:collation                    # Retrieves the collation for the curren...
rake db:create                       # Create the database defined in config/...
rake db:create:all                   # Create all the local databases defined...
rake db:drop                         # Drops the database for the current RAI...
rake db:drop:all                     # Drops all the local databases defined ...
rake db:fixtures:identify            # Search for a fixture given a LABEL or ID.
rake db:fixtures:load                # Load fixtures into the current environ...
rake db:migrate                      # Migrate the database through scripts i...
rake db:migrate:down                 # Runs the "down" for a given migration ...
rake db:migrate:redo                 # Rollbacks the database one migration a...
rake db:migrate:reset                # Resets your database using your migrat...
rake db:migrate:up                   # Runs the "up" for a given migration VE...
rake db:reset                        # Drops and recreates the database from ...
rake db:rollback                     # Rolls the schema back to the previous ...
rake db:schema:dump                  # Create a db/schema.rb file that can be...
rake db:schema:load                  # Load a schema.rb file into the database
rake db:seed                         # Load the seed data from db/seeds.rb
rake db:sessions:clear               # Clear the sessions table
rake db:sessions:create              # Creates a sessions migration for use w...
rake db:setup                        # Create the database, load the schema, ...
rake db:structure:dump               # Dump the database structure to a SQL file
rake db:test:clone                   # Recreate the test database from the cu...
rake db:test:clone_structure         # Recreate the test databases from the d...
rake db:test:load                    # Recreate the test database from the cu...
rake db:test:prepare                 # Check for pending migrations and load ...
rake db:test:purge                   # Empty the test database
rake db:version                      # Retrieves the current schema version n...
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Aber spielen wir lieber unsere Migration wieder ein:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreateDvds: migrating =====================================================
-- create_table(:dvds)
   -&gt; 0.0011s
==  CreateDvds: migrated (0.0021s) ============================================

sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="dvd-start-application">
    <title>Start der Rails-Applikation</title>

    <para>Bitte starten Sie Ihren Webserver:<screen>sw@debian:~/dvd-sammlung$ <command>./script/server</command> 
=&gt; Booting WEBrick
=&gt; Rails 2.3.5 application starting on http://0.0.0.0:3000
=&gt; Call with -d to detach
=&gt; Ctrl-C to shutdown server
[2009-12-25 00:26:24] INFO  WEBrick 1.3.1
[2009-12-25 00:26:24] INFO  ruby 1.9.1 (2009-12-07) [i686-linux]
[2009-12-25 00:26:24] INFO  WEBrick::HTTPServer#start: pid=18632 port=3000
</screen></para>

    <para>Mit Scaffolding haben Sie direkt ein kleine Web-GUI zum
    Administrieren Ihrer DVD-Sammlung bekommen. Diese ist noch sehr
    rudimentär, aber ist ein guter Start.</para>
  </section>

  <section xml:id="zugriff-per-http">
    <title>Zugriff per HTTP-Protokoll</title>

    <para>Gemäss der CRUD Idee (siehe http://de.wikipedia.org/wiki/CRUD)
    bietet Rails ein RESTful Webinterface an. Was heisst das? Sie können auf
    jede Resource innerhalb einer normalen Rails-Umgeben über definierte URLs
    zugreifen und damit folgende Datenbank-Operationen ausführen:<itemizedlist>
        <listitem>
          <para>C für CREATE</para>

          <para>SQL: <code>INSERT INTO dvds (title) VALUES ('Rain
          Man')</code></para>
        </listitem>

        <listitem>
          <para>R für READ</para>

          <para>SQL: <code>SELECT * FROM dvds</code></para>
        </listitem>

        <listitem>
          <para>U für UPDATE</para>

          <para>SQL: <code>UPDATE dvds SET title = 'Rain Man' WHERE id =
          1</code></para>
        </listitem>

        <listitem>
          <para>D für DELETE</para>

          <para>SQL: <code>DELETE FROM dvds WHERE id = 1</code></para>
        </listitem>
      </itemizedlist>Um die CRUD Idee besser erklären zu können, habe ich in
    den nachfolgenden Beispielen drei Beispiel-Filme aus der Terminator-Reihe
    in die Datenbank gefüttert.<qandaset>
        <qandadiv>
          <qandaentry>
            <question>
              <para>Warum wird um das RESTful Interface in Ruby on Rails so
              ein Bohei gemacht?</para>
            </question>

            <answer>
              <para>Damit bekommt man ein sauberes und für alle Programmierer
              leicht verständliches Interface zu Ihrem System. Sie brauchen
              nur die URI <uri>http://localhost:3000/dvds</uri> und das
              Wissen, das es sich um ein RESTful Webdienst handelt und Sie
              können direkt loslegen.</para>
            </answer>
          </qandaentry>

          <qandaentry>
            <question>
              <para>Ist RESTful nur für die automatische Abfrage zwischen
              Computern gut?</para>
            </question>

            <answer>
              <para>Nein. RESTful ist auch ein guter Denkansatz, um URLs und
              damit ganze Webseiten strukturierter zu gestalten.</para>
            </answer>
          </qandaentry>
        </qandadiv>
      </qandaset></para>

    <section xml:id="via-html-webbrowser">
      <title>HTML-Webbrowser</title>

      <para>Sie können mit einem normalen Webbrowser alle CRUD Aktionen
      ausführen und bekommen ein von Menschen leicht bedienbares
      HTML-Interface.</para>

      <section>
        <title>index</title>

        <para>Die Liste aller aktuell gespeicherten DVDs bekommen Sie unter
        der URL <uri>http://localhost:3000/dvds</uri><screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlMjljNWZmNDdlNGVmMGU3OGMwODk4NWM0NmY2ZGZhYzQ6EF9jc3JmX3Rva2VuSSIxQ0VMamhTWHRodGc4c2o0ZndQVUtDUmYwbHZJWGp0SWRaV2JQMUFFdGFRYz0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--010ffc05a95aa7059e7266e4ced21836bb06cd3a
Listing dvds

       Title         Production year Duration Plot Rating
The Terminator       1984                                 Show Edit Destroy
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy


New dvd
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#index (for 127.0.0.1 at 2009-12-25 01:56:29) [GET]
  Dvd Load (0.8ms)   SELECT * FROM "dvds" 
Rendering template within layouts/dvds
Rendering dvds/index
Completed in 44ms (View: 41, DB: 1) | 200 OK [http://localhost/dvds]
</screen></para>
      </section>

      <section>
        <title>new</title>

        <para>Eine neue DVD können Sie unter der URL
        <uri>http://localhost:3000/dvds/new</uri> eintragen:<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds/new</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlZThhNjAxZjE1MThlMzcyZmYzOGIxOTM1Y2JlZTM5MmI6EF9jc3JmX3Rva2VuSSIxdFBoTnFPTEJGbmgrajVQVmNoKzhnNVM1Z3N0aFFOYkdNaEpxNWJlbnpBbz0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--59c0c0badd6f26c43a0b0b5bcabebbf61c97ca76
New dvd

Title
[                              ]

Production year
[                              ]

Duration
[                              ]

Plot
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]

Rating
[                              ]

[Create]

Back
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#new (for 127.0.0.1 at 2009-12-25 01:57:38) [GET]
Rendering template within layouts/dvds
Rendering dvds/new
Completed in 33ms (View: 10, DB: 0) | 200 OK [http://localhost/dvds/new]
</screen></para>

        <para>Nachdem Sie Beispieldaten eingegeben und auf Create geklickt
        haben, werden Sie folgende Ausgabe im Log sehen:<screen>Processing DvdsController#create (for 127.0.0.1 at 2009-12-25 01:59:31) [POST]
  Parameters: {"authenticity_token"=&gt;"DmNBZo3HfeQOxm2fSSJswuGkJpHHegddgbLNj1aCe/I=", "dvd"=&gt;{"title"=&gt;"Rain Man", "production_year"=&gt;"1988", "duration"=&gt;"", "plot"=&gt;"Geschichte zweier sehr ungleicher Br\xC3\xBCder.\r\n", "rating"=&gt;"5"}, "commit"=&gt;"Create"}
  Dvd Create (0.2ms)   INSERT INTO "dvds" ("title", "production_year", "duration", "plot", "rating", "created_at", "updated_at") VALUES('Rain Man', 1988, NULL, 'Geschichte zweier sehr ungleicher Brüder.
', 5, '2009-12-24 23:38:31', '2009-12-24 23:38:31')
Redirected to http://localhost:3000/dvds/1
Completed in 63ms (DB: 0) | 302 Found [http://localhost/dvds]
</screen></para>

        <para>Danach werden Sie auf die show-Seite dieses Eintrages
        umgeleitet.</para>
      </section>

      <section>
        <title>show</title>

        <para>Eine einzelne DVD kann man sich mit der ID des Eintrages (hier
        die 1) und der entsprechenden URL
        <uri>http://localhost:3000/dvds/show/1</uri> anschauen. Alternativ
        geht auch die Kurzform <uri>http://localhost:3000/dvds/1</uri><screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds/1</command>
Received cookie: _dvd-sammlung_session=BAh7BjoPc2Vzc2lvbl9pZCIlMTQ3YTgyNTU3OTUzZGUyYTc4NmIxYTE4MWNiYTZjYmM%3D--787ebfba94fba9eeb0ad1d9de51d2b3933230e2c
Title: The Terminator

Production year: 1984

Duration:

Plot:

Rating:

Edit | Back
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#show (for 127.0.0.1 at 2009-12-25 01:59:32) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Rendering template within layouts/dvds
Rendering dvds/show
Completed in 12ms (View: 8, DB: 0) | 200 OK [http://localhost/dvds/1]
</screen></para>
      </section>

      <section>
        <title>edit</title>

        <para>Den Eintrag dieser einzelnen DVD können Sie mit der URL
        <uri>http://localhost:3000/dvds/edit/1</uri> ändern.<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds/edit/1</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlOWM5YjM3MzRlZGJiZmY2ZWZlZjk4MTAxNTFjMmYyZGE6EF9jc3JmX3Rva2VuSSIxN3BpdmdxcVlIeEhuQmZSVEFPaVRDT1crb2hFeVZxMkMwYWNaYzRuVkV6ST0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--efd0399080f39207d6f46b731c4be6a179624322
Editing dvd

Title
[The Terminator                ]

Production year
[1984                          ]

Duration
[                              ]

Plot
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]

Rating
[                              ]

[Update]

Show | Back
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#edit (for 127.0.0.1 at 2009-12-25 02:00:39) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Rendering template within layouts/dvds
Rendering dvds/edit
Completed in 14ms (View: 11, DB: 0) | 200 OK [http://localhost/dvds/edit/1]
</screen></para>
      </section>

      <section>
        <title>update</title>

        <para>Beispielhaft füllen wir das Webinterface aus dem edit-Beispiel
        wie folgt aus:<screen>Editing dvd

Title
[The Terminator                ]

Production year
[1984                          ]

Duration
[                              ]

Plot
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]
[                                        ]

Rating
[5                             ]

[Update]

Show | Back</screen></para>

        <para>Danach klicken wir auf <command>[Update]</command>. Dabei sehen
        wir im Webserver-Log folgende Ausgabe:<screen>Processing DvdsController#update (for 127.0.0.1 at 2009-12-25 02:03:55) [PUT]
  Parameters: {"authenticity_token"=&gt;"z9rs1PeGoyeEvA1TyOZ000wPsS10OQFVdh2pa0AxA30=", "dvd"=&gt;{"title"=&gt;"The Terminator", "production_year"=&gt;"1984", "duration"=&gt;"", "plot"=&gt;"", "rating"=&gt;"5"}, "commit"=&gt;"Update", "id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
  Dvd Update (0.2ms)   UPDATE "dvds" SET "plot" = '', "rating" = 5, "updated_at" = '2009-12-25 01:03:55' WHERE "id" = 1
Redirected to http://localhost:3000/dvds/1
Completed in 406ms (DB: 0) | 302 Found [http://localhost/dvds/1]


Processing DvdsController#show (for 127.0.0.1 at 2009-12-25 02:03:56) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Rendering template within layouts/dvds
Rendering dvds/show
Completed in 6ms (View: 3, DB: 0) | 200 OK [http://localhost/dvds/1]
</screen></para>

        <para>Nach dem Update des Eintrages, werden wir automatisch auf die
        show-Seite des Eintrages umgeleitet.</para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URL
        <uri>http://localhost:3000/dvds/destroy/1</uri> wieder aus der
        Datenbank löschen.<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds/destroy/1</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlMDRhZDA2OGViMjhhMTg1YjMxNzk0ODQxNjExMjRhYWE6EF9jc3JmX3Rva2VuSSIxckQrR0hwVWRmak53RDh3ZDRhcjNpMVdZWFFtM1hkQUhEa0F6M3VqMHlVdz0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--79f2cb0361e0319908cf252987e08b4bf3746f00
Listing dvds

       Title         Production year Duration Plot Rating
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy


New dvd
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#destroy (for 127.0.0.1 at 2009-12-25 02:05:48) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
  Dvd Destroy (0.1ms)   DELETE FROM "dvds" WHERE "id" = 1
Redirected to http://localhost:3000/dvds
Completed in 386ms (DB: 0) | 302 Found [http://localhost/dvds/destroy/1]
</screen></para>

        <para>Nach dem destroy wird auf index umgeleitet.</para>
      </section>
    </section>

    <section xml:id="via-xml-browser">
      <title>Per XML</title>

      <para>Das XML-Interface erleichtert den Austausch von Daten zwischen
      Maschinen. Dabei wird der ganze HTML-Balast abgeworfen und nur noch die
      reinen Daten per XML ausgetauscht.<important>
          <para>Damit diese Beispiele problemlos funktionieren, habe ich
          <parameter>protect_from_forgery</parameter> in der
          <filename>app/controllers/application_controller.rb</filename> durch
          auskommentieren deaktiviert. Dadurch entfällt eine per default
          aktivierte Sicherheitsschicht, die einen Token austauscht, um die
          anonyme Interaktion von aussen zu underbinden. In späteren Kapiteln
          besprechen wir Authentifizierungsmechanismen für diese Fälle.</para>
        </important></para>

      <section>
        <title>index</title>

        <para>Die Liste aller aktuell gespeicherten DVDs bekommen Sie unter
        der URL <uri>http://localhost:3000/dvds.xml</uri><screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://localhost:3000/dvds.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvds type="array"&gt;
  &lt;dvd&gt;
    &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
    &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
    &lt;id type="integer"&gt;1&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1984&lt;/production-year&gt;
    &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
    &lt;title&gt;The Terminator&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
  &lt;/dvd&gt;
  &lt;dvd&gt;
    &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
    &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
    &lt;id type="integer"&gt;2&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;1992&lt;/production-year&gt;
    &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
    &lt;title&gt;Terminator 2&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
  &lt;/dvd&gt;
  &lt;dvd&gt;
    &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
    &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
    &lt;id type="integer"&gt;3&lt;/id&gt;
    &lt;plot nil="true"&gt;&lt;/plot&gt;
    &lt;production-year type="integer"&gt;2009&lt;/production-year&gt;
    &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
    &lt;title&gt;Terminator Salvation&lt;/title&gt;
    &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
  &lt;/dvd&gt;
&lt;/dvds&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#index to xml (for 127.0.0.1 at 2009-12-25 02:11:09) [GET]
  Dvd Load (0.9ms)   SELECT * FROM "dvds" 
Completed in 494ms (View: 491, DB: 1) | 200 OK [http://0.0.0.0/dvds.xml]
</screen></para>
      </section>

      <section>
        <title>new</title>

        <para>Um eine neue DVD einzutragen, benötigen Sie als erstes die
        Felder die ausgefüllt werden müssen. Dazu können Sie die URL
        <uri>http://localhost:3000/dvds/new.xml</uri> abrufen:<screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://0.0.0.0:3000/dvds/new.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvd&gt;
  &lt;created-at type="datetime" nil="true"&gt;&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer" nil="true"&gt;&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title nil="true"&gt;&lt;/title&gt;
  &lt;updated-at type="datetime" nil="true"&gt;&lt;/updated-at&gt;
&lt;/dvd&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#new to xml (for 127.0.0.1 at 2009-12-25 02:12:34) [GET]
Completed in 6ms (View: 2, DB: 0) | 200 OK [http://0.0.0.0/dvds/new.xml]
</screen></para>

        <para>Danach können Sie mit einem create Aufruf die Daten für einen
        neuen Datensatz uploaden:<screen>sw@debian:~/dvd-sammlung$ <command>curl -X POST -d "&lt;dvd&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/dvd&gt;" http://localhost:3000/dvds</command>
&lt;html&gt;&lt;body&gt;You are being &lt;a href="http://localhost:3000/dvds/5"&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Ausgabe im Log:<screen>Processing DvdsController#create (for 127.0.0.1 at 2009-12-25 02:25:33) [POST]
  Parameters: {"&lt;dvd&gt;&lt;title&gt;Rain Man&lt;/title&gt;&lt;production-year&gt;1988&lt;/production-year&gt;&lt;/dvd&gt;"=&gt;nil}
  Dvd Create (0.3ms)   INSERT INTO "dvds" ("title", "production_year", "duration", "plot", "rating", "created_at", "updated_at") VALUES(NULL, NULL, NULL, NULL, NULL, '2009-12-25 01:25:33', '2009-12-25 01:25:33')
Redirected to http://localhost:3000/dvds/5
Completed in 52ms (DB: 0) | 302 Found [http://localhost/dvds]
</screen></para>

        <para>Danach werden Sie auf die show-Seite dieses Eintrages
        umgeleitet.</para>
      </section>

      <section>
        <title>show</title>

        <para>Eine einzelne DVD kann man sich mit der ID des Eintrages (hier
        die 1) und der entsprechenden URL
        <uri>http://localhost:3000/dvds/show/1.xml</uri> anschauen. Alternativ
        geht auch die Kurzform
        <uri>http://localhost:3000/dvds/1.xml</uri><screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://localhost:3000/dvds/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvd&gt;
  &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1984&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title&gt;The Terminator&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
&lt;/dvd&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#show to xml (for 127.0.0.1 at 2009-12-25 02:31:28) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Completed in 7ms (View: 3, DB: 0) | 200 OK [http://localhost/dvds/1.xml]
</screen></para>
      </section>

      <section>
        <title>edit - update</title>

        <para>Zum Editieren eines Eintrages downloaden wir diesen Eintrag erst
        wieder von der entsprechenden URL
        <uri>http://localhost:3000/dvds/1.xml</uri><screen>sw@debian:~/dvd-sammlung$ <command>curl -X GET http://localhost:3000/dvds/1.xml</command>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;dvd&gt;
  &lt;created-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/created-at&gt;
  &lt;duration type="integer" nil="true"&gt;&lt;/duration&gt;
  &lt;id type="integer"&gt;1&lt;/id&gt;
  &lt;plot nil="true"&gt;&lt;/plot&gt;
  &lt;production-year type="integer"&gt;1984&lt;/production-year&gt;
  &lt;rating type="integer" nil="true"&gt;&lt;/rating&gt;
  &lt;title&gt;The Terminator&lt;/title&gt;
  &lt;updated-at type="datetime"&gt;2009-12-25T01:10:54Z&lt;/updated-at&gt;
&lt;/dvd&gt;
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Danach posten wir den entsprechenden Eintrag neu (in diesem
        Beispiel setzen wir das Rating auf 5 Sterne). Wichtig dabei ist, das
        wir die <parameter>id</parameter> des Eintrages mit
        übertragen:<screen>sw@debian:~/dvd-sammlung$ <command>curl -X PUT -d "&lt;dvd&gt;&lt;id&gt;1&lt;/id&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;/dvd&gt;" http://localhost:3000/dvds/update/1.xml</command>
sw@debian:~/dvd-sammlung$ </screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#update to xml (for 127.0.0.1 at 2009-12-25 02:46:31) [PUT]
  Parameters: {"&lt;dvd&gt;&lt;id&gt;1&lt;/id&gt;&lt;rating&gt;5&lt;/rating&gt;&lt;/dvd&gt;"=&gt;nil, "id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Completed in 5ms (View: 0, DB: 0) | 200 OK [http://localhost/dvds/update/1.xml]
</screen></para>
      </section>

      <section>
        <title>destroy</title>

        <para>Sie können den eben angelegten Datensatz mit der URL
        <uri>http://localhost:3000/dvds/destroy/1</uri> wieder aus der
        Datenbank löschen.<screen>sw@debian:~/dvd-sammlung$ <command>curl -X DELETE http://localhost:3000/dvds/1.xml</command>
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Im Log des Webservers sehen Sie folgende Ausgabe:<screen>Processing DvdsController#destroy to xml (for 127.0.0.1 at 2009-12-25 02:49:40) [DELETE]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.2ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
  Dvd Destroy (0.2ms)   DELETE FROM "dvds" WHERE "id" = 1
Completed in 128ms (View: 0, DB: 0) | 200 OK [http://localhost/dvds/1.xml]
</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="arbeiten-mit-der-console">
    <title>Arbeiten mit ./script/console</title>

    <para>Sie haben im letzten Kapitel gelernt mit irb umzugehen. In Rails
    gibt es noch was cooleres: <filename>./script/console</filename></para>

    <para>Mit <filename>./script/console</filename> haben Sie nicht nur die
    normalen irb Mechanismen, sondern auch direkt alle Class-en und Methoden
    aus Ihrer Rails-Applikation. Und Sie können auf die Daten zugreifen. Diese
    werden automagisch per ActiveRecord als Objekte zur Verfügung gestellt.
    Zur Demonstration lade ich eine frische Datenbank mit drei Beispielfilmen
    aus der Terminatorreihe.</para>

    <para>Die Rails-Console kann parallel zum Webserver oder anstatt des
    Webservers gestartet werden. Wir fangen wieder mit einer leeren Datenbank
    an und starten die Console:<screen>sw@debian:~/dvd-sammlung$ ./script/console 
Loading development environment (Rails 2.3.5)
&gt;&gt;</screen></para>

    <section>
      <title>Neuen Datensatz anlegen</title>

      <para>ActiveRecord stellt uns automagisch eine Class aus der Datenbank
      <parameter>dvds</parameter> mit dem Namen <classname>Dvd</classname> zur
      Verfügung. Diese Class hat eine Methode new und mit der können wir ein
      neues Objekt erstellen.<screen>&gt;&gt; <command>terminator = Dvd.new</command>
=&gt; #&lt;Dvd id: nil, title: nil, production_year: nil, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt;
&gt;&gt; </screen></para>

      <para>Wir können uns sicherheitshalber noch mal die Class der Instance
      terminator ausgeben lassen.<screen>&gt;&gt; <command>terminator.class</command>
=&gt; Dvd(id: integer, title: string, production_year: integer, duration: integer, plot: text, rating: integer, created_at: datetime, updated_at: datetime)
&gt;&gt;</screen></para>

      <para>Das neue Objekt terminator hat automatsch Accessors zu den
      einzelnen Datenfeldern. Schauen wir uns doch mal die für die Class
      <classname>Dvd</classname> verfügbaren Instance-Methoden an:<screen>&gt;&gt; <command>Dvd.instance_methods(false)</command>
=&gt; [:title, :title=, :title?, :production_year, :production_year=, :production_year?, :duration, :duration=, :duration?, :plot, :plot=, :plot?, :rating, :rating=, :rating?, :created_at, :created_at=, :created_at?, :updated_at, :updated_at=, :updated_at?, :id]
&gt;&gt;</screen></para>

      <para>Diese benutzen wir zum Füllen mit einem Beispieldatensatz.<screen>&gt;&gt; <command>terminator.title = 'The Terminator'</command>
=&gt; "The Terminator"
&gt;&gt; <command>terminator.production_year = 1984</command>
=&gt; 1984
&gt;&gt; <command>terminator</command>
=&gt; #&lt;Dvd id: nil, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: nil, updated_at: nil&gt;
&gt;&gt;</screen></para>

      <para>Das Objekt ist allerdings noch nicht in der Datenbank gespeichert.
      Das erfolgt erst durch Aufruf der Methode
      <methodname>save</methodname>.<screen>&gt;&gt; <command>terminator.save</command>
=&gt; true
&gt;&gt;</screen></para>

      <para>Alternative können wir einen zweiten Datensatz auch direkt mit der
      Methode <methodname>create</methodname> anlegen.<screen>&gt;&gt; <command>Dvd.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })</command>
=&gt; #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:31:29", updated_at: "2009-12-25 03:31:29"&gt;
&gt;&gt;</screen></para>

      <section>
        <title>Hilfe zu create</title>

        <para>Die Methode <methodname>create</methodname> gehört zu
        <classname>ActiveRecord::Base</classname>. Die online Hilfe dazu kann
        mit <application>ri</application> abgerufen werden.<screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveRecord::Base.create</command>
--------------------------------------------- ActiveRecord::Base::create
     ActiveRecord::Base::create(attributes = nil, &amp;block) {|object| ...}

     From gem activerecord-2.3.5
------------------------------------------------------------------------
     Creates an object (or multiple objects) and saves it to the
     database, if validations pass. The resulting object is returned
     whether the object was saved successfully to the database or not.

     The +attributes+ parameter can be either be a Hash or an Array of
     Hashes. These Hashes describe the attributes on the objects that
     are to be created.

     Examples

       # Create a single new object
       User.create(:first_name =&gt; 'Jamie')
     
       # Create an Array of new objects
       User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }])
     
       # Create a single object and pass it into a block to set other attributes.
       User.create(:first_name =&gt; 'Jamie') do |u|
         u.is_admin = false
       end
     
       # Creating an Array of new objects using a block, where the block is execut
ed for each object:
       User.create([{ :first_name =&gt; 'Jamie' }, { :first_name =&gt; 'Jeremy' }]) do |
u|
         u.is_admin = false
       end

sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>

    <section>
      <title>Alle Datensätze anzeigen</title>

      <para>Der einfachste Weg alle Datensätze aus der Datenbank dvds
      anzuzeigen ist:<screen>&gt;&gt; <command>Dvd.all</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:31:29", updated_at: "2009-12-25 03:31:29"&gt;]
&gt;&gt;</screen></para>

      <para>Was für eine Class ist <classname>Dvd.all</classname>? Schauen wir
      mal nach.<screen>&gt;&gt; <command>Dvd.all.class</command>
=&gt; Array
&gt;&gt;</screen></para>

      <para>Dann können wir ja die Iterator-Methode
      <methodname>each</methodname> anwenden, um durch die einzelnen Elemente
      des Arrays zu gehen. Damit können Sie sich als Beispiel alle Titel
      ausgeben lassen.<screen>&gt;&gt; <command>Dvd.all.each { |dvd| puts dvd.title }</command>
The Terminator
Terminator 2
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:31:29", updated_at: "2009-12-25 03:31:29"&gt;]
&gt;&gt;</screen></para>
    </section>

    <section xml:id="dvd-seeds">
      <title xml:id="dvd-seeds.title">DVD-Development-Datenbank mit Bespielen
      befüllen</title>

      <para>Gerade bei der Entwicklung kommt es immer mal wieder vor, das man
      den Inhalt der Datenbank löschen und mit neuen Werten befüllen will. In
      Rails gibt es dafür den praktischen Mechanismus der Datei
      <filename>db/seeds.rb</filename></para>

      <para>Die <filename>db/seeds.rb</filename> ist ein normales
      Ruby-Programm, das man mit <command>rake db:seed</command> ausführen
      kann. Dies geht natürlich nicht nur mit der Entwicklungsdatenbank,
      sondern kann später auch in der Produktion geschehen. Das ist z.B.
      praktisch, wenn man initial eine Länderliste in eine Länderdatenbank
      eintragen will.</para>

      <para>Für unsere DVD-Datenbank habe ich folgende
      <filename>db/seeds.rb</filename> vorbereitet:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#   
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Major.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Dvd.create({ :title =&gt; 'The Terminator', :production_year =&gt; 1984 })
Dvd.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 })
Dvd.create({ :title =&gt; 'Terminator Salvation', :production_year =&gt; 2009 })
Dvd.create({ :title =&gt; 'Rain Man', :production_year =&gt; 1988, :rating =&gt; 5 })
Dvd.create({ :title =&gt; 'War of the Worlds', :production_year =&gt; 2005, :rating =&gt; 4 })
Dvd.create({ :title =&gt; 'Collateral', :production_year =&gt; 2004, :rating =&gt; 5})
Dvd.create({ :title =&gt; 'Miami Vice', :production_year =&gt; 2006, :rating =&gt; 5})
Dvd.create({ :title =&gt; 'Hancock', :production_year =&gt; 2008, :rating =&gt;  4})
Dvd.create({ :title =&gt; 'The Aviator', :production_year =&gt; 2004, :rating =&gt;  4})
Dvd.create({ :title =&gt; 'Some Like It Hot', :production_year =&gt; 1959, :rating =&gt;  5})
Dvd.create({ :title =&gt; 'W.', :production_year =&gt; 2008, :rating =&gt;  4})
Dvd.create({ :title =&gt; 'Iron Man', :production_year =&gt; 2008, :rating =&gt;  5})
Dvd.create({ :title =&gt; 'The Dark Knight', :production_year =&gt; 2008, :rating =&gt;  5})
</programlisting></para>

      <section>
        <title>Betankung</title>

        <para>Wenn Sie vorher die Datenbank schon mit <command>rake
        db:migrate</command> angelegt haben, können Sie wie folgt die
        Betankung aus <filename>db/seeds.rb</filename> vornehmen:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:seed</command>
(in /home/sw/dvd-sammlung)
sw@debian:~/dvd-sammlung$</screen></para>
      </section>

      <section>
        <title>Reset</title>

        <para>Wenn Sie im Entwicklungsprozess an der Stelle angekommen sind,
        an der Sie die Datenbank wieder auf die in der
        <filename>db/seeds.rb</filename> aufgeführten Werte setzen möchten, so
        können Sie das wie folgt machen:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:reset</command>
(in /home/sw/dvd-sammlung)
db/development.sqlite3 already exists
-- create_table("dvds", {:force=&gt;true})
   -&gt; 0.4381s
-- initialize_schema_migrations_table()
   -&gt; 0.0396s
-- assume_migrated_upto_version(20091225115807)
   -&gt; 0.0129s
sw@debian:~/dvd-sammlung$ </screen><warning>
            <para>Mit <command>rake db:reset</command> wird die Datenbank vor
            dem Neubetanken gelöscht!</para>
          </warning></para>
      </section>

      <section>
        <title>Wie soll ich mir das alles merken?</title>

        <para>Keine Panik, wenn Sie mal den genauen Rake-Befehl vergessen
        haben. Der Schalter <parameter>"-T"</parameter> ist Ihr
        Hilfe-Freund:<screen>sw@debian:~/dvd-sammlung$ <command>rake -T db</command>
(in /home/sw/dvd-sammlung)
rake db:abort_if_pending_migrations  # Raises an error if there are pending...
rake db:charset                      # Retrieves the charset for the curren...
rake db:collation                    # Retrieves the collation for the curr...
rake db:create                       # Create the database defined in confi...
rake db:create:all                   # Create all the local databases defin...
rake db:drop                         # Drops the database for the current R...
rake db:drop:all                     # Drops all the local databases define...
rake db:fixtures:identify            # Search for a fixture given a LABEL o...
rake db:fixtures:load                # Load fixtures into the current envir...
rake db:migrate                      # Migrate the database through scripts...
rake db:migrate:down                 # Runs the "down" for a given migratio...
rake db:migrate:redo                 # Rollbacks the database one migration...
rake db:migrate:reset                # Resets your database using your migr...
rake db:migrate:up                   # Runs the "up" for a given migration ...
rake db:reset                        # Drops and recreates the database fro...
rake db:rollback                     # Rolls the schema back to the previou...
rake db:schema:dump                  # Create a db/schema.rb file that can ...
rake db:schema:load                  # Load a schema.rb file into the database
rake db:seed                         # Load the seed data from db/seeds.rb
rake db:sessions:clear               # Clear the sessions table
rake db:sessions:create              # Creates a sessions migration for use...
rake db:setup                        # Create the database, load the schema...
rake db:structure:dump               # Dump the database structure to a SQL...
rake db:test:clone                   # Recreate the test database from the ...
rake db:test:clone_structure         # Recreate the test databases from the...
rake db:test:load                    # Recreate the test database from the ...
rake db:test:prepare                 # Check for pending migrations and loa...
rake db:test:purge                   # Empty the test database
rake db:version                      # Retrieves the current schema version...
sw@debian:~/dvd-sammlung$ <command>rake -T db:reset</command>
(in /home/sw/dvd-sammlung)
rake db:reset  # Drops and recreates the database from db/schema.rb for the...
sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>

    <section xml:id="arbeiten-mit-find">
      <title>Arbeiten mit der Methode find</title>

      <para>Es gibt in <classname>ActiveRecord::Base</classname> eine Methode
      <methodname>find</methodname> die es uns ermöglicht ganz ohne
      SQL-Kenntnisse nach Daten in der Datenbank zu suchen.</para>

      <section>
        <title>Nach ID suchen</title>

        <para>Eine DVD nach der ID zu suchen ist der einfachste aller Fälle.
        Suchen wir mal nach der DVD mit der ID 1:<screen>&gt;&gt; <command>Dvd.find(1)</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;
&gt;&gt;</screen></para>
      </section>

      <section>
        <title>Nach einem Feldinhalt suchen</title>

        <para>Jetzt kommt ein wenig Ruby-Magie ins Spiel. Die Methode
        <methodname>find</methodname> kann dynamisch erweitert werden. Am
        einfachsten zeigt sich das mit ein paar Beispielen:<screen>&gt;&gt; <command>Dvd.find_by_title('The Terminator')</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;
&gt;&gt; <command>Dvd.find_by_production_year(1984)</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;
&gt;&gt; <command>Dvd.find_by_rating(nil)</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;
&gt;&gt;</screen></para>

        <para>Bei der letzten Suche zeigt sich dabei allerdings schon ein
        Problem, denn <methodname>find_by_x</methodname> gibt immer nur den
        ersten Treffer aus. Wenn man mehrere Treffer ausgeben will, muss man
        <command>find_all_by_x</command> benutzen:<screen>&gt;&gt; <command>Dvd.find_all_by_rating(nil)</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:31:29", updated_at: "2009-12-25 03:31:29"&gt;]
&gt;&gt; <command>Dvd.find_all_by_rating(nil).count</command>
=&gt; 2
&gt;&gt;</screen></para>

        <para>Man kann die <methodname>find_all_by_x</methodname> oder
        <methodname>find_by_x</methodname> Methoden beliebig mit dem String
        <methodname>_and_</methodname> und weiteren Feldnamen
        verlängern:<screen>&gt;&gt; <command>Dvd.find_all_by_duration_and_rating(nil,nil)</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:29:47", updated_at: "2009-12-25 03:29:47"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 03:31:29", updated_at: "2009-12-25 03:31:29"&gt;]
&gt;&gt; <command>Dvd.find_all_by_duration_and_rating(nil,nil).count</command>
=&gt; 2
&gt;&gt;</screen></para>
      </section>

      <section>
        <title>Komplexere Suchen</title>

        <para>Die Methode find ist sehr mächtig. Bevor ich einzelne Beispiele
        gebe, möchte ich Sie schon mal auf die eingebaute Hilfe
        verweisen:<screen>sw@debian:~/sandbox$ <command>ri ActiveRecord::Base.find</command>
----------------------------------------------- ActiveRecord::Base::find
     ActiveRecord::Base::find(*args)

     From gem activerecord-2.3.5
------------------------------------------------------------------------
     Find operates with four different retrieval approaches:

     *   Find by id - This can either be a specific id (1), a list of
         ids (1, 5, 6), or an array of ids ([5, 6, 10]). If no record
         can be found for all of the listed ids, then RecordNotFound
         will be raised.

     *   Find first - This will return the first record matched by the
         options used. These options can either be specific conditions
         or merely an order. If no record can be matched, +nil+ is
         returned. Use +Model.find(:first, *args)+ or its shortcut
         +Model.first(*args)+.

     *   Find last - This will return the last record matched by the
         options used. These options can either be specific conditions
         or merely an order. If no record can be matched, +nil+ is
         returned. Use +Model.find(:last, *args)+ or its shortcut
         +Model.last(*args)+.

     *   Find all - This will return all the records matched by the
         options used. If no records are found, an empty array is
         returned. Use +Model.find(:all, *args)+ or its shortcut
         +Model.all(*args)+.

     All approaches accept an options hash as their last parameter.

     Parameters

     *   +:conditions+ - An SQL fragment like "administrator = 1", +[
         "user_name = ?", username ]+, or +["user_name = :user_name", {
         :user_name =&gt; user_name }]+. See conditions in the intro.

     *   +:order+ - An SQL fragment like "created_at DESC, name".

     *   +:group+ - An attribute name by which the result should be
         grouped. Uses the +GROUP BY+ SQL-clause.

     *   +:having+ - Combined with +:group+ this can be used to filter
         the records that a +GROUP BY+ returns. Uses the +HAVING+
         SQL-clause.

     *   +:limit+ - An integer determining the limit on the number of
         rows that should be returned.

     *   +:offset+ - An integer determining the offset from where the
         rows should be fetched. So at 5, it would skip rows 0 through
         4.

     *   +:joins+ - Either an SQL fragment for additional joins like
         "LEFT JOIN comments ON comments.post_id = id" (rarely needed),
         named associations in the same form used for the +:include+
         option, which will perform an +INNER JOIN+ on the associated
         table(s), or an array containing a mixture of both strings and
         named associations. If the value is a string, then the records
         will be returned read-only since they will have attributes that
         do not correspond to the table's columns. Pass +:readonly =&gt;
         false+ to override.

     *   +:include+ - Names associations that should be loaded
         alongside. The symbols named refer to already defined
         associations. See eager loading under Associations.

     *   +:select+ - By default, this is "*" as in "SELECT * FROM", but
         can be changed if you, for example, want to do a join but not
         include the joined columns. Takes a string with the SELECT SQL
         fragment (e.g. "id, name").

     *   +:from+ - By default, this is the table name of the class, but
         can be changed to an alternate table name (or even the name of
         a database view).

     *   +:readonly+ - Mark the returned records read-only so they
         cannot be saved or updated.

     *   +:lock+ - An SQL fragment like "FOR UPDATE" or "LOCK IN SHARE
         MODE". +:lock =&gt; true+ gives connection's default exclusive
         lock, usually "FOR UPDATE".

     Examples

       # find by id
       Person.find(1)       # returns the object for ID = 1
       Person.find(1, 2, 6) # returns an array for objects with IDs in (1, 2, 6)
       Person.find([7, 17]) # returns an array for objects with IDs in (7, 17)
       Person.find([1])     # returns an array for the object with ID = 1
       Person.find(1, :conditions =&gt; "administrator = 1", :order =&gt; "created_on DE
SC")

     Note that returned records may not be in the same order as the ids
     you provide since database rows are unordered. Give an explicit
     +:order+ to ensure the results are sorted.

     Examples

       # find first
       Person.find(:first) # returns the first object fetched by SELECT * FROM peo
ple
       Person.find(:first, :conditions =&gt; [ "user_name = ?", user_name])
       Person.find(:first, :conditions =&gt; [ "user_name = :u", { :u =&gt; user_name }]
)
       Person.find(:first, :order =&gt; "created_on DESC", :offset =&gt; 5)
     
       # find last
       Person.find(:last) # returns the last object fetched by SELECT * FROM peopl
e
       Person.find(:last, :conditions =&gt; [ "user_name = ?", user_name])
       Person.find(:last, :order =&gt; "created_on DESC", :offset =&gt; 5)
     
       # find all
       Person.find(:all) # returns an array of objects for all the rows fetched by
 SELECT * FROM people
       Person.find(:all, :conditions =&gt; [ "category IN (?)", categories], :limit =
&gt; 50)
       Person.find(:all, :conditions =&gt; { :friends =&gt; ["Bob", "Steve", "Fred"] }
       Person.find(:all, :offset =&gt; 10, :limit =&gt; 10)
       Person.find(:all, :include =&gt; [ :account, :friends ])
       Person.find(:all, :group =&gt; "category")

     Example for find with a lock: Imagine two concurrent transactions:
     each will read +person.visits == 2+, add 1 to it, and save,
     resulting in two saves of +person.visits = 3+. By locking the row,
     the second transaction has to wait until the first is finished; we
     get the expected +person.visits == 4+.

       Person.transaction do
         person = Person.find(1, :lock =&gt; true)
         person.visits += 1
         person.save!
       end

sw@debian:~/sandbox$ </screen></para>

        <section>
          <title>Such-Beispiele</title>

          <para>Im folgenden werde ich per Fragen und Antwort ein
          Beispielprobleme mit <methodname>find</methodname> lösen.</para>

          <para><qandaset>
              <qandadiv>
                <qandaentry>
                  <question>
                    <para>Wie kann ich alle in der Datenbank enthaltenen Filme
                    in das Objekt mit dem Namen <varname>alle_filme</varname>
                    speichern?</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>alle_filme = Dvd.all</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 4, title: "Rain Man", production_year: 1988, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 5, title: "War of the Worlds", production_year: 2005, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 6, title: "Collateral", production_year: 2004, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 7, title: "Miami Vice", production_year: 2006, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 9, title: "The Aviator", production_year: 2004, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 10, title: "Some Like It Hot", production_year: 1959, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;]
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie finde ich den ersten Film in der
                    Datenbank?</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>Dvd.find(:first)</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 04:55:02", updated_at: "2009-12-25 04:55:02"&gt;
&gt;&gt;</screen>Oder noch kürzer mit der Methode
                    <methodname>first</methodname>.<screen>&gt;&gt; <command>Dvd.first</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 04:55:02", updated_at: "2009-12-25 04:55:02"&gt;
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie kann ich alle Filme die im Jahr 1984 produziert
                    wurden suchen?</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>Dvd.find_all_by_production_year(1984)</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 04:55:02", updated_at: "2009-12-25 04:55:02"&gt;]
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Wie finde ich die Anzahl der im Jahr 1984
                    produzierten Filme raus?</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>Dvd.find_all_by_production_year(1984).count</command>
=&gt; 1
&gt;&gt; <command>Dvd.find_all_by_production_year(1984).count.class</command>
=&gt; Fixnum
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Ein Freund fragt mich nach einer Liste aller DVDs
                    die Filme aus dem Jahr 2008 enthalten. Er hätte die
                    Ausgabe gerne im YAML Format.</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>alle_2008er_5_sterne_dvds = Dvd.find_all_by_production_year_and_rating(2008,5)</command>
=&gt; [#&lt;Dvd id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;]
&gt;&gt; <command>puts alle_2008er_5_sterne_dvds.to_yaml</command>
--- 
- !ruby/object:Dvd 
  attributes: 
    id: "12"
    title: Iron Man
    production_year: "2008"
    duration: 
    plot: 
    rating: "5"
    created_at: 2009-12-25 05:13:53
    updated_at: 2009-12-25 05:13:53
  attributes_cache: {}

- !ruby/object:Dvd 
  attributes: 
    id: "13"
    title: The Dark Knight
    production_year: "2008"
    duration: 
    plot: 
    rating: "5"
    created_at: 2009-12-25 05:13:53
    updated_at: 2009-12-25 05:13:53
  attributes_cache: {}

=&gt; nil
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Alle 2008er Filme, alphabetisch nach Titeln
                    sortiert.</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>Dvd.find_all_by_production_year(2008, :order =&gt; :title)</command>
=&gt; [#&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;]
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>

                <qandaentry>
                  <question>
                    <para>Die find Methode an sich reicht mich nicht. Ich
                    möchte auch noch selbst SQL einbauen. Wie kann ich nach
                    allen Filmen suchen, die im Titel das Wort 'Terminator'
                    enthalten.</para>
                  </question>

                  <answer>
                    <para><screen>&gt;&gt; <command>Dvd.find(:all, :conditions =&gt; [ "title LIKE ?", '%Terminator%' ])</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;, #&lt;Dvd id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;]
&gt;&gt;</screen></para>
                  </answer>
                </qandaentry>
              </qandadiv>
            </qandaset></para>
        </section>
      </section>
    </section>

    <section xml:id="datensatz-loeschen">
      <title>Einen Datensatz löschen</title>

      <para>Es gibt die Methoden <methodname>delete</methodname> und
      <methodname>destroy</methodname>, um Datensätze zu löschen.</para>

      <section>
        <title>delete</title>

        <para>Mit delete können Sie einen Datensatz löschen. Dabei werden
        allerdings keine Abhängigkeiten zu anderen Datensätzen beachtet.
        Delete löscht also nur die eine Zeile in der Datenbank und sonst
        nichts.<note>
            <para>Für unseren jetzigen Kenntnisstand sind solche Abhänigkeiten
            noch egal, aber in ein paar Seiten werden wir verschiedene
            Tabellen mit einander verknüpfen und dann wird es entsprechende
            Abhängigkeiten geben.</para>
          </note> Die Instance wird nach dem Löschen des Datenbankfeldes
        ge-freeze-st. Sie ist also noch da, kann aber nicht verändert
        werden.</para>

        <para>Beispiel:<screen>&gt;&gt; <command>Dvd.find_by_title('Hancock')</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;
&gt;&gt; <command>hancock = Dvd.find_by_title('Hancock')</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;
&gt;&gt; <command>hancock.delete</command>        # Das Feld in der DB wird geloescht.
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;
&gt;&gt; <command>Dvd.find_by_title('Hancock')</command>
=&gt; nil                   # Eine Suche bringt kein Ergebnis mehr.
&gt;&gt; <command>hancock</command>               # Die Instance ist ge-freeze-st.
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 05:13:53", updated_at: "2009-12-25 05:13:53"&gt;
</screen></para>
      </section>

      <section>
        <title>destroy</title>

        <para>Mit <methodname>destroy</methodname> können Sie einen Datensatz
        löschen und dabei werden auch evt. vorhandene Abhängigkeiten beachtet
        (solche Abhängikeiten betrachten wir später). Vereinfacht kann man
        sagen: "Lieber destroy nehmen, das ist sicherer, weil das Rails-System
        dann mehr mitdenkt."</para>

        <para>Beispiel:<screen>&gt;&gt; <command>Dvd.find_by_title('Hancock')</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 06:03:15", updated_at: "2009-12-25 06:03:15"&gt;
&gt;&gt; <command>hancock = Dvd.find_by_title('Hancock')</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 06:03:15", updated_at: "2009-12-25 06:03:15"&gt;
&gt;&gt; <command>hancock.destroy</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 06:03:15", updated_at: "2009-12-25 06:03:15"&gt;
&gt;&gt; <command>Dvd.find_by_title('Hancock')</command>
=&gt; nil
&gt;&gt; <command>hancock</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 06:03:15", updated_at: "2009-12-25 06:03:15"&gt;
&gt;&gt;</screen></para>
      </section>
    </section>

    <section xml:id="datensatz-editieren">
      <title>Einen Datensatz editieren</title>

      <para>Das Verändern eines Datensatzes erfolgt in zwei
      Schritten:<orderedlist>
          <listitem>
            <para>Suche des Datensatzes und erstellen einer entsprechenden
            Instance.</para>
          </listitem>

          <listitem>
            <para>Verändern der Werte.</para>
          </listitem>

          <listitem>
            <para>Abspeichern des Datensatzes mit der Methode
            <methodname>save</methodname>.</para>
          </listitem>
        </orderedlist></para>

      <para>Beispiel:<screen>&gt;&gt; <command>hancock = Dvd.find_by_title('Hancock')</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 06:11:13", updated_at: "2009-12-25 06:11:13"&gt;
&gt;&gt; <command>hancock.rating = 3</command>
=&gt; 3
&gt;&gt; <command>hancock.save</command>
=&gt; true
&gt;&gt; <command>Dvd.find_by_title('Hancock')</command>
=&gt; #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 3, created_at: "2009-12-25 06:11:13", updated_at: "2009-12-25 06:11:51"&gt;
&gt;&gt;</screen></para>

      <section>
        <title>Locking</title>

        <para>Per Default benutzt Rails Optimistisches Locking der Datensätze.
        Dies kann aber umgeschaltet werden. Da für die meisten User
        Optimistisches Locking optimal ist und viele vor diesem Absatz nicht
        mal über das Problem nachgedacht haben, werde ich nicht weiter drauf
        eingehen, sondern auf die ri Hilfe verweisen. Wer pessimistisches
        Locking benötigt, der findet dort die notwendigen Schalter.</para>

        <para><screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveRecord::Locking::Optimistic</command>
------------------------------- Class: ActiveRecord::Locking::Optimistic

What is Optimistic Locking
--------------------------

     Optimistic locking allows multiple users to access the same record
     for edits, and assumes a minimum of conflicts with the data. It
     does this by checking whether another process has made changes to a
     record since it was opened, an ActiveRecord::StaleObjectError is
     thrown if that has occurred and the update is ignored.

     Check out ActiveRecord::Locking::Pessimistic for an alternative.


Usage
-----

     Active Records support optimistic locking if the field
     +lock_version+ is present. Each update to the record increments the
     lock_version column and the locking facilities ensure that records
     instantiated twice will let the last one saved raise a
     StaleObjectError if the first was also updated. Example:

       p1 = Person.find(1)
       p2 = Person.find(1)
     
       p1.first_name = "Michael"
       p1.save
     
       p2.first_name = "should fail"
       p2.save # Raises a ActiveRecord::StaleObjectError

     You're then responsible for dealing with the conflict by rescuing
     the exception and either rolling back, merging, or otherwise apply
     the business logic needed to resolve the conflict.

     You must ensure that your database schema defaults the lock_version
     column to 0.

     This behavior can be turned off by setting
     +ActiveRecord::Base.lock_optimistically = false+. To override the
     name of the lock_version column, invoke the +set_locking_column+
     method. This method uses the same syntax as +set_table_name+

------------------------------------------------------------------------
sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>
  </section>

  <section xml:id="workflow-in-rails">
    <title>Workflow innerhalb Rails</title>

    <para>Jetzt können wir eine Tabelle anlegen und auf diese via HTTP und via
    der Console zugreifen. Jetzt schauen wir uns mal an, was bei einer
    HTTP-Anfrage passiert und welchen Weg diese Anfrage geht.</para>

    <section xml:id="dvd-show-html">
      <title>Beispiel dvds/show/1</title>

      <para>Nehmen wir an, ein User ruft die URL
      <uri>http://localhost:3000/dvds/show/1</uri> auf.<note>
          <para>Die beiden URLs <uri>http://localhost:3000/dvds/show/1</uri>
          und <uri>http://localhost:3000/dvds/1</uri> zeigen das gleiche
          Ergebnis an. Ich habe hier die längere Variante benutzt, um das
          Beispiel logischer zu gestalten.</para>
        </note></para>

      <section>
        <title>Routing</title>

        <para>Kommt ein Aufruf per HTTP rein, so wird die URL durch eine
        Routing-Engine verarbeitet. Diese wird durch die Datei
        <filename>config/routes.rb</filename> konfiguriert. Schauen wir mal
        rein:<screen>sw@debian:~/dvd-sammlung$ cat -n config/routes.rb 
     1 ActionController::Routing::Routes.draw do |map|
     2   map.resources :dvds
     3 
     4   # The priority is based upon order of creation: first created -&gt; highest priority.
     5 
     6   # Sample of regular route:
     7   #   map.connect 'products/:id', :controller =&gt; 'catalog', :action =&gt; 'view'
     8   # Keep in mind you can assign values other than :controller and :action
     9 
    10   # Sample of named route:
    11   #   map.purchase 'products/:id/purchase', :controller =&gt; 'catalog', :action =&gt; 'purchase'
    12   # This route can be invoked with purchase_url(:id =&gt; product.id)
    13 
    14   # Sample resource route (maps HTTP verbs to controller actions automatically):
    15   #   map.resources :products
    16 
    17   # Sample resource route with options:
    18   #   map.resources :products, :member =&gt; { :short =&gt; :get, :toggle =&gt; :post }, :collection =&gt; { :sold =&gt; :get }
    19 
    20   # Sample resource route with sub-resources:
    21   #   map.resources :products, :has_many =&gt; [ :comments, :sales ], :has_one =&gt; :seller
    22   
    23   # Sample resource route with more complex sub-resources
    24   #   map.resources :products do |products|
    25   #     products.resources :comments
    26   #     products.resources :sales, :collection =&gt; { :recent =&gt; :get }
    27   #   end
    28 
    29   # Sample resource route within a namespace:
    30   #   map.namespace :admin do |admin|
    31   #     # Directs /admin/products/* to Admin::ProductsController (app/controllers/admin/products_controller.rb)
    32   #     admin.resources :products
    33   #   end
    34 
    35   # You can have the root of your site routed with map.root -- just remember to delete public/index.html.
    36   # map.root :controller =&gt; "welcome"
    37 
    38   # See how all your routes lay out with "rake routes"
    39 
    40   # Install the default routes as the lowest priority.
    41   # Note: These default routes make all actions in every controller accessible via GET requests. You should
    42   # consider removing or commenting them out if you're using named routes and resources.
    43   map.connect ':controller/:action/:id'
    44   map.connect ':controller/:action/:id.:format'
    45 end
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Die Zeile 4 sagt aus, das die Priorität einer Route anhand ihrer
        Position in dieser Datei bestimmt wird. Es können also mehrere Regeln
        auf die gleiche Route matchen. Die am weitesten oben stehende gewinnt
        dann.</para>

        <para>In der Zeile 2 steht eine für unsere Anfrage wichtige
        Zeile:<programlisting>map.resources :dvds</programlisting></para>

        <para>Dummerweise steht aber nicht viel mehr dazu da (mal abgesehen
        von Zeile 14 und 15). Bemühen wir mal <application>ri</application> um
        Aufklärung:<screen xml:id="ri_ActionController_Resources.resource">sw@debian:~/dvd-sammlung$ <command>ri ActionController::Resources.resource</command>
----------------------------------- ActionController::Resources#resource
     resource(*entities, &amp;block)

     From gem actionpack-2.3.5
------------------------------------------------------------------------
     Creates named routes for implementing verb-oriented controllers for
     a singleton \resource. A singleton \resource is global to its
     current context. For unnested singleton \resources, the \resource
     is global to the current user visiting the application, such as a
     user's +/account+ profile. For nested singleton \resources, the
     \resource is global to its parent \resource, such as a +projects+
     \resource that +has_one :project_manager+. The +project_manager+
     should be mapped as a singleton \resource under +projects+:

       map.resources :projects do |project|
         project.resource :project_manager
       end

     See +resources+ for general conventions. These are the main
     differences:

     *   A singular name is given to +map.resource+. The default
         controller name is still taken from the plural name.

     *   To specify a custom plural name, use the +:plural+ option.
         There is no +:singular+ option.

     *   No default index route is created for the singleton \resource
         controller.

     *   When nesting singleton \resources, only the singular name is
         used as the path prefix (example: 'account/messages/1')

     For example:

       map.resource :account

     maps these actions in the Accounts controller:

       class AccountsController &lt; ActionController::Base
         # GET new_account_url
         def new
           # return an HTML form for describing the new account
         end
     
         # POST account_url
         def create
           # create an account
         end
     
         # GET account_url
         def show
           # find and return the account
         end
     
         # GET edit_account_url
         def edit
           # return an HTML form for editing the account
         end
     
         # PUT account_url
         def update
           # find and update the account
         end
     
         # DELETE account_url
         def destroy
           # delete the account
         end
       end

     Along with the routes themselves, +resource+ generates named routes
     for use in controllers and views. +map.resource :account+ produces
     these named routes and helpers:

       Named Route   Helpers
       ============  =============================================
       account       account_url, hash_for_account_url,
                     account_path, hash_for_account_path
     
       new_account   new_account_url, hash_for_new_account_url,
                     new_account_path, hash_for_new_account_path
     
       edit_account  edit_account_url, hash_for_edit_account_url,
                     edit_account_path, hash_for_edit_account_path

sw@debian:~/dvd-sammlung$</screen></para>

        <para>Die Zeile <programlisting>map.resources :dvds</programlisting>sorgt
        dafür das automagisch die Anfragen mit der RESTful Logik an die
        Methoden <methodname>index</methodname>,
        <methodname>show</methodname>, <methodname>new</methodname>,
        <methodname>edit</methodname>, <methodname>create</methodname>,
        <methodname>update</methodname> und <methodname>destroy</methodname>
        der Class <classname>DvdsController</classname> weitergeleitet werden.
        Diese Class wird in der Datei
        <filename>app/controllers/dvds_controller.rb</filename> definiert.
        Schauen wir mal rein, was da bei der Methode
        <methodname>show</methodname> steht:<programlisting>  # GET /dvds/1
  # GET /dvds/1.xml
  def show
    @dvd = Dvd.find(params[:id])

    respond_to do |format|      
      format.html # show.html.erb
      format.xml  { render :xml =&gt; @dvd }
    end
  end</programlisting></para>

        <para>Direkt am Anfang wird die Instance-Variable
        <varname>@dvd</varname> mit dem Ergebnis der Suche nach einer ID
        gefüllt (<code>Dvd.find(params[:id])</code>).</para>

        <para>hmmmm... was hat es mit diesem Hash <varname>params[]</varname>
        auf sich? Machen wir mal testweise die Abfrage mit dem
        Webbrowser:<screen>sw@debian:~$ <command>w3m -dump http://0.0.0.0:3000/dvds/show/1</command>
Received cookie: _dvd-sammlung_session=BAh7BjoPc2Vzc2lvbl9pZCIlODgwZDU5ZjVmNzVkMzkzY2ExM2I3M2MxMGUwOWMxMDE%3D--5cf65da6c88441a14feed1d6d141bf4818eeceed
Title: The Terminator

Production year: 1984

Duration: 120

Plot:

Rating: 5

Edit | Back
sw@debian:~$</screen></para>

        <para>Und gleichzeitig schauen wir uns die Log-Ausgabe des Webservers
        an:<screen>Processing DvdsController#show (for 127.0.0.1 at 2009-12-25 10:46:33) [GET]
  Parameters: {"id"=&gt;"1"}
  Dvd Load (0.3ms)   SELECT * FROM "dvds" WHERE ("dvds"."id" = 1) 
Rendering template within layouts/dvds
Rendering dvds/show
Completed in 166ms (View: 159, DB: 0) | 200 OK [http://0.0.0.0/dvds/show/1]
</screen></para>

        <para>Da wird auf den Controller <classname>DvdsController</classname>
        und dort auf die Methode <methodname>show</methodname> verwiesen.
        Gleichzeitig wird ein Hash mit dem Namen <varname>params[]</varname>
        generiert und dort <varname>params[:id]</varname> auf 1 gesetzt.
        Schauen Sie sich bitte noch mal die Datei
        <filename>config/routes.rb</filename> an. Dort wird es an dem Beispiel
        in der Zeile 43 klar:<programlisting>map.connect ':controller/:action/:id'</programlisting></para>

        <para>Die per regular Expression in der
        <filename>config/routes.rb</filename> Datei gesetzten Routen füllen
        automatisch das <varname>params[]</varname>-Hash. Und damit wiederum
        können wir in der Methode show den entsprechenden Datensatz
        finden:<programlisting>@dvd = Dvd.find(params[:id])</programlisting></para>

        <para>Danach wird überprüft, ob es sich um eine
        <filename>.html</filename> oder <filename>.xml</filename> Anfrage
        gehandelt hat. Wurde vom Browser nur <filename>1</filename> und nicht
        <filename>1.html</filename> abgefragt, setzt Rails den Default auf
        <filename>.html</filename>.</para>

        <para>Was passiert als nächstes? Denken wir noch mal über das
        MCV-Model nach. Wir haben schon das Model
        (<methodname>dvds</methodname>) und wir haben den Controller
        (<classname>DvdsController</classname>). Was noch fehlt ist der View -
        also die Darstellung der Webseite. Die Views für unser Model finden
        sich alle im Unterverzeichnis
        <filename>app/view/dvds</filename><screen>sw@debian:~/dvd-sammlung$ <command>ls app/views/dvds/</command>
edit.html.erb  index.html.erb  new.html.erb  show.html.erb
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Schauen wir uns mal die Datei <filename>show.html.erb</filename>
        an:<programlisting>&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%=h @dvd.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Production year:&lt;/b&gt;
  &lt;%=h @dvd.production_year %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Duration:&lt;/b&gt;
  &lt;%=h @dvd.duration %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Plot:&lt;/b&gt;
  &lt;%=h @dvd.plot %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Rating:&lt;/b&gt;
  &lt;%=h @dvd.rating %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_dvd_path(@dvd) %&gt; |
&lt;%= link_to 'Back', dvds_path %&gt;
</programlisting></para>

        <para>Die HTML-Elemente sind klar. Und die <code>&lt;%= ...
        %&gt;</code> Elemente enthalten Ruby-Code. Wenn ein solches Element
        mit <code>&lt;%=</code> anfängt, dann bedeutet das "Gib das Ergebnis
        an dieser Stelle aus.". Wenn ein Element mit <code>&lt;%-</code>
        anfängt, dann wird der Ruby-Code ausgeführt, aber es wird nichts
        ausgegeben.</para>

        <para>Die ganze erb-Datei ist also eine Mischung zwischen
        HTML-Elementen und Ruby-Code. Damit hat sie Ähnlichkeiten zu
        PHP-Seiten.</para>

        <para>Das <code>h</code> hinter <code>&lt;%=</code> bedeuted, das die
        Ausgabe escaped werden soll, um sicher zu stellen, das nicht
        automatisch böse Java-Scripts oder ähnliches gestartet wird (wir
        wissen an dieser Stelle ja nicht, was in der Datenbank steht).</para>

        <para>Ist Ihnen aufgefallen, das bei dieser erb-Datei ja wichtige
        HTML-Elemente fehlen? Die sind in der Datei
        <filename>app/views/layouts/dvds.html.erb</filename><programlisting>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
       "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;

&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"&gt;
&lt;head&gt;
  &lt;meta http-equiv="content-type" content="text/html;charset=UTF-8" /&gt;
  &lt;title&gt;Dvds: &lt;%= controller.action_name %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag 'scaffold' %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p style="color: green"&gt;&lt;%= flash[:notice] %&gt;&lt;/p&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</programlisting></para>

        <para>Das ist der Rahmen für alle Views des Models
        <varname>dvds</varname>. Da es oft keinen Sinn macht für jedes Model
        ein eigenes Grundlayout zu generieren, kann man diese Datei auch
        löschen und stattdessen eine Datei
        <filename>app/views/layouts/application.html.erb</filename> mit dem
        Grundlayout erstellen. Die gilt dann für die gesamte
        Rails-Application. Die Zeile <code>&lt;%= yield %&gt;</code> wird
        dabei immer von der aufzurufenden View-Datei ersetzt.</para>
      </section>
    </section>

    <section xml:id="dvd-index-html">
      <title>Beispiel /dvds (Index aller Datensätze)</title>

      <para>Da der Grundweg im letzten Segment erklärt wurde, gehe ich jetzt
      auf die schnelle durch die Anfrage
      <uri>http://localhost:3000/dvds</uri></para>

      <para>Erst mal das Ergebnis des Webbrowser-Aufrufs:<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlYzViZWZkOWY4OWEzNTM0ZjdiNmZiYjJmODMzOTA1MmU6EF9jc3JmX3Rva2VuSSIxV1h4bUljZ0EyMnc3bld4WThyeExpekpCRjRQZDdvUVliSWVXUENmVU5Wcz0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--08b823e340bf0d62bf1725a23a9e5a041d914013
Listing dvds

       Title         Production year Duration Plot Rating
The Terminator       1984                                 Show Edit Destroy
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy
Rain Man             1988                          5      Show Edit Destroy
War of the Worlds    2005                          4      Show Edit Destroy
Collateral           2004                          5      Show Edit Destroy
Miami Vice           2006                          5      Show Edit Destroy
Hancock              2008                          4      Show Edit Destroy
The Aviator          2004                          4      Show Edit Destroy
Some Like It Hot     1959                          5      Show Edit Destroy
W.                   2008                          4      Show Edit Destroy
Iron Man             2008                          5      Show Edit Destroy
The Dark Knight      2008                          5      Show Edit Destroy


New dvd
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Die Anfrage wird in der <filename>config/routes.rb</filename> mit
      der kleinen aber mächtigen Regel für diese Resource gehandelt:
      <programlisting>map.resources :dvds</programlisting>Es geht also zu der
      Methode <methodname>index</methodname> der Class
      <classname>DvdsController</classname>. Diese Class wird in der Datei
      <filename>app/controllers/dvds_controller.rb</filename> definiert.
      Schauen wir mal rein, was da bei der Methode
      <methodname>index</methodname> steht:<programlisting>  # GET /dvds
  # GET /dvds.xml
  def index
    @dvds = Dvd.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @dvds }
    end
  end
</programlisting></para>

      <para>In der Instance-Variable <varname>@dvds</varname> wird diesmal ein
      Array aus allen Datensätze die mit Dvd.all angezeigt werden gespeichert.
      Da es sich um eine html-Anfrage handelt wird als nächstes der View
      <filename>app/views/dvds/index.html.erb</filename> gerendert. Ein Blick
      in die erb-Datei:<screen>sw@debian:~/dvd-sammlung$ <command>cat -n app/views/dvds/index.html.erb</command>
     1 &lt;h1&gt;Listing dvds&lt;/h1&gt;
     2 
     3 &lt;table&gt;
     4   &lt;tr&gt;
     5     &lt;th&gt;Title&lt;/th&gt;
     6     &lt;th&gt;Production year&lt;/th&gt;
     7     &lt;th&gt;Duration&lt;/th&gt;
     8     &lt;th&gt;Plot&lt;/th&gt;
     9     &lt;th&gt;Rating&lt;/th&gt;
    10   &lt;/tr&gt;
    11 
    12 &lt;% @dvds.each do |dvd| %&gt;
    13   &lt;tr&gt;
    14     &lt;td&gt;&lt;%=h dvd.title %&gt;&lt;/td&gt;
    15     &lt;td&gt;&lt;%=h dvd.production_year %&gt;&lt;/td&gt;
    16     &lt;td&gt;&lt;%=h dvd.duration %&gt;&lt;/td&gt;
    17     &lt;td&gt;&lt;%=h dvd.plot %&gt;&lt;/td&gt;
    18     &lt;td&gt;&lt;%=h dvd.rating %&gt;&lt;/td&gt;
    19     &lt;td&gt;&lt;%= link_to 'Show', dvd %&gt;&lt;/td&gt;
    20     &lt;td&gt;&lt;%= link_to 'Edit', edit_dvd_path(dvd) %&gt;&lt;/td&gt;
    21     &lt;td&gt;&lt;%= link_to 'Destroy', dvd, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
    22   &lt;/tr&gt;
    23 &lt;% end %&gt;
    24 &lt;/table&gt;
    25 
    26 &lt;br /&gt;
    27 
    28 &lt;%= link_to 'New dvd', new_dvd_path %&gt;</screen></para>

      <para>In der Zeile 12 wird mit der Iternator-Methode
      <methodname>each</methodname> das Array <varname>@dvds</varname> Eintrag
      für Eintrag angezeigt. Jeder Eintrag wird dann für den Block in der
      lokalen Variable <varname>dvd</varname> gespeichert und die wird dann in
      den Zeilen 14 bis 18 dazu benutzt den Inhalt des Eintrages
      darzustellen.</para>

      <section>
        <title>link_to und UrlWriter</title>

        <para>Was hat es mit <code>link_to</code> in den Zeilen 19 bis 21 auf
        sich? Probieren wir es doch mal in der Console aus. Dazu müssen wir
        als erstes die <classname>ActionController::UrlWriter</classname>
        Class includieren (das passiert im View automatisch im Hintergrund)
        und können dann mal den Block im kleinen nachstellen.<note>
            <para>Mit <command>helper</command> können Sie in der Rails
            Console Ausgaben von Helpern ausgeben. Mehr zum Thema Helper
            gleich.</para>
          </note><screen>&gt;&gt; <command>include ActionController::UrlWriter</command>
=&gt; Object
&gt;&gt; <command>@dvds = Dvd.all</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 3, title: "Terminator Salvation", production_year: 2009, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 4, title: "Rain Man", production_year: 1988, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 5, title: "War of the Worlds", production_year: 2005, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 6, title: "Collateral", production_year: 2004, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 7, title: "Miami Vice", production_year: 2006, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 8, title: "Hancock", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 9, title: "The Aviator", production_year: 2004, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 10, title: "Some Like It Hot", production_year: 1959, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 11, title: "W.", production_year: 2008, duration: nil, plot: nil, rating: 4, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 12, title: "Iron Man", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;, #&lt;Dvd id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;]
&gt;&gt; <command>@dvds.each do |dvd|</command>
?&gt; <command>puts helper.edit_dvd_path(dvd)</command>
&gt;&gt; <command>end</command>
/dvds/1/edit
/dvds/2/edit
/dvds/3/edit
/dvds/4/edit
/dvds/5/edit
/dvds/6/edit
/dvds/7/edit
/dvds/8/edit
/dvds/9/edit
/dvds/10/edit
/dvds/11/edit
/dvds/12/edit
/dvds/13/edit
=&gt;</screen></para>

        <para><code>edit_dvd_path(Dvd.first)</code> gibt also den URL-Pfad für
        die Edit-Seite der ersten DVD an:<screen>sw@debian:~/dvd-sammlung$ <command>./script/console</command> 
Loading development environment (Rails 2.3.5)
&gt;&gt; <command>include ActionController::UrlWriter</command>
=&gt; Object
&gt;&gt; <command>edit_dvd_path(Dvd.first)</command>
=&gt; "/dvds/1/edit"
&gt;&gt; <command>exit</command>
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Schauen Sie sich bitte noch mal die letzten Zeilen aus der Hilfe
        <classname>ActionController::Resources.recource</classname> an: <xref
        linkend="ri_ActionController_Resources.resource" /></para>

        <para>Dort steht in den letzten Zeilen:<screen>     Along with the routes themselves, +resource+ generates named routes
     for use in controllers and views. +map.resource :account+ produces
     these named routes and helpers:

       Named Route   Helpers
       ============  =============================================
       account       account_url, hash_for_account_url,
                     account_path, hash_for_account_path
     
       new_account   new_account_url, hash_for_new_account_url,
                     new_account_path, hash_for_new_account_path
     
       edit_account  edit_account_url, hash_for_edit_account_url,
                     edit_account_path, hash_for_edit_account_path
</screen></para>

        <para>Rails legt also für die wichtigen URLs automatisch diese Helper
        an. Aber warum soll man sich damit rumschlagen? Ich weiß ja, wie die
        URL heißt. Da könnte ich es ja auch direkt wie folgt
        angeben:<programlisting>link_to 'Edit', '/dvds/'+dvd.id.to_s+'/edit'</programlisting></para>

        <para>Abgesehen davon, das es nicht so sauber aussieht wie
        <code>edit_dvd_path(dvd)</code> ist der Hauptgrund in der Möglichkeit
        diesen Pfad in der <filename>config.routes.rb</filename> ändern zu
        können, ohne den Rest der Application anzufassen.</para>

        <section>
          <title>Beispiel für geänderte Routen</title>

          <para>Nehmen wir mal an, das wir in Zukunft nicht nur DVDs, sondern
          auch CDs und BlueRays in jeweils eigenen Datenbanken und Controllern
          halten wollen. Trotzdem sollte alles von aussen per logischer URL
          erreichbar sein. Dann könnten wir die Route für die DVDs in der
          <filename>config/routes.rb</filename> wie folgt
          ändern:<programlisting>map.resources :dvds, :path_prefix =&gt; 'medien'
</programlisting></para>

          <para>Jetzt bekommen wir mit den obigen Helpern die neuen und
          richtigen URLs angezeigt:<screen>sw@debian:~/dvd-sammlung$ <command>./script/console</command> 
Loading development environment (Rails 2.3.5)
&gt;&gt; <command>include ActionController::UrlWriter</command>
=&gt; Object
&gt;&gt; <command>dvd = Dvd.last</command>
=&gt; #&lt;Dvd id: 13, title: "The Dark Knight", production_year: 2008, duration: nil, plot: nil, rating: 5, created_at: "2009-12-25 12:15:21", updated_at: "2009-12-25 12:15:21"&gt;
&gt;&gt; <command>helper.link_to 'Show', dvd</command>
=&gt; "&lt;a href=\"/medien/dvds/13\"&gt;Show&lt;/a&gt;"
&gt;&gt; <command>helper.link_to 'Edit', edit_dvd_path(dvd)</command>
=&gt; "&lt;a href=\"/medien/dvds/13/edit\"&gt;Edit&lt;/a&gt;"
&gt;&gt; <command>exit</command>
sw@debian:~/dvd-sammlung$</screen></para>

          <para>Obwohl Sie nichts an Ihren Views verändert haben, werden die
          richtigen neuen URL benutzt.</para>
        </section>
      </section>
    </section>
  </section>

  <section xml:id="helper">
    <title>Helper</title>

    <para>Wer schon mal einen Blick in das <filename>app</filename>
    Verzeichnis geworfen hat, wird dort folgendes gesehen haben:<screen>sw@debian:~/dvd-sammlung$ <command>ls app/</command>
controllers  helpers  models  views
sw@debian:~/dvd-sammlung$</screen></para>

    <para>Was Controller, Models und Views sind, haben wir mittlerweile
    besprochen. - Ja, ja, ... bis es wirklich in Fleisch und Blut übergeht
    braucht es noch ein paar Übungen, aber wir sind ja auch erst am Anfang. -
    Was aber hat es mit den Helpers auf sich?</para>

    <para>Im Helper-Verzeichnis sind zwei Daten:<screen>sw@debian:~/dvd-sammlung$ <command>ls app/helpers/</command>
application_helper.rb  dvds_helper.rb
sw@debian:~/dvd-sammlung$ </screen></para>

    <para>Der Default-Inhalt ist auch nicht gerade vielsagend:<screen>sw@debian:~/dvd-sammlung$ <command>cat app/helpers/application_helper.rb </command>
# Methods added to this helper will be available to all templates in the application.
module ApplicationHelper
end
sw@debian:~/dvd-sammlung$ <command>cat app/helpers/dvds_helper.rb</command> 
module DvdsHelper
end
sw@debian:~/dvd-sammlung$</screen></para>

    <para>Ich lös das Rätsel mal auf: Helper sind Methoden, die
    Programmierlogik aus dem View raushalten sollen. Allgemein gilt ja die
    Annahme, das das Layout einer Webseite auch von Nicht-Programmiern
    erstellt werden kann. Helper sind da sehr praktisch. Zusätzlich
    erleichtern Sie es uns den Code weiter aufzuräumen und besser zu
    strukturieren.</para>

    <section xml:id="dvd-sterne-helper">
      <title>Beispiel Film-Bewertung</title>

      <para>Aktuell sieht unsere DVD-Index-Seite so aus:<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlYzViZWZkOWY4OWEzNTM0ZjdiNmZiYjJmODMzOTA1MmU6EF9jc3JmX3Rva2VuSSIxV1h4bUljZ0EyMnc3bld4WThyeExpekpCRjRQZDdvUVliSWVXUENmVU5Wcz0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--08b823e340bf0d62bf1725a23a9e5a041d914013
Listing dvds

       Title         Production year Duration Plot Rating
The Terminator       1984                                 Show Edit Destroy
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy
Rain Man             1988                          5      Show Edit Destroy
War of the Worlds    2005                          4      Show Edit Destroy
Collateral           2004                          5      Show Edit Destroy
Miami Vice           2006                          5      Show Edit Destroy
Hancock              2008                          4      Show Edit Destroy
The Aviator          2004                          4      Show Edit Destroy
Some Like It Hot     1959                          5      Show Edit Destroy
W.                   2008                          4      Show Edit Destroy
Iron Man             2008                          5      Show Edit Destroy
The Dark Knight      2008                          5      Show Edit Destroy


New dvd
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Anstatt der Zahlen für das Rating der Filme, möchten wir gerne
      Sterne anzeigen. Das könnten wir in der Datei
      <filename>app/views/dvds/index.html.erb</filename>
      realisieren:<programlisting>&lt;h1&gt;Listing dvds&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Production year&lt;/th&gt;
    &lt;th&gt;Duration&lt;/th&gt;
    &lt;th&gt;Plot&lt;/th&gt;
    &lt;th&gt;Rating&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @dvds.each do |dvd| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%=h dvd.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=h dvd.production_year %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=h dvd.duration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=h dvd.plot %&gt;&lt;/td&gt;
    &lt;td&gt;
<emphasis>    &lt;%- stars = '' %&gt;
    &lt;%- dvd.rating.to_i.times { stars = stars + '*' } %&gt;
    &lt;%=h stars %&gt;</emphasis>
    &lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', dvd %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_dvd_path(dvd) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', dvd, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New dvd', new_dvd_path %&gt;
</programlisting></para>

      <para>Die fertige HTML-Seite sieht das so aus:<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlMWJjZDI4ZDVmYjUxNTBiZGE4NjZkZjkwNDAxNjU5Zjk6EF9jc3JmX3Rva2VuSSIxWnZNc2dsTFNGdmEzeTh4b3Bua1BTdUNwWTY0dnhZME51bmxUKyszOGkvVT0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--e432e5bdd136e5e38bc074fe0c6693dc2b818b0e
Listing dvds

       Title         Production year Duration Plot Rating
The Terminator       1984                                 Show Edit Destroy
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy
Rain Man             1988                          *****  Show Edit Destroy
War of the Worlds    2005                          ****   Show Edit Destroy
Collateral           2004                          *****  Show Edit Destroy
Miami Vice           2006                          *****  Show Edit Destroy
Hancock              2008                          ****   Show Edit Destroy
The Aviator          2004                          ****   Show Edit Destroy
Some Like It Hot     1959                          *****  Show Edit Destroy
W.                   2008                          ****   Show Edit Destroy
Iron Man             2008                          *****  Show Edit Destroy
The Dark Knight      2008                          *****  Show Edit Destroy


New dvd
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Dummerweise hat aber solche Art von Logik und Programmierung im
      View nichts zu suchen. Deshalb erstellen wir einen Helper
      <methodname>stars_for_rating</methodname> in der Datei
      <filename>app/helpers/dvds_helper.rb</filename>:<programlisting>module DvdsHelper

  # Zeigt das Rating nicht als Zahl sondern in Sternen an.
  #
  def stars_for_rating(rating)
    stars = ''
    rating.to_i.times { stars = stars + '*' }
    stars
  end

end
</programlisting></para>

      <para>Jetzt ändern wir noch die Datei
      <filename>app/views/dvds/index.html.erb</filename>:<programlisting>&lt;h1&gt;Listing dvds&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Production year&lt;/th&gt;
    &lt;th&gt;Duration&lt;/th&gt;
    &lt;th&gt;Plot&lt;/th&gt;
    &lt;th&gt;Rating&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @dvds.each do |dvd| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%=h dvd.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=h dvd.production_year %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=h dvd.duration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%=h dvd.plot %&gt;&lt;/td&gt;
    <emphasis>&lt;td&gt;&lt;%=h stars_for_rating(dvd.rating) %&gt;&lt;/td&gt;</emphasis>
    &lt;td&gt;&lt;%= link_to 'Show', dvd %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_dvd_path(dvd) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', dvd, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New dvd', new_dvd_path %&gt;
</programlisting></para>

      <para>Das Ergebnis ist das gleiche:<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds</command>
Received cookie: _dvd-sammlung_session=BAh7BzoPc2Vzc2lvbl9pZCIlMWJjZDI4ZDVmYjUxNTBiZGE4NjZkZjkwNDAxNjU5Zjk6EF9jc3JmX3Rva2VuSSIxWnZNc2dsTFNGdmEzeTh4b3Bua1BTdUNwWTY0dnhZME51bmxUKyszOGkvVT0GOg1lbmNvZGluZyINVVMtQVNDSUk%3D--e432e5bdd136e5e38bc074fe0c6693dc2b818b0e
Listing dvds

       Title         Production year Duration Plot Rating
The Terminator       1984                                 Show Edit Destroy
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy
Rain Man             1988                          *****  Show Edit Destroy
War of the Worlds    2005                          ****   Show Edit Destroy
Collateral           2004                          *****  Show Edit Destroy
Miami Vice           2006                          *****  Show Edit Destroy
Hancock              2008                          ****   Show Edit Destroy
The Aviator          2004                          ****   Show Edit Destroy
Some Like It Hot     1959                          *****  Show Edit Destroy
W.                   2008                          ****   Show Edit Destroy
Iron Man             2008                          *****  Show Edit Destroy
The Dark Knight      2008                          *****  Show Edit Destroy


New dvd
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Durch die Benutzung einer Helper-Methode ist unsere ganze
      Application aufgeräumter. Zusätzlich können wir die gleiche Methode auch
      noch in der <filename>app/views/dvds/show.html.erb</filename> Datei zum
      Anzeigen einer einzelnen DVD einbauen:<programlisting>&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%=h @dvd.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Production year:&lt;/b&gt;
  &lt;%=h @dvd.production_year %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Duration:&lt;/b&gt;
  &lt;%=h @dvd.duration %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Plot:&lt;/b&gt;
  &lt;%=h @dvd.plot %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Rating:&lt;/b&gt;
  <emphasis>&lt;%=h stars_for_rating(@dvd.rating) %&gt;</emphasis>
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_dvd_path(@dvd) %&gt; |
&lt;%= link_to 'Back', dvds_path %&gt;
</programlisting></para>

      <para>Das Ergebnis sieht dann so aus:<screen>sw@debian:~/dvd-sammlung$ <command>w3m -dump http://localhost:3000/dvds/5</command>
Received cookie: _dvd-sammlung_session=BAh7BjoPc2Vzc2lvbl9pZCIlNjhhYTI0ODIwMjBmZWRiMjU4YzI1NTA1MjZiNmRiODY%3D--6d466ee486dc4481e006a2ff317525f939b21926
Title: War of the Worlds

Production year: 2005

Duration:

Plot:

Rating: ****

Edit | Back
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Wenn Sie einen Helper in der ganzen Application und nicht nur in
      einem Controller benötigt, dann können Sie die Helper-Methode in der
      Datei <filename>app/helpers/application_helper.rb</filename> definieren.
      Vor dort aus ist Sie dann in jedem View abrufbar.</para>
    </section>

    <section xml:id="eingebaute-helper">
      <title>Eingebaute Helper</title>

      <para>Es gibt einige schon fertig mitgelieferte Helper. Einige haben wir
      schon benutzt:<itemizedlist>
          <listitem>
            <para><code>edit_dvd_path(dvd)</code></para>
          </listitem>

          <listitem>
            <para><code>new_dvd_path</code></para>
          </listitem>
        </itemizedlist></para>

      <para>Also nicht wundern, wenn von Helpern die Rede ist, aber die
      entsprechende Helperdatei leer ist.</para>
    </section>

    <section xml:id="helper-method">
      <title>helper_method</title>

      <para>Helper können nicht nur in
      <filename>app/helpers/beispiel.rb</filename> definiert werden. Sie
      können eine Methode aus Ihrem Controller zu einem Helper machen. In der
      Hilfe zu helper_method finden sich ein sehr gutes Beispiel dafür.
      Dummweise haben wir bis jetzt noch keine Sessions durchgenommen (Sie
      haben sich vielleicht schon über die automatischen Cookies gewundert),
      aber das Beispiel sollte trotzdem verständlich sein:<screen>sw@debian:~/dvd-sammlung$ <command>ri ActionController::Helpers::ClassMethods.helper_method</command>
------------------ ActionController::Helpers::ClassMethods#helper_method
     helper_method(*methods)

     From gem actionpack-2.3.5
------------------------------------------------------------------------
     Declare a controller method as a helper. For example, the following
     makes the +current_user+ controller method available to the view:

       class ApplicationController &lt; ActionController::Base
         helper_method :current_user, :logged_in?
     
         def current_user
           @current_user ||= User.find_by_id(session[:user])
         end
     
          def logged_in?
            current_user != nil
          end
       end

     In a view:

      &lt;% if logged_in? -%&gt;Welcome, &lt;%= current_user.name %&gt;&lt;% end -%&gt;

sw@debian:~/dvd-sammlung$</screen></para>
    </section>

    <section xml:id="mvc-ist-das-nicht-uebertrieben">
      <title>MVC - Ist das nicht übertrieben?</title>

      <para>Bei den ersten Rails-Projekten denkt man sich: "Das mache ich
      gerade schnell und neu im View". Aber schon schnell merkt man die
      Eleganz von Helpern und das saubere Abtrennen von Layout und
      Programmierung zu schätzen. Gerade wer schon mal in der
      PHP-Spagetti-Code Hölle war, wird die Arbeit mit Helpern bald
      lieben.</para>

      <para>Aber: Auto fahren, lernt man beim Auto fahren!</para>
    </section>
  </section>
</chapter>
