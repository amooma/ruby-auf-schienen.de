<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>1:n und n:n Verknüpfungen</title>

  <section>
    <title>has_many (1:n)</title>

    <para>In unserer DVD-Datenbank möchten wir nicht nur die DVDs
    katalogisieren, sondern auch die Zeitpunkte, wann wir welche DVD zuletzt
    gesehen haben. Also eine klassische 1:n Datenbank-Struktur. Das Model
    nennen wir <methodname>showtime</methodname> und die Datenbank wird nur
    folgende Werte enthalten:<itemizedlist>
        <listitem>
          <para><code>dvd_id</code></para>

          <para>Das ist die ID der DVD.</para>
        </listitem>

        <listitem>
          <para><code>showtime</code></para>

          <para>Das ist die Uhrzeit der Vorführung.</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>showtime Scaffolding</title>

      <para>Scaffolding ist ja schon ein alter Hut für Sie:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate scaffold showtime dvd_id:integer showtime:datetime</command>
      exists  app/models/
      exists  app/controllers/
      exists  app/helpers/
      create  app/views/showtimes
      exists  app/views/layouts/
      exists  test/functional/
      exists  test/unit/
      exists  test/unit/helpers/
      exists  public/stylesheets/
      create  app/views/showtimes/index.html.erb
      create  app/views/showtimes/show.html.erb
      create  app/views/showtimes/new.html.erb
      create  app/views/showtimes/edit.html.erb
      create  app/views/layouts/showtimes.html.erb
   identical  public/stylesheets/scaffold.css
      create  app/controllers/showtimes_controller.rb
      create  test/functional/showtimes_controller_test.rb
      create  app/helpers/showtimes_helper.rb
      create  test/unit/helpers/showtimes_helper_test.rb
       route  map.resources :showtimes
  dependency  model
      exists    app/models/
      exists    test/unit/
      exists    test/fixtures/
      create    app/models/showtime.rb
      create    test/unit/showtime_test.rb
      create    test/fixtures/showtimes.yml
      exists    db/migrate
      create    db/migrate/20100102120720_create_showtimes.rb
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Aus reiner Neugierde noch mal kurz in die Migrationsdatei
      schauen:<screen>sw@debian:~/dvd-sammlung$ <command>cat db/migrate/20100102120720_create_showtimes.rb</command> 
class CreateShowtimes &lt; ActiveRecord::Migration
  def self.up
    create_table :showtimes do |t|
      t.integer :dvd_id
      t.datetime :showtime

      t.timestamps
    end
  end

  def self.down
    drop_table :showtimes
  end
end
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Und jetzt die Migrations starten:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreateShowtimes: migrating ================================================
-- create_table(:showtimes)
   -&gt; 0.0011s
==  CreateShowtimes: migrated (0.0022s) =======================================

sw@debian:~/dvd-sammlung$</screen></para>
    </section>

    <section>
      <title>1:n im Model einbauen</title>

      <para>Sie können es sich wahrscheinlich schon denken: Es gibt dafür
      fertige Methoden.</para>

      <section>
        <title>has_many</title>

        <para>In die Datei <filename>app/models/dvd.rb</filename> tragen Sie
        bitte folgenden Inhalt ein:<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes
end
</programlisting></para>
      </section>

      <section>
        <title>belongs_to</title>

        <para>In die Datei <filename>app/models/showtime.rb</filename> tragen
        Sie bitte diesen Inhalt ein:<programlisting>class Showtime &lt; ActiveRecord::Base
  belongs_to :dvd
end
</programlisting></para>
      </section>

      <section>
        <title>Das war alles?</title>

        <para>Ja, das war alles. Jetzt sind beide Datenbanken in der
        Rails-Application 1:n verknüpft. Und mit dieser Verknüpfung bekommen
        sowohl dvd wie auch showtime eine ganze Menge an praktischen Methoden.
        Ich zitiere mal ein Beispiel aus der Anzeige von <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command></para>

        <screen>     Example

     Example: A Firm class declares +has_many :clients+, which will add:

     *   +Firm#clients+ (similar to +Clients.find :all, :conditions =&gt;
         ["firm_id = ?", id]+)

     *   +Firm#clients&lt;&lt;+

     *   +Firm#clients.delete+

     *   +Firm#clients=+

     *   +Firm#client_ids+

     *   +Firm#client_ids=+

     *   +Firm#clients.clear+

     *   +Firm#clients.empty?+ (similar to +firm.clients.size == 0+)

     *   +Firm#clients.size+ (similar to +Client.count "firm_id =
         #{id}"+)

     *   +Firm#clients.find+ (similar to +Client.find(id, :conditions =&gt;
         "firm_id = #{id}")+)

     *   +Firm#clients.exists?(:name =&gt; 'ACME')+ (similar to
         +Client.exists?(:name =&gt; 'ACME', :firm_id =&gt; firm.id)+)

     *   +Firm#clients.build+ (similar to +Client.new("firm_id" =&gt; id)+)

     *   +Firm#clients.create+ (similar to +c = Client.new("firm_id" =&gt;
         id); c.save; c+)
</screen>

        <para>Damit beschäftigen wir uns gleich noch.</para>
      </section>

      <section>
        <title>Geht es noch besser?</title>

        <para>Ja, unser erster Wurf war die Default-Variante. Das kann man
        aber noch besser machen. Im dvd-Model können wir noch den Schalter
        <varname>dependent</varname> setzen, damit eine showtime beim Löschen
        eines Filmes auch direkt mitgelöscht wird. Die
        <filename>app/models/dvd.rb</filename> sieht dann so
        aus:<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes, :dependent =&gt; :destroy
end
</programlisting></para>
      </section>
    </section>

    <section>
      <title>In der Console</title>

      <para>Starten wir die Console und ziehen den ersten Datensatz aus der
      DVD-Tabelle:<screen>sw@debian:~/dvd-sammlung$ <command>./script/console</command> 
Loading development environment (Rails 2.3.5)
&gt;&gt; <command>terminator = Dvd.first</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 17:04:23", updated_at: "2009-12-25 17:04:23"&gt;
&gt;&gt;
</screen></para>

      <section>
        <title>Showtimes anzeigen</title>

        <para>Mal schauen, ob dieser Film schon mal angeschaut wurde:<screen>&gt;&gt; <command>terminator.showtimes</command>
=&gt; []
&gt;&gt;</screen></para>

        <para>Schauen wir uns mal an, was dazu im
        <filename>log/development.log</filename> steht:<programlisting>  Showtime Load (0.2ms)   SELECT * FROM "showtimes" WHERE ("showtimes".dvd_id = 1) 
</programlisting></para>

        <para>Rails stellt automagisch die optimale SQL-Anfrage für das
        gegebene Problem und gibt ein Array mit den showtimes zur angefragten
        DVD aus.</para>

        <para>ActiveRecord ist aber noch viel intelligenter! Wenn wir mit der
        Methode <methodname>count</methodname> das Anzahl der Einträge im
        Array rausfinden wollen, passiert das folgende:<screen>&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 0
&gt;&gt;</screen></para>

        <para>Interessant ist dabei das benutzte SQL:<programlisting>  SQL (0.6ms)   SELECT count(*) AS count_all FROM "showtimes" WHERE ("showtimes".dvd_id = 1) 
</programlisting></para>

        <para>Rails fragt also nicht erst das Array ab und zählt dann die
        Elemente (was reichlich Resourcenfressend wäre), sonder ist so
        intelligent die Anfrage auf den SQL-Server zu leiten. Der kann das
        Problem schneller und einfacher lösen.<note>
            <para>Rails nimmt einem viele Optimierungen ab. Deshalb sollte man
            immer versuchen mit den eingebauten Methoden und nicht mit eigenem
            SQL zu arbeiten. Allerdings sollte man bei der Entwicklung auch
            immer einen Blick auf die Log Datei werfen und sich den SQL-Code
            anschauen, um zu verstehen, was im Hintergrund abläuft.</para>
          </note></para>
      </section>

      <section>
        <title>Showtime hinzufügen</title>

        <para>Wenn wir vor 4 Stunden und vor einem Monat den Film angeschaut
        haben und die Einträge in der Console nachziehen wollen:<screen>&gt;&gt; <command>terminator.showtimes.create({:showtime =&gt; Time.now - 4.hours})</command>
=&gt; #&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;
&gt;&gt; <command>terminator.showtimes.create({:showtime =&gt; Time.now - 2.month})</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt;</screen></para>

        <tip>
          <para><code>4.hours</code> und <code>2.month</code> ist eingebaute
          Rails-Magie. Hier die entsprechende Hilfe mit weiteren
          Beispielen:<screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveSupport::CoreExtensions::Numeric::Time</command>
-------------------- Class: ActiveSupport::CoreExtensions::Numeric::Time
     Enables the use of time calculations and declarations, like
     45.minutes + 2.hours + 4.years.

     These methods use Time#advance for precise date calculations when
     using from_now, ago, etc. as well as adding or subtracting their
     results from a Time object. For example:

       # equivalent to Time.now.advance(:months =&gt; 1)
       1.month.from_now
     
       # equivalent to Time.now.advance(:years =&gt; 2)
       2.years.from_now
     
       # equivalent to Time.now.advance(:months =&gt; 4, :years =&gt; 5)
       (4.months + 5.years).from_now

     While these methods provide precise calculation when used as in the
     examples above, care should be taken to note that this is not true
     if the result of `months', `years', etc is converted before use:

       # equivalent to 30.days.to_i.from_now
       1.month.to_i.from_now
     
       # equivalent to 365.25.days.to_f.from_now
       1.year.to_f.from_now

     In such cases, Ruby's core
     Date[http://stdlib.rubyonrails.org/libdoc/date/rdoc/index.html] and
     Time[http://stdlib.rubyonrails.org/libdoc/time/rdoc/index.html]
     should be used for precision date and time arithmetic

------------------------------------------------------------------------


Instance methods:
-----------------

     ago, day, days, fortnight, fortnights, from_now, hour, hours,
     minute, minutes, second, seconds, since, until, week, weeks
sw@debian:~/dvd-sammlung$</screen></para>
        </tip>

        <para>Noch mal nachschauen, ob auch alles richtig gespeichert
        wurde:<screen>&gt;&gt; <command>terminator.showtimes</command>
=&gt; [#&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;, #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;]
&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 2
&gt;&gt;</screen></para>

        <para>Und schauen wir auch mal in die <modifier>showtimes</modifier>
        Datenbank:<screen>&gt;&gt; <command>Showtime.all</command>
=&gt; [#&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;, #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;]
&gt;&gt;</screen></para>

        <para>Sie können auch gleichzeit eine DVD und eine Showtime
        hinzufügen:<screen>&gt;&gt; <command>Dvd.create({:title =&gt; 'Top Gun'}).showtimes.create({:showtime =&gt; Time.now - 10.years})</command>
=&gt; #&lt;Showtime id: 6, dvd_id: 20, showtime: "2000-01-02 13:42:47", created_at: "2010-01-02 13:42:47", updated_at: "2010-01-02 13:42:47"&gt;
&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 20, title: "Top Gun", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:42:47", updated_at: "2010-01-02 13:42:47"&gt;
&gt;&gt; <command>Dvd.last.showtimes</command>
=&gt; [#&lt;Showtime id: 6, dvd_id: 20, showtime: "2000-01-02 13:42:47", created_at: "2010-01-02 13:42:47", updated_at: "2010-01-02 13:42:47"&gt;]
&gt;&gt;</screen></para>

        <para>Und Sie können natürlich auch mehrere Showtimes zu einer neuen
        DVD hinzufügen. Bitte achten Sie auf die Klammern, denn mehrere
        Showtimes werden in einem Array übergeben:<screen>&gt;&gt; <command>Dvd.create({:title =&gt; 'Some like it hot.'}).showtimes.create([{:showtime =&gt; Time.now - 20.years}, {:showtime =&gt; Time.now - 25.years}, {:showtime =&gt; Time.now - 30.years}])</command>
=&gt; [#&lt;Showtime id: 7, dvd_id: 21, showtime: "1990-01-02 13:47:15", created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;, #&lt;Showtime id: 8, dvd_id: 21, showtime: "1985-01-02 13:47:15", created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;, #&lt;Showtime id: 9, dvd_id: 21, showtime: "1980-01-02 13:47:15", created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;]
&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 21, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;
&gt;&gt; <command>Dvd.last.showtimes.count</command>
=&gt; 3
&gt;&gt;</screen>Für die letzten drei Befehle noch die Ausgabe von
        <filename>log/development.log</filename>:<programlisting>  Dvd Create (0.7ms)   INSERT INTO "dvds" ("title", "production_year", "duration", "plot", "rating", "created_at", "updated_at") VALUES('Some like it hot.', NULL, NULL, NULL, NULL, '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Showtime Create (0.2ms)   INSERT INTO "showtimes" ("dvd_id", "showtime", "created_at", "updated_at") VALUES(21, '1990-01-02 13:47:15', '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Showtime Create (0.1ms)   INSERT INTO "showtimes" ("dvd_id", "showtime", "created_at", "updated_at") VALUES(21, '1985-01-02 13:47:15', '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Showtime Create (0.1ms)   INSERT INTO "showtimes" ("dvd_id", "showtime", "created_at", "updated_at") VALUES(21, '1980-01-02 13:47:15', '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Dvd Load (0.3ms)   SELECT * FROM "dvds" ORDER BY dvds.id DESC LIMIT 1
  Dvd Load (0.3ms)   SELECT * FROM "dvds" ORDER BY dvds.id DESC LIMIT 1
  SQL (0.2ms)   SELECT count(*) AS count_all FROM "showtimes" WHERE ("showtimes".dvd_id = 21) 
</programlisting></para>
      </section>

      <section>
        <title>Showtime löschen</title>

        <para>Wenn wir den letzten Showtime Eintrag löschen wollen, dann geht
        das mit der <methodname>delete</methodname> Methode:<screen>&gt;&gt; <command>terminator.showtimes.last</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt; <command>terminator.showtimes.last.delete</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 1
&gt;&gt;</screen></para>

        <section>
          <title>DVD mit damit verknüpften Showtimes löschen</title>

          <para>Da wir in der <filename>app/models/dvd.rb</filename> das
          has_many mit der Dependency destroy erweitert haben
          ...<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes, :dependent =&gt; :destroy
end
</programlisting>... brauchen wir uns bei einem destroy keine Gedanken zu
          machen. Rails übernimmt das für uns.</para>

          <para>Löschen wir den eben angelegten Film mit all seinen
          Showtimes:<screen>&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 22, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:56:15", updated_at: "2010-01-02 13:56:15"&gt;
&gt;&gt; <command>Dvd.last.showtimes.count</command>
=&gt; 3
&gt;&gt; <command>Dvd.last.destroy</command>
=&gt; #&lt;Dvd id: 22, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:56:15", updated_at: "2010-01-02 13:56:15"&gt;
&gt;&gt; <command>Showtime.find_all_by_dvd_id(22).count</command>
=&gt; 0
&gt;&gt;</screen></para>

          <warning>
            <para>Bitte beachten Sie hierbei den Unterschied zwischen den
            Methoden <methodname>destroy</methodname> und
            <methodname>delete</methodname>! Nur die Methode destroy löst alle
            Abhängigkeiten auf.</para>

            <para>Beispiel für <methodname>delete</methodname>. Hierbei wird
            die DVD gelöscht, aber die Showtimes bleiben als Zombies in der
            Datenbank.<screen>&gt;&gt; <command>Dvd.create({:title =&gt; 'Some like it hot.'}).showtimes.create([{:showtime =&gt; Time.now - 20.years}, {:showtime =&gt; Time.now - 25.years}, {:showtime =&gt; Time.now - 30.years}])</command>
=&gt; [#&lt;Showtime id: 13, dvd_id: 23, showtime: "1990-01-02 13:59:50", created_at: "2010-01-02 13:59:50", updated_at: "2010-01-02 13:59:50"&gt;, #&lt;Showtime id: 14, dvd_id: 23, showtime: "1985-01-02 13:59:50", created_at: "2010-01-02 13:59:50", updated_at: "2010-01-02 13:59:50"&gt;, #&lt;Showtime id: 15, dvd_id: 23, showtime: "1980-01-02 13:59:50", created_at: "2010-01-02 13:59:50", updated_at: "2010-01-02 13:59:50"&gt;]
&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 23, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:59:49", updated_at: "2010-01-02 13:59:49"&gt;
&gt;&gt; <command>Dvd.last.showtimes.count</command>
=&gt; 3
&gt;&gt; <command>Dvd.last.delete</command>
=&gt; #&lt;Dvd id: 23, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:59:49", updated_at: "2010-01-02 13:59:49"&gt;
&gt;&gt; <command>Showtime.find_all_by_dvd_id(23).count</command>
=&gt; 3
&gt;&gt;</screen></para>
          </warning>
        </section>
      </section>

      <section>
        <title>DVD zu einer Showtime suchen</title>

        <para>In der Datenbank haben wir als erste Showtime die folgende
        eingetragen:<screen>&gt;&gt; <command>Showtime.first</command>
=&gt; #&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;
&gt;&gt;</screen></para>

        <para>Wenn wir mit der "<code>dvd_id: 1</code>" aber nichts anfangen
        können und den Namen der DVD ausgeben möchten, dann können wir auf die
        neuen dvd-Methoden zugreifen:<screen>&gt;&gt; <command>Showtime.first.dvd</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 17:04:23", updated_at: "2009-12-25 17:04:23"&gt;
&gt;&gt;</screen></para>

        <para>Wir können uns natürlich auch direkt den Titel ausgeben
        lassen:<screen>&gt;&gt; <command>Showtime.first.dvd.title</command>
=&gt; "The Terminator"
&gt;&gt;</screen></para>
      </section>
    </section>

    <section>
      <title>Im Webinterface</title>

      <para>Mit Dvd und Showtime haben wir jetzt zwei Datenbanken, die wir
      über folgende URLs lokal abrufen können:<itemizedlist>
          <listitem>
            <para><uri>http://localhost:3000/dvds</uri></para>

            <para><screen>Listing dvds

       Title         Production year Duration Plot Rating
The Terminator       1984                                 Show Edit Destroy
Terminator 2         1992                                 Show Edit Destroy
Terminator Salvation 2009                                 Show Edit Destroy
Rain Man             1988                          *****  Show Edit Destroy
War of the Worlds    2005                          ****   Show Edit Destroy
Collateral           2004                          *****  Show Edit Destroy
Miami Vice           2006                          *****  Show Edit Destroy
Hancock              2008                          ****   Show Edit Destroy
The Aviator          2004                          ****   Show Edit Destroy
Some Like It Hot     1959                          *****  Show Edit Destroy
W.                   2008                          ****   Show Edit Destroy
Iron Man             2008                          *****  Show Edit Destroy
The Dark Knight      2008                          *****  Show Edit Destroy


New dvd
</screen></para>
          </listitem>

          <listitem>
            <para><uri>http://localhost:3000/showtimes</uri><screen>Listing showtimes

Dvd        Showtime
1   2009-01-02 16:40:30 UTC Show Edit Destroy
1   2009-12-13 16:40:30 UTC Show Edit Destroy
2   2009-01-02 16:40:30 UTC Show Edit Destroy
2   2009-11-02 16:40:30 UTC Show Edit Destroy
2   2009-12-13 16:40:30 UTC Show Edit Destroy
4   2008-01-02 16:40:30 UTC Show Edit Destroy
4   2009-10-02 15:40:30 UTC Show Edit Destroy
4   2009-12-15 14:40:30 UTC Show Edit Destroy
6   2009-01-02 16:40:30 UTC Show Edit Destroy


New showtime
</screen></para>
          </listitem>
        </itemizedlist></para>

      <para>Wir können auch wunderbar in der Console beides Verknüpfen und
      damit arbeiten. Aber das nützt natürlich gar nichts im Webinterface. Da
      wir wissen, das wir problemlos an die Daten rankommen, müssen wir uns
      jetzt überlegen, was wir überhaupt über das Webinterface machen wollen.
      Fangen wir erst mal mit dem einfachsten an: Einen Link, um eine neue
      Showtime hinzuzufügen. Und wo wir schon mal dabei sind, räumen wir noch
      ein wenig die Seite auf. Dazu verändern wir den View, also die Datei
      <filename>app/views/dvds/index.html.erb</filename> wie folgt:</para>

      <para>TBD</para>
    </section>
  </section>

  <section>
    <title>n:n Verknüpfung (has_many :through)</title>

    <para>Als nächstes wollen wir unsere Datenbank um die Schauspiele in den
    Filmen erweitern. Das ginge zur Not auch mit 1:n (also has_many), aber
    wäre unschön, weil ein Schauspieler ja in mehreren Filmen mitspielen kann
    und dann mehrmals in der Datenbank wäre. Wir suchen also eine n:n
    Verknüpfung.</para>

    <section>
      <title>Schauspieler Datenbank</title>

      <para>Fangen wir mal mit der Actor-Datenbank an. Die soll folgende
      Felder enthalten:<itemizedlist>
          <listitem>
            <para>firstname:string</para>
          </listitem>

          <listitem>
            <para>lastname:string</para>
          </listitem>

          <listitem>
            <para>gender:boolean</para>

            <para>Das Geschlecht können wir ruhig in einem Boolean
            abspeichern. Das ist performanter und benötigt weniger Platz als
            ein String. true:männlich und false:weiblich<footnote>
                <para>Ich sehe schon die Beschwerden der weiblichen Leser vor
                mir. Wie rum man es macht ist logischerweise völlig
                egal.</para>
              </footnote></para>
          </listitem>

          <listitem>
            <para>birthdate:date</para>
          </listitem>

          <listitem>
            <para>homepage_url:string</para>
          </listitem>
        </itemizedlist></para>

      <para>Wieder ein Fall für Scaffolding:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate scaffold actor firstname:string lastname:string gender:boolean birthdate:date homepage_url:string</command>
      exists  app/models/
      exists  app/controllers/
      exists  app/helpers/
      create  app/views/people
      exists  app/views/layouts/
      exists  test/functional/
      exists  test/unit/
      exists  test/unit/helpers/
      exists  public/stylesheets/
      create  app/views/people/index.html.erb
      create  app/views/people/show.html.erb
      create  app/views/people/new.html.erb
      create  app/views/people/edit.html.erb
      create  app/views/layouts/people.html.erb
   identical  public/stylesheets/scaffold.css
      create  app/controllers/people_controller.rb
      create  test/functional/people_controller_test.rb
      create  app/helpers/people_helper.rb
      create  test/unit/helpers/people_helper_test.rb
       route  map.resources :people
  dependency  model
      exists    app/models/
      exists    test/unit/
      exists    test/fixtures/
      create    app/models/person.rb
      create    test/unit/person_test.rb
      create    test/fixtures/people.yml
      exists    db/migrate
      create    db/migrate/20100102142248_create_people.rb
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Und die Migration ausführen:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreatePeople: migrating ===================================================
-- create_table(:people)
   -&gt; 0.0012s
==  CreatePeople: migrated (0.0022s) ==========================================

sw@debian:~/dvd-sammlung$</screen></para>

      <warning>
        <para>Bitte beachten Sie, das eine Class immer Singular (also in
        <classname>Person</classname>) und ein Model immer Plural (also
        <varname>people</varname>) ist!</para>
      </warning>
    </section>

    <section>
      <title>Cast Datenbank</title>

      <para>Wir haben eine Datenbank mit Schauspielern und wir haben eine
      Datenbank mit DVDs. Da jeder Schauspieler in mehreren Filmen mitspielen
      kann, benötigen wir jetzt noch eine Datenbank in der beide Tabellen mit
      einander verknüpft werden. Die Class nennen wir
      <classname>Cast</classname> (englisch für Besetzung).</para>

      <para>Wir benötigen folgendes Datenbankmodel:<itemizedlist>
          <listitem>
            <para>person_id:integer</para>
          </listitem>

          <listitem>
            <para>dvd_id:integer</para>
          </listitem>
        </itemizedlist></para>

      <section>
        <title>./script/generate model</title>

        <para>Diemal benötigen wir kein Scaffolding, da wir ja gar kein
        Webinterface benötigen (wir werden diese Verküpfungen nie per Hand
        eingeben). Deshalb reicht es aus, nur ein Model anzulegen. Ich kann
        mir die Syntax nie merken und rufe deshalb erstmal das Programm ohne
        weitere Parameter auf:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate model</command>
Usage: ./script/generate model ModelName [field:type, field:type]

Options:
        --skip-timestamps            Don't add timestamps to the migration file for this model
        --skip-migration             Don't generate a migration file for this model
        --skip-fixture               Don't generation a fixture file for this model

Rails Info:
    -v, --version                    Show the Rails version number and quit.
    -h, --help                       Show this help message and quit.

General Options:
    -p, --pretend                    Run but do not make any changes.
    -f, --force                      Overwrite files that already exist.
    -s, --skip                       Skip files that already exist.
    -q, --quiet                      Suppress normal output.
    -t, --backtrace                  Debugging: show backtrace on errors.
    -c, --svn                        Modify files with subversion. (Note: svn must be in path)
    -g, --git                        Modify files with git. (Note: git must be in path)

Description:
    Stubs out a new model. Pass the model name, either CamelCased or
    under_scored, and an optional list of attribute pairs as arguments.

    Attribute pairs are column_name:sql_type arguments specifying the
    model's attributes. Timestamps are added by default, so you don't have to
    specify them by hand as 'created_at:datetime updated_at:datetime'.

    You don't have to think up every attribute up front, but it helps to
    sketch out a few so you can start working with the model immediately.

    This generates a model class in app/models, a unit test in test/unit,
    a test fixture in test/fixtures/singular_name.yml, and a migration in
    db/migrate.

Examples:
    `./script/generate model account`

        creates an Account model, test, fixture, and migration:
            Model:      app/models/account.rb
            Test:       test/unit/account_test.rb
            Fixtures:   test/fixtures/accounts.yml
            Migration:  db/migrate/XXX_add_accounts.rb

    `./script/generate model post title:string body:text published:boolean`

        creates a Post model with a string title, text body, and published flag.
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Ähnelt alles stark dem Scaffolding.</para>

        <para>Legen wir los:<screen>sw@debian:~/dvd-sammlung$ ./script/generate model cast actor_id:integer dvd_id:integer
      exists  app/models/
      exists  test/unit/
      exists  test/fixtures/
      create  app/models/cast.rb
      create  test/unit/cast_test.rb
      create  test/fixtures/casts.yml
      exists  db/migrate
      create  db/migrate/20100102152113_create_casts.rb
sw@debian:~/dvd-sammlung$</screen></para>

        <para>Man sieht den Unterschied zu Scaffolding: Es wird viel weniger
        Code erzeugt. Auch hier müssen wir jetzt noch die Migration
        durchführen:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreateCasts: migrating ====================================================
-- create_table(:casts)
   -&gt; 0.0011s
==  CreateCasts: migrated (0.0020s) ===========================================

sw@debian:~/dvd-sammlung$</screen></para>
      </section>
    </section>

    <section>
      <title>has_many :through</title>

      <para>Jetzt müssen wir in den Modelen die Verknüpfungen
      eintragen:<itemizedlist>
          <listitem>
            <para><filename>app/models/cast.rb</filename></para>

            <para><programlisting>class Cast &lt; ActiveRecord::Base
  belongs_to :dvd
  belongs_to :actor
end
</programlisting></para>

            <para>Die Class <classname>Cast</classname> hat belongs_to
            Verbindungen zur <classname>Dvd</classname>- und zur
            <classname>Actor</classname>-Class.</para>
          </listitem>

          <listitem>
            <para><filename>app/models/actor.rb</filename></para>

            <para><programlisting>class Actor &lt; ActiveRecord::Base
  has_many :casts, :dependent =&gt; :destroy
  has_many :dvds, :through =&gt; :casts
end
</programlisting>Die Class <classname>Actor</classname> hat viele (has_many)
            Casts zu denen eine <methodname>:destroy</methodname> Abhängigkeit
            aufgebaut wird. Denn wenn ein Schauspieler aus der Datenbank
            gelöscht wird, so macht es auch Sinn alle Einträge zu diesem
            Schauspieler in der casts Datenbank zu löschen.</para>

            <para>Weiterhin hat Actor viele (has_many) dvds durch eine
            Verknüpfung mit casts.</para>
          </listitem>

          <listitem>
            <para><filename>app/models/dvd.rb</filename></para>

            <para><programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes, :dependent =&gt; :destroy
  has_many :casts, :dependent =&gt; :destroy
  has_many :actors, :through =&gt; :casts
end
</programlisting></para>

            <para>Die Class <classname>Dvd</classname> hat viele (has_many)
            Casts zu denen auch sie eine :destroy Abhängikeit aufbaut.
            Zusätzlich baut Sie noch eine Verbindung durch (:through) casts zu
            actors auf.</para>
          </listitem>
        </itemizedlist></para>
    </section>

    <section>
      <title>In der Console</title>

      <para>Starten wir die Console.<screen>sw@debian:~/dvd-sammlung$ <command>./script/console</command> 
Loading development environment (Rails 2.3.5)
&gt;&gt;</screen></para>

      <section>
        <title>Schauspieler hinzufügen</title>

        <para>Fügen wir erst mal Arnold Schwarzenegger, Michael Biehn und
        Linda Hamilton als Schauspieler im ersten Terminator Film
        hinzu:<screen>&gt;&gt; <command>Dvd.find_by_title('The Terminator').actors.create({:firstname =&gt; 'Arnold', :lastname =&gt; 'Schwarzenegger'})</command>
=&gt; #&lt;Actor id: 1, firstname: "Arnold", lastname: "Schwarzenegger", gender: nil, birthdate: nil, homepage_url: nil, created_at: "2010-01-02 15:27:20", updated_at: "2010-01-02 15:27:20"&gt;
&gt;&gt; <command>Dvd.find_by_title('The Terminator').actors.create({:firstname =&gt; 'Michael', :lastname =&gt; 'Biehn'})</command>
=&gt; #&lt;Actor id: 2, firstname: "Michael", lastname: "Biehn", gender: nil, birthdate: nil, homepage_url: nil, created_at: "2010-01-02 15:41:00", updated_at: "2010-01-02 15:41:00"&gt;
&gt;&gt; <command>Dvd.find_by_title('The Terminator').actors.create({:firstname =&gt; 'Linda', :lastname =&gt; 'Hamilton'})</command>
=&gt; #&lt;Actor id: 3, firstname: "Linda", lastname: "Hamilton", gender: nil, birthdate: nil, homepage_url: nil, created_at: "2010-01-02 15:41:33", updated_at: "2010-01-02 15:41:33"&gt;
&gt;&gt;</screen></para>

        <para>Überprüfen wir mal das Ergebnis:<screen>&gt;&gt; <command>Dvd.find_by_title('The Terminator').actors</command>
=&gt; [#&lt;Actor id: 1, firstname: "Arnold", lastname: "Schwarzenegger", gender: nil, birthdate: nil, homepage_url: nil, created_at: "2010-01-02 15:27:20", updated_at: "2010-01-02 15:27:20"&gt;, #&lt;Actor id: 2, firstname: "Michael", lastname: "Biehn", gender: nil, birthdate: nil, homepage_url: nil, created_at: "2010-01-02 15:41:00", updated_at: "2010-01-02 15:41:00"&gt;, #&lt;Actor id: 3, firstname: "Linda", lastname: "Hamilton", gender: nil, birthdate: nil, homepage_url: nil, created_at: "2010-01-02 15:41:33", updated_at: "2010-01-02 15:41:33"&gt;]
&gt;&gt; <command>Dvd.find_by_title('The Terminator').actors.count</command>
=&gt; 3
&gt;&gt;</screen></para>

        <para>Dummerweise können wir nicht mit dem gleichen Verfahren die
        beiden anderen Terminator Einträge in der DVD-Tabelle befüllen, denn
        der Eintrag für z.B. Arnold Schwarzenegger ist ja schon in der
        Actors-Tabelle und würde dann doppelt sein.</para>

        <para>Eine Lösung für das Problem ist die
        <methodname>find_or_create_by</methodname> Methode und der kleine
        Umweg über casts:<screen>&gt;&gt; <command>Dvd.find_by_title('Terminator 2').casts.find_or_create_by_actor_id(Actor.find_or_create_by_firstname_and_lastname('Arnold','Schwarzenegger').id)</command>
=&gt; #&lt;Cast id: 4, actor_id: 1, dvd_id: 2, created_at: "2010-01-02 16:37:20", updated_at: "2010-01-02 16:37:20"&gt;
&gt;&gt;</screen></para>

        <para>Mal schauen, ob wir auch sehen, welche DVDs bis jetzt mit Arnold
        Schwarzenegger verknüpft sind:<screen>&gt;&gt; <command>Actor.find_by_lastname('Schwarzenegger').dvds</command>
=&gt; [#&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 16:40:30", updated_at: "2010-01-02 16:40:30"&gt;, #&lt;Dvd id: 2, title: "Terminator 2", production_year: 1992, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 16:40:30", updated_at: "2010-01-02 16:40:30"&gt;]
&gt;&gt; <command>Actor.find_by_lastname('Schwarzenegger').dvds.count</command>
=&gt; 2
&gt;&gt;</screen></para>
      </section>
    </section>
  </section>
</chapter>
