<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2.10. Arrays und Hashes</title><link rel="stylesheet" href="./default.css" type="text/css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="package" content="" /><link rel="home" href="index.html" title="Ruby on Rails 3.0" /><link rel="up" href="ruby-grundlagen.html" title="Kapitel 2. Ruby Grundlagen" /><link rel="prev" href="ruby-schleifen.html" title="2.9. Schleifen" /><link rel="next" href="erste_schritte_mit_rails.html" title="Kapitel 3. Erste Schritte mit Rails" /></head><body id="your-body"><div id="content"><div id="content-inner"><div id="leftcol" class="sidebar"><ul class="breadcrumbs"><li class="breadcrumb-link" style="margin-left: 0em"><a href="index.html">Ruby on Rails 3.0</a></li><li class="breadcrumb-link breadcrumb-bullet" style="margin-left: 0.8em"><a href="ruby-grundlagen.html">Ruby Grundlagen</a></li><li class="breadcrumb-node breadcrumb-last breadcrumb-bullet" style="margin-left: 1.6em"><a href="ruby-array-und-hash.html">Arrays und Hashes</a></li><li class="breadcrumb-link breadcrumb-bullet-another" style="margin-left: 2.4em"><a href="ruby-array-und-hash.html#id3306834">Array</a></li><li class="breadcrumb-link breadcrumb-bullet-another" style="margin-left: 2.4em"><a href="ruby-array-und-hash.html#id3307222">Hash</a></li></ul><div id="textsize"><span class="textts"> Change Text Size</span><br /><a href="javascript:void(0);" onclick="javascript:body.style.fontSize='13px'"><span class="plusts" style="font-size: small;">+</span></a><a href="javascript:void(0);" onclick="javascript:body.style.fontSize='15px'"><span class="plusts" style="font-size: large;">+</span></a><a href="javascript:void(0);" onclick="javascript:body.style.fontSize='17px'"><span class="plusts" style="font-size: x-large;">+</span></a></div></div><div id="rightcol" class="sidebar"></div><div id="maincol"><ul class="docnav top"><li class="previous"><a accesskey="p" href="ruby-schleifen.html"><strong>Zurück</strong></a></li><li class="next"><a accesskey="n" href="erste_schritte_mit_rails.html"><strong>Weiter</strong></a></li></ul><div class="section" title="2.10. Arrays und Hashes" id="ruby-array-und-hash"><div class="titlepage"><div><div><h2 class="title">2.10. Arrays und Hashes</h2></div></div></div><div class="para">Wie in vielen Programmiersprachen sind auch in Ruby Arrays und
    Hashes beliebte Mechanismen um Daten zu speichern.</div><div class="section" title="2.10.1. Array"><div class="titlepage"><div><div><h3 class="title">2.10.1. Array</h3></div></div></div><div class="para">Eine Array ist eine Liste von Objekten. Spielen wir doch einmal
      ein wenig im irb.<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>a = [1,2,3,4,5]</strong></span>
=&gt; [1, 2, 3, 4, 5]
irb(main):002:0&gt; <span class="command"><strong>a.class</strong></span>
=&gt; Array
irb(main):003:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Das ist einfach und verständlich.</div><div class="para">Mal schauen ob das so auch mit Strings im Array
      funktioniert.<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>a = ['Test', 'Apfelbaum', 'blau']</strong></span>
=&gt; ["Test", "Apfelbaum", "blau"]
irb(main):002:0&gt; <span class="command"><strong>a.class</strong></span>
=&gt; Array
irb(main):003:0&gt; <span class="command"><strong>a[1]</strong></span>
=&gt; "Apfelbaum"
irb(main):004:0&gt; <span class="command"><strong>a[1].class</strong></span>
=&gt; String
irb(main):005:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Das geht auch.</div><div class="para">Dann fehlt nur noch ein Array mit einem Mix aus beidem. Ist klar,
      dass es gehen muss, weil das Array ja Objekte speichert und es egal ist,
      welche Art von Objekten (sprich <code class="classname">String</code>,
      <code class="classname">Fixnum</code> oder <code class="classname">Float</code>) das
      sind. Aber ein Versuch schadet ja nicht.<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>a = [1, 2, 'Haus', 'Baum', 4]</strong></span>
=&gt; [1, 2, "Haus", "Baum", 4]
irb(main):002:0&gt; <span class="command"><strong>a.class</strong></span>
=&gt; Array
irb(main):003:0&gt; <span class="command"><strong>a[0]</strong></span>
=&gt; 1
irb(main):004:0&gt; <span class="command"><strong>a[0].class</strong></span>
=&gt; Fixnum
irb(main):005:0&gt; <span class="command"><strong>a[2]</strong></span>
=&gt; "Haus"
irb(main):006:0&gt; <span class="command"><strong>a[2].class</strong></span>
=&gt; String
irb(main):007:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Schauen wir uns als nächstes mal die ri-Hilfeseite zu
      <code class="classname">Array</code> an.<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>ri Array</strong></span>
-------------------------------------------------- Class: Array &lt; Object
     Arrays are ordered, integer-indexed collections of any object.
     Array indexing starts at 0, as in C or Java. A negative index is
     assumed to be relative to the end of the array---that is, an index
     of -1 indicates the last element of the array, -2 is the next to
     last element in the array, and so on.

------------------------------------------------------------------------


Includes:
---------

     Enumerable


Class methods:
--------------

     [], new, try_convert


Instance methods:
-----------------

     &amp;, *, +, -, &lt;&lt;, &lt;=&gt;, ==, [], []=, abbrev, assoc, at, clear,
     collect, collect!, combination, compact, compact!, concat, count,
     cycle, dclone, delete, delete_at, delete_if, drop, drop_while,
     each, each_index, empty?, eql?, fetch, fill, find_index, first,
     flatten, flatten!, frozen?, hash, include?, index, initialize_copy,
     insert, inspect, join, last, length, map, map!, pack, permutation,
     pop, pretty_print, pretty_print_cycle, product, push, rassoc,
     reject, reject!, replace, reverse, reverse!, reverse_each, rindex,
     sample, select, shelljoin, shift, shuffle, shuffle!, size, slice,
     slice!, sort, sort!, take, take_while, to_a, to_ary, to_csv, to_s,
     to_yaml, transpose, uniq, uniq!, unshift, values_at,
     yaml_initialize, zip, |
sw@debian:~/sandbox$ </pre></div><div class="para">Arrays können also auch (wie jede Klasse) mit der Methode
      <code class="methodname">new</code> erstellt werden. Einzelne neue Elemente
      können dann mit der Methode <code class="methodname">&lt;&lt;</code>
      hinzugefügt werden. Auch hierzu ein Beispiel:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>a = Array.new</strong></span>
=&gt; []
irb(main):002:0&gt; <span class="command"><strong>a.class</strong></span>
=&gt; Array
irb(main):003:0&gt; <span class="command"><strong>a &lt;&lt; 'erster Eintrag'</strong></span>
=&gt; ["erster Eintrag"]
irb(main):004:0&gt; <span class="command"><strong>a &lt;&lt; 'zweiter Eintrag'</strong></span>
=&gt; ["erster Eintrag", "zweiter Eintrag"]
irb(main):005:0&gt; <span class="command"><strong>a &lt;&lt; 'dritter Eintrag'</strong></span>
=&gt; ["erster Eintrag", "zweiter Eintrag", "dritter Eintrag"]
irb(main):006:0&gt; <span class="command"><strong>a.size</strong></span>
=&gt; 3
irb(main):007:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Aber versuchen wir doch mal ein Array mit Einträgen aus einer
      selbstdefinierten Klasse zu erstellen:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>class Tier</strong></span>              # Definition einer Klasse Tier
irb(main):002:1&gt; <span class="command"><strong>  def initialize(de_name,en_name)</strong></span>
irb(main):003:2&gt;     <span class="command"><strong>@de_name = de_name</strong></span>
irb(main):004:2&gt; <span class="command"><strong>    @en_name = en_name</strong></span>
irb(main):005:2&gt; <span class="command"><strong>  end</strong></span>
irb(main):006:1&gt;   <span class="command"><strong>def to_s</strong></span>
irb(main):007:2&gt; <span class="command"><strong>    @de_name + ' (' + @en_name + ')'</strong></span>
irb(main):008:2&gt; <span class="command"><strong>  end</strong></span>
irb(main):009:1&gt; <span class="command"><strong>end</strong></span>
=&gt; nil
irb(main):010:0&gt; <span class="command"><strong>lumpi = Tier.new('Hund', 'Dog')</strong></span>
=&gt; #&lt;Tier:0x873b5c8 @de_name="Hund", @en_name="Dog"&gt;
irb(main):011:0&gt; <span class="command"><strong>hansi = Tier.new('Wellensittich', 'Budgerigar')</strong></span>           
=&gt; #&lt;Tier:0x86b60f8 @de_name="Wellensittich", @en_name="Budgerigar"&gt;
irb(main):012:0&gt; <span class="command"><strong>haustiere = Array.new</strong></span>   # haustiere ist ein Array
=&gt; []
irb(main):013:0&gt; <span class="command"><strong>haustiere &lt;&lt; hansi</strong></span>      # hansi wird hinzugefuegt
=&gt; [#&lt;Tier:0x8d11f18 @de_name="Wellensittich", @en_name="Budgerigar"&gt;]
irb(main):014:0&gt; <span class="command"><strong>haustiere &lt;&lt; lumpi</strong></span>      # lumpi wird hinzugefuegt
=&gt; [#&lt;Tier:0x8d11f18 @de_name="Wellensittich", @en_name="Budgerigar"&gt;, #&lt;Tier:0x8d9751c @de_name="Hund", @en_name="Dog"&gt;]
irb(main):015:0&gt; <span class="command"><strong>haustiere.count</strong></span>
=&gt; 2
irb(main):016:0&gt; <span class="command"><strong>puts haustiere[1]</strong></span>       # Ausgabe der Position 1
Hund (Dog)
=&gt; nil
irb(main):017:0&gt; <span class="command"><strong>puts haustiere[0]</strong></span>       # Ausgabe der Position 0
Wellensittich (Budgerigar)
=&gt; nil
irb(main):018:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="section" title="2.10.1.1. Iterator (each)" id="array_iterator"><div class="titlepage"><div><div><h4 class="title">2.10.1.1. Iterator (each)</h4></div></div></div><div class="para">Mit der Methode <code class="methodname">each</code> kann man sich
        Stück für Stück durch ein Array arbeiten. Beispiel:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>einkaufsliste = ['Eier', 'Butter', 'Mehl']</strong></span>
=&gt; ["Eier", "Butter", "Mehl"]
irb(main):002:0&gt; <span class="command"><strong>einkaufsliste.each do |produkt|</strong></span>
irb(main):003:1* <span class="command"><strong>  puts produkt</strong></span>
irb(main):004:1&gt; <span class="command"><strong>end</strong></span>
Eier
Butter
Mehl
=&gt; ["Eier", "Butter", "Mehl"]
irb(main):005:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Auch hier gibt Ihnen <span class="application">ri</span> Hilfe und ein
        Beispiel, falls Sie mal vergessen haben sollten wie
        <code class="methodname">each</code> anzuwenden ist:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>ri Array.each</strong></span>
------------------------------------------------------------- Array#each
     array.each {|item| block }   -&gt;   array

     From Ruby 1.9.1
------------------------------------------------------------------------
     Calls _block_ once for each element in _self_, passing that element
     as a parameter.

        a = [ "a", "b", "c" ]
        a.each {|x| print x, " -- " }

     produces:

        a -- b -- c --

sw@debian:~/sandbox$ </pre></div></div></div><div class="section" title="2.10.2. Hash"><div class="titlepage"><div><div><h3 class="title">2.10.2. Hash</h3></div></div></div><div class="para">Ein <span class="quote">„<span class="quote">Hash</span>“</span> ist eine Liste aus Schlüssel-/Wert-Paaren
      (key/value pairs). Ein Beispiel mit Strings als Schlüssel:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>preisliste = { '6 Eier' =&gt; 1.2, '12 Eier' =&gt; 2, '500 gr Butter' =&gt; 0.99 }</strong></span>
=&gt; {"6 Eier"=&gt;1.2, "12 Eier"=&gt;2, "500 gr Butter"=&gt;0.99}
irb(main):002:0&gt; <span class="command"><strong>preisliste['12 Eier']</strong></span>
=&gt; 2
irb(main):003:0&gt; <span class="command"><strong>preisliste.count</strong></span>
=&gt; 3
irb(main):004:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Die Benutzung von Symbolen als Schlüssel ist speicher-effizienter
      (auch wenn das bei diesem Beispiel natürlich keinen großen Unterschied
      macht):<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>farben = { :black =&gt; '#000000', :white =&gt; ':FFFFFF', :green =&gt; '#00C000', :blue =&gt; '#0000FF' }
=&gt; {:black=&gt;"#000000", :white=&gt;":FFFFFF", :green=&gt;"#00C000", :blue=&gt;"#0000FF"}</strong></span>
irb(main):002:0&gt; <span class="command"><strong>puts farben[:green]</strong></span>
#00C000
=&gt; nil
irb(main):003:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Natürlich können in Hashes nicht nur Strings, sondern auch selbst
      definierte Klassen als Objekte in der Werten gespeichert werden (siehe
      Array-Beispiel).</div><div class="para">Wie zu <code class="classname">Array</code> gibt es auch zu
      <code class="classname">Hash</code> eine sehr gute ri-Hilfe-Seite:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>ri Hash</strong></span>
--------------------------------------------------- Class: Hash &lt; Object
     A +Hash+ is a collection of key-value pairs. It is similar to an
     +Array+, except that indexing is done via arbitrary keys of any
     object type, not an integer index. The order in which you traverse
     a hash by either key or value may seem arbitrary, and will
     generally not be in the insertion order.

     Hashes have a _default value_ that is returned when accessing keys
     that do not exist in the hash. By default, that value is +nil+.

------------------------------------------------------------------------


Includes:
---------

     Enumerable


Class methods:
--------------

     [], new, try_convert


Instance methods:
-----------------

     ==, [], []=, assoc, clear, compare_by_identity,
     compare_by_identity?, default, default=, default_proc,
     default_proc=, delete, delete_if, each, each_key, each_pair,
     each_value, empty?, eql?, fetch, flatten, has_key?, has_value?,
     hash, include?, initialize_copy, inspect, invert, key, key?, keys,
     length, member?, merge, merge!, pretty_print, pretty_print_cycle,
     rassoc, rehash, reject, reject!, replace, select, shift, size,
     store, to_a, to_hash, to_s, to_yaml, update, value?, values,
     values_at, yaml_initialize
sw@debian:~/sandbox$</pre></div><div class="section" title="2.10.2.1. Iterator (each)"><div class="titlepage"><div><div><h4 class="title">2.10.2.1. Iterator (each)</h4></div></div></div><div class="para">Mit der Methode <code class="methodname">each</code> kann man sich
        Stück für Stück durch einen Hash arbeiten. Beispiel:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>irb</strong></span>
irb(main):001:0&gt; <span class="command"><strong>einkaufsliste = { 'Eier' =&gt; 6, 'Butter' =&gt; '500 gr' }</strong></span>
=&gt; {"Eier"=&gt;6, "Butter"=&gt;"500 gr"}
irb(main):002:0&gt; <span class="command"><strong>einkaufsliste.each do |key,value|</strong></span>
irb(main):003:1* <span class="command"><strong>  puts "Produkt: #{key} - Menge: #{value}"</strong></span>
irb(main):004:1&gt; <span class="command"><strong>end</strong></span>
Produkt: Eier - Menge: 6
Produkt: Butter - Menge: 500 gr
=&gt; {"Eier"=&gt;6, "Butter"=&gt;"500 gr"}
irb(main):005:0&gt; <span class="command"><strong>exit</strong></span>
</pre></div><div class="para">Auch hier gibt Ihnen <span class="application">ri</span> Hilfe und ein
        Beispiel, falls Sie mal vergessen haben sollten wie
        <code class="methodname">each</code> anzuwenden ist:<pre class="screen">sw@debian:~/sandbox$ <span class="command"><strong>ri Hash.each</strong></span>
-------------------------------------------------------------- Hash#each
     hsh.each {| key, value | block } -&gt; hsh
     hsh.each_pair {| key, value | block } -&gt; hsh

     From Ruby 1.9.1
------------------------------------------------------------------------
     Calls _block_ once for each key in _hsh_, passing the key-value
     pair as parameters.

        h = { "a" =&gt; 100, "b" =&gt; 200 }
        h.each {|key, value| puts "#{key} is #{value}" }

     _produces:_

        a is 100
        b is 200

sw@debian:~/sandbox$</pre></div></div></div></div><ul class="docnav bottom"><li class="previous"><a accesskey="p" href="ruby-schleifen.html"><strong>Zurück</strong>2.9. Schleifen</a></li><li class="up"><a accesskey="u" href="#"><strong>Nach oben</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Zum Anfang</strong></a></li><li class="next"><a accesskey="n" href="erste_schritte_mit_rails.html"><strong>Weiter</strong>Kapitel 3. Erste Schritte mit
  Rails</a></li></ul></div><div class="clear"></div></div></div></body></html>
