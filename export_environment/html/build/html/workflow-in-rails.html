<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3.10. MVC-Workflow innerhalb Rails</title><link rel="stylesheet" href="./default.css" type="text/css" /><link rel="stylesheet" media="print" href="Common_Content/css/print.css" type="text/css" /><meta name="package" content="" /><link rel="home" href="index.html" title="Ruby on Rails 3.0" /><link rel="up" href="erste_schritte_mit_rails.html" title="Kapitel 3. Erste Schritte mit Rails" /><link rel="prev" href="die_console.html" title="3.9. Die Console" /><link rel="next" href="model.html" title="Kapitel 4. Model - Das M in MVC." /></head><body id="your-body"><div id="content"><div id="content-inner"><div id="leftcol" class="sidebar"><ul class="breadcrumbs"><li class="breadcrumb-link" style="margin-left: 0em"><a href="index.html">Ruby on Rails 3.0</a></li><li class="breadcrumb-link breadcrumb-bullet" style="margin-left: 0.8em"><a href="erste_schritte_mit_rails.html">Erste Schritte mit
  Rails</a></li><li class="breadcrumb-node breadcrumb-last breadcrumb-bullet" style="margin-left: 1.6em"><a href="workflow-in-rails.html">MVC-Workflow innerhalb
    Rails</a></li><li class="breadcrumb-link breadcrumb-bullet-another" style="margin-left: 2.4em"><a href="workflow-in-rails.html#dvd-show-html">Beispiel movies/1</a></li><li class="breadcrumb-link breadcrumb-bullet-another" style="margin-left: 2.4em"><a href="workflow-in-rails.html#dvd-index-html">Beispiel /movies (Index aller Datensätze)</a></li></ul><div id="textsize"><span class="textts"> Change Text Size</span><br /><a href="javascript:void(0);" onclick="javascript:body.style.fontSize='13px'"><span class="plusts" style="font-size: small;">+</span></a><a href="javascript:void(0);" onclick="javascript:body.style.fontSize='15px'"><span class="plusts" style="font-size: large;">+</span></a><a href="javascript:void(0);" onclick="javascript:body.style.fontSize='17px'"><span class="plusts" style="font-size: x-large;">+</span></a></div></div><div id="rightcol" class="sidebar"></div><div id="maincol"><ul class="docnav top"><li class="previous"><a accesskey="p" href="die_console.html"><strong>Zurück</strong></a></li><li class="next"><a accesskey="n" href="model.html"><strong>Weiter</strong></a></li></ul><div class="section" title="3.10. MVC-Workflow innerhalb Rails" id="workflow-in-rails"><div class="titlepage"><div><div><h2 class="title">3.10. MVC-Workflow innerhalb
    Rails</h2></div></div></div><div class="para">Jetzt können wir eine Tabelle anlegen und auf diese via HTTP und via
    der Console zugreifen. Jetzt schauen wir uns mal an, was bei einer
    HTTP-Anfrage passiert und welchen Weg diese Anfrage geht. Hier kommt die
    versprochene Fortführung von <a class="xref" href="scaffolding.html#routen" title="3.8.6. Routen">Abschnitt 3.8.6, „Routen“</a>.</div><div class="section" title="3.10.1. Beispiel movies/1" id="dvd-show-html"><div class="titlepage"><div><div><h3 class="title">3.10.1. Beispiel movies/1</h3></div></div></div><div class="para">Nehmen wir an, ein User ruft die URL <code class="uri"><a class="uri" href="http://0.0.0.0:3000/movies/1" target="">http://0.0.0.0:3000/movies/1</a></code>
      auf.</div><div class="section" title="3.10.1.1. Routing"><div class="titlepage"><div><div><h4 class="title">3.10.1.1. Routing</h4></div></div></div><div class="para">Kommt ein Aufruf per HTTP rein, so wird die URL durch eine
        Routing-Engine verarbeitet. Diese wird durch die Datei
        <code class="filename">config/routes.rb</code> konfiguriert. Schauen wir noch
        mal rein. Diesmal mit allen Kommentaren.<pre class="programlisting">MovieApp::Application.routes.draw do |map|
  resources :movies

  get "example/test"

  # The priority is based upon order of creation:
  # first created -&gt; highest priority.

  # Sample of regular route:
  #   match 'products/:id' =&gt; 'catalog#view'
  # Keep in mind you can assign values other than :controller and :action

  # Sample of named route:
  #   match 'products/:id/purchase' =&gt; 'catalog#purchase', :as =&gt; :purchase
  # This route can be invoked with purchase_url(:id =&gt; product.id)

  # Sample resource route (maps HTTP verbs to controller actions automatically):
  #   resources :products

  # Sample resource route with options:
  #   resources :products do
  #     member do
  #       get :short
  #       post :toggle
  #     end
  #
  #     collection do
  #       get :sold
  #     end
  #   end

  # Sample resource route with sub-resources:
  #   resources :products do
  #     resources :comments, :sales
  #     resource :seller
  #   end

  # Sample resource route with more complex sub-resources
  #   resources :products do
  #     resources :comments
  #     resources :sales do
  #       get :recent, :on =&gt; :collection
  #     end
  #   end

  # Sample resource route within a namespace:
  #   namespace :admin do
  #     # Directs /admin/products/* to Admin::ProductsController
  #     # (app/controllers/admin/products_controller.rb)
  #     resources :products
  #   end

  # You can have the root of your site routed with "root"
  # just remember to delete public/index.html.
  # root :to =&gt; "welcome#index"

  # See how all your routes lay out with "rake routes"

  # This is a legacy wild controller route that's not recommended for RESTful applications.
  # Note: This route will make all actions in every controller accessible via GET requests.
  # match ':controller(/:action(/:id(.:format)))'
end</pre></div><div class="para">Die Priorität einer Route wird anhand ihrer Position in dieser
        Datei bestimmt. Es können also mehrere Regeln auf die gleiche Route
        matchen. Die am weitesten oben stehende gewinnt.</div><div class="para">In der Zeile 2 steht eine für unsere Applikation bis jetzt die
        wichtige Konfiguration:<pre class="programlisting">resources :movies</pre></div><div class="para">Sie sorgt dafür das automagisch die Anfragen mit der RESTful
        Logik an die Methoden <code class="methodname">index</code>,
        <code class="methodname">show</code>, <code class="methodname">new</code>,
        <code class="methodname">edit</code>, <code class="methodname">create</code>,
        <code class="methodname">update</code> und <code class="methodname">destroy</code>
        der Klasse <code class="classname">MoviesController</code> weitergeleitet
        werden.</div><div class="para">Diese Routen können wir uns mit <span class="command"><strong>rake routes</strong></span>
        anzeigen lassen.<pre class="screen">MacBook:movie-app sw$ <span class="command"><strong>rake routes</strong></span>
(in /Users/sw/Development/movie-app)
             GET    /movies(.:format)          {:action=&gt;"index", :controller=&gt;"movies"}
      movies POST   /movies(.:format)          {:action=&gt;"create", :controller=&gt;"movies"}
   new_movie GET    /movies/new(.:format)      {:action=&gt;"new", :controller=&gt;"movies"}
             GET    /movies/:id(.:format)      {:action=&gt;"show", :controller=&gt;"movies"}
             PUT    /movies/:id(.:format)      {:action=&gt;"update", :controller=&gt;"movies"}
       movie DELETE /movies/:id(.:format)      {:action=&gt;"destroy", :controller=&gt;"movies"}
  edit_movie GET    /movies/:id/edit(.:format) {:action=&gt;"edit", :controller=&gt;"movies"}
example_test GET    /example/test              {:controller=&gt;"example", :action=&gt;"test"}
MacBook:movie-app sw$</pre></div><div class="para">Diese Klasse wird in der Datei
        <code class="filename">app/controllers/movies_controller.rb</code> definiert.
        Schauen wir mal rein, was da bei der Methode
        <code class="methodname">show</code> steht:<pre class="programlisting">  # GET /movies/1
  # GET /movies/1.xml
  def show
    @movie = Movie.find(params[:id])

    respond_to do |format|
      format.html # show.html.erb
      format.xml  { render :xml =&gt; @movie }
    end
  end
</pre></div><div class="para">Direkt am Anfang wird die Instance-Variable
        <code class="varname">@movie</code> mit dem Ergebnis der Suche nach einer ID
        gefüllt (<code class="code">Movie.find(params[:id])</code>). Die :id finden Sie
        oben in den Routen. Der Hash params wird automatisch von Rails gefühlt
        und steht dem Programmierer im Controller zur Verfügung.</div><div class="para">hmmmm... was hat es mit diesem Hash <code class="varname">params[]</code>
        auf sich? Machen wir mal testweise die Abfrage <code class="uri"><a class="uri" href="http://0.0.0.0:3000/movies/1" target="">http://0.0.0.0:3000/movies/1</a></code>.
        Ich gehe mal davon aus, das Sie mittlerweile den dazu passenden
        Browser-Screenshot vor Ihrem virtuellen Auge haben. Falls nicht =&gt;
        <a class="xref" href="scaffolding.html#screenshot_show">???</a></div><div class="para">Und gleichzeitig schauen wir uns die Log-Ausgabe des Webservers
        an:<pre class="screen">Started GET "/movies/1" for 127.0.0.1 at 2010-04-05 10:49:59
  Processing by MoviesController#show as HTML
  Parameters: {"id"=&gt;"1"}
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.2ms)  SELECT "movies".* FROM "movies" WHERE ("movies"."id" = 1) LIMIT 1
Rendered movies/show.html.erb within layouts/movies (9.6ms)
Completed 200 OK in 30ms (Views: 12.5ms | ActiveRecord: 0.7ms)
</pre></div><div class="para">Da wird in der zweiten Zeile auf den Controller
        <code class="classname">MoviesController</code> und dort auf die Methode
        <code class="methodname">show</code> verwiesen
        (<code class="code">MoviesController#show</code>). Gleichzeitig wird ein Hash mit
        dem Namen <code class="varname">params[]</code> generiert und dort
        <code class="varname">params[:id]</code> auf 1 gesetzt.</div><div class="para">Danach wird überprüft, ob es sich um eine
        <code class="filename">.html</code> oder <code class="filename">.xml</code> Anfrage
        gehandelt hat. Wurde vom Browser nur <code class="filename">1</code> und nicht
        <code class="filename">1.html</code> abgefragt, setzt Rails den Default auf
        <code class="filename">.html</code>. In der Log-Ausgabe finden Sie den Eintrag
        "<code class="code">as HTML</code>".</div><div class="para">Was passiert als nächstes? Denken wir noch mal über das
        MCV-Model nach. Wir haben schon das Model
        (<code class="methodname">movies</code>) und wir haben den Controller
        (<code class="classname">MoviesController</code>). Was noch fehlt ist der View
        - also die Darstellung der Webseite. Die Views für unser Model finden
        sich alle im Unterverzeichnis
        <code class="filename">app/view/movies</code><pre class="screen">MacBook:movie-app sw$ <span class="command"><strong>ls app/views/movies</strong></span>
_form.html.erb edit.html.erb index.html.erb new.html.erb show.html.erb
MacBook:movie-app</pre></div><div class="para">Schauen wir uns mal die Datei <code class="filename">show.html.erb</code>
        an:<pre class="programlisting">&lt;p&gt;
  &lt;b&gt;Title:&lt;/b&gt;
  &lt;%= @movie.title %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Production year:&lt;/b&gt;
  &lt;%= @movie.production_year %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Duration:&lt;/b&gt;
  &lt;%= @movie.duration %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Plot:&lt;/b&gt;
  &lt;%= @movie.plot %&gt;
&lt;/p&gt;

&lt;p&gt;
  &lt;b&gt;Rating:&lt;/b&gt;
  &lt;%= @movie.rating %&gt;
&lt;/p&gt;


&lt;%= link_to 'Edit', edit_movie_path(@movie) %&gt; |
&lt;%= link_to 'Back', movies_path %&gt;
</pre></div><div class="para">Ist Ihnen aufgefallen, das bei dieser erb-Datei ja wichtige
        HTML-Elemente fehlen? Die sind in der Datei
        <code class="filename">app/views/layouts/movies.html.erb</code><pre class="programlisting">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;title&gt;Movies: &lt;%= controller.action_name %&gt;&lt;/title&gt;
  &lt;%= stylesheet_link_tag 'scaffold' %&gt;
  &lt;%= javascript_include_tag :defaults %&gt;
  &lt;%= csrf_meta_tag %&gt;
&lt;/head&gt;
&lt;body&gt;

&lt;p class="notice"&gt;&lt;%= notice %&gt;&lt;/p&gt;
&lt;p class="alert"&gt;&lt;%= alert %&gt;&lt;/p&gt;

&lt;%= yield %&gt;

&lt;/body&gt;
&lt;/html&gt;
</pre></div><div class="para">Das ist der Rahmen für alle Views des Models
        <code class="varname">movies</code>. Da es oft keinen Sinn macht für jedes Model
        ein eigenes Grundlayout zu generieren, kann man diese Datei auch
        löschen und stattdessen eine Datei
        <code class="filename">app/views/layouts/application.html.erb</code> mit dem
        Grundlayout erstellen. Die gilt dann für die gesamte
        Rails-Application. Die Zeile <code class="code">&lt;%= yield %&gt;</code> wird
        dabei immer von der aufzurufenden View-Datei ersetzt.</div></div></div><div class="section" title="3.10.2. Beispiel /movies (Index aller Datensätze)" id="dvd-index-html"><div class="titlepage"><div><div><h3 class="title">3.10.2. Beispiel /movies (Index aller Datensätze)</h3></div></div></div><div class="para">Da der Grundweg im letzten Segment erklärt wurde, gehe ich jetzt
      auf die schnelle durch die Anfrage <code class="uri"><a class="uri" href="http://localhost:3000/movies" target="">http://0.0.0.0:3000/movies</a></code>.
      Hier noch mal den Screenshot dazu:<div class="screenshot"><div class="mediaobject"><img src="screenshots/movies_index.jpg" width="500" /></div></div></div><div class="para">Im Log erscheint:<pre class="screen">Started GET "/movies" for 127.0.0.1 at 2010-04-05 11:02:42
  Processing by MoviesController#index as HTML
  SQL (0.5ms)   SELECT name
 FROM sqlite_master
 WHERE type = 'table' AND NOT name = 'sqlite_sequence'

  Movie Load (0.6ms)  SELECT "movies".* FROM "movies"
Rendered movies/index.html.erb within layouts/movies (28.2ms)
Completed 200 OK in 47ms (Views: 31.2ms | ActiveRecord: 1.1ms)
</pre></div><div class="para">Es geht also zu der Methode <code class="methodname">index</code> der
      Klasse <code class="classname">MoviesController</code>
      (<code class="code">MoviesController#index</code>). Diese Klasse wird in der Datei
      <code class="filename">app/controllers/movies_controller.rb</code> definiert.
      Schauen wir mal rein, was da bei der Methode
      <code class="methodname">index</code> steht:<pre class="programlisting">  # GET /movies
  # GET /movies.xml
  def index
    @movies = Movie.all

    respond_to do |format|
      format.html # index.html.erb
      format.xml  { render :xml =&gt; @movies }
    end
  end
</pre></div><div class="para">In der Instance-Variable <code class="varname">@movies</code> wird diesmal
      ein Array aus allen Datensätze die mit <code class="code">Movie.all</code> angezeigt
      werden gespeichert. Da es sich um eine html-Anfrage handelt wird als
      nächstes der View <code class="filename">app/views/movies/index.html.erb</code>
      gerendert. Ein Blick in diese erb-Datei:<pre class="programlisting">&lt;h1&gt;Listing movies&lt;/h1&gt;

&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Title&lt;/th&gt;
    &lt;th&gt;Production year&lt;/th&gt;
    &lt;th&gt;Duration&lt;/th&gt;
    &lt;th&gt;Plot&lt;/th&gt;
    &lt;th&gt;Rating&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
    &lt;th&gt;&lt;/th&gt;
  &lt;/tr&gt;

&lt;% @movies.each do |movie| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= movie.title %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.production_year %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.duration %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.plot %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= movie.rating %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Show', movie %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Edit', edit_movie_path(movie) %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= link_to 'Destroy', movie, :confirm =&gt; 'Are you sure?', :method =&gt; :delete %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
&lt;/table&gt;

&lt;br /&gt;

&lt;%= link_to 'New Movie', new_movie_path %&gt;
</pre></div><div class="para">In der Zeile "<code class="code">&lt;% @movies.each do |movie| %&gt;</code>"
      wird mit der Iternator-Methode <code class="methodname">each</code> das Array
      <code class="varname">@movies</code> Eintrag für Eintrag angezeigt. Jeder Eintrag
      wird dann für den Block in der lokalen Variable <code class="varname">movie</code>
      gespeichert und die wird dann im Block der mit "<code class="code">&lt;% end
      %&gt;</code>" endet dazu benutzt den Inhalt des Eintrages
      darzustellen.</div></div></div><ul class="docnav bottom"><li class="previous"><a accesskey="p" href="die_console.html"><strong>Zurück</strong>3.9. Die Console</a></li><li class="up"><a accesskey="u" href="#"><strong>Nach oben</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Zum Anfang</strong></a></li><li class="next"><a accesskey="n" href="model.html"><strong>Weiter</strong>Kapitel 4. Model - Das M in MVC.</a></li></ul></div><div class="clear"></div></div></div></body></html>
