<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>1:n und n:n Verknüpfungen</title>

  <section>
    <title>has_many (1:n)</title>

    <para>In unserer DVD-Datenbank möchten wir nicht nur die DVDs
    katalogisieren, sondern auch die Zeitpunkte, wann wir welche DVD zuletzt
    gesehen haben. Also eine klassische 1:n Datenbank-Struktur. Das Model
    nennen wir <methodname>showtime</methodname> und die Datenbank wird nur
    folgende Werte enthalten:<itemizedlist>
        <listitem>
          <para><code>dvd_id</code></para>

          <para>Das ist die ID der DVD.</para>
        </listitem>

        <listitem>
          <para><code>showtime</code></para>

          <para>Das ist die Uhrzeit der Vorführung.</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>showtime Scaffolding</title>

      <para>Scaffolding ist ja schon ein alter Hut für Sie:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate scaffold showtime dvd_id:integer showtime:datetime</command>
      exists  app/models/
      exists  app/controllers/
      exists  app/helpers/
      create  app/views/showtimes
      exists  app/views/layouts/
      exists  test/functional/
      exists  test/unit/
      exists  test/unit/helpers/
      exists  public/stylesheets/
      create  app/views/showtimes/index.html.erb
      create  app/views/showtimes/show.html.erb
      create  app/views/showtimes/new.html.erb
      create  app/views/showtimes/edit.html.erb
      create  app/views/layouts/showtimes.html.erb
   identical  public/stylesheets/scaffold.css
      create  app/controllers/showtimes_controller.rb
      create  test/functional/showtimes_controller_test.rb
      create  app/helpers/showtimes_helper.rb
      create  test/unit/helpers/showtimes_helper_test.rb
       route  map.resources :showtimes
  dependency  model
      exists    app/models/
      exists    test/unit/
      exists    test/fixtures/
      create    app/models/showtime.rb
      create    test/unit/showtime_test.rb
      create    test/fixtures/showtimes.yml
      exists    db/migrate
      create    db/migrate/20100102120720_create_showtimes.rb
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Aus reiner Neugierde noch mal kurz in die Migrationsdatei
      schauen:<screen>sw@debian:~/dvd-sammlung$ <command>cat db/migrate/20100102120720_create_showtimes.rb</command> 
class CreateShowtimes &lt; ActiveRecord::Migration
  def self.up
    create_table :showtimes do |t|
      t.integer :dvd_id
      t.datetime :showtime

      t.timestamps
    end
  end

  def self.down
    drop_table :showtimes
  end
end
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Und jetzt die Migrations starten:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreateShowtimes: migrating ================================================
-- create_table(:showtimes)
   -&gt; 0.0011s
==  CreateShowtimes: migrated (0.0022s) =======================================

sw@debian:~/dvd-sammlung$</screen></para>
    </section>

    <section>
      <title>1:n im Model einbauen</title>

      <para>Sie können es sich wahrscheinlich schon denken: Es gibt dafür
      fertige Methoden.</para>

      <section>
        <title>has_many</title>

        <para>In die Datei <filename>app/models/dvd.rb</filename> tragen Sie
        bitte folgenden Inhalt ein:<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes
end
</programlisting></para>
      </section>

      <section>
        <title>belongs_to</title>

        <para>In die Datei <filename>app/models/showtime.rb</filename> tragen
        Sie bitte diesen Inhalt ein:<programlisting>class Showtime &lt; ActiveRecord::Base
  belongs_to :dvd
end
</programlisting></para>
      </section>

      <section>
        <title>Das war alles?</title>

        <para>Ja, das war alles. Jetzt sind beide Datenbanken in der
        Rails-Application 1:n verknüpft. Und mit dieser Verknüpfung bekommen
        sowohl dvd wie auch showtime eine ganze Menge an praktischen Methoden.
        Ich zitiere mal ein Beispiel aus der Anzeige von <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command></para>

        <screen>     Example

     Example: A Firm class declares +has_many :clients+, which will add:

     *   +Firm#clients+ (similar to +Clients.find :all, :conditions =&gt;
         ["firm_id = ?", id]+)

     *   +Firm#clients&lt;&lt;+

     *   +Firm#clients.delete+

     *   +Firm#clients=+

     *   +Firm#client_ids+

     *   +Firm#client_ids=+

     *   +Firm#clients.clear+

     *   +Firm#clients.empty?+ (similar to +firm.clients.size == 0+)

     *   +Firm#clients.size+ (similar to +Client.count "firm_id =
         #{id}"+)

     *   +Firm#clients.find+ (similar to +Client.find(id, :conditions =&gt;
         "firm_id = #{id}")+)

     *   +Firm#clients.exists?(:name =&gt; 'ACME')+ (similar to
         +Client.exists?(:name =&gt; 'ACME', :firm_id =&gt; firm.id)+)

     *   +Firm#clients.build+ (similar to +Client.new("firm_id" =&gt; id)+)

     *   +Firm#clients.create+ (similar to +c = Client.new("firm_id" =&gt;
         id); c.save; c+)
</screen>

        <para>Damit beschäftigen wir uns gleich noch.</para>
      </section>

      <section>
        <title>Geht es noch besser?</title>

        <para>Ja, unser erster Wurf war die Default-Variante. Das kann man
        aber noch besser machen. Im dvd-Model können wir noch den Schalter
        <varname>dependent</varname> setzen, damit eine showtime beim Löschen
        eines Filmes auch direkt mitgelöscht wird. Die
        <filename>app/models/dvd.rb</filename> sieht dann so
        aus:<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes, :dependent =&gt; :destroy
end
</programlisting></para>
      </section>
    </section>

    <section>
      <title>In der Console</title>

      <para>Starten wir die Console und ziehen den ersten Datensatz aus der
      DVD-Tabelle:<screen>sw@debian:~/dvd-sammlung$ <command>./script/console</command> 
Loading development environment (Rails 2.3.5)
&gt;&gt; <command>terminator = Dvd.first</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 17:04:23", updated_at: "2009-12-25 17:04:23"&gt;
&gt;&gt;
</screen></para>

      <section>
        <title>Showtimes anzeigen</title>

        <para>Mal schauen, ob dieser Film schon mal angeschaut wurde:<screen>&gt;&gt; <command>terminator.showtimes</command>
=&gt; []
&gt;&gt;</screen></para>

        <para>Schauen wir uns mal an, was dazu im
        <filename>log/development.log</filename> steht:<programlisting>  Showtime Load (0.2ms)   SELECT * FROM "showtimes" WHERE ("showtimes".dvd_id = 1) 
</programlisting></para>

        <para>Rails stellt automagisch die optimale SQL-Anfrage für das
        gegebene Problem und gibt ein Array mit den showtimes zur angefragten
        DVD aus.</para>

        <para>ActiveRecord ist aber noch viel intelligenter! Wenn wir mit der
        Methode <methodname>count</methodname> das Anzahl der Einträge im
        Array rausfinden wollen, passiert das folgende:<screen>&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 0
&gt;&gt;</screen></para>

        <para>Interessant ist dabei das benutzte SQL:<programlisting>  SQL (0.6ms)   SELECT count(*) AS count_all FROM "showtimes" WHERE ("showtimes".dvd_id = 1) 
</programlisting></para>

        <para>Rails fragt also nicht erst das Array ab und zählt dann die
        Elemente (was reichlich Resourcenfressend wäre), sonder ist so
        intelligent die Anfrage auf den SQL-Server zu leiten. Der kann das
        Problem schneller und einfacher lösen.<note>
            <para>Rails nimmt einem viele Optimierungen ab. Deshalb sollte man
            immer versuchen mit den eingebauten Methoden und nicht mit eigenem
            SQL zu arbeiten. Allerdings sollte man bei der Entwicklung auch
            immer einen Blick auf die Log Datei werfen und sich den SQL-Code
            anschauen, um zu verstehen, was im Hintergrund abläuft.</para>
          </note></para>
      </section>

      <section>
        <title>Showtime hinzufügen</title>

        <para>Wenn wir vor 4 Stunden und vor einem Monat den Film angeschaut
        haben und die Einträge in der Console nachziehen wollen:<screen>&gt;&gt; <command>terminator.showtimes.create({:showtime =&gt; Time.now - 4.hours})</command>
=&gt; #&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;
&gt;&gt; <command>terminator.showtimes.create({:showtime =&gt; Time.now - 2.month})</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt;</screen></para>

        <tip>
          <para><code>4.hours</code> und <code>2.month</code> ist eingebaute
          Rails-Magie. Hier die entsprechende Hilfe mit weiteren
          Beispielen:<screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveSupport::CoreExtensions::Numeric::Time</command>
-------------------- Class: ActiveSupport::CoreExtensions::Numeric::Time
     Enables the use of time calculations and declarations, like
     45.minutes + 2.hours + 4.years.

     These methods use Time#advance for precise date calculations when
     using from_now, ago, etc. as well as adding or subtracting their
     results from a Time object. For example:

       # equivalent to Time.now.advance(:months =&gt; 1)
       1.month.from_now
     
       # equivalent to Time.now.advance(:years =&gt; 2)
       2.years.from_now
     
       # equivalent to Time.now.advance(:months =&gt; 4, :years =&gt; 5)
       (4.months + 5.years).from_now

     While these methods provide precise calculation when used as in the
     examples above, care should be taken to note that this is not true
     if the result of `months', `years', etc is converted before use:

       # equivalent to 30.days.to_i.from_now
       1.month.to_i.from_now
     
       # equivalent to 365.25.days.to_f.from_now
       1.year.to_f.from_now

     In such cases, Ruby's core
     Date[http://stdlib.rubyonrails.org/libdoc/date/rdoc/index.html] and
     Time[http://stdlib.rubyonrails.org/libdoc/time/rdoc/index.html]
     should be used for precision date and time arithmetic

------------------------------------------------------------------------


Instance methods:
-----------------

     ago, day, days, fortnight, fortnights, from_now, hour, hours,
     minute, minutes, second, seconds, since, until, week, weeks
sw@debian:~/dvd-sammlung$</screen></para>
        </tip>

        <para>Noch mal nachschauen, ob auch alles richtig gespeichert
        wurde:<screen>&gt;&gt; <command>terminator.showtimes</command>
=&gt; [#&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;, #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;]
&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 2
&gt;&gt;</screen></para>

        <para>Und schauen wir auch mal in die <modifier>showtimes</modifier>
        Datenbank:<screen>&gt;&gt; <command>Showtime.all</command>
=&gt; [#&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;, #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;]
&gt;&gt;</screen></para>
      </section>

      <section>
        <title>Showtime löschen</title>

        <para>Wenn wir den letzten Showtime Eintrag löschen wollen, dann geht
        das mit der <methodname>delete</methodname> Methode:<screen>&gt;&gt; <command>terminator.showtimes.last</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt; <command>terminator.showtimes.last.delete</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 1
&gt;&gt;</screen></para>
      </section>

      <section>
        <title>DVD zu einer Showtime suchen</title>

        <para>In der Datenbank haben wir als erste Showtime die folgende
        eingetragen:<screen>&gt;&gt; <command>Showtime.first</command>
=&gt; #&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;
&gt;&gt;</screen></para>

        <para>Wenn wir mit der "<code>dvd_id: 1</code>" aber nichts anfangen
        können und den Namen der DVD ausgeben möchten, dann können wir auf die
        neuen dvd-Methoden zugreifen:<screen>&gt;&gt; <command>Showtime.first.dvd</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 17:04:23", updated_at: "2009-12-25 17:04:23"&gt;
&gt;&gt;</screen></para>

        <para>Wir können uns natürlich auch direkt den Titel ausgeben
        lassen:<screen>&gt;&gt; <command>Showtime.first.dvd.title</command>
=&gt; "The Terminator"
&gt;&gt;</screen></para>
      </section>

      <section>
        <title>Beispiele</title>

        <para>Um das ganze ein wenig besser zu zeigen, benötigen wir eine
        Beispiel-Datenbank. Dazu benutzen wir die folgende
        <filename>db/seed.rb</filename> Datei:</para>
      </section>
    </section>
  </section>
</chapter>
