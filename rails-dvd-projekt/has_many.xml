<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>1:n und n:n Verknüpfungen</title>

  <section>
    <title>has_many (1:n)</title>

    <para>In unserer DVD-Datenbank möchten wir nicht nur die DVDs
    katalogisieren, sondern auch die Zeitpunkte, wann wir welche DVD zuletzt
    gesehen haben. Also eine klassische 1:n Datenbank-Struktur. Das Model
    nennen wir <methodname>showtime</methodname> und die Datenbank wird nur
    folgende Werte enthalten:<itemizedlist>
        <listitem>
          <para><code>dvd_id</code></para>

          <para>Das ist die ID der DVD.</para>
        </listitem>

        <listitem>
          <para><code>showtime</code></para>

          <para>Das ist die Uhrzeit der Vorführung.</para>
        </listitem>
      </itemizedlist></para>

    <section>
      <title>showtime Scaffolding</title>

      <para>Scaffolding ist ja schon ein alter Hut für Sie:<screen>sw@debian:~/dvd-sammlung$ <command>./script/generate scaffold showtime dvd_id:integer showtime:datetime</command>
      exists  app/models/
      exists  app/controllers/
      exists  app/helpers/
      create  app/views/showtimes
      exists  app/views/layouts/
      exists  test/functional/
      exists  test/unit/
      exists  test/unit/helpers/
      exists  public/stylesheets/
      create  app/views/showtimes/index.html.erb
      create  app/views/showtimes/show.html.erb
      create  app/views/showtimes/new.html.erb
      create  app/views/showtimes/edit.html.erb
      create  app/views/layouts/showtimes.html.erb
   identical  public/stylesheets/scaffold.css
      create  app/controllers/showtimes_controller.rb
      create  test/functional/showtimes_controller_test.rb
      create  app/helpers/showtimes_helper.rb
      create  test/unit/helpers/showtimes_helper_test.rb
       route  map.resources :showtimes
  dependency  model
      exists    app/models/
      exists    test/unit/
      exists    test/fixtures/
      create    app/models/showtime.rb
      create    test/unit/showtime_test.rb
      create    test/fixtures/showtimes.yml
      exists    db/migrate
      create    db/migrate/20100102120720_create_showtimes.rb
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Aus reiner Neugierde noch mal kurz in die Migrationsdatei
      schauen:<screen>sw@debian:~/dvd-sammlung$ <command>cat db/migrate/20100102120720_create_showtimes.rb</command> 
class CreateShowtimes &lt; ActiveRecord::Migration
  def self.up
    create_table :showtimes do |t|
      t.integer :dvd_id
      t.datetime :showtime

      t.timestamps
    end
  end

  def self.down
    drop_table :showtimes
  end
end
sw@debian:~/dvd-sammlung$</screen></para>

      <para>Und jetzt die Migrations starten:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:migrate</command>
(in /home/sw/dvd-sammlung)
==  CreateShowtimes: migrating ================================================
-- create_table(:showtimes)
   -&gt; 0.0011s
==  CreateShowtimes: migrated (0.0022s) =======================================

sw@debian:~/dvd-sammlung$</screen></para>
    </section>

    <section>
      <title>1:n im Model einbauen</title>

      <para>Sie können es sich wahrscheinlich schon denken: Es gibt dafür
      fertige Methoden.</para>

      <section>
        <title>has_many</title>

        <para>In die Datei <filename>app/models/dvd.rb</filename> tragen Sie
        bitte folgenden Inhalt ein:<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes
end
</programlisting></para>
      </section>

      <section>
        <title>belongs_to</title>

        <para>In die Datei <filename>app/models/showtime.rb</filename> tragen
        Sie bitte diesen Inhalt ein:<programlisting>class Showtime &lt; ActiveRecord::Base
  belongs_to :dvd
end
</programlisting></para>
      </section>

      <section>
        <title>Das war alles?</title>

        <para>Ja, das war alles. Jetzt sind beide Datenbanken in der
        Rails-Application 1:n verknüpft. Und mit dieser Verknüpfung bekommen
        sowohl dvd wie auch showtime eine ganze Menge an praktischen Methoden.
        Ich zitiere mal ein Beispiel aus der Anzeige von <command>ri
        ActiveRecord::Associations::ClassMethods#has_many</command></para>

        <screen>     Example

     Example: A Firm class declares +has_many :clients+, which will add:

     *   +Firm#clients+ (similar to +Clients.find :all, :conditions =&gt;
         ["firm_id = ?", id]+)

     *   +Firm#clients&lt;&lt;+

     *   +Firm#clients.delete+

     *   +Firm#clients=+

     *   +Firm#client_ids+

     *   +Firm#client_ids=+

     *   +Firm#clients.clear+

     *   +Firm#clients.empty?+ (similar to +firm.clients.size == 0+)

     *   +Firm#clients.size+ (similar to +Client.count "firm_id =
         #{id}"+)

     *   +Firm#clients.find+ (similar to +Client.find(id, :conditions =&gt;
         "firm_id = #{id}")+)

     *   +Firm#clients.exists?(:name =&gt; 'ACME')+ (similar to
         +Client.exists?(:name =&gt; 'ACME', :firm_id =&gt; firm.id)+)

     *   +Firm#clients.build+ (similar to +Client.new("firm_id" =&gt; id)+)

     *   +Firm#clients.create+ (similar to +c = Client.new("firm_id" =&gt;
         id); c.save; c+)
</screen>

        <para>Damit beschäftigen wir uns gleich noch.</para>
      </section>

      <section>
        <title>Geht es noch besser?</title>

        <para>Ja, unser erster Wurf war die Default-Variante. Das kann man
        aber noch besser machen. Im dvd-Model können wir noch den Schalter
        <varname>dependent</varname> setzen, damit eine showtime beim Löschen
        eines Filmes auch direkt mitgelöscht wird. Die
        <filename>app/models/dvd.rb</filename> sieht dann so
        aus:<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes, :dependent =&gt; :destroy
end
</programlisting></para>
      </section>
    </section>

    <section>
      <title>In der Console</title>

      <para>Starten wir die Console und ziehen den ersten Datensatz aus der
      DVD-Tabelle:<screen>sw@debian:~/dvd-sammlung$ <command>./script/console</command> 
Loading development environment (Rails 2.3.5)
&gt;&gt; <command>terminator = Dvd.first</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 17:04:23", updated_at: "2009-12-25 17:04:23"&gt;
&gt;&gt;
</screen></para>

      <section>
        <title>Showtimes anzeigen</title>

        <para>Mal schauen, ob dieser Film schon mal angeschaut wurde:<screen>&gt;&gt; <command>terminator.showtimes</command>
=&gt; []
&gt;&gt;</screen></para>

        <para>Schauen wir uns mal an, was dazu im
        <filename>log/development.log</filename> steht:<programlisting>  Showtime Load (0.2ms)   SELECT * FROM "showtimes" WHERE ("showtimes".dvd_id = 1) 
</programlisting></para>

        <para>Rails stellt automagisch die optimale SQL-Anfrage für das
        gegebene Problem und gibt ein Array mit den showtimes zur angefragten
        DVD aus.</para>

        <para>ActiveRecord ist aber noch viel intelligenter! Wenn wir mit der
        Methode <methodname>count</methodname> das Anzahl der Einträge im
        Array rausfinden wollen, passiert das folgende:<screen>&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 0
&gt;&gt;</screen></para>

        <para>Interessant ist dabei das benutzte SQL:<programlisting>  SQL (0.6ms)   SELECT count(*) AS count_all FROM "showtimes" WHERE ("showtimes".dvd_id = 1) 
</programlisting></para>

        <para>Rails fragt also nicht erst das Array ab und zählt dann die
        Elemente (was reichlich Resourcenfressend wäre), sonder ist so
        intelligent die Anfrage auf den SQL-Server zu leiten. Der kann das
        Problem schneller und einfacher lösen.<note>
            <para>Rails nimmt einem viele Optimierungen ab. Deshalb sollte man
            immer versuchen mit den eingebauten Methoden und nicht mit eigenem
            SQL zu arbeiten. Allerdings sollte man bei der Entwicklung auch
            immer einen Blick auf die Log Datei werfen und sich den SQL-Code
            anschauen, um zu verstehen, was im Hintergrund abläuft.</para>
          </note></para>
      </section>

      <section>
        <title>Showtime hinzufügen</title>

        <para>Wenn wir vor 4 Stunden und vor einem Monat den Film angeschaut
        haben und die Einträge in der Console nachziehen wollen:<screen>&gt;&gt; <command>terminator.showtimes.create({:showtime =&gt; Time.now - 4.hours})</command>
=&gt; #&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;
&gt;&gt; <command>terminator.showtimes.create({:showtime =&gt; Time.now - 2.month})</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt;</screen></para>

        <tip>
          <para><code>4.hours</code> und <code>2.month</code> ist eingebaute
          Rails-Magie. Hier die entsprechende Hilfe mit weiteren
          Beispielen:<screen>sw@debian:~/dvd-sammlung$ <command>ri ActiveSupport::CoreExtensions::Numeric::Time</command>
-------------------- Class: ActiveSupport::CoreExtensions::Numeric::Time
     Enables the use of time calculations and declarations, like
     45.minutes + 2.hours + 4.years.

     These methods use Time#advance for precise date calculations when
     using from_now, ago, etc. as well as adding or subtracting their
     results from a Time object. For example:

       # equivalent to Time.now.advance(:months =&gt; 1)
       1.month.from_now
     
       # equivalent to Time.now.advance(:years =&gt; 2)
       2.years.from_now
     
       # equivalent to Time.now.advance(:months =&gt; 4, :years =&gt; 5)
       (4.months + 5.years).from_now

     While these methods provide precise calculation when used as in the
     examples above, care should be taken to note that this is not true
     if the result of `months', `years', etc is converted before use:

       # equivalent to 30.days.to_i.from_now
       1.month.to_i.from_now
     
       # equivalent to 365.25.days.to_f.from_now
       1.year.to_f.from_now

     In such cases, Ruby's core
     Date[http://stdlib.rubyonrails.org/libdoc/date/rdoc/index.html] and
     Time[http://stdlib.rubyonrails.org/libdoc/time/rdoc/index.html]
     should be used for precision date and time arithmetic

------------------------------------------------------------------------


Instance methods:
-----------------

     ago, day, days, fortnight, fortnights, from_now, hour, hours,
     minute, minutes, second, seconds, since, until, week, weeks
sw@debian:~/dvd-sammlung$</screen></para>
        </tip>

        <para>Noch mal nachschauen, ob auch alles richtig gespeichert
        wurde:<screen>&gt;&gt; <command>terminator.showtimes</command>
=&gt; [#&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;, #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;]
&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 2
&gt;&gt;</screen></para>

        <para>Und schauen wir auch mal in die <modifier>showtimes</modifier>
        Datenbank:<screen>&gt;&gt; <command>Showtime.all</command>
=&gt; [#&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;, #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;]
&gt;&gt;</screen></para>

        <para>Sie können auch gleichzeit eine DVD und eine Showtime
        hinzufügen:<screen>&gt;&gt; <command>Dvd.create({:title =&gt; 'Top Gun'}).showtimes.create({:showtime =&gt; Time.now - 10.years})</command>
=&gt; #&lt;Showtime id: 6, dvd_id: 20, showtime: "2000-01-02 13:42:47", created_at: "2010-01-02 13:42:47", updated_at: "2010-01-02 13:42:47"&gt;
&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 20, title: "Top Gun", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:42:47", updated_at: "2010-01-02 13:42:47"&gt;
&gt;&gt; <command>Dvd.last.showtimes</command>
=&gt; [#&lt;Showtime id: 6, dvd_id: 20, showtime: "2000-01-02 13:42:47", created_at: "2010-01-02 13:42:47", updated_at: "2010-01-02 13:42:47"&gt;]
&gt;&gt;</screen></para>

        <para>Und Sie können natürlich auch mehrere Showtimes zu einer neuen
        DVD hinzufügen. Bitte achten Sie auf die Klammern, denn mehrere
        Showtimes werden in einem Array übergeben:<screen>&gt;&gt; <command>Dvd.create({:title =&gt; 'Some like it hot.'}).showtimes.create([{:showtime =&gt; Time.now - 20.years}, {:showtime =&gt; Time.now - 25.years}, {:showtime =&gt; Time.now - 30.years}])</command>
=&gt; [#&lt;Showtime id: 7, dvd_id: 21, showtime: "1990-01-02 13:47:15", created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;, #&lt;Showtime id: 8, dvd_id: 21, showtime: "1985-01-02 13:47:15", created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;, #&lt;Showtime id: 9, dvd_id: 21, showtime: "1980-01-02 13:47:15", created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;]
&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 21, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:47:15", updated_at: "2010-01-02 13:47:15"&gt;
&gt;&gt; <command>Dvd.last.showtimes.count</command>
=&gt; 3
&gt;&gt;</screen>Für die letzten drei Befehle noch die Ausgabe von
        <filename>log/development.log</filename>:<programlisting>  Dvd Create (0.7ms)   INSERT INTO "dvds" ("title", "production_year", "duration", "plot", "rating", "created_at", "updated_at") VALUES('Some like it hot.', NULL, NULL, NULL, NULL, '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Showtime Create (0.2ms)   INSERT INTO "showtimes" ("dvd_id", "showtime", "created_at", "updated_at") VALUES(21, '1990-01-02 13:47:15', '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Showtime Create (0.1ms)   INSERT INTO "showtimes" ("dvd_id", "showtime", "created_at", "updated_at") VALUES(21, '1985-01-02 13:47:15', '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Showtime Create (0.1ms)   INSERT INTO "showtimes" ("dvd_id", "showtime", "created_at", "updated_at") VALUES(21, '1980-01-02 13:47:15', '2010-01-02 13:47:15', '2010-01-02 13:47:15')
  Dvd Load (0.3ms)   SELECT * FROM "dvds" ORDER BY dvds.id DESC LIMIT 1
  Dvd Load (0.3ms)   SELECT * FROM "dvds" ORDER BY dvds.id DESC LIMIT 1
  SQL (0.2ms)   SELECT count(*) AS count_all FROM "showtimes" WHERE ("showtimes".dvd_id = 21) 
</programlisting></para>
      </section>

      <section>
        <title>Showtime löschen</title>

        <para>Wenn wir den letzten Showtime Eintrag löschen wollen, dann geht
        das mit der <methodname>delete</methodname> Methode:<screen>&gt;&gt; <command>terminator.showtimes.last</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt; <command>terminator.showtimes.last.delete</command>
=&gt; #&lt;Showtime id: 2, dvd_id: 1, showtime: "2009-11-02 13:00:20", created_at: "2010-01-02 13:00:20", updated_at: "2010-01-02 13:00:20"&gt;
&gt;&gt; <command>terminator.showtimes.count</command>
=&gt; 1
&gt;&gt;</screen></para>

        <section>
          <title>DVD mit damit verknüpften Showtimes löschen</title>

          <para>Da wir in der <filename>app/models/dvd.rb</filename> das
          has_many mit der Dependency destroy erweitert haben
          ...<programlisting>class Dvd &lt; ActiveRecord::Base
  has_many :showtimes, :dependent =&gt; :destroy
end
</programlisting>... brauchen wir uns bei einem destroy keine Gedanken zu
          machen. Rails übernimmt das für uns.</para>

          <para>Löschen wir den eben angelegten Film mit all seinen
          Showtimes:<screen>&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 22, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:56:15", updated_at: "2010-01-02 13:56:15"&gt;
&gt;&gt; <command>Dvd.last.showtimes.count</command>
=&gt; 3
&gt;&gt; <command>Dvd.last.destroy</command>
=&gt; #&lt;Dvd id: 22, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:56:15", updated_at: "2010-01-02 13:56:15"&gt;
&gt;&gt; <command>Showtime.find_all_by_dvd_id(22).count</command>
=&gt; 0
&gt;&gt;</screen></para>

          <warning>
            <para>Bitte beachten Sie hierbei den Unterschied zwischen den
            Methoden <methodname>destroy</methodname> und
            <methodname>delete</methodname>! Nur die Methode destroy löst alle
            Abhängigkeiten auf.</para>

            <para>Beispiel für <methodname>delete</methodname>. Hierbei wird
            die DVD gelöscht, aber die Showtimes bleiben als Zombies in der
            Datenbank.<screen>&gt;&gt; <command>Dvd.create({:title =&gt; 'Some like it hot.'}).showtimes.create([{:showtime =&gt; Time.now - 20.years}, {:showtime =&gt; Time.now - 25.years}, {:showtime =&gt; Time.now - 30.years}])</command>
=&gt; [#&lt;Showtime id: 13, dvd_id: 23, showtime: "1990-01-02 13:59:50", created_at: "2010-01-02 13:59:50", updated_at: "2010-01-02 13:59:50"&gt;, #&lt;Showtime id: 14, dvd_id: 23, showtime: "1985-01-02 13:59:50", created_at: "2010-01-02 13:59:50", updated_at: "2010-01-02 13:59:50"&gt;, #&lt;Showtime id: 15, dvd_id: 23, showtime: "1980-01-02 13:59:50", created_at: "2010-01-02 13:59:50", updated_at: "2010-01-02 13:59:50"&gt;]
&gt;&gt; <command>Dvd.last</command>
=&gt; #&lt;Dvd id: 23, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:59:49", updated_at: "2010-01-02 13:59:49"&gt;
&gt;&gt; <command>Dvd.last.showtimes.count</command>
=&gt; 3
&gt;&gt; <command>Dvd.last.delete</command>
=&gt; #&lt;Dvd id: 23, title: "Some like it hot.", production_year: nil, duration: nil, plot: nil, rating: nil, created_at: "2010-01-02 13:59:49", updated_at: "2010-01-02 13:59:49"&gt;
&gt;&gt; <command>Showtime.find_all_by_dvd_id(23).count</command>
=&gt; 3
&gt;&gt;</screen></para>
          </warning>
        </section>
      </section>

      <section>
        <title>DVD zu einer Showtime suchen</title>

        <para>In der Datenbank haben wir als erste Showtime die folgende
        eingetragen:<screen>&gt;&gt; <command>Showtime.first</command>
=&gt; #&lt;Showtime id: 1, dvd_id: 1, showtime: "2010-01-02 08:59:20", created_at: "2010-01-02 12:59:20", updated_at: "2010-01-02 12:59:20"&gt;
&gt;&gt;</screen></para>

        <para>Wenn wir mit der "<code>dvd_id: 1</code>" aber nichts anfangen
        können und den Namen der DVD ausgeben möchten, dann können wir auf die
        neuen dvd-Methoden zugreifen:<screen>&gt;&gt; <command>Showtime.first.dvd</command>
=&gt; #&lt;Dvd id: 1, title: "The Terminator", production_year: 1984, duration: nil, plot: nil, rating: nil, created_at: "2009-12-25 17:04:23", updated_at: "2009-12-25 17:04:23"&gt;
&gt;&gt;</screen></para>

        <para>Wir können uns natürlich auch direkt den Titel ausgeben
        lassen:<screen>&gt;&gt; <command>Showtime.first.dvd.title</command>
=&gt; "The Terminator"
&gt;&gt;</screen></para>
      </section>

      <section>
        <title>Weitere Beispiele</title>

        <para>Um das ganze ein wenig besser zu zeigen, benötigen wir eine
        Beispiel-Datenbank. Dazu benutzen wir die folgende
        <filename>db/seed.rb</filename> Datei:<programlisting># This file should contain all the record creation needed to seed the database with its default values.
# The data can then be loaded with the rake db:seed (or created alongside the db with db:setup).
#
# Examples:
#   
#   cities = City.create([{ :name =&gt; 'Chicago' }, { :name =&gt; 'Copenhagen' }])
#   Major.create(:name =&gt; 'Daley', :city =&gt; cities.first)

Dvd.create({ :title =&gt; 'The Terminator', :production_year =&gt; 1984 }).showtimes.create([{:showtime =&gt; Time.now - 1.year},{:showtime =&gt; Time.now - 20.days}])
Dvd.create({ :title =&gt; 'Terminator 2', :production_year =&gt; 1992 }).showtimes.create([{:showtime =&gt; Time.now - 1.year},{:showtime =&gt; Time.now - 2.months},{:showtime =&gt; Time.now - 20.days}])
Dvd.create({ :title =&gt; 'Terminator Salvation', :production_year =&gt; 2009 })
Dvd.create({ :title =&gt; 'Rain Man', :production_year =&gt; 1988, :rating =&gt; 5 }).showtimes.create([{:showtime =&gt; Time.now - 2.year},{:showtime =&gt; Time.now - 3.months},{:showtime =&gt; Time.now - 18.days - 2.hours}]
)
Dvd.create({ :title =&gt; 'War of the Worlds', :production_year =&gt; 2005, :rating =&gt; 4 })
Dvd.create({ :title =&gt; 'Collateral', :production_year =&gt; 2004, :rating =&gt; 5}).showtimes.create({:showtime =&gt; Time.now - 1.year}) 
Dvd.create({ :title =&gt; 'Miami Vice', :production_year =&gt; 2006, :rating =&gt; 5})
Dvd.create({ :title =&gt; 'Hancock', :production_year =&gt; 2008, :rating =&gt;  4})
Dvd.create({ :title =&gt; 'The Aviator', :production_year =&gt; 2004, :rating =&gt;  4})
Dvd.create({ :title =&gt; 'Some Like It Hot', :production_year =&gt; 1959, :rating =&gt;  5})
Dvd.create({ :title =&gt; 'W.', :production_year =&gt; 2008, :rating =&gt;  4})
Dvd.create({ :title =&gt; 'Iron Man', :production_year =&gt; 2008, :rating =&gt;  5})
Dvd.create({ :title =&gt; 'The Dark Knight', :production_year =&gt; 2008, :rating =&gt;  5})
</programlisting></para>

        <para>Bitte mit <command>rake db:reset</command> einspielen:<screen>sw@debian:~/dvd-sammlung$ <command>rake db:reset</command>
(in /home/sw/dvd-sammlung)
db/development.sqlite3 already exists
-- create_table("dvds", {:force=&gt;true})
   -&gt; 0.0760s
-- create_table("showtimes", {:force=&gt;true})
   -&gt; 0.0463s
-- initialize_schema_migrations_table()
   -&gt; 0.0171s
-- assume_migrated_upto_version(20100102120720)
   -&gt; 0.0054s
sw@debian:~/dvd-sammlung$</screen></para>

        <section>
          <title></title>

          <para></para>
        </section>

        <section>
          <title></title>

          <para></para>
        </section>
      </section>
    </section>
  </section>
</chapter>
