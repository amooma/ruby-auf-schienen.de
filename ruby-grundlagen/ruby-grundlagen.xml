<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Ruby Grundlagen</title>

  <para>Genauso wie dieses Buch Grundkenntnisse in HTML vorraussetzt, so muss
  der Leser auch ein Grundverständnis von Programmierung mitbringen.
  Allerdings schreibt schon der Ruby-Erfinder Yukihiro Matsumoto in seinem
  Buch "The Ruby Programming Language"<footnote>
      <para>Das Buch ist sehr empfehlenswert für jeden der Ruby verstehen
      will.</para>
    </footnote>: </para>

  <para><quote>It is easy to program in Ruby, but Ruby is not a simple
  language.</quote></para>

  <para>Dieses Kapitel ist eine Gradwanderung zwischen falscher Vereinfachung
  und unnötiger Ausführlichkeit. Es geht ja nicht darum ein Ruby-Guru zu
  werden, sondern Rails zu verstehen. Ich kann Ihnen nicht versprechen, das
  Sie nach diesem Kapitel alles verstehen. Ich kann Ihnen auch nicht
  versprechen, das es gerade in diesem Kapitel nicht auch ein wenig holprig
  zugehen. Ich kann Ihnen aber versprechen, das sich die Lektüre lohnt.
  </para>

  <para>Ich habe lange den Fehler gemacht und versucht mit Rails zu arbeiten,
  ohne eine Ahnung von Ruby zu haben. Ruby sah so einfach aus und deshalb habe
  ich mir keine Gedanken darüber gemacht. Da ich aber Ruby nicht verstand,
  konnte ich auch Rails nicht verstehen. Deshalb habe ich es immer wieder in
  die virtuelle Ecke gelegt und weiter mit PHP gearbeitet. Erst nachdem ich
  mir Ruby intensiv angeschaut hatte, viel der Groschen. Heute bin ich so ein
  grosser Ruby und Rails Fan, das ich mir sogar die Mühe mache dazu ein Buch
  zu schreiben, um es Ihnen näher zu bringen.</para>

  <section>
    <title>Eine Skriptsprache</title>

    <para>Ruby ist eine Skriptsprache. Es wird also nicht kompiliert und dann
    ausgeführt, sondern von einem Interpreter eingelesen und dann Zeile für
    Zeile abgearbeitet.</para>
  </section>

  <section>
    <title>Hello World</title>

    <para>Ein einfaches Ruby <filename>hello-world.rb</filename> Programm
    besteht aus folgender Zeile:<programlisting>puts 'Hello World!'
</programlisting></para>

    <para>Und kann auf der Kommandozeile wie folgt aufgerufen werden:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!
sw@debian:~/sandbox$ </screen></para>

    <section>
      <title>puts und print</title>

      <para>Wer im Internet nach Beispiel zu Ruby sucht, findet zwei typische
      Möglichkeiten Bildschirmausgaben zu starten:<itemizedlist>
          <listitem>
            <para><application>puts</application></para>

            <para>Gibt einen String aus und bendet die Ausgabe mit einer
            Zeilenschaltung.</para>
          </listitem>

          <listitem>
            <para><application>print</application></para>

            <para>Gibt einen String aus und bendet die Ausgabe nicht mit einer
            Zeilenschaltung. Sollte der String selber eine Zeilenschaltung
            enthalten, so wird diese normal ausgeben.</para>
          </listitem>
        </itemizedlist>Beispielprogramm (eine Erweiterung des
      <filename>hello-world.rb</filename> Programmes):<programlisting>puts 'Hello World!'
puts
puts '------------'
print 'Hello World!'
print
puts '------------'
</programlisting>Die dazu gehörige Bildschirmausgabe:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!

------------
Hello World!------------
sw@debian:~/sandbox$</screen></para>
    </section>
  </section>

  <section>
    <title>irb</title>

    <para><acronym>irb</acronym> steht für Interactive Ruby Shell und ist eine
    Art Sandbox in der man beliebig mit Ruby rumspielen kann. irb wird mit der
    Eingabe von <command>irb</command> auf der Shell gestartet und durch
    Eingabe von <command>exit</command> wieder beendet. </para>

    <para>Ein Beispiel sagt mehr als tausend Worte:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):003:0&gt; <command>exit</command>
sw@debian:~/sandbox$ </screen></para>

    <para>In diesem Kapitel werden viele Beispiele innerhalb von
    <application>irb</application> erarbeitet. Sie werden auch später bei der
    Arbeit oft innerhalb von irb neue Sachen ausprobieren, weil es so herlich
    schnell und unkompliziert ist.</para>
  </section>

  <section>
    <title>Kommentare</title>

    <para>Ein Kommentar in einem Ruby-Programm wird mit einem
    <code>#</code>-Zeichen eingeleitet und von einer Zeilenendschaltung
    beendet. Als Beispiel erweitere ich das obige
    <filename>hello-world.rb</filename> um einen Kommentar.<programlisting># Programm zum Anzeigen von "Hello World!"
# by Stefan Wintermeyer

puts 'Hello World!'</programlisting></para>

    <para>Ein Kommentar kann auch nach einer Programmzeile
    stehen:<programlisting># Programm zum Anzeigen von "Hello World!"
# by Stefan Wintermeyer

puts 'Hello World!' # Ausgabe</programlisting></para>

    <para>Ein #-Zeichen innerhalb von Anführungszeichen wird nicht als Anfang
    eines Kommentars behandelt. Beispielprogramm:<programlisting># Beispielprogramm
# by Stefan Wintermeyer

puts 'Hello World!'
puts '############'
puts
puts '1#2#3#4#5#6#' # Kommentar dazu
</programlisting> Die Bildschirmausgabe dazu:<screen>sw@debian:~/sandbox$ <command>ruby hello-world.rb</command> 
Hello World!
############

1#2#3#4#5#6#
sw@debian:~/sandbox$</screen></para>

    <section>
      <title>Kommentare im irb</title>

      <para>Kommentar innerhalb von irb machen logischweise selten richtig
      Sinn, da in irb erarbeiteter Code quasi Wegwerf-Code ist. Innerhalb
      dieses Buches werden aber immer mal wieder Kommentare zur Erklärung auch
      im irb benutzt. Diese können Sie problemlos mit kopieren und im irb
      einfügen.</para>
    </section>
  </section>

  <section>
    <title>Ruby ist Objekt-orientiert</title>

    <para>Ruby kennt nur Objekte. Alles ist ein Objekt (was ja fast schon
    zen-artig ist). Jedes Objekt ist eine Instance einer Klasse. Die Class
    eines Objektes lässt sich mit der Methode <code>.class</code>
    rausfinden.</para>

    <para>Ein Objekt in Ruby ist eingekapselt und kann von Aussen nur mit den
    Methoden des entsprechenden Objektes erreicht werden. Was das heißt? Ich
    kann von Aussen keine Variable in einem Objekt dirket verändern. Das
    entsprechende Objekt muss mir dafür eine Methode zur Verfügung
    stellen.</para>

    <important>
      <para>Sie haben keine Ahnung was eine Class und was ein Objekt ist?
      Keine Panik! Ich werde es keinem erzählen und man kann auch ganz gut
      damit arbeiten, ohne sich grosse Gedanken darüber zu machen - Mit dem
      Thema alleine könnte man ein ganzes Buch füllen. Ganz grob: Eine Class
      ist ein Container für irgendwas und eine Methode verändert etwas in
      diesem Container.</para>

      <para>Lesen Sie bitte weiter und schauen Sie sich die Beispiele an.
      Stück für Stück wird das Puzzle dann klarer.</para>
    </important>

    <section>
      <title>Methoden</title>

      <para>In anderen Programmiersprachen würden man zu Ruby-Methoden
      Begriffe wie die folgenen verwenden:<itemizedlist>
          <listitem>
            <para>Funktionen</para>
          </listitem>

          <listitem>
            <para>Prozeduren</para>
          </listitem>

          <listitem>
            <para>Subroutinen</para>
          </listitem>

          <listitem>
            <para>Makros</para>
          </listitem>
        </itemizedlist></para>

      <para>Da Ruby objektorientiert angelegt ist, sind es in Ruby halt
      Methoden. Man darf sich da an dem Namen nicht stören.<note>
          <para>Es gibt zwei Arten von Methoden (Class Method und Instance
          Method). Ich will es an dieser Stelle nicht zu kompliziert machen
          und übergehe diese "Feinheit" einfach mal.</para>
        </note></para>

      <para>An so einer Stelle sucht man immer nach einem guten Beispiel, aber
      es fallen nur eigentlich unsinnige Beispiele ein. Das Problem ist dabei
      die Prämisse, das man nur Wissen benutzen kann/darf, das bis zu dieser
      Stelle schon im Buch beschrieben wurde.</para>

      <para>Nehmen wir also an, das wir folgenden Code-Ablauf aus welchem
      Grund auch immer häufig verwenden:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):002:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):003:0&gt; <command>puts 'Hello World!'</command>
Hello World!
=&gt; nil
irb(main):004:0&gt; <command>exit</command>
</screen></para>

      <para>Wir möchten also drei mal hintereinander den String 'Hello World!'
      ausgeben. Da dies unseren täglichen Arbeitsablauf stark in die Länge
      zieht, definieren wir jetzt eine Methode (mit dem sinnfreien Namen
      <methodname>drei_mal</methodname>), mit der man das alles auf einmal
      machen kann.<important>
          <para>Namen von Methoden fangen immer kleingeschrieben.</para>
        </important><screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>def drei_mal</command>  # Start der Definition
irb(main):002:1&gt; <command>puts 'Hello World!'</command>
irb(main):003:1&gt; <command>puts 'Hello World!'</command>
irb(main):004:1&gt; <command>puts 'Hello World!'</command>
irb(main):005:1&gt; <command>end</command>           # Ende der Definition
=&gt; nil
irb(main):006:0&gt; <command>drei_mal</command>      # Aufruf der Methode
Hello World!
Hello World!
Hello World!
=&gt; nil
irb(main):007:0&gt; <command>exit</command>
</screen></para>

      <para>Bei der Definition eines Moduls kann man benötigte Parameter
      definieren und diese innerhalb des Moduls benutzen. Damit können wir
      eine Methode erstellen, der wir einen String als Parameter übergeben und
      den dann drei mal ausgeben lassen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>def drei_mal(dummy)</command> # Parameter: dummy
irb(main):002:1&gt; <command>puts dummy</command>
irb(main):003:1&gt; <command>puts dummy</command>
irb(main):004:1&gt; <command>puts dummy</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>drei_mal('Hello World!')</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
</screen></para>

      <para>Die Klammern beim Aufruf kann man sich übrigens sparen. <screen>irb(main):007:0&gt; <command>drei_mal 'Hello World!'</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
</screen></para>

      <tip>
        <para>Ruby-Gurus und Möchte-Gern-Ruby-Gurus werden über "unnötige"
        Klammern in Ihren Programmen die Nase rüpfen und wahrscheinlich mehr
        oder weniger blöde Kommentare mit Vergleichen zu Java und anderen
        Programmiersprachen machen.</para>

        <para>Es gilt in der Ruby-Community eine einfache Regel: Je weniger
        Klammern, desto cooler! ;-)</para>
      </tip>

      <para>Und wenn man keinen Parameter angibt, kommt die Fehlermeldung:
      <code>wrong number of arguments</code><screen>irb(main):008:0&gt; <command>drei_mal</command>
ArgumentError: wrong number of arguments (0 for 1)
 from (irb):8
 from /usr/local/bin/irb:12:in `&lt;main&gt;'
irb(main):009:0&gt; <command>exit</command>
</screen></para>
    </section>

    <section>
      <title>Class (Klassen)</title>

      <para>Eine Class ist nichts anderes als eine Ansammlung von Methoden.
      Der Name einer Class beginnt immer mit einem Grossbuchstaben. Nehmen wir
      mal an, das die Methode zur neuen Class Dies_und_das gehört. Dann würde
      Sie in einem Ruby-Programm folgendermassen definiert:<programlisting>class Dies_und_das      # Start der Klassendefinition
  def drei_mail
    puts 'Hello World!'
    puts 'Hello World!'
    puts 'Hello World!'
  end
end                     # Ende der Klassendefinition</programlisting></para>

      <para>Spielen wir das mal im irb durch:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Dies_und_das</command>
irb(main):002:1&gt; <command>def drei_mal</command>
irb(main):003:2&gt; <command>puts 'Hello World!'</command>
irb(main):004:2&gt; <command>puts 'Hello World!'</command>
irb(main):005:2&gt; <command>puts 'Hello World!'</command>
irb(main):006:2&gt; <command>end</command>
irb(main):007:1&gt; <command>end</command>
=&gt; nil
</screen></para>

      <para>Jetzt probieren wir mal aus, die Methode
      <methodname>drei_mail</methodname> aufzurufen:<screen>irb(main):008:0&gt; <command>Dies_und_das.drei_mal</command>
NoMethodError: undefined method `drei_mal' for Dies_und_das:Class
 from (irb):8
from /usr/local/bin/irb:12:in `&lt;main&gt;'
</screen></para>

      <para>Das gibt eine Fehlermeldung, den
      <classname>Dies_und_das</classname> ist hier ein Class und kein Objekt.
      Es funktioniert nur, wenn wir vorher ein neuen Objekt (eine neue
      Instance) der Class <classname>Dies_und_das</classname> mit der Methode
      <methodname>new</methodname> generiert haben:<screen>irb(main):009:0&gt; <command>abc = Dies_und_das.new</command>
=&gt; #&lt;Dies_und_das:0x9ebb3f0&gt;
irb(main):010:0&gt; <command>abc.drei_mal</command>
Hello World!
Hello World!
Hello World!
=&gt; nil
irb(main):011:0&gt; <command>exit</command>
</screen></para>

      <section>
        <title>def initialize</title>

        <para>Wenn man eine neue Instanz erstellt (also die Methode .new
        aufruft), dann gibt es einen Mechanismus eine Art Start-Skript
        ablaufen zu lassen. Dieser Mechanismus ist die Methode initialize. Die
        Methode ist automatisch eine private Methode (das heißt, sie kann
        nicht von aussen, sondern nur innerhalb der Class aufgerufen
        werden).</para>

        <para>irb Beispiel<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Beispiel</command>
irb(main):002:1&gt; <command>def initialize</command>
irb(main):003:2&gt; <command>puts 'Hello World!'</command>
irb(main):004:2&gt; <command>end</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>test = Beispiel.new</command>
Hello World!
=&gt; #&lt;Beispiel:0x99f1e24&gt;
irb(main):007:0&gt; <command>exit</command>
</screen></para>

        <para>Die Instance <classname>test</classname> wird mit
        <methodname>Beispiel.new</methodname> erstellt und als erstes wird
        dabei die Methode <methodname>initialize</methodname> abgearbeitet.
        Deshalb sieht man im irb die <application>puts</application>-Ausgabe
        aus der irb-Zeile 3. </para>
      </section>
    </section>

    <section>
      <title>Variablen</title>

      <para>Wir wissen ja jetzt, das in Ruby alles ein Objekt ist. Also muss
      auch eine Variable ein Objekt sein. </para>

      <section>
        <title>Namenskonventionen</title>

        <para>Normale Variablen werden kleingeschrieben. Konstanten fangen mit
        einem Grossbuchstaben an.<important>
            <para>Eine Konstante kann in Ruby auch mit einem neuen Wert
            überschrieben werden (allerdings wird dabei eine Warnung
            ausgegeben). Man sollte sich also nicht auf Unveränderlichkeit
            einer Konstanten verlassen.</para>
          </important> Auf der sicheren Seite ist man, wenn man nur
        ASCII-Zeichen verwendet. Allerdings könnten Sie mit Ruby 1.9 und der
        richtigen Codierung auch problemlos Sonderzeichen und Umlaute in einem
        Variablennamen verwenden. Die Höfflichkeit gegenüber anderen (evt.
        ausländischen) Programmierern die diese Zeichen vielleicht nicht fix
        und fertig auf der Tastatur haben, ist aber Grund eher auf rein ASCII
        zu gehen.</para>
      </section>

      <section>
        <title>String</title>

        <para>Probieren wir mal ein wenig im irb aus.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Ein Test.'</command>
=&gt; "Ein Test."
irb(main):002:0&gt; <command>a.class</command>
=&gt; String
</screen></para>

        <para>Das war einfach. Ruby erschaft also automagisch ein Objekt mit
        der Class String. Das ginge auch mit der Methode
        <methodname>new</methodname>:<screen>irb(main):003:0&gt; <command>b = String.new('Noch ein Test.')</command>
=&gt; "Noch ein Test."
irb(main):004:0&gt; <command>b.class</command>
=&gt; String
</screen></para>

        <para>Wenn wir
        <classname>String</classname><methodname>.new</methodname> ohne einen
        Parameter aufrufen, dann wird auch ein Objekt der Class
        <classname>String</classname> erstellt. Nur ist das dann leer:<screen>irb(main):005:0&gt; <command>c = String.new</command>
=&gt; ""
irb(main):006:0&gt; <command>c.class</command>
=&gt; String
irb(main):007:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Zahlen</title>

        <section>
          <title>Fixnum und Bignum</title>

          <para>In <classname>Fixnum</classname> und
          <classname>Bignum</classname> sind
          <classname>Integer</classname>-Klassen (sprich ganze Zahlen). Ein
          Fixnum ist ein Integer, der in einem Word gespeichert werden kann
          (falls Sie nicht wissen, was ein Word ist =&gt; egal). Wird ein
          Fixnum größer, wandelt es sich automatisch in ein Bignum um.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>20.class</command>
=&gt; Fixnum
irb(main):002:0&gt; <command>a = 20</command>
=&gt; 20
irb(main):003:0&gt; <command>a.class</command>
=&gt; Fixnum
irb(main):004:0&gt; <command>a = a * 555555555</command> # Das Ergebnis wird automatisch ein Bignum.
=&gt; 11111111100
irb(main):005:0&gt; <command>a.class</command>
=&gt; Bignum
irb(main):006:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>Float</title>

          <para><classname>Float</classname> ist eine Class für reele Zahlen.
          Dabei wird die englische Schreibweise für das Komma (also ein Punkt)
          benutzt.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 20.424</command>
=&gt; 20.424
irb(main):002:0&gt; <command>a.class</command>
=&gt; Float
irb(main):003:0&gt; <command>42.2.class</command>
=&gt; Float
irb(main):004:0&gt; <command>exit</command>
</screen></para>
        </section>
      </section>

      <section>
        <title>Reichweite von Variablen</title>

        <para>Variablen haben je nach Art eine unterschiedliche "Reichweite"
        innerhalb der Ruby oder Ruby on Rails Applikation. Am besten zeigt
        sich das mit diesem kleinen Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>def test</command>
irb(main):003:1&gt; <command>a = 20</command>
irb(main):004:1&gt; <command>end</command>
=&gt; nil
irb(main):005:0&gt; <command>puts a</command>
10
=&gt; nil
irb(main):006:0&gt; <command>test</command>
=&gt; 20
irb(main):007:0&gt; <command>puts a</command>
10
=&gt; nil
irb(main):008:0&gt; <command>exit</command>
</screen></para>

        <para>Obwohl die Methode <methodname>test</methodname> den Wert der
        Variable <varname>a</varname> auf 20 gesetzt hat, wurde dabei nur eine
        lokale Variable gesetzt. Das vorher im Hauptprogramm gesetzte
        <varname>a</varname> war davon nicht betroffen.</para>

        <section>
          <title>Lokale Variablen (aaa oder _aaa)</title>

          <para>Lokale Variablen fangen entweder mit einem kleinen Buchstaben
          oder mit einem Underscore (_) an. Ihre Reichweite beschränkt sich
          auf die aktuelle Umgebung (z.B. auf die aktuelle Methode).
          Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>aaa = 10</command>    # Lokale Variable aaa
=&gt; 10
irb(main):002:0&gt; <command>_bbb = 20</command>   # Lokale Variable _bbb
=&gt; 20
irb(main):003:0&gt; <command>puts aaa</command>
10
=&gt; nil
irb(main):004:0&gt; <command>puts _bbb</command>
20
=&gt; nil
irb(main):005:0&gt; <command>def test</command>    # Definition der Methode test
irb(main):006:1&gt; <command>aaa = 1000</command>  # Lokale Variable aaa
irb(main):007:1&gt; <command>_bbb = 2000</command> # Lokale Variable _bbb
irb(main):008:1&gt; <command>puts aaa</command>    # Ausgabe von aaa
irb(main):009:1&gt; <command>puts _bbb</command>   # Ausgabe von _bbb
irb(main):010:1&gt; <command>end</command>         # Ende der Methode test
=&gt; nil
irb(main):011:0&gt; <command>puts aaa</command>
10
=&gt; nil
irb(main):012:0&gt; <command>puts _bbb</command>
20
=&gt; nil
irb(main):013:0&gt; <command>test</command>        # Aufruf der Methode test
1000                         # siehe irb-Zeile 8
2000                         # siehe irb-Ziele 9
=&gt; nil
irb(main):014:0&gt; <command>puts aaa</command>
10
=&gt; nil
irb(main):015:0&gt; <command>puts _bbb</command>
20
=&gt; nil
irb(main):016:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>Globale Variablen ($aaa)</title>

          <para>Eine globale Variable fäng mit einem
          <varname>$</varname>-Zeichen an und ist im gesamten Programm
          erreichbar. Beispiel:<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>$aaa = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>puts $aaa</command>
10
=&gt; nil
irb(main):003:0&gt; <command>def test</command>    # Definition der Methode test
irb(main):004:1&gt; <command>$aaa = 20</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>puts $aaa</command>   # Ausgabe von $aaa
10
=&gt; nil
irb(main):007:0&gt; <command>test</command>        # Aufruf der Methode test
=&gt; 20
irb(main):008:0&gt; <command>puts $aaa</command>   # Ausgabe von $aaa
20
=&gt; nil
irb(main):009:0&gt; <command>$aaa.class</command>
=&gt; Fixnum
irb(main):010:0&gt; <command>exit</command>
</screen></para>

          <para>Globale Variablen werden recht selten benutzt.</para>
        </section>

        <section>
          <title>Instance Variablen</title>

          <para>Instance Variablen gelten nur innerhalb einer Klasse, dort
          aber überall. Also quasi eine Mini-Version von Globalen Variablen.
          Im Gegensatz zu globalen Variablen findet man Instance Variablen in
          einer Rails-Applikation an jeder Ecke. Wir gehen die Sachen über ein
          Beispielprogramm mit dem Namen <filename>farbe.rb</filename>
          an:<programlisting>class Wand
  def initialize
    @farbe = 'weiss'
  end

  def farbe
    @farbe
  end

  def streich_alles_rot
    @farbe = 'rot'
  end

  def streich_alles_gelb
    @farbe = 'gelb'
  end

  def streich_alles_rosa
    farbe = 'rosa'
  end
end

meine_wand = Wand.new

puts meine_wand.farbe

meine_wand.streich_alles_rot

puts meine_wand.farbe

meine_wand.streich_alles_rosa

puts meine_wand.farbe
</programlisting>Wenn wir diese Programm starten, gibt es folgende
          Ausgabe:<screen>sw@debian:~/sandbox$ <command>ruby farbe.rb</command>
weiss
rot
rot
sw@debian:~/sandbox$</screen></para>

          <para></para>

          <para></para>
        </section>
      </section>
    </section>

    <section>
      <title>Noch ein paar Worte zu Methoden</title>

      <para>Jetzt haben Sie ein wenig mehr Grundwissen und da können wir bei
      den Methoden ein kleine Stufe tiefer gehen.</para>

      <section>
        <title>Mitgelieferte Methoden bei String</title>

        <para>Die meisten Klassen kommen von Hause aus schon mit einem ganzen
        Sack voll äusserst praktischer Methoden. Diese Methoden werden immer
        mit einem Punkt abgetrennt hinter dem entsprechenden Objekt
        geschrieben.</para>

        <para>Hier ein paar Beispiele für Methoden der Class
        <classname>String</classname>.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Das Haus.'</command>
=&gt; "Das Haus."
irb(main):002:0&gt; <command>a.class</command>     # .class gibt immer die Class des Objektes aus
=&gt; String
irb(main):003:0&gt; <command>a.size</command>      # Laenge des Strings
=&gt; 9
irb(main):004:0&gt; <command>a.downcase</command>  # Umwandlung in Kleinbuchstaben
=&gt; "das haus."
irb(main):005:0&gt; <command>a.upcase</command>    # Umwandlung in Grossbuchstaben
=&gt; "DAS HAUS."
irb(main):006:0&gt; <command>a.reverse</command>   # Buchstabenreihenfolge umdrehen
=&gt; ".suaH saD"
irb(main):007:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Verketten von Methoden</title>

        <para>Man kommt nicht direkt drauf, aber wenn man sich an das Arbeiten
        mit Ruby gewöhnt hat, dann ist es auch völlig selbstverständlich (weil
        logisch) verschiedene Methoden zu verketten.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Das Haus.'</command>
=&gt; "Das Haus."
irb(main):002:0&gt; <command>a.class</command>
=&gt; String
irb(main):003:0&gt; <command>a.upcase.reverse</command>  # Grossbuchstaben umgedreht
=&gt; ".SUAH SAD"
irb(main):004:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>Von einem zum anderen (Konvertieren)</title>

        <para>Logischerweise gibt es eine ganze Reihe von praktischen Instance
        Methoden, um Objekte von einer Class in eine andere zu wandeln. Als
        erstes verwandelt wir mal mit der Methode
        <methodname>.to_s</methodname> ein Fixnum in einen String.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 10</command>
=&gt; 10
irb(main):002:0&gt; <command>a.class</command>
=&gt; Fixnum
irb(main):003:0&gt; <command>b = a.to_s</command>
=&gt; "10"
irb(main):004:0&gt; <command>exit</command>
</screen></para>

        <para>Nichts anderes macht übrigens <application>puts</application>,
        wenn man mit puts ein Fixnum oder ein Float ausgibt (es fügt bei
        Nicht-Strings einfach die Methode <methodname>.to_s</methodname> hinzu
        und gibt das Ergebnis aus).</para>

        <para>Jetzt wandeln wir mal mit der Methode
        <methodname>.to_i</methodname> ein Float in ein Fixnum um.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>c = 10.0</command>
=&gt; 10.0
irb(main):002:0&gt; <command>c.class</command>
=&gt; Float
irb(main):003:0&gt; <command>d = c.to_i</command>
=&gt; 10
irb(main):004:0&gt; <command>d.class</command>
=&gt; Fixnum
irb(main):005:0&gt; <command>exit</command>
</screen></para>
      </section>

      <section>
        <title>"+" ist eine Methode?</title>

        <para>Wieso steht bei der Liste der Methoden beim
        <classname>String</classname> auch das Pluszeichen? Schauen wir mal
        mit <application>ri</application> nach.<screen>sw@debian:~/sandbox$ <command>ri String.+</command>
--------------------------------------------------------------- String#+
     str + other_str   =&gt; new_str

     From Ruby 1.9.1
------------------------------------------------------------------------
     Concatenation---Returns a new +String+ containing _other_str_
     concatenated to _str_.

        "Hello from " + self.to_s   #=&gt; "Hello from main"

sw@debian:~/sandbox$</screen></para>

        <para>hmmm... mal schauen was da bei <classname>Fixnum</classname>
        steht.<screen>sw@debian:~/sandbox$ <command>ri Fixnum.+</command>
--------------------------------------------------------------- Fixnum#+
     fix + numeric   =&gt;  numeric_result

     From Ruby 1.9.1
------------------------------------------------------------------------
     Performs addition: the class of the resulting object depends on the
     class of +numeric+ and on the magnitude of the result.

sw@debian:~/sandbox$</screen></para>

        <para>Spielen wir damit mal im irb. Wir müssten ja dann das
        <methodname>+</methodname> genauso wie jede andere Methode mit einem
        Punkt an die Class hängen können und die zweite Zahl in einer Klammer
        als Parameter anfügen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>10 + 10</command>
=&gt; 20
irb(main):002:0&gt; <command>10+10</command>
=&gt; 20
irb(main):003:0&gt; <command>10.+10</command>
=&gt; 20
irb(main):004:0&gt; <command>10.+(10)</command>
=&gt; 20
irb(main):005:0&gt; <command>exit</command>
</screen></para>

        <para>Aha! Das Pluszeichen ist tatsächlich eine Methode und diese
        Methode nimmt den nächsten Wert als Parameter. Eigentlich müssten wir
        diesen Wert in einer Klammer setzen, aber Ruby erspart mit
        durchdachter Syntax.</para>

        <section>
          <title>Kann ich die Methode + überschreiben?</title>

          <para>Ja, man kann alle Methoden überschreiben. Logischerweise macht
          das bei Methoden wie <methodname>+</methodname> wenig Sinn, ausser
          man will damit seine Programmierkollegen in den Wahnsinn treiben.
          Damit Sie mir glauben, führe ich jetzt im irb mal eine kleine Demo
          aus.</para>

          <para>Das Ziel ist es die Methode <methodname>+</methodname> für
          Fixnum umzuschreiben. Als Ergebnis jeder Addition soll die Zahl 42
          rauskommen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>10 + 10</command>
=&gt; 20
irb(main):002:0&gt; <command>10 + 5555</command>
=&gt; 5565
irb(main):003:0&gt; <command>class Fixnum</command> 
irb(main):004:1&gt; <command>def +(name, *args, &amp;blk)</command>
irb(main):005:2&gt; <command>42</command>
irb(main):006:2&gt; <command>end</command>
irb(main):007:1&gt; <command>end</command>
=&gt; nil
irb(main):008:0&gt; <command>10 + 10</command>
=&gt; 42
irb(main):042:0&gt; <command>10 + 5555</command>
=&gt; 42
irb(main):042:0&gt; <command>exit</command>
</screen></para>

          <para>In den Zeilen 1 und 2 führen wir die normale Addition durch.
          In den Zeilen 3 bis 7 definieren wir die Methode
          <methodname>+</methodname> für die Class
          <classname>Fixnum</classname> neu und danach führen wir noch einmal
          die Berechnung durch. Dann allerdings mit anderen
          Ergebnissen.</para>
        </section>
      </section>

      <section>
        <title>Liste aller Methoden für eine bestimmte Class</title>

        <para>Nun hat man nicht immer alle Methoden-Namen im Kopf, weiß aber
        das es für das spezielle Problem eine perfekte Methode gibt (passiert
        mir ständig).</para>

        <section>
          <title>Im irb</title>

          <para>Mit der Methode methods kann man die zur Verfügung stehenden
          Methoden anzeigen. Allerdings weiß man dann nicht unbedingt was
          diese genau machen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = 'Das blaue Haus.'</command>
=&gt; "Das blaue Haus."
irb(main):002:0&gt; <command>a.methods</command>
=&gt; [:&lt;=&gt;, :==, :===, :eql?, :hash, :casecmp, :+, :*, :%, :[], :[]=, :insert, :length, :size, :bytesize, :empty?, :=~, :match, :succ, :succ!, :next, :next!, :upto, :index, :rindex, :replace, :clear, :chr, :getbyte, :setbyte, :to_i, :to_f, :to_s, :to_str, :inspect, :dump, :upcase, :downcase, :capitalize, :swapcase, :upcase!, :downcase!, :capitalize!, :swapcase!, :hex, :oct, :split, :lines, :bytes, :chars, :codepoints, :reverse, :reverse!, :concat, :&lt;&lt;, :crypt, :intern, :to_sym, :ord, :include?, :start_with?, :end_with?, :scan, :ljust, :rjust, :center, :sub, :gsub, :chop, :chomp, :strip, :lstrip, :rstrip, :sub!, :gsub!, :chop!, :chomp!, :strip!, :lstrip!, :rstrip!, :tr, :tr_s, :delete, :squeeze, :count, :tr!, :tr_s!, :delete!, :squeeze!, :each_line, :each_byte, :each_char, :each_codepoint, :sum, :slice, :slice!, :partition, :rpartition, :encoding, :force_encoding, :valid_encoding?, :ascii_only?, :unpack, :encode, :encode!, :to_r, :to_c, :&gt;, :&gt;=, :&lt;, :&lt;=, :between?, :nil?, :!~, :class, :clone, :dup, :taint, :tainted?, :untaint, :untrust, :untrusted?, :trust, :freeze, :frozen?, :methods, :singleton_methods, :protected_methods, :private_methods, :public_methods, :instance_variables, :instance_variable_get, :instance_variable_set, :instance_variable_defined?, :instance_of?, :kind_of?, :is_a?, :tap, :send, :public_send, :respond_to?, :extend, :display, :method, :public_method, :define_singleton_method, :__id__, :object_id, :to_enum, :enum_for, :gem, :equal?, :!, :!=, :instance_eval, :instance_exec, :__send__]
irb(main):003:0&gt; <command>exit</command>
</screen></para>
        </section>

        <section>
          <title>http://ruby-doc.org via Google und Co.</title>

          <para>Unter <olink>http://ruby-doc.org</olink> finden Sie online
          eine optisch aufbereitete und unter einander verlinkte Ruby
          Dokumentaion. Der einfachste Weg dort eine Liste der Methoden zu
          bekommen ist sicherlich eine Suchmaschine. Einfach "Ruby" und den
          Namen der Class als Suchbegriff eingeben und dann bekommt man meist
          als ersten Eintrag diese offizielle Ruby Dokumentation
          angezeigt.</para>

          <para>Wenn ich alle Methoden für die Class String suche, dann suche
          in in Google nach "ruby string" und bekomme als ersten Treffer die
          URL
          <olink>http://ruby-doc.org/core/classes/String.html</olink>.<footnote>
              <para>Wer ganz sicher gehen will, kann auch folgenden Suchstring
              nehmen "String site:ruby-doc.org"</para>
            </footnote> Auf dieser Seite bekomme ich dann Beispiele zu allen
          Methoden.</para>

          <screenshot>
            <info>
              <title>Screenshot der Ruby-Doku zur Classe String auf
              ruby-doc.org</title>
            </info>

            <mediaobject>
              <imageobject>
                <imagedata fileref="string-doku.png"></imagedata>
              </imageobject>
            </mediaobject>
          </screenshot>
        </section>

        <section>
          <title>Hilfe per ri</title>

          <para>Es gibt noch eine eingebaute Hilfe (das Programm
          <application>ri</application>) die wir anstatt Google auf der
          Kommandozeile aufrufen können. Sehr praktisch, allerdings nicht so
          schön bunt. ;-)</para>

          <para>Wenn Sie Informationen zur Class String suchen, dann können
          Sie diese auf der Kommandozeile wie folgt ausgeben:<screen>sw@debian:~/sandbox$ <command>ri String</command>
------------------------------------------------- Class: String &lt; Object
     A +String+ object holds and manipulates an arbitrary sequence of
     bytes, typically representing characters. String objects may be
     created using +String::new+ or as literals.

     Because of aliasing issues, users of strings should be aware of the
     methods that modify the contents of a +String+ object. Typically,
     methods with names ending in ``!'' modify their receiver, while
     those without a ``!'' return a new +String+. However, there are
     exceptions, such as +String#[]=+.

     Enhance the String class with a XML escaped character version of
     to_s.

     User defined methods to be added to String.

------------------------------------------------------------------------


Includes:
---------

     Comparable


Class methods:
--------------

     new, try_convert, yaml_new


Instance methods:
-----------------

     %, *, +, &lt;&lt;, &lt;=&gt;, ==, ===, =~, [], []=, ascii_only?, block_scanf,
     bytes, bytesize, capitalize, capitalize!, casecmp, center, chars,
     chomp, chomp!, chop, chop!, chr, clear, codepoints, concat, count,
     crypt, delete, delete!, downcase, downcase!, dump, each_byte,
     each_char, each_codepoint, each_line, empty?, encode, encode!,
     encoding, end_with?, eql?, ext, force_encoding, getbyte, gsub,
     gsub!, hash, hex, include?, index, initialize_copy, insert,
     inspect, intern, is_binary_data?, is_complex_yaml?, iseuc, isjis,
     issjis, isutf8, kconv, length, lines, ljust, lstrip, lstrip!,
     match, next, next!, oct, ord, parse_csv, partition, pathmap,
     pathmap_explode, pathmap_partial, pathmap_replace, replace,
     reverse, reverse!, rindex, rjust, rpartition, rstrip, rstrip!,
     scan, scanf, setbyte, shellescape, shellsplit, size, slice, slice!,
     split, squeeze, squeeze!, start_with?, strip, strip!, sub, sub!,
     succ, succ!, sum, swapcase, swapcase!, to_blob, to_d, to_f, to_i,
     to_s, to_str, to_sym, to_yaml, toeuc, tojis, tolocale, tosjis,
     toutf16, toutf32, toutf8, tr, tr!, tr_s, tr_s!, unpack, upcase,
     upcase!, upto, valid_encoding?
sw@debian:~/sandbox$</screen></para>

          <para>Suchen wir jetzt Informationen zu einer bestimmten Methode,
          dann geht das auch mit ri. Als Beispiel nehmen wir mal gsub. Das ist
          eine Methode, mit der man Elemente in einem String austauschen kann
          (immer wieder praktisch).<screen>sw@debian:~/sandbox$ <command>ri String.gsub</command>
------------------------------------------------------------ String#gsub
     str.gsub(pattern, replacement)       =&gt; new_str
     str.gsub(pattern) {|match| block }   =&gt; new_str

     From Ruby 1.9.1
------------------------------------------------------------------------
     Returns a copy of _str_ with _all_ occurrences of _pattern_
     replaced with either _replacement_ or the value of the block. The
     _pattern_ will typically be a +Regexp+; if it is a +String+ then no
     regular expression metacharacters will be interpreted (that is
     +/\d/+ will match a digit, but +'\d'+ will match a backslash
     followed by a 'd').

     If a string is used as the replacement, special variables from the
     match (such as +$&amp;+ and +$1+) cannot be substituted into it, as
     substitution into the string occurs before the pattern match
     starts. However, the sequences +\1+, +\2+, +\k&lt;group_name&gt;+, and so
     on may be used to interpolate successive groups in the match.

     In the block form, the current match string is passed in as a
     parameter, and variables such as +$1+, +$2+, +$`+, +$&amp;+, and +$'+
     will be set appropriately. The value returned by the block will be
     substituted for the match on each call.

     The result inherits any tainting in the original string or any
     supplied replacement string.

        "hello".gsub(/[aeiou]/, '*')                  #=&gt; "h*ll*"
        "hello".gsub(/([aeiou])/, '&lt;\1&gt;')             #=&gt; "h&lt;e&gt;ll&lt;o&gt;"
        "hello".gsub(/./) {|s| s[0].ord.to_s + ' '}   #=&gt; "104 101 108 108 111 "
        "hello".gsub(/(?&lt;foo&gt;[aeiou])/, '{\k&lt;foo&gt;}')  #=&gt; "h{e}ll{o}"

sw@debian:~/sandbox$</screen></para>
        </section>
      </section>
    </section>

    <section>
      <title>Hello World mit Klassen und Methoden</title>

      <para>Bringen wir mal ein wenig Leben in das Theoretische Klassen- und
      Methoden-Konstrukt. Definieren wir mal eine Class mit dem Namen
      <classname>Person</classname> (Klassen fangen immer mit einem
      Grossbuchstaben an):<programlisting>class Person

end</programlisting></para>

      <para>Jetzt definieren wir für diese Class einen Default-Wert für den
      Namen der Person. Dies geschied mit der Methode initialize. Sie wird
      immer dann aufgerufen, wenn ein neues Objekt der entsprechenden Class
      generiert wird.<programlisting>class Person
  def initialize(name = 'John Doe')
    @name = name
  end
end</programlisting></para>

      <para>Probieren wir das mal im irb aus.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>class Person</command>
irb(main):002:1&gt; <command>def initialize(name = 'John Doe')</command>
irb(main):003:2&gt; <command>@name = name</command>
irb(main):004:2&gt; <command>end</command>
irb(main):005:1&gt; <command>end</command>
=&gt; nil
irb(main):006:0&gt; <command>test = Person.new</command>
=&gt; #&lt;Person:0xa118410 @name="John Doe"&gt;
irb(main):007:0&gt; <command>@name</command>
=&gt; nil
irb(main):008:0&gt; <command>exit</command>
</screen></para>

      <para></para>

      <para></para>

      <para></para>

      <para></para>
    </section>
  </section>

  <section>
    <title>Expressions</title>

    <para></para>
  </section>

  <section>
    <title>Schleifen</title>

    <para>Wieder so eine Henne-Ei-Problem. Ich zeige mal ein Beispiel für eine
    Schleife.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>5.times do |i|</command>
irb(main):002:1* <command>puts i</command>
irb(main):003:1&gt; <command>end</command>
0
1
2
3
4
=&gt; 5
irb(main):004:0&gt; <command>exit</command>
</screen>Es git also eine <classname>Fixnum</classname> Methode mit dem Namen
    <methodname>times</methodname>. Schauen wir mal mir
    <application>ri</application> nach:<screen>sw@debian:~/sandbox$ <command>ri Fixnum.times</command>
---------------------------------------------------------- Integer#times
     int.times {|i| block }     =&gt; int

     From Ruby 1.9.1
------------------------------------------------------------------------
     Iterates block _int_ times, passing in values from zero to _int_ -
     1.

        5.times do |i|
          print i, " "
        end

     _produces:_

        0 1 2 3 4

sw@debian:~/sandbox$</screen></para>

    <para>Und wie es der Zufall will ist dort genau unser Beispiel aufgeführt.
    Und es scheint auch noch eine andere Schreibweise zu geben. Probieren wir
    die auch mal aus.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>5.times { |i| puts i }</command>
0
1
2
3
4
=&gt; 5
irb(main):002:0&gt; <command>exit</command>
</screen></para>

    <section>
      <title>While und until</title>

      <para></para>
    </section>

    <section>
      <title>Blocks und Iteratoren</title>

      <para>Bei der Schleife<programlisting>5.times { |i| puts i }</programlisting>
      ist <varname>i</varname> der Iterator und <code>puts i</code> der
      Block.</para>

      <para>Das ganze kann aber auch in der folgenden Form ausgedrückt
      werden:<programlisting>5.times do |i|
  puts i
end</programlisting></para>
    </section>

    <section>
      <title>Die upto Methode</title>

      <para>Neben <methodname>times</methodname> gibt es noch die
      <methodname>upto</methodname> Methode, um leicht eine Schleife zu
      realisieren. ri gibt uns auch hier ein schönes Beispiel.<screen>sw@debian:~/sandbox$ <command>ri Fixnum.upto</command>
----------------------------------------------------------- Integer#upto
     int.upto(limit) {|i| block }     =&gt; int

     From Ruby 1.9.1
------------------------------------------------------------------------
     Iterates _block_, passing in integer values from _int_ up to and
     including _limit_.

        5.upto(10) { |i| print i, " " }

     _produces:_

        5 6 7 8 9 10

sw@debian:~/sandbox$</screen></para>
    </section>

    <section>
      <title>Kein Interator benötigt?</title>

      <para>Der Iterator ist ein Konstrukt, um den Inhalt des Blocks mehrmals
      durchlaufen zu lassen. Dazu muss er aber als Zähler aber gar nicht
      benutzt werden.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>5.times { puts 'Das blaue Haus.' }</command>
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
Das blaue Haus.
=&gt; 5
irb(main):002:0&gt; <command>exit</command>
</screen></para>
    </section>
  </section>

  <section>
    <title>Arrays und Hashes</title>

    <para>Wie in vielen Programmiersprachen sind auch in Ruby Arrays und
    Hashes beliebte Mechanismen, um Daten zu speichern.</para>

    <section>
      <title>Array</title>

      <para>Spielen wir doch einmal ein wenig im irb.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = [1,2,3,4,5]</command>
=&gt; [1, 2, 3, 4, 5]
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>exit</command>
</screen></para>

      <para>Das ist einfach und verständlich. Mal schauen, ob das so auch mit
      Strings im Array funktioniert.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = ['Test', 'Apfelbaum', 'blau']</command>
=&gt; ["Test", "Apfelbaum", "blau"]
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>a[1]</command>
=&gt; "Apfelbaum"
irb(main):004:0&gt; <command>a[1].class</command>
=&gt; String
irb(main):005:0&gt; <command>exit</command>
</screen></para>

      <para>Das geht auch. Dann fehlt nur noch ein Array mit einem Mix aus
      beidem. Ist klar, das es gehen muss, weil das Array ja Objekte speichert
      und es egal ist, welche Art von Objekten (sprich String, Fixnum oder
      Float) das ist. Aber ein Versuch schadet ja nicht.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>a = [1, 2, 'Haus', 'Baum', 4]</command>
=&gt; [1, 2, "Haus", "Baum", 4]
irb(main):002:0&gt; <command>a.class</command>
=&gt; Array
irb(main):003:0&gt; <command>a[0]</command>
=&gt; 1
irb(main):004:0&gt; <command>a[0].class</command>
=&gt; Fixnum
irb(main):005:0&gt; <command>a[2]</command>
=&gt; "Haus"
irb(main):006:0&gt; <command>a[2].class</command>
=&gt; String
irb(main):007:0&gt; <command>exit</command>
</screen></para>

      <para>Schauen wir uns als nächstes mal die ri Hilfeseite zu Array
      an.<screen>sw@debian:~/sandbox$ <command>ri Array</command>
-------------------------------------------------- Class: Array &lt; Object
     Arrays are ordered, integer-indexed collections of any object.
     Array indexing starts at 0, as in C or Java. A negative index is
     assumed to be relative to the end of the array---that is, an index
     of -1 indicates the last element of the array, -2 is the next to
     last element in the array, and so on.

------------------------------------------------------------------------


Includes:
---------

     Enumerable


Class methods:
--------------

     [], new, try_convert


Instance methods:
-----------------

     &amp;, *, +, -, &lt;&lt;, &lt;=&gt;, ==, [], []=, abbrev, assoc, at, clear,
     collect, collect!, combination, compact, compact!, concat, count,
     cycle, dclone, delete, delete_at, delete_if, drop, drop_while,
     each, each_index, empty?, eql?, fetch, fill, find_index, first,
     flatten, flatten!, frozen?, hash, include?, index, initialize_copy,
     insert, inspect, join, last, length, map, map!, pack, permutation,
     pop, pretty_print, pretty_print_cycle, product, push, rassoc,
     reject, reject!, replace, reverse, reverse!, reverse_each, rindex,
     sample, select, shelljoin, shift, shuffle, shuffle!, size, slice,
     slice!, sort, sort!, take, take_while, to_a, to_ary, to_csv, to_s,
     to_yaml, transpose, uniq, uniq!, unshift, values_at,
     yaml_initialize, zip, |
sw@debian:~/sandbox$</screen></para>

      <para>Interessant ist dabei das Mixin der Class
      <classname>Enumerable</classname>.</para>

      <para></para>
    </section>

    <section>
      <title>Parkplatz</title>

      <para>Und mit doppelten Anführungszeichen und einem
      <varname>#{varname}</varname> Konstrukt können wir diese Variable sogar
      zusammen mit anderem Text ausgeben lassen.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>farbe = 'blau'</command>
=&gt; "blau"
irb(main):002:0&gt; <command>puts "Das Haus ist #{farbe}."</command> # wird ersetzt  
Das Haus ist blau.
=&gt; nil
irb(main):003:0&gt; <command>puts 'Das Haus ist #{farbe}.'</command> # wird nicht ersetzt
Das Haus ist #{farbe}.
=&gt; nil
irb(main):004:0&gt; <command>exit</command>
</screen></para>

      <para>Schauen wir uns erst mal die Class String an.</para>

      <para>Interessant. Jetzt mal ein Fixnum (Integer).</para>

      <para>Ein Float.</para>

      <para>Und zum Schluss Booleans und nil.<screen>sw@debian:~/sandbox$ <command>irb</command>
irb(main):001:0&gt; <command>true.class</command>
=&gt; TrueClass
irb(main):002:0&gt; <command>false.class</command>
=&gt; FalseClass
irb(main):003:0&gt; <command>nil.class</command>
=&gt; NilClass
irb(main):004:0&gt; <command>exit</command>
</screen></para>

      <para>Ruby erkennt also automagisch welche Art von Objekt es gerade
      behandelt. Da haben wir schon mal eine Sorge weniger.</para>
    </section>
  </section>
</chapter>
